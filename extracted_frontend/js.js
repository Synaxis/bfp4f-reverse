
/*!
 * jQuery JavaScript Library v1.5.1
 * http://jquery.com/
 *
 * Copyright 2011, John Resig
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 * Copyright 2011, The Dojo Foundation
 * Released under the MIT, BSD, and GPL Licenses.
 *
 * Date: Wed Feb 23 13:55:29 2011 -0500
 */
(function( window, undefined ) {

// Use the correct document accordingly with window argument (sandbox)
var document = window.document;
var jQuery = (function() {

// Define a local copy of jQuery
var jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		return new jQuery.fn.init( selector, context, rootjQuery );
	},

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$,

	// A central reference to the root jQuery(document)
	rootjQuery,

	// A simple way to check for HTML strings or ID strings
	// (both of which we optimize for)
	quickExpr = /^(?:[^<]*(<[\w\W]+>)[^>]*$|#([\w\-]+)$)/,

	// Check if a string has a non-whitespace character in it
	rnotwhite = /\S/,

	// Used for trimming whitespace
	trimLeft = /^\s+/,
	trimRight = /\s+$/,

	// Check for digits
	rdigit = /\d/,

	// Match a standalone tag
	rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>)?$/,

	// JSON RegExp
	rvalidchars = /^[\],:{}\s]*$/,
	rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
	rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
	rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,

	// Useragent RegExp
	rwebkit = /(webkit)[ \/]([\w.]+)/i,
	ropera = /(opera)(?:.*version)?[ \/]([\w.]+)/i,
	rmsie = /(msie) ([\w.]+)/i,
    rie = /(trident)(?:.*? rv:([\w.]+))?/i,
	rmozilla = /(mozilla)(?:.*? rv:([\w.]+))?/i,

	// Keep a UserAgent string for use with jQuery.browser
	userAgent = navigator.userAgent,

	// For matching the engine and version of the browser
	browserMatch,

	// Has the ready events already been bound?
	readyBound = false,

	// The deferred used on DOM ready
	readyList,

	// Promise methods
	promiseMethods = "then done fail isResolved isRejected promise".split( " " ),

	// The ready event handler
	DOMContentLoaded,

	// Save a reference to some core methods
	toString = Object.prototype.toString,
	hasOwn = Object.prototype.hasOwnProperty,
	push = Array.prototype.push,
	slice = Array.prototype.slice,
	trim = String.prototype.trim,
	indexOf = Array.prototype.indexOf,

	// [[Class]] -> type pairs
	class2type = {};

jQuery.fn = jQuery.prototype = {
	constructor: jQuery,
	init: function( selector, context, rootjQuery ) {
		var match, elem, ret, doc;

		// Handle $(""), $(null), or $(undefined)
		if ( !selector ) {
			return this;
		}

		// Handle $(DOMElement)
		if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;
		}

		// The body element only exists once, optimize finding it
		if ( selector === "body" && !context && document.body ) {
			this.context = document;
			this[0] = document.body;
			this.selector = "body";
			this.length = 1;
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			// Are we dealing with HTML string or an ID?
			match = quickExpr.exec( selector );

			// Verify a match, and that no context was specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;
					doc = (context ? context.ownerDocument || context : document);

					// If a single string is passed in and it's a single tag
					// just do a createElement and skip the rest
					ret = rsingleTag.exec( selector );

					if ( ret ) {
						if ( jQuery.isPlainObject( context ) ) {
							selector = [ document.createElement( ret[1] ) ];
							jQuery.fn.attr.call( selector, context, true );

						} else {
							selector = [ doc.createElement( ret[1] ) ];
						}

					} else {
						ret = jQuery.buildFragment( [ match[1] ], [ doc ] );
						selector = (ret.cacheable ? jQuery.clone(ret.fragment) : ret.fragment).childNodes;
					}

					return jQuery.merge( this, selector );

				// HANDLE: $("#id")
				} else {
					elem = document.getElementById( match[2] );

					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					if ( elem && elem.parentNode ) {
						// Handle the case where IE and Opera return items
						// by name instead of ID
						if ( elem.id !== match[2] ) {
							return rootjQuery.find( selector );
						}

						// Otherwise, we inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return (context || rootjQuery).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return rootjQuery.ready( selector );
		}

		if (selector.selector !== undefined) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	},

	// Start with an empty selector
	selector: "",

	// The current version of jQuery being used
	jquery: "1.5.1",

	// The default length of a jQuery object is 0
	length: 0,

	// The number of elements contained in the matched element set
	size: function() {
		return this.length;
	},

	toArray: function() {
		return slice.call( this, 0 );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num == null ?

			// Return a 'clean' array
			this.toArray() :

			// Return just the object
			( num < 0 ? this[ this.length + num ] : this[ num ] );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems, name, selector ) {
		// Build a new jQuery matched element set
		var ret = this.constructor();

		if ( jQuery.isArray( elems ) ) {
			push.apply( ret, elems );

		} else {
			jQuery.merge( ret, elems );
		}

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		ret.context = this.context;

		if ( name === "find" ) {
			ret.selector = this.selector + (this.selector ? " " : "") + selector;
		} else if ( name ) {
			ret.selector = this.selector + "." + name + "(" + selector + ")";
		}

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	ready: function( fn ) {
		// Attach the listeners
		jQuery.bindReady();

		// Add the callback
		readyList.done( fn );

		return this;
	},

	eq: function( i ) {
		return i === -1 ?
			this.slice( i ) :
			this.slice( i, +i + 1 );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ),
			"slice", slice.call(arguments).join(",") );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: [].sort,
	splice: [].splice
};

// Give the init function the jQuery prototype for later instantiation
jQuery.fn.init.prototype = jQuery.fn;

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// extend jQuery itself if only one argument is passed
	if ( length === i ) {
		target = this;
		--i;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	noConflict: function( deep ) {
		window.$ = _$;

		if ( deep ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	},

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {
		// A third-party is pushing the ready event forwards
		if ( wait === true ) {
			jQuery.readyWait--;
		}

		// Make sure that the DOM is not already loaded
		if ( !jQuery.readyWait || (wait !== true && !jQuery.isReady) ) {
			// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
			if ( !document.body ) {
				return setTimeout( jQuery.ready, 1 );
			}

			// Remember that the DOM is ready
			jQuery.isReady = true;

			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}

			// If there are functions bound, to execute
			readyList.resolveWith( document, [ jQuery ] );

			// Trigger any bound ready events
			if ( jQuery.fn.trigger ) {
				jQuery( document ).trigger( "ready" ).unbind( "ready" );
			}
		}
	},

	bindReady: function() {
		if ( readyBound ) {
			return;
		}

		readyBound = true;

		// Catch cases where $(document).ready() is called after the
		// browser event has already occurred.
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			return setTimeout( jQuery.ready, 1 );
		}

		// Mozilla, Opera and webkit nightlies currently support this event
		if ( document.addEventListener ) {
			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", DOMContentLoaded, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", jQuery.ready, false );

		// If IE event model is used
		} else if ( document.attachEvent ) {
			// ensure firing before onload,
			// maybe late but safe also for iframes
			document.attachEvent("onreadystatechange", DOMContentLoaded);

			// A fallback to window.onload, that will always work
			window.attachEvent( "onload", jQuery.ready );

			// If IE and not a frame
			// continually check to see if the document is ready
			var toplevel = false;

			try {
				toplevel = window.frameElement == null;
			} catch(e) {}

			if ( document.documentElement.doScroll && toplevel ) {
				doScrollCheck();
			}
		}
	},

	// See test/unit/core.js for details concerning isFunction.
	// Since version 1.3, DOM methods and functions like alert
	// aren't supported. They return false on IE (#2968).
	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray || function( obj ) {
		return jQuery.type(obj) === "array";
	},

	// A crude way of determining if an object is a window
	isWindow: function( obj ) {
		return obj && typeof obj === "object" && "setInterval" in obj;
	},

	isNaN: function( obj ) {
		return obj == null || !rdigit.test( obj ) || isNaN( obj );
	},

	type: function( obj ) {
		return obj == null ?
			String( obj ) :
			class2type[ toString.call(obj) ] || "object";
	},

	isPlainObject: function( obj ) {
		// Must be an Object.
		// Because of IE, we also have to check the presence of the constructor property.
		// Make sure that DOM nodes and window objects don't pass through, as well
		if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		// Not own constructor property must be Object
		if ( obj.constructor &&
			!hasOwn.call(obj, "constructor") &&
			!hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
			return false;
		}

		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.

		var key;
		for ( key in obj ) {}

		return key === undefined || hasOwn.call( obj, key );
	},

	isEmptyObject: function( obj ) {
		for ( var name in obj ) {
			return false;
		}
		return true;
	},

	error: function( msg ) {
		throw msg;
	},

	parseJSON: function( data ) {
		if ( typeof data !== "string" || !data ) {
			return null;
		}

		// Make sure leading/trailing whitespace is removed (IE can't handle it)
		data = jQuery.trim( data );

		// Make sure the incoming data is actual JSON
		// Logic borrowed from http://json.org/json2.js
		if ( rvalidchars.test(data.replace(rvalidescape, "@")
			.replace(rvalidtokens, "]")
			.replace(rvalidbraces, "")) ) {

			// Try to use the native JSON parser first
			return window.JSON && window.JSON.parse ?
				window.JSON.parse( data ) :
				(new Function("return " + data))();

		} else {
			jQuery.error( "Invalid JSON: " + data );
		}
	},

	// Cross-browser xml parsing
	// (xml & tmp used internally)
	parseXML: function( data , xml , tmp ) {

		if ( window.DOMParser ) { // Standard
			tmp = new DOMParser();
			xml = tmp.parseFromString( data , "text/xml" );
		} else { // IE
			xml = new ActiveXObject( "Microsoft.XMLDOM" );
			xml.async = "false";
			xml.loadXML( data );
		}

		tmp = xml.documentElement;

		if ( ! tmp || ! tmp.nodeName || tmp.nodeName === "parsererror" ) {
			jQuery.error( "Invalid XML: " + data );
		}

		return xml;
	},

	noop: function() {},

	// Evalulates a script in a global context
	globalEval: function( data ) {
		if ( data && rnotwhite.test(data) ) {
			// Inspired by code by Andrea Giammarchi
			// http://webreflection.blogspot.com/2007/08/global-scope-evaluation-and-dom.html
			var head = document.head || document.getElementsByTagName( "head" )[0] || document.documentElement,
				script = document.createElement( "script" );

			if ( jQuery.support.scriptEval() ) {
				script.appendChild( document.createTextNode( data ) );
			} else {
				script.text = data;
			}

			// Use insertBefore instead of appendChild to circumvent an IE6 bug.
			// This arises when a base node is used (#2709).
			head.insertBefore( script, head.firstChild );
			head.removeChild( script );
		}
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toUpperCase() === name.toUpperCase();
	},

	// args is for internal usage only
	each: function( object, callback, args ) {
		var name, i = 0,
			length = object.length,
			isObj = length === undefined || jQuery.isFunction(object);

		if ( args ) {
			if ( isObj ) {
				for ( name in object ) {
					if ( callback.apply( object[ name ], args ) === false ) {
						break;
					}
				}
			} else {
				for ( ; i < length; ) {
					if ( callback.apply( object[ i++ ], args ) === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isObj ) {
				for ( name in object ) {
					if ( callback.call( object[ name ], name, object[ name ] ) === false ) {
						break;
					}
				}
			} else {
				for ( var value = object[0];
					i < length && callback.call( value, i, value ) !== false; value = object[++i] ) {}
			}
		}

		return object;
	},

	// Use native String.trim function wherever possible
	trim: trim ?
		function( text ) {
			return text == null ?
				"" :
				trim.call( text );
		} :

		// Otherwise use our own trimming functionality
		function( text ) {
			return text == null ?
				"" :
				text.toString().replace( trimLeft, "" ).replace( trimRight, "" );
		},

	// results is for internal usage only
	makeArray: function( array, results ) {
		var ret = results || [];

		if ( array != null ) {
			// The window, strings (and functions) also have 'length'
			// The extra typeof function check is to prevent crashes
			// in Safari 2 (See: #3039)
			// Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930
			var type = jQuery.type(array);

			if ( array.length == null || type === "string" || type === "function" || type === "regexp" || jQuery.isWindow( array ) ) {
				push.call( ret, array );
			} else {
				jQuery.merge( ret, array );
			}
		}

		return ret;
	},

	inArray: function( elem, array ) {
		if ( array.indexOf ) {
			return array.indexOf( elem );
		}

		for ( var i = 0, length = array.length; i < length; i++ ) {
			if ( array[ i ] === elem ) {
				return i;
			}
		}

		return -1;
	},

	merge: function( first, second ) {
		var i = first.length,
			j = 0;

		if ( typeof second.length === "number" ) {
			for ( var l = second.length; j < l; j++ ) {
				first[ i++ ] = second[ j ];
			}

		} else {
			while ( second[j] !== undefined ) {
				first[ i++ ] = second[ j++ ];
			}
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, inv ) {
		var ret = [], retVal;
		inv = !!inv;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( var i = 0, length = elems.length; i < length; i++ ) {
			retVal = !!callback( elems[ i ], i );
			if ( inv !== retVal ) {
				ret.push( elems[ i ] );
			}
		}

		return ret;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var ret = [], value;

		// Go through the array, translating each of the items to their
		// new value (or values).
		for ( var i = 0, length = elems.length; i < length; i++ ) {
			value = callback( elems[ i ], i, arg );

			if ( value != null ) {
				ret[ ret.length ] = value;
			}
		}

		// Flatten any nested arrays
		return ret.concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	proxy: function( fn, proxy, thisObject ) {
		if ( arguments.length === 2 ) {
			if ( typeof proxy === "string" ) {
				thisObject = fn;
				fn = thisObject[ proxy ];
				proxy = undefined;

			} else if ( proxy && !jQuery.isFunction( proxy ) ) {
				thisObject = proxy;
				proxy = undefined;
			}
		}

		if ( !proxy && fn ) {
			proxy = function() {
				return fn.apply( thisObject || this, arguments );
			};
		}

		// Set the guid of unique handler to the same of original handler, so it can be removed
		if ( fn ) {
			proxy.guid = fn.guid = fn.guid || proxy.guid || jQuery.guid++;
		}

		// So proxy can be declared as an argument
		return proxy;
	},

	// Mutifunctional method to get and set values to a collection
	// The value/s can be optionally by executed if its a function
	access: function( elems, key, value, exec, fn, pass ) {
		var length = elems.length;

		// Setting many attributes
		if ( typeof key === "object" ) {
			for ( var k in key ) {
				jQuery.access( elems, k, key[k], exec, fn, value );
			}
			return elems;
		}

		// Setting one attribute
		if ( value !== undefined ) {
			// Optionally, function values get executed if exec is true
			exec = !pass && exec && jQuery.isFunction(value);

			for ( var i = 0; i < length; i++ ) {
				fn( elems[i], key, exec ? value.call( elems[i], i, fn( elems[i], key ) ) : value, pass );
			}

			return elems;
		}

		// Getting an attribute
		return length ? fn( elems[0], key ) : undefined;
	},

	now: function() {
		return (new Date()).getTime();
	},

	// Create a simple deferred (one callbacks list)
	_Deferred: function() {
		var // callbacks list
			callbacks = [],
			// stored [ context , args ]
			fired,
			// to avoid firing when already doing so
			firing,
			// flag to know if the deferred has been cancelled
			cancelled,
			// the deferred itself
			deferred  = {

				// done( f1, f2, ...)
				done: function() {
					if ( !cancelled ) {
						var args = arguments,
							i,
							length,
							elem,
							type,
							_fired;
						if ( fired ) {
							_fired = fired;
							fired = 0;
						}
						for ( i = 0, length = args.length; i < length; i++ ) {
							elem = args[ i ];
							type = jQuery.type( elem );
							if ( type === "array" ) {
								deferred.done.apply( deferred, elem );
							} else if ( type === "function" ) {
								callbacks.push( elem );
							}
						}
						if ( _fired ) {
							deferred.resolveWith( _fired[ 0 ], _fired[ 1 ] );
						}
					}
					return this;
				},

				// resolve with given context and args
				resolveWith: function( context, args ) {
					if ( !cancelled && !fired && !firing ) {
						firing = 1;
						try {
							while( callbacks[ 0 ] ) {
								callbacks.shift().apply( context, args );
							}
						}
						// We have to add a catch block for
						// IE prior to 8 or else the finally
						// block will never get executed
						catch (e) {
							throw e;
						}
						finally {
							fired = [ context, args ];
							firing = 0;
						}
					}
					return this;
				},

				// resolve with this as context and given arguments
				resolve: function() {
					deferred.resolveWith( jQuery.isFunction( this.promise ) ? this.promise() : this, arguments );
					return this;
				},

				// Has this deferred been resolved?
				isResolved: function() {
					return !!( firing || fired );
				},

				// Cancel
				cancel: function() {
					cancelled = 1;
					callbacks = [];
					return this;
				}
			};

		return deferred;
	},

	// Full fledged deferred (two callbacks list)
	Deferred: function( func ) {
		var deferred = jQuery._Deferred(),
			failDeferred = jQuery._Deferred(),
			promise;
		// Add errorDeferred methods, then and promise
		jQuery.extend( deferred, {
			then: function( doneCallbacks, failCallbacks ) {
				deferred.done( doneCallbacks ).fail( failCallbacks );
				return this;
			},
			fail: failDeferred.done,
			rejectWith: failDeferred.resolveWith,
			reject: failDeferred.resolve,
			isRejected: failDeferred.isResolved,
			// Get a promise for this deferred
			// If obj is provided, the promise aspect is added to the object
			promise: function( obj ) {
				if ( obj == null ) {
					if ( promise ) {
						return promise;
					}
					promise = obj = {};
				}
				var i = promiseMethods.length;
				while( i-- ) {
					obj[ promiseMethods[i] ] = deferred[ promiseMethods[i] ];
				}
				return obj;
			}
		} );
		// Make sure only one callback list will be used
		deferred.done( failDeferred.cancel ).fail( deferred.cancel );
		// Unexpose cancel
		delete deferred.cancel;
		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}
		return deferred;
	},

	// Deferred helper
	when: function( object ) {
		var lastIndex = arguments.length,
			deferred = lastIndex <= 1 && object && jQuery.isFunction( object.promise ) ?
				object :
				jQuery.Deferred(),
			promise = deferred.promise();

		if ( lastIndex > 1 ) {
			var array = slice.call( arguments, 0 ),
				count = lastIndex,
				iCallback = function( index ) {
					return function( value ) {
						array[ index ] = arguments.length > 1 ? slice.call( arguments, 0 ) : value;
						if ( !( --count ) ) {
							deferred.resolveWith( promise, array );
						}
					};
				};
			while( ( lastIndex-- ) ) {
				object = array[ lastIndex ];
				if ( object && jQuery.isFunction( object.promise ) ) {
					object.promise().then( iCallback(lastIndex), deferred.reject );
				} else {
					--count;
				}
			}
			if ( !count ) {
				deferred.resolveWith( promise, array );
			}
		} else if ( deferred !== object ) {
			deferred.resolve( object );
		}
		return promise;
	},

	// Use of jQuery.browser is frowned upon.
	// More details: http://docs.jquery.com/Utilities/jQuery.browser
	uaMatch: function( ua ) {
		ua = ua.toLowerCase();
		var match = rwebkit.exec( ua ) ||
			ropera.exec( ua ) ||
            rie.exec( ua ) ||
			rmsie.exec( ua ) ||
			ua.indexOf("compatible") < 0 && rmozilla.exec( ua ) ||
			[];
        if (match[1] === 'trident') {
            match[1] = 'msie';
        }

        return { browser: match[1] || "", version: match[2] || "0" };
	},

	sub: function() {
		function jQuerySubclass( selector, context ) {
			return new jQuerySubclass.fn.init( selector, context );
		}
		jQuery.extend( true, jQuerySubclass, this );
		jQuerySubclass.superclass = this;
		jQuerySubclass.fn = jQuerySubclass.prototype = this();
		jQuerySubclass.fn.constructor = jQuerySubclass;
		jQuerySubclass.subclass = this.subclass;
		jQuerySubclass.fn.init = function init( selector, context ) {
			if ( context && context instanceof jQuery && !(context instanceof jQuerySubclass) ) {
				context = jQuerySubclass(context);
			}

			return jQuery.fn.init.call( this, selector, context, rootjQuerySubclass );
		};
		jQuerySubclass.fn.init.prototype = jQuerySubclass.fn;
		var rootjQuerySubclass = jQuerySubclass(document);
		return jQuerySubclass;
	},

	browser: {}
});

// Create readyList deferred
readyList = jQuery._Deferred();

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

browserMatch = jQuery.uaMatch( userAgent );
if ( browserMatch.browser ) {
	jQuery.browser[ browserMatch.browser ] = true;
	jQuery.browser.version = browserMatch.version;
}

// Deprecated, use jQuery.browser.webkit instead
if ( jQuery.browser.webkit ) {
	jQuery.browser.safari = true;
}

if ( indexOf ) {
	jQuery.inArray = function( elem, array ) {
		return indexOf.call( array, elem );
	};
}

// IE doesn't match non-breaking spaces with \s
if ( rnotwhite.test( "\xA0" ) ) {
	trimLeft = /^[\s\xA0]+/;
	trimRight = /[\s\xA0]+$/;
}

// All jQuery objects should point back to these
rootjQuery = jQuery(document);

// Cleanup functions for the document ready method
if ( document.addEventListener ) {
	DOMContentLoaded = function() {
		document.removeEventListener( "DOMContentLoaded", DOMContentLoaded, false );
		jQuery.ready();
	};

} else if ( document.attachEvent ) {
	DOMContentLoaded = function() {
		// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
		if ( document.readyState === "complete" ) {
			document.detachEvent( "onreadystatechange", DOMContentLoaded );
			jQuery.ready();
		}
	};
}

// The DOM ready check for Internet Explorer
function doScrollCheck() {
	if ( jQuery.isReady ) {
		return;
	}

	try {
		// If IE is used, use the trick by Diego Perini
		// http://javascript.nwbox.com/IEContentLoaded/
		document.documentElement.doScroll("left");
	} catch(e) {
		setTimeout( doScrollCheck, 1 );
		return;
	}

	// and execute any waiting functions
	jQuery.ready();
}

// Expose jQuery to the global object
return jQuery;

})();


(function() {

	jQuery.support = {};

	var div = document.createElement("div");

	div.style.display = "none";
	div.innerHTML = "   <link/><table></table><a href='/a' style='color:red;float:left;opacity:.55;'>a</a><input type='checkbox'/>";

	var all = div.getElementsByTagName("*"),
		a = div.getElementsByTagName("a")[0],
		select = document.createElement("select"),
		opt = select.appendChild( document.createElement("option") ),
		input = div.getElementsByTagName("input")[0];

	// Can't get basic test support
	if ( !all || !all.length || !a ) {
		return;
	}

	jQuery.support = {
		// IE strips leading whitespace when .innerHTML is used
		leadingWhitespace: div.firstChild.nodeType === 3,

		// Make sure that tbody elements aren't automatically inserted
		// IE will insert them into empty tables
		tbody: !div.getElementsByTagName("tbody").length,

		// Make sure that link elements get serialized correctly by innerHTML
		// This requires a wrapper element in IE
		htmlSerialize: !!div.getElementsByTagName("link").length,

		// Get the style information from getAttribute
		// (IE uses .cssText insted)
		style: /red/.test( a.getAttribute("style") ),

		// Make sure that URLs aren't manipulated
		// (IE normalizes it by default)
		hrefNormalized: a.getAttribute("href") === "/a",

		// Make sure that element opacity exists
		// (IE uses filter instead)
		// Use a regex to work around a WebKit issue. See #5145
		opacity: /^0.55$/.test( a.style.opacity ),

		// Verify style float existence
		// (IE uses styleFloat instead of cssFloat)
		cssFloat: !!a.style.cssFloat,

		// Make sure that if no value is specified for a checkbox
		// that it defaults to "on".
		// (WebKit defaults to "" instead)
		checkOn: input.value === "on",

		// Make sure that a selected-by-default option has a working selected property.
		// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
		optSelected: opt.selected,

		// Will be defined later
		deleteExpando: true,
		optDisabled: false,
		checkClone: false,
		noCloneEvent: true,
		noCloneChecked: true,
		boxModel: null,
		inlineBlockNeedsLayout: false,
		shrinkWrapBlocks: false,
		reliableHiddenOffsets: true
	};

	input.checked = true;
	jQuery.support.noCloneChecked = input.cloneNode( true ).checked;

	// Make sure that the options inside disabled selects aren't marked as disabled
	// (WebKit marks them as diabled)
	select.disabled = true;
	jQuery.support.optDisabled = !opt.disabled;

	var _scriptEval = null;
	jQuery.support.scriptEval = function() {
		if ( _scriptEval === null ) {
			var root = document.documentElement,
				script = document.createElement("script"),
				id = "script" + jQuery.now();

			try {
				script.appendChild( document.createTextNode( "window." + id + "=1;" ) );
			} catch(e) {}

			root.insertBefore( script, root.firstChild );

			// Make sure that the execution of code works by injecting a script
			// tag with appendChild/createTextNode
			// (IE doesn't support this, fails, and uses .text instead)
			if ( window[ id ] ) {
				_scriptEval = true;
				delete window[ id ];
			} else {
				_scriptEval = false;
			}

			root.removeChild( script );
			// release memory in IE
			root = script = id  = null;
		}

		return _scriptEval;
	};

	// Test to see if it's possible to delete an expando from an element
	// Fails in Internet Explorer
	try {
		delete div.test;

	} catch(e) {
		jQuery.support.deleteExpando = false;
	}

	if ( !div.addEventListener && div.attachEvent && div.fireEvent ) {
		div.attachEvent("onclick", function click() {
			// Cloning a node shouldn't copy over any
			// bound event handlers (IE does this)
			jQuery.support.noCloneEvent = false;
			div.detachEvent("onclick", click);
		});
		div.cloneNode(true).fireEvent("onclick");
	}

	div = document.createElement("div");
	div.innerHTML = "<input type='radio' name='radiotest' checked='checked'/>";

	var fragment = document.createDocumentFragment();
	fragment.appendChild( div.firstChild );

	// WebKit doesn't clone checked state correctly in fragments
	jQuery.support.checkClone = fragment.cloneNode(true).cloneNode(true).lastChild.checked;

	// Figure out if the W3C box model works as expected
	// document.body must exist before we can do this
	jQuery(function() {
		var div = document.createElement("div"),
			body = document.getElementsByTagName("body")[0];

		// Frameset documents with no body should not run this code
		if ( !body ) {
			return;
		}

		div.style.width = div.style.paddingLeft = "1px";
		body.appendChild( div );
		jQuery.boxModel = jQuery.support.boxModel = div.offsetWidth === 2;

		if ( "zoom" in div.style ) {
			// Check if natively block-level elements act like inline-block
			// elements when setting their display to 'inline' and giving
			// them layout
			// (IE < 8 does this)
			div.style.display = "inline";
			div.style.zoom = 1;
			jQuery.support.inlineBlockNeedsLayout = div.offsetWidth === 2;

			// Check if elements with layout shrink-wrap their children
			// (IE 6 does this)
			div.style.display = "";
			div.innerHTML = "<div style='width:4px;'></div>";
			jQuery.support.shrinkWrapBlocks = div.offsetWidth !== 2;
		}

		div.innerHTML = "<table><tr><td style='padding:0;border:0;display:none'></td><td>t</td></tr></table>";
		var tds = div.getElementsByTagName("td");

		// Check if table cells still have offsetWidth/Height when they are set
		// to display:none and there are still other visible table cells in a
		// table row; if so, offsetWidth/Height are not reliable for use when
		// determining if an element has been hidden directly using
		// display:none (it is still safe to use offsets if a parent element is
		// hidden; don safety goggles and see bug #4512 for more information).
		// (only IE 8 fails this test)
		jQuery.support.reliableHiddenOffsets = tds[0].offsetHeight === 0;

		tds[0].style.display = "";
		tds[1].style.display = "none";

		// Check if empty table cells still have offsetWidth/Height
		// (IE < 8 fail this test)
		jQuery.support.reliableHiddenOffsets = jQuery.support.reliableHiddenOffsets && tds[0].offsetHeight === 0;
		div.innerHTML = "";

		body.removeChild( div ).style.display = "none";
		div = tds = null;
	});

	// Technique from Juriy Zaytsev
	// http://thinkweb2.com/projects/prototype/detecting-event-support-without-browser-sniffing/
	var eventSupported = function( eventName ) {
		var el = document.createElement("div");
		eventName = "on" + eventName;

		// We only care about the case where non-standard event systems
		// are used, namely in IE. Short-circuiting here helps us to
		// avoid an eval call (in setAttribute) which can cause CSP
		// to go haywire. See: https://developer.mozilla.org/en/Security/CSP
		if ( !el.attachEvent ) {
			return true;
		}

		var isSupported = (eventName in el);
		if ( !isSupported ) {
			el.setAttribute(eventName, "return;");
			isSupported = typeof el[eventName] === "function";
		}
		el = null;

		return isSupported;
	};

	jQuery.support.submitBubbles = eventSupported("submit");
	jQuery.support.changeBubbles = eventSupported("change");

	// release memory in IE
	div = all = a = null;
})();



var rbrace = /^(?:\{.*\}|\[.*\])$/;

jQuery.extend({
	cache: {},

	// Please use with caution
	uuid: 0,

	// Unique for each copy of jQuery on the page
	// Non-digits removed to match rinlinejQuery
	expando: "jQuery" + ( jQuery.fn.jquery + Math.random() ).replace( /\D/g, "" ),

	// The following elements throw uncatchable exceptions if you
	// attempt to add expando properties to them.
	noData: {
		"embed": true,
		// Ban all objects except for Flash (which handle expandos)
		"object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
		"applet": true
	},

	hasData: function( elem ) {
		elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];

		return !!elem && !isEmptyDataObject( elem );
	},

	data: function( elem, name, data, pvt /* Internal Use Only */ ) {
		if ( !jQuery.acceptData( elem ) ) {
			return;
		}

		var internalKey = jQuery.expando, getByName = typeof name === "string", thisCache,

			// We have to handle DOM nodes and JS objects differently because IE6-7
			// can't GC object references properly across the DOM-JS boundary
			isNode = elem.nodeType,

			// Only DOM nodes need the global jQuery cache; JS object data is
			// attached directly to the object so GC can occur automatically
			cache = isNode ? jQuery.cache : elem,

			// Only defining an ID for JS objects if its cache already exists allows
			// the code to shortcut on the same path as a DOM node with no cache
			id = isNode ? elem[ jQuery.expando ] : elem[ jQuery.expando ] && jQuery.expando;

		// Avoid doing any more work than we need to when trying to get data on an
		// object that has no data at all
		if ( (!id || (pvt && id && !cache[ id ][ internalKey ])) && getByName && data === undefined ) {
			return;
		}

		if ( !id ) {
			// Only DOM nodes need a new unique ID for each element since their data
			// ends up in the global cache
			if ( isNode ) {
				elem[ jQuery.expando ] = id = ++jQuery.uuid;
			} else {
				id = jQuery.expando;
			}
		}

		if ( !cache[ id ] ) {
			cache[ id ] = {};

			// TODO: This is a hack for 1.5 ONLY. Avoids exposing jQuery
			// metadata on plain JS objects when the object is serialized using
			// JSON.stringify
			if ( !isNode ) {
				cache[ id ].toJSON = jQuery.noop;
			}
		}

		// An object can be passed to jQuery.data instead of a key/value pair; this gets
		// shallow copied over onto the existing cache
		if ( typeof name === "object" || typeof name === "function" ) {
			if ( pvt ) {
				cache[ id ][ internalKey ] = jQuery.extend(cache[ id ][ internalKey ], name);
			} else {
				cache[ id ] = jQuery.extend(cache[ id ], name);
			}
		}

		thisCache = cache[ id ];

		// Internal jQuery data is stored in a separate object inside the object's data
		// cache in order to avoid key collisions between internal data and user-defined
		// data
		if ( pvt ) {
			if ( !thisCache[ internalKey ] ) {
				thisCache[ internalKey ] = {};
			}

			thisCache = thisCache[ internalKey ];
		}

		if ( data !== undefined ) {
			thisCache[ name ] = data;
		}

		// TODO: This is a hack for 1.5 ONLY. It will be removed in 1.6. Users should
		// not attempt to inspect the internal events object using jQuery.data, as this
		// internal data object is undocumented and subject to change.
		if ( name === "events" && !thisCache[name] ) {
			return thisCache[ internalKey ] && thisCache[ internalKey ].events;
		}

		return getByName ? thisCache[ name ] : thisCache;
	},

	removeData: function( elem, name, pvt /* Internal Use Only */ ) {
		if ( !jQuery.acceptData( elem ) ) {
			return;
		}

		var internalKey = jQuery.expando, isNode = elem.nodeType,

			// See jQuery.data for more information
			cache = isNode ? jQuery.cache : elem,

			// See jQuery.data for more information
			id = isNode ? elem[ jQuery.expando ] : jQuery.expando;

		// If there is already no cache entry for this object, there is no
		// purpose in continuing
		if ( !cache[ id ] ) {
			return;
		}

		if ( name ) {
			var thisCache = pvt ? cache[ id ][ internalKey ] : cache[ id ];

			if ( thisCache ) {
				delete thisCache[ name ];

				// If there is no data left in the cache, we want to continue
				// and let the cache object itself get destroyed
				if ( !isEmptyDataObject(thisCache) ) {
					return;
				}
			}
		}

		// See jQuery.data for more information
		if ( pvt ) {
			delete cache[ id ][ internalKey ];

			// Don't destroy the parent cache unless the internal data object
			// had been the only thing left in it
			if ( !isEmptyDataObject(cache[ id ]) ) {
				return;
			}
		}

		var internalCache = cache[ id ][ internalKey ];

		// Browsers that fail expando deletion also refuse to delete expandos on
		// the window, but it will allow it on all other JS objects; other browsers
		// don't care
		if ( jQuery.support.deleteExpando || cache != window ) {
			delete cache[ id ];
		} else {
			cache[ id ] = null;
		}

		// We destroyed the entire user cache at once because it's faster than
		// iterating through each key, but we need to continue to persist internal
		// data if it existed
		if ( internalCache ) {
			cache[ id ] = {};
			// TODO: This is a hack for 1.5 ONLY. Avoids exposing jQuery
			// metadata on plain JS objects when the object is serialized using
			// JSON.stringify
			if ( !isNode ) {
				cache[ id ].toJSON = jQuery.noop;
			}

			cache[ id ][ internalKey ] = internalCache;

		// Otherwise, we need to eliminate the expando on the node to avoid
		// false lookups in the cache for entries that no longer exist
		} else if ( isNode ) {
			// IE does not allow us to delete expando properties from nodes,
			// nor does it have a removeAttribute function on Document nodes;
			// we must handle all of these cases
			if ( jQuery.support.deleteExpando ) {
				delete elem[ jQuery.expando ];
			} else if ( elem.removeAttribute ) {
				elem.removeAttribute( jQuery.expando );
			} else {
				elem[ jQuery.expando ] = null;
			}
		}
	},

	// For internal use only.
	_data: function( elem, name, data ) {
		return jQuery.data( elem, name, data, true );
	},

	// A method for determining if a DOM node can handle the data expando
	acceptData: function( elem ) {
		if ( elem.nodeName ) {
			var match = jQuery.noData[ elem.nodeName.toLowerCase() ];

			if ( match ) {
				return !(match === true || elem.getAttribute("classid") !== match);
			}
		}

		return true;
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var data = null;

		if ( typeof key === "undefined" ) {
			if ( this.length ) {
				data = jQuery.data( this[0] );

				if ( this[0].nodeType === 1 ) {
					var attr = this[0].attributes, name;
					for ( var i = 0, l = attr.length; i < l; i++ ) {
						name = attr[i].name;

						if ( name.indexOf( "data-" ) === 0 ) {
							name = name.substr( 5 );
							dataAttr( this[0], name, data[ name ] );
						}
					}
				}
			}

			return data;

		} else if ( typeof key === "object" ) {
			return this.each(function() {
				jQuery.data( this, key );
			});
		}

		var parts = key.split(".");
		parts[1] = parts[1] ? "." + parts[1] : "";

		if ( value === undefined ) {
			data = this.triggerHandler("getData" + parts[1] + "!", [parts[0]]);

			// Try to fetch any internally stored data first
			if ( data === undefined && this.length ) {
				data = jQuery.data( this[0], key );
				data = dataAttr( this[0], key, data );
			}

			return data === undefined && parts[1] ?
				this.data( parts[0] ) :
				data;

		} else {
			return this.each(function() {
				var $this = jQuery( this ),
					args = [ parts[0], value ];

				$this.triggerHandler( "setData" + parts[1] + "!", args );
				jQuery.data( this, key, value );
				$this.triggerHandler( "changeData" + parts[1] + "!", args );
			});
		}
	},

	removeData: function( key ) {
		return this.each(function() {
			jQuery.removeData( this, key );
		});
	}
});

function dataAttr( elem, key, data ) {
	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		data = elem.getAttribute( "data-" + key );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
				data === "false" ? false :
				data === "null" ? null :
				!jQuery.isNaN( data ) ? parseFloat( data ) :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			jQuery.data( elem, key, data );

		} else {
			data = undefined;
		}
	}

	return data;
}

// TODO: This is a hack for 1.5 ONLY to allow objects with a single toJSON
// property to be considered empty objects; this property always exists in
// order to make sure JSON.stringify does not expose internal metadata
function isEmptyDataObject( obj ) {
	for ( var name in obj ) {
		if ( name !== "toJSON" ) {
			return false;
		}
	}

	return true;
}




jQuery.extend({
	queue: function( elem, type, data ) {
		if ( !elem ) {
			return;
		}

		type = (type || "fx") + "queue";
		var q = jQuery._data( elem, type );

		// Speed up dequeue by getting out quickly if this is just a lookup
		if ( !data ) {
			return q || [];
		}

		if ( !q || jQuery.isArray(data) ) {
			q = jQuery._data( elem, type, jQuery.makeArray(data) );

		} else {
			q.push( data );
		}

		return q;
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			fn = queue.shift();

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
		}

		if ( fn ) {
			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift("inprogress");
			}

			fn.call(elem, function() {
				jQuery.dequeue(elem, type);
			});
		}

		if ( !queue.length ) {
			jQuery.removeData( elem, type + "queue", true );
		}
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
		}

		if ( data === undefined ) {
			return jQuery.queue( this[0], type );
		}
		return this.each(function( i ) {
			var queue = jQuery.queue( this, type, data );

			if ( type === "fx" && queue[0] !== "inprogress" ) {
				jQuery.dequeue( this, type );
			}
		});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},

	// Based off of the plugin by Clint Helfers, with permission.
	// http://blindsignals.com/index.php/2009/07/jquery-delay/
	delay: function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
		type = type || "fx";

		return this.queue( type, function() {
			var elem = this;
			setTimeout(function() {
				jQuery.dequeue( elem, type );
			}, time );
		});
	},

	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	}
});




var rclass = /[\n\t\r]/g,
	rspaces = /\s+/,
	rreturn = /\r/g,
	rspecialurl = /^(?:href|src|style)$/,
	rtype = /^(?:button|input)$/i,
	rfocusable = /^(?:button|input|object|select|textarea)$/i,
	rclickable = /^a(?:rea)?$/i,
	rradiocheck = /^(?:radio|checkbox)$/i;

jQuery.props = {
	"for": "htmlFor",
	"class": "className",
	readonly: "readOnly",
	maxlength: "maxLength",
	cellspacing: "cellSpacing",
	rowspan: "rowSpan",
	colspan: "colSpan",
	tabindex: "tabIndex",
	usemap: "useMap",
	frameborder: "frameBorder"
};

jQuery.fn.extend({
	attr: function( name, value ) {
		return jQuery.access( this, name, value, true, jQuery.attr );
	},

	removeAttr: function( name, fn ) {
		return this.each(function(){
			jQuery.attr( this, name, "" );
			if ( this.nodeType === 1 ) {
				this.removeAttribute( name );
			}
		});
	},

	addClass: function( value ) {
		if ( jQuery.isFunction(value) ) {
			return this.each(function(i) {
				var self = jQuery(this);
				self.addClass( value.call(this, i, self.attr("class")) );
			});
		}

		if ( value && typeof value === "string" ) {
			var classNames = (value || "").split( rspaces );

			for ( var i = 0, l = this.length; i < l; i++ ) {
				var elem = this[i];

				if ( elem.nodeType === 1 ) {
					if ( !elem.className ) {
						elem.className = value;

					} else {
						var className = " " + elem.className + " ",
							setClass = elem.className;

						for ( var c = 0, cl = classNames.length; c < cl; c++ ) {
							if ( className.indexOf( " " + classNames[c] + " " ) < 0 ) {
								setClass += " " + classNames[c];
							}
						}
						elem.className = jQuery.trim( setClass );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		if ( jQuery.isFunction(value) ) {
			return this.each(function(i) {
				var self = jQuery(this);
				self.removeClass( value.call(this, i, self.attr("class")) );
			});
		}

		if ( (value && typeof value === "string") || value === undefined ) {
			var classNames = (value || "").split( rspaces );

			for ( var i = 0, l = this.length; i < l; i++ ) {
				var elem = this[i];

				if ( elem.nodeType === 1 && elem.className ) {
					if ( value ) {
						var className = (" " + elem.className + " ").replace(rclass, " ");
						for ( var c = 0, cl = classNames.length; c < cl; c++ ) {
							className = className.replace(" " + classNames[c] + " ", " ");
						}
						elem.className = jQuery.trim( className );

					} else {
						elem.className = "";
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isBool = typeof stateVal === "boolean";

		if ( jQuery.isFunction( value ) ) {
			return this.each(function(i) {
				var self = jQuery(this);
				self.toggleClass( value.call(this, i, self.attr("class"), stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					state = stateVal,
					classNames = value.split( rspaces );

				while ( (className = classNames[ i++ ]) ) {
					// check each className given, space seperated list
					state = isBool ? state : !self.hasClass( className );
					self[ state ? "addClass" : "removeClass" ]( className );
				}

			} else if ( type === "undefined" || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					jQuery._data( this, "__className__", this.className );
				}

				// toggle whole className
				this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ";
		for ( var i = 0, l = this.length; i < l; i++ ) {
			if ( (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) > -1 ) {
				return true;
			}
		}

		return false;
	},

	val: function( value ) {
		if ( !arguments.length ) {
			var elem = this[0];

			if ( elem ) {
				if ( jQuery.nodeName( elem, "option" ) ) {
					// attributes.value is undefined in Blackberry 4.7 but
					// uses .value. See #6932
					var val = elem.attributes.value;
					return !val || val.specified ? elem.value : elem.text;
				}

				// We need to handle select boxes special
				if ( jQuery.nodeName( elem, "select" ) ) {
					var index = elem.selectedIndex,
						values = [],
						options = elem.options,
						one = elem.type === "select-one";

					// Nothing was selected
					if ( index < 0 ) {
						return null;
					}

					// Loop through all the selected options
					for ( var i = one ? index : 0, max = one ? index + 1 : options.length; i < max; i++ ) {
						var option = options[ i ];

						// Don't return options that are disabled or in a disabled optgroup
						if ( option.selected && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) &&
								(!option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" )) ) {

							// Get the specific value for the option
							value = jQuery(option).val();

							// We don't need an array for one selects
							if ( one ) {
								return value;
							}

							// Multi-Selects return an array
							values.push( value );
						}
					}

					// Fixes Bug #2551 -- select.val() broken in IE after form.reset()
					if ( one && !values.length && options.length ) {
						return jQuery( options[ index ] ).val();
					}

					return values;
				}

				// Handle the case where in Webkit "" is returned instead of "on" if a value isn't specified
				if ( rradiocheck.test( elem.type ) && !jQuery.support.checkOn ) {
					return elem.getAttribute("value") === null ? "on" : elem.value;
				}

				// Everything else, we just grab the value
				return (elem.value || "").replace(rreturn, "");

			}

			return undefined;
		}

		var isFunction = jQuery.isFunction(value);

		return this.each(function(i) {
			var self = jQuery(this), val = value;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call(this, i, self.val());
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";
			} else if ( typeof val === "number" ) {
				val += "";
			} else if ( jQuery.isArray(val) ) {
				val = jQuery.map(val, function (value) {
					return value == null ? "" : value + "";
				});
			}

			if ( jQuery.isArray(val) && rradiocheck.test( this.type ) ) {
				this.checked = jQuery.inArray( self.val(), val ) >= 0;

			} else if ( jQuery.nodeName( this, "select" ) ) {
				var values = jQuery.makeArray(val);

				jQuery( "option", this ).each(function() {
					this.selected = jQuery.inArray( jQuery(this).val(), values ) >= 0;
				});

				if ( !values.length ) {
					this.selectedIndex = -1;
				}

			} else {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	attrFn: {
		val: true,
		css: true,
		html: true,
		text: true,
		data: true,
		width: true,
		height: true,
		offset: true
	},

	attr: function( elem, name, value, pass ) {
		// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || elem.nodeType === 2 ) {
			return undefined;
		}

		if ( pass && name in jQuery.attrFn ) {
			return jQuery(elem)[name](value);
		}

		var notxml = elem.nodeType !== 1 || !jQuery.isXMLDoc( elem ),
			// Whether we are setting (or getting)
			set = value !== undefined;

		// Try to normalize/fix the name
		name = notxml && jQuery.props[ name ] || name;

		// Only do all the following if this is a node (faster for style)
		if ( elem.nodeType === 1 ) {
			// These attributes require special treatment
			var special = rspecialurl.test( name );

			// Safari mis-reports the default selected property of an option
			// Accessing the parent's selectedIndex property fixes it
			if ( name === "selected" && !jQuery.support.optSelected ) {
				var parent = elem.parentNode;
				if ( parent ) {
					parent.selectedIndex;

					// Make sure that it also works with optgroups, see #5701
					if ( parent.parentNode ) {
						parent.parentNode.selectedIndex;
					}
				}
			}

			// If applicable, access the attribute via the DOM 0 way
			// 'in' checks fail in Blackberry 4.7 #6931
			if ( (name in elem || elem[ name ] !== undefined) && notxml && !special ) {
				if ( set ) {
					// We can't allow the type property to be changed (since it causes problems in IE)
					if ( name === "type" && rtype.test( elem.nodeName ) && elem.parentNode ) {
						jQuery.error( "type property can't be changed" );
					}

					if ( value === null ) {
						if ( elem.nodeType === 1 ) {
							elem.removeAttribute( name );
						}

					} else {
						elem[ name ] = value;
					}
				}

				// browsers index elements by id/name on forms, give priority to attributes.
				if ( jQuery.nodeName( elem, "form" ) && elem.getAttributeNode(name) ) {
					return elem.getAttributeNode( name ).nodeValue;
				}

				// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
				// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				if ( name === "tabIndex" ) {
					var attributeNode = elem.getAttributeNode( "tabIndex" );

					return attributeNode && attributeNode.specified ?
						attributeNode.value :
						rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
							0 :
							undefined;
				}

				return elem[ name ];
			}

			if ( !jQuery.support.style && notxml && name === "style" ) {
				if ( set ) {
					elem.style.cssText = "" + value;
				}

				return elem.style.cssText;
			}

			if ( set ) {
				// convert the value to a string (all browsers do this but IE) see #1070
				elem.setAttribute( name, "" + value );
			}

			// Ensure that missing attributes return undefined
			// Blackberry 4.7 returns "" from getAttribute #6938
			if ( !elem.attributes[ name ] && (elem.hasAttribute && !elem.hasAttribute( name )) ) {
				return undefined;
			}

			var attr = !jQuery.support.hrefNormalized && notxml && special ?
					// Some attributes require a special call on IE
					elem.getAttribute( name, 2 ) :
					elem.getAttribute( name );

			// Non-existent attributes return null, we normalize to undefined
			return attr === null ? undefined : attr;
		}
		// Handle everything which isn't a DOM element node
		if ( set ) {
			elem[ name ] = value;
		}
		return elem[ name ];
	}
});




var rnamespaces = /\.(.*)$/,
	rformElems = /^(?:textarea|input|select)$/i,
	rperiod = /\./g,
	rspace = / /g,
	rescape = /[^\w\s.|`]/g,
	fcleanup = function( nm ) {
		return nm.replace(rescape, "\\$&");
	};

/*
 * A number of helper functions used for managing events.
 * Many of the ideas behind this code originated from
 * Dean Edwards' addEvent library.
 */
jQuery.event = {

	// Bind an event to an element
	// Original by Dean Edwards
	add: function( elem, types, handler, data ) {
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// TODO :: Use a try/catch until it's safe to pull this out (likely 1.6)
		// Minor release fix for bug #8018
		try {
			// For whatever reason, IE has trouble passing the window object
			// around, causing it to be cloned in the process
			if ( jQuery.isWindow( elem ) && ( elem !== window && !elem.frameElement ) ) {
				elem = window;
			}
		}
		catch ( e ) {}

		if ( handler === false ) {
			handler = returnFalse;
		} else if ( !handler ) {
			// Fixes bug #7229. Fix recommended by jdalton
			return;
		}

		var handleObjIn, handleObj;

		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
		}

		// Make sure that the function being executed has a unique ID
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure
		var elemData = jQuery._data( elem );

		// If no elemData is found then we must be trying to bind to one of the
		// banned noData elements
		if ( !elemData ) {
			return;
		}

		var events = elemData.events,
			eventHandle = elemData.handle;

		if ( !events ) {
			elemData.events = events = {};
		}

		if ( !eventHandle ) {
			elemData.handle = eventHandle = function() {
				// Handle the second event of a trigger and when
				// an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && !jQuery.event.triggered ?
					jQuery.event.handle.apply( eventHandle.elem, arguments ) :
					undefined;
			};
		}

		// Add elem as a property of the handle function
		// This is to prevent a memory leak with non-native events in IE.
		eventHandle.elem = elem;

		// Handle multiple events separated by a space
		// jQuery(...).bind("mouseover mouseout", fn);
		types = types.split(" ");

		var type, i = 0, namespaces;

		while ( (type = types[ i++ ]) ) {
			handleObj = handleObjIn ?
				jQuery.extend({}, handleObjIn) :
				{ handler: handler, data: data };

			// Namespaced event handlers
			if ( type.indexOf(".") > -1 ) {
				namespaces = type.split(".");
				type = namespaces.shift();
				handleObj.namespace = namespaces.slice(0).sort().join(".");

			} else {
				namespaces = [];
				handleObj.namespace = "";
			}

			handleObj.type = type;
			if ( !handleObj.guid ) {
				handleObj.guid = handler.guid;
			}

			// Get the current list of functions bound to this event
			var handlers = events[ type ],
				special = jQuery.event.special[ type ] || {};

			// Init the event handler queue
			if ( !handlers ) {
				handlers = events[ type ] = [];

				// Check for a special event handler
				// Only use addEventListener/attachEvent if the special
				// events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					// Bind the global event handler to the element
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );

					} else if ( elem.attachEvent ) {
						elem.attachEvent( "on" + type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add the function to the element's handler list
			handlers.push( handleObj );

			// Keep track of which events have been used, for global triggering
			jQuery.event.global[ type ] = true;
		}

		// Nullify elem to prevent memory leaks in IE
		elem = null;
	},

	global: {},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, pos ) {
		// don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		if ( handler === false ) {
			handler = returnFalse;
		}

		var ret, type, fn, j, i = 0, all, namespaces, namespace, special, eventType, handleObj, origType,
			elemData = jQuery.hasData( elem ) && jQuery._data( elem ),
			events = elemData && elemData.events;

		if ( !elemData || !events ) {
			return;
		}

		// types is actually an event object here
		if ( types && types.type ) {
			handler = types.handler;
			types = types.type;
		}

		// Unbind all events for the element
		if ( !types || typeof types === "string" && types.charAt(0) === "." ) {
			types = types || "";

			for ( type in events ) {
				jQuery.event.remove( elem, type + types );
			}

			return;
		}

		// Handle multiple events separated by a space
		// jQuery(...).unbind("mouseover mouseout", fn);
		types = types.split(" ");

		while ( (type = types[ i++ ]) ) {
			origType = type;
			handleObj = null;
			all = type.indexOf(".") < 0;
			namespaces = [];

			if ( !all ) {
				// Namespaced event handlers
				namespaces = type.split(".");
				type = namespaces.shift();

				namespace = new RegExp("(^|\\.)" +
					jQuery.map( namespaces.slice(0).sort(), fcleanup ).join("\\.(?:.*\\.)?") + "(\\.|$)");
			}

			eventType = events[ type ];

			if ( !eventType ) {
				continue;
			}

			if ( !handler ) {
				for ( j = 0; j < eventType.length; j++ ) {
					handleObj = eventType[ j ];

					if ( all || namespace.test( handleObj.namespace ) ) {
						jQuery.event.remove( elem, origType, handleObj.handler, j );
						eventType.splice( j--, 1 );
					}
				}

				continue;
			}

			special = jQuery.event.special[ type ] || {};

			for ( j = pos || 0; j < eventType.length; j++ ) {
				handleObj = eventType[ j ];

				if ( handler.guid === handleObj.guid ) {
					// remove the given handler for the given type
					if ( all || namespace.test( handleObj.namespace ) ) {
						if ( pos == null ) {
							eventType.splice( j--, 1 );
						}

						if ( special.remove ) {
							special.remove.call( elem, handleObj );
						}
					}

					if ( pos != null ) {
						break;
					}
				}
			}

			// remove generic event handler if no more handlers exist
			if ( eventType.length === 0 || pos != null && eventType.length === 1 ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				ret = null;
				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			var handle = elemData.handle;
			if ( handle ) {
				handle.elem = null;
			}

			delete elemData.events;
			delete elemData.handle;

			if ( jQuery.isEmptyObject( elemData ) ) {
				jQuery.removeData( elem, undefined, true );
			}
		}
	},

	// bubbling is internal
	trigger: function( event, data, elem /*, bubbling */ ) {
		// Event object or event type
		var type = event.type || event,
			bubbling = arguments[3];

		if ( !bubbling ) {
			event = typeof event === "object" ?
				// jQuery.Event object
				event[ jQuery.expando ] ? event :
				// Object literal
				jQuery.extend( jQuery.Event(type), event ) :
				// Just the event type (string)
				jQuery.Event(type);

			if ( type.indexOf("!") >= 0 ) {
				event.type = type = type.slice(0, -1);
				event.exclusive = true;
			}

			// Handle a global trigger
			if ( !elem ) {
				// Don't bubble custom events when global (to avoid too much overhead)
				event.stopPropagation();

				// Only trigger if we've ever bound an event for it
				if ( jQuery.event.global[ type ] ) {
					// XXX This code smells terrible. event.js should not be directly
					// inspecting the data cache
					jQuery.each( jQuery.cache, function() {
						// internalKey variable is just used to make it easier to find
						// and potentially change this stuff later; currently it just
						// points to jQuery.expando
						var internalKey = jQuery.expando,
							internalCache = this[ internalKey ];
						if ( internalCache && internalCache.events && internalCache.events[ type ] ) {
							jQuery.event.trigger( event, data, internalCache.handle.elem );
						}
					});
				}
			}

			// Handle triggering a single element

			// don't do events on text and comment nodes
			if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 ) {
				return undefined;
			}

			// Clean up in case it is reused
			event.result = undefined;
			event.target = elem;

			// Clone the incoming data, if any
			data = jQuery.makeArray( data );
			data.unshift( event );
		}

		event.currentTarget = elem;

		// Trigger the event, it is assumed that "handle" is a function
		var handle = jQuery._data( elem, "handle" );

		if ( handle ) {
			handle.apply( elem, data );
		}9

		var parent = elem.parentNode || elem.ownerDocument;

		// Trigger an inline bound script
		try {
			if ( !(elem && elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()]) ) {
				if ( elem[ "on" + type ] && elem[ "on" + type ].apply( elem, data ) === false ) {
					event.result = false;
					event.preventDefault();
				}
			}

		// prevent IE from throwing an error for some elements with some event types, see #3533
		} catch (inlineError) {}

		if ( !event.isPropagationStopped() && parent ) {
			jQuery.event.trigger( event, data, parent, true );

		} else if ( !event.isDefaultPrevented() ) {
			var old,
				target = event.target,
				targetType = type.replace( rnamespaces, "" ),
				isClick = jQuery.nodeName( target, "a" ) && targetType === "click",
				special = jQuery.event.special[ targetType ] || {};

			if ( (!special._default || special._default.call( elem, event ) === false) &&
				!isClick && !(target && target.nodeName && jQuery.noData[target.nodeName.toLowerCase()]) ) {

				try {
					if ( target[ targetType ] ) {
						// Make sure that we don't accidentally re-trigger the onFOO events
						old = target[ "on" + targetType ];

						if ( old ) {
							target[ "on" + targetType ] = null;
						}

						jQuery.event.triggered = true;
						target[ targetType ]();
					}

				// prevent IE from throwing an error for some elements with some event types, see #3533
				} catch (triggerError) {}

				if ( old ) {
					target[ "on" + targetType ] = old;
				}

				jQuery.event.triggered = false;
			}
		}
	},

	handle: function( event ) {
		var all, handlers, namespaces, namespace_re, events,
			namespace_sort = [],
			args = jQuery.makeArray( arguments );

		event = args[0] = jQuery.event.fix( event || window.event );
		event.currentTarget = this;

		// Namespaced event handlers
		all = event.type.indexOf(".") < 0 && !event.exclusive;

		if ( !all ) {
			namespaces = event.type.split(".");
			event.type = namespaces.shift();
			namespace_sort = namespaces.slice(0).sort();
			namespace_re = new RegExp("(^|\\.)" + namespace_sort.join("\\.(?:.*\\.)?") + "(\\.|$)");
		}

		event.namespace = event.namespace || namespace_sort.join(".");

		events = jQuery._data(this, "events");

		handlers = (events || {})[ event.type ];

		if ( events && handlers ) {
			// Clone the handlers to prevent manipulation
			handlers = handlers.slice(0);

			for ( var j = 0, l = handlers.length; j < l; j++ ) {
				var handleObj = handlers[ j ];

				// Filter the functions by class
				if ( all || namespace_re.test( handleObj.namespace ) ) {
					// Pass in a reference to the handler function itself
					// So that we can later remove it
					event.handler = handleObj.handler;
					event.data = handleObj.data;
					event.handleObj = handleObj;

					var ret = handleObj.handler.apply( this, args );

					if ( ret !== undefined ) {
						event.result = ret;
						if ( ret === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}

					if ( event.isImmediatePropagationStopped() ) {
						break;
					}
				}
			}
		}

		return event.result;
	},

	props: "altKey attrChange attrName bubbles button cancelable charCode clientX clientY ctrlKey currentTarget data detail eventPhase fromElement handler keyCode layerX layerY metaKey newValue offsetX offsetY pageX pageY prevValue relatedNode relatedTarget screenX screenY shiftKey srcElement target toElement view wheelDelta which".split(" "),

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// store a copy of the original event object
		// and "clone" to set read-only properties
		var originalEvent = event;
		event = jQuery.Event( originalEvent );

		for ( var i = this.props.length, prop; i; ) {
			prop = this.props[ --i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Fix target property, if necessary
		if ( !event.target ) {
			// Fixes #1925 where srcElement might not be defined either
			event.target = event.srcElement || document;
		}

		// check if target is a textnode (safari)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		// Add relatedTarget, if necessary
		if ( !event.relatedTarget && event.fromElement ) {
			event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement;
		}

		// Calculate pageX/Y if missing and clientX/Y available
		if ( event.pageX == null && event.clientX != null ) {
			var doc = document.documentElement,
				body = document.body;

			event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
			event.pageY = event.clientY + (doc && doc.scrollTop  || body && body.scrollTop  || 0) - (doc && doc.clientTop  || body && body.clientTop  || 0);
		}

		// Add which for key events
		if ( event.which == null && (event.charCode != null || event.keyCode != null) ) {
			event.which = event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add metaKey to non-Mac browsers (use ctrl for PC's and Meta for Macs)
		if ( !event.metaKey && event.ctrlKey ) {
			event.metaKey = event.ctrlKey;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		// Note: button is not normalized, so don't use it
		if ( !event.which && event.button !== undefined ) {
			event.which = (event.button & 1 ? 1 : ( event.button & 2 ? 3 : ( event.button & 4 ? 2 : 0 ) ));
		}

		return event;
	},

	// Deprecated, use jQuery.guid instead
	guid: 1E8,

	// Deprecated, use jQuery.proxy instead
	proxy: jQuery.proxy,

	special: {
		ready: {
			// Make sure the ready event is setup
			setup: jQuery.bindReady,
			teardown: jQuery.noop
		},

		live: {
			add: function( handleObj ) {
				jQuery.event.add( this,
					liveConvert( handleObj.origType, handleObj.selector ),
					jQuery.extend({}, handleObj, {handler: liveHandler, guid: handleObj.handler.guid}) );
			},

			remove: function( handleObj ) {
				jQuery.event.remove( this, liveConvert( handleObj.origType, handleObj.selector ), handleObj );
			}
		},

		beforeunload: {
			setup: function( data, namespaces, eventHandle ) {
				// We only want to do this special case on windows
				if ( jQuery.isWindow( this ) ) {
					this.onbeforeunload = eventHandle;
				}
			},

			teardown: function( namespaces, eventHandle ) {
				if ( this.onbeforeunload === eventHandle ) {
					this.onbeforeunload = null;
				}
			}
		}
	}
};

jQuery.removeEvent = document.removeEventListener ?
	function( elem, type, handle ) {
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle, false );
		}
	} :
	function( elem, type, handle ) {
		if ( elem.detachEvent ) {
			elem.detachEvent( "on" + type, handle );
		}
	};

jQuery.Event = function( src ) {
	// Allow instantiation without the 'new' keyword
	if ( !this.preventDefault ) {
		return new jQuery.Event( src );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = (src.defaultPrevented || src.returnValue === false ||
			src.getPreventDefault && src.getPreventDefault()) ? returnTrue : returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// timeStamp is buggy for some events on Firefox(#3843)
	// So we won't rely on the native value
	this.timeStamp = jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

function returnFalse() {
	return false;
}
function returnTrue() {
	return true;
}

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	preventDefault: function() {
		this.isDefaultPrevented = returnTrue;

		var e = this.originalEvent;
		if ( !e ) {
			return;
		}

		// if preventDefault exists run it on the original event
		if ( e.preventDefault ) {
			e.preventDefault();

		// otherwise set the returnValue property of the original event to false (IE)
		} else {
			e.returnValue = false;
		}
	},
	stopPropagation: function() {
		this.isPropagationStopped = returnTrue;

		var e = this.originalEvent;
		if ( !e ) {
			return;
		}
		// if stopPropagation exists run it on the original event
		if ( e.stopPropagation ) {
			e.stopPropagation();
		}
		// otherwise set the cancelBubble property of the original event to true (IE)
		e.cancelBubble = true;
	},
	stopImmediatePropagation: function() {
		this.isImmediatePropagationStopped = returnTrue;
		this.stopPropagation();
	},
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse
};

// Checks if an event happened on an element within another element
// Used in jQuery.event.special.mouseenter and mouseleave handlers
var withinElement = function( event ) {
	// Check if mouse(over|out) are still within the same parent element
	var parent = event.relatedTarget;

	// Firefox sometimes assigns relatedTarget a XUL element
	// which we cannot access the parentNode property of
	try {

		// Chrome does something similar, the parentNode property
		// can be accessed but is null.
		if ( parent !== document && !parent.parentNode ) {
			return;
		}
		// Traverse up the tree
		while ( parent && parent !== this ) {
			parent = parent.parentNode;
		}

		if ( parent !== this ) {
			// set the correct event type
			event.type = event.data;

			// handle event if we actually just moused on to a non sub-element
			jQuery.event.handle.apply( this, arguments );
		}

	// assuming we've left the element since we most likely mousedover a xul element
	} catch(e) { }
},

// In case of event delegation, we only need to rename the event.type,
// liveHandler will take care of the rest.
delegate = function( event ) {
	event.type = event.data;
	jQuery.event.handle.apply( this, arguments );
};

// Create mouseenter and mouseleave events
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		setup: function( data ) {
			jQuery.event.add( this, fix, data && data.selector ? delegate : withinElement, orig );
		},
		teardown: function( data ) {
			jQuery.event.remove( this, fix, data && data.selector ? delegate : withinElement );
		}
	};
});

// submit delegation
if ( !jQuery.support.submitBubbles ) {

	jQuery.event.special.submit = {
		setup: function( data, namespaces ) {
			if ( this.nodeName && this.nodeName.toLowerCase() !== "form" ) {
				jQuery.event.add(this, "click.specialSubmit", function( e ) {
					var elem = e.target,
						type = elem.type;

					if ( (type === "submit" || type === "image") && jQuery( elem ).closest("form").length ) {
						trigger( "submit", this, arguments );
					}
				});

				jQuery.event.add(this, "keypress.specialSubmit", function( e ) {
					var elem = e.target,
						type = elem.type;

					if ( (type === "text" || type === "password") && jQuery( elem ).closest("form").length && e.keyCode === 13 ) {
						trigger( "submit", this, arguments );
					}
				});

			} else {
				return false;
			}
		},

		teardown: function( namespaces ) {
			jQuery.event.remove( this, ".specialSubmit" );
		}
	};

}

// change delegation, happens here so we have bind.
if ( !jQuery.support.changeBubbles ) {

	var changeFilters,

	getVal = function( elem ) {
		var type = elem.type, val = elem.value;

		if ( type === "radio" || type === "checkbox" ) {
			val = elem.checked;

		} else if ( type === "select-multiple" ) {
			val = elem.selectedIndex > -1 ?
				jQuery.map( elem.options, function( elem ) {
					return elem.selected;
				}).join("-") :
				"";

		} else if ( elem.nodeName.toLowerCase() === "select" ) {
			val = elem.selectedIndex;
		}

		return val;
	},

	testChange = function testChange( e ) {
		var elem = e.target, data, val;

		if ( !rformElems.test( elem.nodeName ) || elem.readOnly ) {
			return;
		}

		data = jQuery._data( elem, "_change_data" );
		val = getVal(elem);

		// the current data will be also retrieved by beforeactivate
		if ( e.type !== "focusout" || elem.type !== "radio" ) {
			jQuery._data( elem, "_change_data", val );
		}

		if ( data === undefined || val === data ) {
			return;
		}

		if ( data != null || val ) {
			e.type = "change";
			e.liveFired = undefined;
			jQuery.event.trigger( e, arguments[1], elem );
		}
	};

	jQuery.event.special.change = {
		filters: {
			focusout: testChange,

			beforedeactivate: testChange,

			click: function( e ) {
				var elem = e.target, type = elem.type;

				if ( type === "radio" || type === "checkbox" || elem.nodeName.toLowerCase() === "select" ) {
					testChange.call( this, e );
				}
			},

			// Change has to be called before submit
			// Keydown will be called before keypress, which is used in submit-event delegation
			keydown: function( e ) {
				var elem = e.target, type = elem.type;

				if ( (e.keyCode === 13 && elem.nodeName.toLowerCase() !== "textarea") ||
					(e.keyCode === 32 && (type === "checkbox" || type === "radio")) ||
					type === "select-multiple" ) {
					testChange.call( this, e );
				}
			},

			// Beforeactivate happens also before the previous element is blurred
			// with this event you can't trigger a change event, but you can store
			// information
			beforeactivate: function( e ) {
				var elem = e.target;
				jQuery._data( elem, "_change_data", getVal(elem) );
			}
		},

		setup: function( data, namespaces ) {
			if ( this.type === "file" ) {
				return false;
			}

			for ( var type in changeFilters ) {
				jQuery.event.add( this, type + ".specialChange", changeFilters[type] );
			}

			return rformElems.test( this.nodeName );
		},

		teardown: function( namespaces ) {
			jQuery.event.remove( this, ".specialChange" );

			return rformElems.test( this.nodeName );
		}
	};

	changeFilters = jQuery.event.special.change.filters;

	// Handle when the input is .focus()'d
	changeFilters.focus = changeFilters.beforeactivate;
}

function trigger( type, elem, args ) {
	// Piggyback on a donor event to simulate a different one.
	// Fake originalEvent to avoid donor's stopPropagation, but if the
	// simulated event prevents default then we do the same on the donor.
	// Don't pass args or remember liveFired; they apply to the donor event.
	var event = jQuery.extend( {}, args[ 0 ] );
	event.type = type;
	event.originalEvent = {};
	event.liveFired = undefined;
	jQuery.event.handle.call( elem, event );
	if ( event.isDefaultPrevented() ) {
		args[ 0 ].preventDefault();
	}
}

// Create "bubbling" focus and blur events
if ( document.addEventListener ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {
		jQuery.event.special[ fix ] = {
			setup: function() {
				this.addEventListener( orig, handler, true );
			},
			teardown: function() {
				this.removeEventListener( orig, handler, true );
			}
		};

		function handler( e ) {
			e = jQuery.event.fix( e );
			e.type = fix;
			return jQuery.event.handle.call( this, e );
		}
	});
}

jQuery.each(["bind", "one"], function( i, name ) {
	jQuery.fn[ name ] = function( type, data, fn ) {
		// Handle object literals
		if ( typeof type === "object" ) {
			for ( var key in type ) {
				this[ name ](key, data, type[key], fn);
			}
			return this;
		}

		if ( jQuery.isFunction( data ) || data === false ) {
			fn = data;
			data = undefined;
		}

		var handler = name === "one" ? jQuery.proxy( fn, function( event ) {
			jQuery( this ).unbind( event, handler );
			return fn.apply( this, arguments );
		}) : fn;

		if ( type === "unload" && name !== "one" ) {
			this.one( type, data, fn );

		} else {
			for ( var i = 0, l = this.length; i < l; i++ ) {
				jQuery.event.add( this[i], type, handler, data );
			}
		}

		return this;
	};
});

jQuery.fn.extend({
	unbind: function( type, fn ) {
		// Handle object literals
		if ( typeof type === "object" && !type.preventDefault ) {
			for ( var key in type ) {
				this.unbind(key, type[key]);
			}

		} else {
			for ( var i = 0, l = this.length; i < l; i++ ) {
				jQuery.event.remove( this[i], type, fn );
			}
		}

		return this;
	},

	delegate: function( selector, types, data, fn ) {
		return this.live( types, data, fn, selector );
	},

	undelegate: function( selector, types, fn ) {
		if ( arguments.length === 0 ) {
				return this.unbind( "live" );

		} else {
			return this.die( types, null, fn, selector );
		}
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},

	triggerHandler: function( type, data ) {
		if ( this[0] ) {
			var event = jQuery.Event( type );
			event.preventDefault();
			event.stopPropagation();
			jQuery.event.trigger( event, data, this[0] );
			return event.result;
		}
	},

	toggle: function( fn ) {
		// Save reference to arguments for access in closure
		var args = arguments,
			i = 1;

		// link all the functions, so any of them can unbind this click handler
		while ( i < args.length ) {
			jQuery.proxy( fn, args[ i++ ] );
		}

		return this.click( jQuery.proxy( fn, function( event ) {
			// Figure out which function to execute
			var lastToggle = ( jQuery._data( this, "lastToggle" + fn.guid ) || 0 ) % i;
			jQuery._data( this, "lastToggle" + fn.guid, lastToggle + 1 );

			// Make sure that clicks stop
			event.preventDefault();

			// and execute the function
			return args[ lastToggle ].apply( this, arguments ) || false;
		}));
	},

	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
});

var liveMap = {
	focus: "focusin",
	blur: "focusout",
	mouseenter: "mouseover",
	mouseleave: "mouseout"
};

jQuery.each(["live", "die"], function( i, name ) {
	jQuery.fn[ name ] = function( types, data, fn, origSelector /* Internal Use Only */ ) {
		var type, i = 0, match, namespaces, preType,
			selector = origSelector || this.selector,
			context = origSelector ? this : jQuery( this.context );

		if ( typeof types === "object" && !types.preventDefault ) {
			for ( var key in types ) {
				context[ name ]( key, data, types[key], selector );
			}

			return this;
		}

		if ( jQuery.isFunction( data ) ) {
			fn = data;
			data = undefined;
		}

		types = (types || "").split(" ");

		while ( (type = types[ i++ ]) != null ) {
			match = rnamespaces.exec( type );
			namespaces = "";

			if ( match )  {
				namespaces = match[0];
				type = type.replace( rnamespaces, "" );
			}

			if ( type === "hover" ) {
				types.push( "mouseenter" + namespaces, "mouseleave" + namespaces );
				continue;
			}

			preType = type;

			if ( type === "focus" || type === "blur" ) {
				types.push( liveMap[ type ] + namespaces );
				type = type + namespaces;

			} else {
				type = (liveMap[ type ] || type) + namespaces;
			}

			if ( name === "live" ) {
				// bind live handler
				for ( var j = 0, l = context.length; j < l; j++ ) {
					jQuery.event.add( context[j], "live." + liveConvert( type, selector ),
						{ data: data, selector: selector, handler: fn, origType: type, origHandler: fn, preType: preType } );
				}

			} else {
				// unbind live handler
				context.unbind( "live." + liveConvert( type, selector ), fn );
			}
		}

		return this;
	};
});

function liveHandler( event ) {
	var stop, maxLevel, related, match, handleObj, elem, j, i, l, data, close, namespace, ret,
		elems = [],
		selectors = [],
		events = jQuery._data( this, "events" );

	// Make sure we avoid non-left-click bubbling in Firefox (#3861) and disabled elements in IE (#6911)
	if ( event.liveFired === this || !events || !events.live || event.target.disabled || event.button && event.type === "click" ) {
		return;
	}

	if ( event.namespace ) {
		namespace = new RegExp("(^|\\.)" + event.namespace.split(".").join("\\.(?:.*\\.)?") + "(\\.|$)");
	}

	event.liveFired = this;

	var live = events.live.slice(0);

	for ( j = 0; j < live.length; j++ ) {
		handleObj = live[j];

		if ( handleObj.origType.replace( rnamespaces, "" ) === event.type ) {
			selectors.push( handleObj.selector );

		} else {
			live.splice( j--, 1 );
		}
	}

	match = jQuery( event.target ).closest( selectors, event.currentTarget );

	for ( i = 0, l = match.length; i < l; i++ ) {
		close = match[i];

		for ( j = 0; j < live.length; j++ ) {
			handleObj = live[j];

			if ( close.selector === handleObj.selector && (!namespace || namespace.test( handleObj.namespace )) && !close.elem.disabled ) {
				elem = close.elem;
				related = null;

				// Those two events require additional checking
				if ( handleObj.preType === "mouseenter" || handleObj.preType === "mouseleave" ) {
					event.type = handleObj.preType;
					related = jQuery( event.relatedTarget ).closest( handleObj.selector )[0];
				}

				if ( !related || related !== elem ) {
					elems.push({ elem: elem, handleObj: handleObj, level: close.level });
				}
			}
		}
	}

	for ( i = 0, l = elems.length; i < l; i++ ) {
		match = elems[i];

		if ( maxLevel && match.level > maxLevel ) {
			break;
		}

		event.currentTarget = match.elem;
		event.data = match.handleObj.data;
		event.handleObj = match.handleObj;

		ret = match.handleObj.origHandler.apply( match.elem, arguments );

		if ( ret === false || event.isPropagationStopped() ) {
			maxLevel = match.level;

			if ( ret === false ) {
				stop = false;
			}
			if ( event.isImmediatePropagationStopped() ) {
				break;
			}
		}
	}

	return stop;
}

function liveConvert( type, selector ) {
	return (type && type !== "*" ? type + "." : "") + selector.replace(rperiod, "`").replace(rspace, "&");
}

jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		if ( fn == null ) {
			fn = data;
			data = null;
		}

		return arguments.length > 0 ?
			this.bind( name, data, fn ) :
			this.trigger( name );
	};

	if ( jQuery.attrFn ) {
		jQuery.attrFn[ name ] = true;
	}
});


/*!
 * Sizzle CSS Selector Engine
 *  Copyright 2011, The Dojo Foundation
 *  Released under the MIT, BSD, and GPL Licenses.
 *  More information: http://sizzlejs.com/
 */
(function(){

var chunker = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
	done = 0,
	toString = Object.prototype.toString,
	hasDuplicate = false,
	baseHasDuplicate = true,
	rBackslash = /\\/g,
	rNonWord = /\W/;

// Here we check if the JavaScript engine is using some sort of
// optimization where it does not always call our comparision
// function. If that is the case, discard the hasDuplicate value.
//   Thus far that includes Google Chrome.
[0, 0].sort(function() {
	baseHasDuplicate = false;
	return 0;
});

var Sizzle = function( selector, context, results, seed ) {
	results = results || [];
	context = context || document;

	var origContext = context;

	if ( context.nodeType !== 1 && context.nodeType !== 9 ) {
		return [];
	}
	
	if ( !selector || typeof selector !== "string" ) {
		return results;
	}

	var m, set, checkSet, extra, ret, cur, pop, i,
		prune = true,
		contextXML = Sizzle.isXML( context ),
		parts = [],
		soFar = selector;
	
	// Reset the position of the chunker regexp (start from head)
	do {
		chunker.exec( "" );
		m = chunker.exec( soFar );

		if ( m ) {
			soFar = m[3];
		
			parts.push( m[1] );
		
			if ( m[2] ) {
				extra = m[3];
				break;
			}
		}
	} while ( m );

	if ( parts.length > 1 && origPOS.exec( selector ) ) {

		if ( parts.length === 2 && Expr.relative[ parts[0] ] ) {
			set = posProcess( parts[0] + parts[1], context );

		} else {
			set = Expr.relative[ parts[0] ] ?
				[ context ] :
				Sizzle( parts.shift(), context );

			while ( parts.length ) {
				selector = parts.shift();

				if ( Expr.relative[ selector ] ) {
					selector += parts.shift();
				}
				
				set = posProcess( selector, set );
			}
		}

	} else {
		// Take a shortcut and set the context if the root selector is an ID
		// (but not if it'll be faster if the inner selector is an ID)
		if ( !seed && parts.length > 1 && context.nodeType === 9 && !contextXML &&
				Expr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1]) ) {

			ret = Sizzle.find( parts.shift(), context, contextXML );
			context = ret.expr ?
				Sizzle.filter( ret.expr, ret.set )[0] :
				ret.set[0];
		}

		if ( context ) {
			ret = seed ?
				{ expr: parts.pop(), set: makeArray(seed) } :
				Sizzle.find( parts.pop(), parts.length === 1 && (parts[0] === "~" || parts[0] === "+") && context.parentNode ? context.parentNode : context, contextXML );

			set = ret.expr ?
				Sizzle.filter( ret.expr, ret.set ) :
				ret.set;

			if ( parts.length > 0 ) {
				checkSet = makeArray( set );

			} else {
				prune = false;
			}

			while ( parts.length ) {
				cur = parts.pop();
				pop = cur;

				if ( !Expr.relative[ cur ] ) {
					cur = "";
				} else {
					pop = parts.pop();
				}

				if ( pop == null ) {
					pop = context;
				}

				Expr.relative[ cur ]( checkSet, pop, contextXML );
			}

		} else {
			checkSet = parts = [];
		}
	}

	if ( !checkSet ) {
		checkSet = set;
	}

	if ( !checkSet ) {
		Sizzle.error( cur || selector );
	}

	if ( toString.call(checkSet) === "[object Array]" ) {
		if ( !prune ) {
			results.push.apply( results, checkSet );

		} else if ( context && context.nodeType === 1 ) {
			for ( i = 0; checkSet[i] != null; i++ ) {
				if ( checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && Sizzle.contains(context, checkSet[i])) ) {
					results.push( set[i] );
				}
			}

		} else {
			for ( i = 0; checkSet[i] != null; i++ ) {
				if ( checkSet[i] && checkSet[i].nodeType === 1 ) {
					results.push( set[i] );
				}
			}
		}

	} else {
		makeArray( checkSet, results );
	}

	if ( extra ) {
		Sizzle( extra, origContext, results, seed );
		Sizzle.uniqueSort( results );
	}

	return results;
};

Sizzle.uniqueSort = function( results ) {
	if ( sortOrder ) {
		hasDuplicate = baseHasDuplicate;
		results.sort( sortOrder );

		if ( hasDuplicate ) {
			for ( var i = 1; i < results.length; i++ ) {
				if ( results[i] === results[ i - 1 ] ) {
					results.splice( i--, 1 );
				}
			}
		}
	}

	return results;
};

Sizzle.matches = function( expr, set ) {
	return Sizzle( expr, null, null, set );
};

Sizzle.matchesSelector = function( node, expr ) {
	return Sizzle( expr, null, null, [node] ).length > 0;
};

Sizzle.find = function( expr, context, isXML ) {
	var set;

	if ( !expr ) {
		return [];
	}

	for ( var i = 0, l = Expr.order.length; i < l; i++ ) {
		var match,
			type = Expr.order[i];
		
		if ( (match = Expr.leftMatch[ type ].exec( expr )) ) {
			var left = match[1];
			match.splice( 1, 1 );

			if ( left.substr( left.length - 1 ) !== "\\" ) {
				match[1] = (match[1] || "").replace( rBackslash, "" );
				set = Expr.find[ type ]( match, context, isXML );

				if ( set != null ) {
					expr = expr.replace( Expr.match[ type ], "" );
					break;
				}
			}
		}
	}

	if ( !set ) {
		set = typeof context.getElementsByTagName !== "undefined" ?
			context.getElementsByTagName( "*" ) :
			[];
	}

	return { set: set, expr: expr };
};

Sizzle.filter = function( expr, set, inplace, not ) {
	var match, anyFound,
		old = expr,
		result = [],
		curLoop = set,
		isXMLFilter = set && set[0] && Sizzle.isXML( set[0] );

	while ( expr && set.length ) {
		for ( var type in Expr.filter ) {
			if ( (match = Expr.leftMatch[ type ].exec( expr )) != null && match[2] ) {
				var found, item,
					filter = Expr.filter[ type ],
					left = match[1];

				anyFound = false;

				match.splice(1,1);

				if ( left.substr( left.length - 1 ) === "\\" ) {
					continue;
				}

				if ( curLoop === result ) {
					result = [];
				}

				if ( Expr.preFilter[ type ] ) {
					match = Expr.preFilter[ type ]( match, curLoop, inplace, result, not, isXMLFilter );

					if ( !match ) {
						anyFound = found = true;

					} else if ( match === true ) {
						continue;
					}
				}

				if ( match ) {
					for ( var i = 0; (item = curLoop[i]) != null; i++ ) {
						if ( item ) {
							found = filter( item, match, i, curLoop );
							var pass = not ^ !!found;

							if ( inplace && found != null ) {
								if ( pass ) {
									anyFound = true;

								} else {
									curLoop[i] = false;
								}

							} else if ( pass ) {
								result.push( item );
								anyFound = true;
							}
						}
					}
				}

				if ( found !== undefined ) {
					if ( !inplace ) {
						curLoop = result;
					}

					expr = expr.replace( Expr.match[ type ], "" );

					if ( !anyFound ) {
						return [];
					}

					break;
				}
			}
		}

		// Improper expression
		if ( expr === old ) {
			if ( anyFound == null ) {
				Sizzle.error( expr );

			} else {
				break;
			}
		}

		old = expr;
	}

	return curLoop;
};

Sizzle.error = function( msg ) {
	throw "Syntax error, unrecognized expression: " + msg;
};

var Expr = Sizzle.selectors = {
	order: [ "ID", "NAME", "TAG" ],

	match: {
		ID: /#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
		CLASS: /\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
		NAME: /\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,
		ATTR: /\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,
		TAG: /^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,
		CHILD: /:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,
		POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,
		PSEUDO: /:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/
	},

	leftMatch: {},

	attrMap: {
		"class": "className",
		"for": "htmlFor"
	},

	attrHandle: {
		href: function( elem ) {
			return elem.getAttribute( "href" );
		},
		type: function( elem ) {
			return elem.getAttribute( "type" );
		}
	},

	relative: {
		"+": function(checkSet, part){
			var isPartStr = typeof part === "string",
				isTag = isPartStr && !rNonWord.test( part ),
				isPartStrNotTag = isPartStr && !isTag;

			if ( isTag ) {
				part = part.toLowerCase();
			}

			for ( var i = 0, l = checkSet.length, elem; i < l; i++ ) {
				if ( (elem = checkSet[i]) ) {
					while ( (elem = elem.previousSibling) && elem.nodeType !== 1 ) {}

					checkSet[i] = isPartStrNotTag || elem && elem.nodeName.toLowerCase() === part ?
						elem || false :
						elem === part;
				}
			}

			if ( isPartStrNotTag ) {
				Sizzle.filter( part, checkSet, true );
			}
		},

		">": function( checkSet, part ) {
			var elem,
				isPartStr = typeof part === "string",
				i = 0,
				l = checkSet.length;

			if ( isPartStr && !rNonWord.test( part ) ) {
				part = part.toLowerCase();

				for ( ; i < l; i++ ) {
					elem = checkSet[i];

					if ( elem ) {
						var parent = elem.parentNode;
						checkSet[i] = parent.nodeName.toLowerCase() === part ? parent : false;
					}
				}

			} else {
				for ( ; i < l; i++ ) {
					elem = checkSet[i];

					if ( elem ) {
						checkSet[i] = isPartStr ?
							elem.parentNode :
							elem.parentNode === part;
					}
				}

				if ( isPartStr ) {
					Sizzle.filter( part, checkSet, true );
				}
			}
		},

		"": function(checkSet, part, isXML){
			var nodeCheck,
				doneName = done++,
				checkFn = dirCheck;

			if ( typeof part === "string" && !rNonWord.test( part ) ) {
				part = part.toLowerCase();
				nodeCheck = part;
				checkFn = dirNodeCheck;
			}

			checkFn( "parentNode", part, doneName, checkSet, nodeCheck, isXML );
		},

		"~": function( checkSet, part, isXML ) {
			var nodeCheck,
				doneName = done++,
				checkFn = dirCheck;

			if ( typeof part === "string" && !rNonWord.test( part ) ) {
				part = part.toLowerCase();
				nodeCheck = part;
				checkFn = dirNodeCheck;
			}

			checkFn( "previousSibling", part, doneName, checkSet, nodeCheck, isXML );
		}
	},

	find: {
		ID: function( match, context, isXML ) {
			if ( typeof context.getElementById !== "undefined" && !isXML ) {
				var m = context.getElementById(match[1]);
				// Check parentNode to catch when Blackberry 4.6 returns
				// nodes that are no longer in the document #6963
				return m && m.parentNode ? [m] : [];
			}
		},

		NAME: function( match, context ) {
			if ( typeof context.getElementsByName !== "undefined" ) {
				var ret = [],
					results = context.getElementsByName( match[1] );

				for ( var i = 0, l = results.length; i < l; i++ ) {
					if ( results[i].getAttribute("name") === match[1] ) {
						ret.push( results[i] );
					}
				}

				return ret.length === 0 ? null : ret;
			}
		},

		TAG: function( match, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( match[1] );
			}
		}
	},
	preFilter: {
		CLASS: function( match, curLoop, inplace, result, not, isXML ) {
			match = " " + match[1].replace( rBackslash, "" ) + " ";

			if ( isXML ) {
				return match;
			}

			for ( var i = 0, elem; (elem = curLoop[i]) != null; i++ ) {
				if ( elem ) {
					if ( not ^ (elem.className && (" " + elem.className + " ").replace(/[\t\n\r]/g, " ").indexOf(match) >= 0) ) {
						if ( !inplace ) {
							result.push( elem );
						}

					} else if ( inplace ) {
						curLoop[i] = false;
					}
				}
			}

			return false;
		},

		ID: function( match ) {
			return match[1].replace( rBackslash, "" );
		},

		TAG: function( match, curLoop ) {
			return match[1].replace( rBackslash, "" ).toLowerCase();
		},

		CHILD: function( match ) {
			if ( match[1] === "nth" ) {
				if ( !match[2] ) {
					Sizzle.error( match[0] );
				}

				match[2] = match[2].replace(/^\+|\s*/g, '');

				// parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'
				var test = /(-?)(\d*)(?:n([+\-]?\d*))?/.exec(
					match[2] === "even" && "2n" || match[2] === "odd" && "2n+1" ||
					!/\D/.test( match[2] ) && "0n+" + match[2] || match[2]);

				// calculate the numbers (first)n+(last) including if they are negative
				match[2] = (test[1] + (test[2] || 1)) - 0;
				match[3] = test[3] - 0;
			}
			else if ( match[2] ) {
				Sizzle.error( match[0] );
			}

			// TODO: Move to normal caching system
			match[0] = done++;

			return match;
		},

		ATTR: function( match, curLoop, inplace, result, not, isXML ) {
			var name = match[1] = match[1].replace( rBackslash, "" );
			
			if ( !isXML && Expr.attrMap[name] ) {
				match[1] = Expr.attrMap[name];
			}

			// Handle if an un-quoted value was used
			match[4] = ( match[4] || match[5] || "" ).replace( rBackslash, "" );

			if ( match[2] === "~=" ) {
				match[4] = " " + match[4] + " ";
			}

			return match;
		},

		PSEUDO: function( match, curLoop, inplace, result, not ) {
			if ( match[1] === "not" ) {
				// If we're dealing with a complex expression, or a simple one
				if ( ( chunker.exec(match[3]) || "" ).length > 1 || /^\w/.test(match[3]) ) {
					match[3] = Sizzle(match[3], null, null, curLoop);

				} else {
					var ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);

					if ( !inplace ) {
						result.push.apply( result, ret );
					}

					return false;
				}

			} else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( match[0] ) ) {
				return true;
			}
			
			return match;
		},

		POS: function( match ) {
			match.unshift( true );

			return match;
		}
	},
	
	filters: {
		enabled: function( elem ) {
			return elem.disabled === false && elem.type !== "hidden";
		},

		disabled: function( elem ) {
			return elem.disabled === true;
		},

		checked: function( elem ) {
			return elem.checked === true;
		},
		
		selected: function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}
			
			return elem.selected === true;
		},

		parent: function( elem ) {
			return !!elem.firstChild;
		},

		empty: function( elem ) {
			return !elem.firstChild;
		},

		has: function( elem, i, match ) {
			return !!Sizzle( match[3], elem ).length;
		},

		header: function( elem ) {
			return (/h\d/i).test( elem.nodeName );
		},

		text: function( elem ) {
			// IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc) 
			// use getAttribute instead to test this case
			return "text" === elem.getAttribute( 'type' );
		},
		radio: function( elem ) {
			return "radio" === elem.type;
		},

		checkbox: function( elem ) {
			return "checkbox" === elem.type;
		},

		file: function( elem ) {
			return "file" === elem.type;
		},
		password: function( elem ) {
			return "password" === elem.type;
		},

		submit: function( elem ) {
			return "submit" === elem.type;
		},

		image: function( elem ) {
			return "image" === elem.type;
		},

		reset: function( elem ) {
			return "reset" === elem.type;
		},

		button: function( elem ) {
			return "button" === elem.type || elem.nodeName.toLowerCase() === "button";
		},

		input: function( elem ) {
			return (/input|select|textarea|button/i).test( elem.nodeName );
		}
	},
	setFilters: {
		first: function( elem, i ) {
			return i === 0;
		},

		last: function( elem, i, match, array ) {
			return i === array.length - 1;
		},

		even: function( elem, i ) {
			return i % 2 === 0;
		},

		odd: function( elem, i ) {
			return i % 2 === 1;
		},

		lt: function( elem, i, match ) {
			return i < match[3] - 0;
		},

		gt: function( elem, i, match ) {
			return i > match[3] - 0;
		},

		nth: function( elem, i, match ) {
			return match[3] - 0 === i;
		},

		eq: function( elem, i, match ) {
			return match[3] - 0 === i;
		}
	},
	filter: {
		PSEUDO: function( elem, match, i, array ) {
			var name = match[1],
				filter = Expr.filters[ name ];

			if ( filter ) {
				return filter( elem, i, match, array );

			} else if ( name === "contains" ) {
				return (elem.textContent || elem.innerText || Sizzle.getText([ elem ]) || "").indexOf(match[3]) >= 0;

			} else if ( name === "not" ) {
				var not = match[3];

				for ( var j = 0, l = not.length; j < l; j++ ) {
					if ( not[j] === elem ) {
						return false;
					}
				}

				return true;

			} else {
				Sizzle.error( name );
			}
		},

		CHILD: function( elem, match ) {
			var type = match[1],
				node = elem;

			switch ( type ) {
				case "only":
				case "first":
					while ( (node = node.previousSibling) )	 {
						if ( node.nodeType === 1 ) { 
							return false; 
						}
					}

					if ( type === "first" ) { 
						return true; 
					}

					node = elem;

				case "last":
					while ( (node = node.nextSibling) )	 {
						if ( node.nodeType === 1 ) { 
							return false; 
						}
					}

					return true;

				case "nth":
					var first = match[2],
						last = match[3];

					if ( first === 1 && last === 0 ) {
						return true;
					}
					
					var doneName = match[0],
						parent = elem.parentNode;
	
					if ( parent && (parent.sizcache !== doneName || !elem.nodeIndex) ) {
						var count = 0;
						
						for ( node = parent.firstChild; node; node = node.nextSibling ) {
							if ( node.nodeType === 1 ) {
								node.nodeIndex = ++count;
							}
						} 

						parent.sizcache = doneName;
					}
					
					var diff = elem.nodeIndex - last;

					if ( first === 0 ) {
						return diff === 0;

					} else {
						return ( diff % first === 0 && diff / first >= 0 );
					}
			}
		},

		ID: function( elem, match ) {
			return elem.nodeType === 1 && elem.getAttribute("id") === match;
		},

		TAG: function( elem, match ) {
			return (match === "*" && elem.nodeType === 1) || elem.nodeName.toLowerCase() === match;
		},
		
		CLASS: function( elem, match ) {
			return (" " + (elem.className || elem.getAttribute("class")) + " ")
				.indexOf( match ) > -1;
		},

		ATTR: function( elem, match ) {
			var name = match[1],
				result = Expr.attrHandle[ name ] ?
					Expr.attrHandle[ name ]( elem ) :
					elem[ name ] != null ?
						elem[ name ] :
						elem.getAttribute( name ),
				value = result + "",
				type = match[2],
				check = match[4];

			return result == null ?
				type === "!=" :
				type === "=" ?
				value === check :
				type === "*=" ?
				value.indexOf(check) >= 0 :
				type === "~=" ?
				(" " + value + " ").indexOf(check) >= 0 :
				!check ?
				value && result !== false :
				type === "!=" ?
				value !== check :
				type === "^=" ?
				value.indexOf(check) === 0 :
				type === "$=" ?
				value.substr(value.length - check.length) === check :
				type === "|=" ?
				value === check || value.substr(0, check.length + 1) === check + "-" :
				false;
		},

		POS: function( elem, match, i, array ) {
			var name = match[2],
				filter = Expr.setFilters[ name ];

			if ( filter ) {
				return filter( elem, i, match, array );
			}
		}
	}
};

var origPOS = Expr.match.POS,
	fescape = function(all, num){
		return "\\" + (num - 0 + 1);
	};

for ( var type in Expr.match ) {
	Expr.match[ type ] = new RegExp( Expr.match[ type ].source + (/(?![^\[]*\])(?![^\(]*\))/.source) );
	Expr.leftMatch[ type ] = new RegExp( /(^(?:.|\r|\n)*?)/.source + Expr.match[ type ].source.replace(/\\(\d+)/g, fescape) );
}

var makeArray = function( array, results ) {
	array = Array.prototype.slice.call( array, 0 );

	if ( results ) {
		results.push.apply( results, array );
		return results;
	}
	
	return array;
};

// Perform a simple check to determine if the browser is capable of
// converting a NodeList to an array using builtin methods.
// Also verifies that the returned array holds DOM nodes
// (which is not the case in the Blackberry browser)
try {
	Array.prototype.slice.call( document.documentElement.childNodes, 0 )[0].nodeType;

// Provide a fallback method if it does not work
} catch( e ) {
	makeArray = function( array, results ) {
		var i = 0,
			ret = results || [];

		if ( toString.call(array) === "[object Array]" ) {
			Array.prototype.push.apply( ret, array );

		} else {
			if ( typeof array.length === "number" ) {
				for ( var l = array.length; i < l; i++ ) {
					ret.push( array[i] );
				}

			} else {
				for ( ; array[i]; i++ ) {
					ret.push( array[i] );
				}
			}
		}

		return ret;
	};
}

var sortOrder, siblingCheck;

if ( document.documentElement.compareDocumentPosition ) {
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		if ( !a.compareDocumentPosition || !b.compareDocumentPosition ) {
			return a.compareDocumentPosition ? -1 : 1;
		}

		return a.compareDocumentPosition(b) & 4 ? -1 : 1;
	};

} else {
	sortOrder = function( a, b ) {
		var al, bl,
			ap = [],
			bp = [],
			aup = a.parentNode,
			bup = b.parentNode,
			cur = aup;

		// The nodes are identical, we can exit early
		if ( a === b ) {
			hasDuplicate = true;
			return 0;

		// If the nodes are siblings (or identical) we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );

		// If no parents were found then the nodes are disconnected
		} else if ( !aup ) {
			return -1;

		} else if ( !bup ) {
			return 1;
		}

		// Otherwise they're somewhere else in the tree so we need
		// to build up a full list of the parentNodes for comparison
		while ( cur ) {
			ap.unshift( cur );
			cur = cur.parentNode;
		}

		cur = bup;

		while ( cur ) {
			bp.unshift( cur );
			cur = cur.parentNode;
		}

		al = ap.length;
		bl = bp.length;

		// Start walking down the tree looking for a discrepancy
		for ( var i = 0; i < al && i < bl; i++ ) {
			if ( ap[i] !== bp[i] ) {
				return siblingCheck( ap[i], bp[i] );
			}
		}

		// We ended someplace up the tree so do a sibling check
		return i === al ?
			siblingCheck( a, bp[i], -1 ) :
			siblingCheck( ap[i], b, 1 );
	};

	siblingCheck = function( a, b, ret ) {
		if ( a === b ) {
			return ret;
		}

		var cur = a.nextSibling;

		while ( cur ) {
			if ( cur === b ) {
				return -1;
			}

			cur = cur.nextSibling;
		}

		return 1;
	};
}

// Utility function for retreiving the text value of an array of DOM nodes
Sizzle.getText = function( elems ) {
	var ret = "", elem;

	for ( var i = 0; elems[i]; i++ ) {
		elem = elems[i];

		// Get the text from text nodes and CDATA nodes
		if ( elem.nodeType === 3 || elem.nodeType === 4 ) {
			ret += elem.nodeValue;

		// Traverse everything else, except comment nodes
		} else if ( elem.nodeType !== 8 ) {
			ret += Sizzle.getText( elem.childNodes );
		}
	}

	return ret;
};

// Check to see if the browser returns elements by name when
// querying by getElementById (and provide a workaround)
(function(){
	// We're going to inject a fake input element with a specified name
	var form = document.createElement("div"),
		id = "script" + (new Date()).getTime(),
		root = document.documentElement;

	form.innerHTML = "<a name='" + id + "'/>";

	// Inject it into the root element, check its status, and remove it quickly
	root.insertBefore( form, root.firstChild );

	// The workaround has to do additional checks after a getElementById
	// Which slows things down for other browsers (hence the branching)
	if ( document.getElementById( id ) ) {
		Expr.find.ID = function( match, context, isXML ) {
			if ( typeof context.getElementById !== "undefined" && !isXML ) {
				var m = context.getElementById(match[1]);

				return m ?
					m.id === match[1] || typeof m.getAttributeNode !== "undefined" && m.getAttributeNode("id").nodeValue === match[1] ?
						[m] :
						undefined :
					[];
			}
		};

		Expr.filter.ID = function( elem, match ) {
			var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");

			return elem.nodeType === 1 && node && node.nodeValue === match;
		};
	}

	root.removeChild( form );

	// release memory in IE
	root = form = null;
})();

(function(){
	// Check to see if the browser returns only elements
	// when doing getElementsByTagName("*")

	// Create a fake element
	var div = document.createElement("div");
	div.appendChild( document.createComment("") );

	// Make sure no comments are found
	if ( div.getElementsByTagName("*").length > 0 ) {
		Expr.find.TAG = function( match, context ) {
			var results = context.getElementsByTagName( match[1] );

			// Filter out possible comments
			if ( match[1] === "*" ) {
				var tmp = [];

				for ( var i = 0; results[i]; i++ ) {
					if ( results[i].nodeType === 1 ) {
						tmp.push( results[i] );
					}
				}

				results = tmp;
			}

			return results;
		};
	}

	// Check to see if an attribute returns normalized href attributes
	div.innerHTML = "<a href='#'></a>";

	if ( div.firstChild && typeof div.firstChild.getAttribute !== "undefined" &&
			div.firstChild.getAttribute("href") !== "#" ) {

		Expr.attrHandle.href = function( elem ) {
			return elem.getAttribute( "href", 2 );
		};
	}

	// release memory in IE
	div = null;
})();

if ( document.querySelectorAll ) {
	(function(){
		var oldSizzle = Sizzle,
			div = document.createElement("div"),
			id = "__sizzle__";

		div.innerHTML = "<p class='TEST'></p>";

		// Safari can't handle uppercase or unicode characters when
		// in quirks mode.
		if ( div.querySelectorAll && div.querySelectorAll(".TEST").length === 0 ) {
			return;
		}
	
		Sizzle = function( query, context, extra, seed ) {
			context = context || document;

			// Only use querySelectorAll on non-XML documents
			// (ID selectors don't work in non-HTML documents)
			if ( !seed && !Sizzle.isXML(context) ) {
				// See if we find a selector to speed up
				var match = /^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec( query );
				
				if ( match && (context.nodeType === 1 || context.nodeType === 9) ) {
					// Speed-up: Sizzle("TAG")
					if ( match[1] ) {
						return makeArray( context.getElementsByTagName( query ), extra );
					
					// Speed-up: Sizzle(".CLASS")
					} else if ( match[2] && Expr.find.CLASS && context.getElementsByClassName ) {
						return makeArray( context.getElementsByClassName( match[2] ), extra );
					}
				}
				
				if ( context.nodeType === 9 ) {
					// Speed-up: Sizzle("body")
					// The body element only exists once, optimize finding it
					if ( query === "body" && context.body ) {
						return makeArray( [ context.body ], extra );
						
					// Speed-up: Sizzle("#ID")
					} else if ( match && match[3] ) {
						var elem = context.getElementById( match[3] );

						// Check parentNode to catch when Blackberry 4.6 returns
						// nodes that are no longer in the document #6963
						if ( elem && elem.parentNode ) {
							// Handle the case where IE and Opera return items
							// by name instead of ID
							if ( elem.id === match[3] ) {
								return makeArray( [ elem ], extra );
							}
							
						} else {
							return makeArray( [], extra );
						}
					}
					
					try {
						return makeArray( context.querySelectorAll(query), extra );
					} catch(qsaError) {}

				// qSA works strangely on Element-rooted queries
				// We can work around this by specifying an extra ID on the root
				// and working up from there (Thanks to Andrew Dupont for the technique)
				// IE 8 doesn't work on object elements
				} else if ( context.nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
					var oldContext = context,
						old = context.getAttribute( "id" ),
						nid = old || id,
						hasParent = context.parentNode,
						relativeHierarchySelector = /^\s*[+~]/.test( query );

					if ( !old ) {
						context.setAttribute( "id", nid );
					} else {
						nid = nid.replace( /'/g, "\\$&" );
					}
					if ( relativeHierarchySelector && hasParent ) {
						context = context.parentNode;
					}

					try {
						if ( !relativeHierarchySelector || hasParent ) {
							return makeArray( context.querySelectorAll( "[id='" + nid + "'] " + query ), extra );
						}

					} catch(pseudoError) {
					} finally {
						if ( !old ) {
							oldContext.removeAttribute( "id" );
						}
					}
				}
			}
		
			return oldSizzle(query, context, extra, seed);
		};

		for ( var prop in oldSizzle ) {
			Sizzle[ prop ] = oldSizzle[ prop ];
		}

		// release memory in IE
		div = null;
	})();
}

(function(){
	var html = document.documentElement,
		matches = html.matchesSelector || html.mozMatchesSelector || html.webkitMatchesSelector || html.msMatchesSelector,
		pseudoWorks = false;

	try {
		// This should fail with an exception
		// Gecko does not error, returns false instead
		matches.call( document.documentElement, "[test!='']:sizzle" );
	
	} catch( pseudoError ) {
		pseudoWorks = true;
	}

	if ( matches ) {
		Sizzle.matchesSelector = function( node, expr ) {
			// Make sure that attribute selectors are quoted
			expr = expr.replace(/\=\s*([^'"\]]*)\s*\]/g, "='$1']");

			if ( !Sizzle.isXML( node ) ) {
				try { 
					if ( pseudoWorks || !Expr.match.PSEUDO.test( expr ) && !/!=/.test( expr ) ) {
						return matches.call( node, expr );
					}
				} catch(e) {}
			}

			return Sizzle(expr, null, null, [node]).length > 0;
		};
	}
})();

(function(){
	var div = document.createElement("div");

	div.innerHTML = "<div class='test e'></div><div class='test'></div>";

	// Opera can't find a second classname (in 9.6)
	// Also, make sure that getElementsByClassName actually exists
	if ( !div.getElementsByClassName || div.getElementsByClassName("e").length === 0 ) {
		return;
	}

	// Safari caches class attributes, doesn't catch changes (in 3.2)
	div.lastChild.className = "e";

	if ( div.getElementsByClassName("e").length === 1 ) {
		return;
	}
	
	Expr.order.splice(1, 0, "CLASS");
	Expr.find.CLASS = function( match, context, isXML ) {
		if ( typeof context.getElementsByClassName !== "undefined" && !isXML ) {
			return context.getElementsByClassName(match[1]);
		}
	};

	// release memory in IE
	div = null;
})();

function dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
		var elem = checkSet[i];

		if ( elem ) {
			var match = false;

			elem = elem[dir];

			while ( elem ) {
				if ( elem.sizcache === doneName ) {
					match = checkSet[elem.sizset];
					break;
				}

				if ( elem.nodeType === 1 && !isXML ){
					elem.sizcache = doneName;
					elem.sizset = i;
				}

				if ( elem.nodeName.toLowerCase() === cur ) {
					match = elem;
					break;
				}

				elem = elem[dir];
			}

			checkSet[i] = match;
		}
	}
}

function dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
		var elem = checkSet[i];

		if ( elem ) {
			var match = false;
			
			elem = elem[dir];

			while ( elem ) {
				if ( elem.sizcache === doneName ) {
					match = checkSet[elem.sizset];
					break;
				}

				if ( elem.nodeType === 1 ) {
					if ( !isXML ) {
						elem.sizcache = doneName;
						elem.sizset = i;
					}

					if ( typeof cur !== "string" ) {
						if ( elem === cur ) {
							match = true;
							break;
						}

					} else if ( Sizzle.filter( cur, [elem] ).length > 0 ) {
						match = elem;
						break;
					}
				}

				elem = elem[dir];
			}

			checkSet[i] = match;
		}
	}
}

if ( document.documentElement.contains ) {
	Sizzle.contains = function( a, b ) {
		return a !== b && (a.contains ? a.contains(b) : true);
	};

} else if ( document.documentElement.compareDocumentPosition ) {
	Sizzle.contains = function( a, b ) {
		return !!(a.compareDocumentPosition(b) & 16);
	};

} else {
	Sizzle.contains = function() {
		return false;
	};
}

Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833) 
	var documentElement = (elem ? elem.ownerDocument || elem : 0).documentElement;

	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

var posProcess = function( selector, context ) {
	var match,
		tmpSet = [],
		later = "",
		root = context.nodeType ? [context] : context;

	// Position selectors must be done after the filter
	// And so must :not(positional) so we move all PSEUDOs to the end
	while ( (match = Expr.match.PSEUDO.exec( selector )) ) {
		later += match[0];
		selector = selector.replace( Expr.match.PSEUDO, "" );
	}

	selector = Expr.relative[selector] ? selector + "*" : selector;

	for ( var i = 0, l = root.length; i < l; i++ ) {
		Sizzle( selector, root[i], tmpSet );
	}

	return Sizzle.filter( later, tmpSet );
};

// EXPOSE
jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.filters;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;


})();


var runtil = /Until$/,
	rparentsprev = /^(?:parents|prevUntil|prevAll)/,
	// Note: This RegExp should be improved, or likely pulled from Sizzle
	rmultiselector = /,/,
	isSimple = /^.[^:#\[\.,]*$/,
	slice = Array.prototype.slice,
	POS = jQuery.expr.match.POS,
	// methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend({
	find: function( selector ) {
		var ret = this.pushStack( "", "find", selector ),
			length = 0;

		for ( var i = 0, l = this.length; i < l; i++ ) {
			length = ret.length;
			jQuery.find( selector, this[i], ret );

			if ( i > 0 ) {
				// Make sure that the results are unique
				for ( var n = length; n < ret.length; n++ ) {
					for ( var r = 0; r < length; r++ ) {
						if ( ret[r] === ret[n] ) {
							ret.splice(n--, 1);
							break;
						}
					}
				}
			}
		}

		return ret;
	},

	has: function( target ) {
		var targets = jQuery( target );
		return this.filter(function() {
			for ( var i = 0, l = targets.length; i < l; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	not: function( selector ) {
		return this.pushStack( winnow(this, selector, false), "not", selector);
	},

	filter: function( selector ) {
		return this.pushStack( winnow(this, selector, true), "filter", selector );
	},

	is: function( selector ) {
		return !!selector && jQuery.filter( selector, this ).length > 0;
	},

	closest: function( selectors, context ) {
		var ret = [], i, l, cur = this[0];

		if ( jQuery.isArray( selectors ) ) {
			var match, selector,
				matches = {},
				level = 1;

			if ( cur && selectors.length ) {
				for ( i = 0, l = selectors.length; i < l; i++ ) {
					selector = selectors[i];

					if ( !matches[selector] ) {
						matches[selector] = jQuery.expr.match.POS.test( selector ) ?
							jQuery( selector, context || this.context ) :
							selector;
					}
				}

				while ( cur && cur.ownerDocument && cur !== context ) {
					for ( selector in matches ) {
						match = matches[selector];

						if ( match.jquery ? match.index(cur) > -1 : jQuery(cur).is(match) ) {
							ret.push({ selector: selector, elem: cur, level: level });
						}
					}

					cur = cur.parentNode;
					level++;
				}
			}

			return ret;
		}

		var pos = POS.test( selectors ) ?
			jQuery( selectors, context || this.context ) : null;

		for ( i = 0, l = this.length; i < l; i++ ) {
			cur = this[i];

			while ( cur ) {
				if ( pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors) ) {
					ret.push( cur );
					break;

				} else {
					cur = cur.parentNode;
					if ( !cur || !cur.ownerDocument || cur === context ) {
						break;
					}
				}
			}
		}

		ret = ret.length > 1 ? jQuery.unique(ret) : ret;

		return this.pushStack( ret, "closest", selectors );
	},

	// Determine the position of an element within
	// the matched set of elements
	index: function( elem ) {
		if ( !elem || typeof elem === "string" ) {
			return jQuery.inArray( this[0],
				// If it receives a string, the selector is used
				// If it receives nothing, the siblings are used
				elem ? jQuery( elem ) : this.parent().children() );
		}
		// Locate the position of the desired element
		return jQuery.inArray(
			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[0] : elem, this );
	},

	add: function( selector, context ) {
		var set = typeof selector === "string" ?
				jQuery( selector, context ) :
				jQuery.makeArray( selector ),
			all = jQuery.merge( this.get(), set );

		return this.pushStack( isDisconnected( set[0] ) || isDisconnected( all[0] ) ?
			all :
			jQuery.unique( all ) );
	},

	andSelf: function() {
		return this.add( this.prevObject );
	}
});

// A painfully simple check to see if an element is disconnected
// from a document (should be improved, where feasible).
function isDisconnected( node ) {
	return !node || !node.parentNode || node.parentNode.nodeType === 11;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return jQuery.nth( elem, 2, "nextSibling" );
	},
	prev: function( elem ) {
		return jQuery.nth( elem, 2, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( elem.parentNode.firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return jQuery.nodeName( elem, "iframe" ) ?
			elem.contentDocument || elem.contentWindow.document :
			jQuery.makeArray( elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var ret = jQuery.map( this, fn, until ),
			// The variable 'args' was introduced in
			// https://github.com/jquery/jquery/commit/52a0238
			// to work around a bug in Chrome 10 (Dev) and should be removed when the bug is fixed.
			// http://code.google.com/p/v8/issues/detail?id=1050
			args = slice.call(arguments);

		if ( !runtil.test( name ) ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			ret = jQuery.filter( selector, ret );
		}

		ret = this.length > 1 && !guaranteedUnique[ name ] ? jQuery.unique( ret ) : ret;

		if ( (this.length > 1 || rmultiselector.test( selector )) && rparentsprev.test( name ) ) {
			ret = ret.reverse();
		}

		return this.pushStack( ret, name, args.join(",") );
	};
});

jQuery.extend({
	filter: function( expr, elems, not ) {
		if ( not ) {
			expr = ":not(" + expr + ")";
		}

		return elems.length === 1 ?
			jQuery.find.matchesSelector(elems[0], expr) ? [ elems[0] ] : [] :
			jQuery.find.matches(expr, elems);
	},

	dir: function( elem, dir, until ) {
		var matched = [],
			cur = elem[ dir ];

		while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
			if ( cur.nodeType === 1 ) {
				matched.push( cur );
			}
			cur = cur[dir];
		}
		return matched;
	},

	nth: function( cur, result, dir, elem ) {
		result = result || 1;
		var num = 0;

		for ( ; cur; cur = cur[dir] ) {
			if ( cur.nodeType === 1 && ++num === result ) {
				break;
			}
		}

		return cur;
	},

	sibling: function( n, elem ) {
		var r = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				r.push( n );
			}
		}

		return r;
	}
});

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, keep ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep(elements, function( elem, i ) {
			var retVal = !!qualifier.call( elem, i, elem );
			return retVal === keep;
		});

	} else if ( qualifier.nodeType ) {
		return jQuery.grep(elements, function( elem, i ) {
			return (elem === qualifier) === keep;
		});

	} else if ( typeof qualifier === "string" ) {
		var filtered = jQuery.grep(elements, function( elem ) {
			return elem.nodeType === 1;
		});

		if ( isSimple.test( qualifier ) ) {
			return jQuery.filter(qualifier, filtered, !keep);
		} else {
			qualifier = jQuery.filter( qualifier, filtered );
		}
	}

	return jQuery.grep(elements, function( elem, i ) {
		return (jQuery.inArray( elem, qualifier ) >= 0) === keep;
	});
}




var rinlinejQuery = / jQuery\d+="(?:\d+|null)"/g,
	rleadingWhitespace = /^\s+/,
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,
	rtagName = /<([\w:]+)/,
	rtbody = /<tbody/i,
	rhtml = /<|&#?\w+;/,
	rnocache = /<(?:script|object|embed|option|style)/i,
	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	wrapMap = {
		option: [ 1, "<select multiple='multiple'>", "</select>" ],
		legend: [ 1, "<fieldset>", "</fieldset>" ],
		thead: [ 1, "<table>", "</table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
		col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
		area: [ 1, "<map>", "</map>" ],
		_default: [ 0, "", "" ]
	};

wrapMap.optgroup = wrapMap.option;
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// IE can't serialize <link> and <script> tags normally
if ( !jQuery.support.htmlSerialize ) {
	wrapMap._default = [ 1, "div<div>", "</div>" ];
}

jQuery.fn.extend({
	text: function( text ) {
		if ( jQuery.isFunction(text) ) {
			return this.each(function(i) {
				var self = jQuery( this );

				self.text( text.call(this, i, self.text()) );
			});
		}

		if ( typeof text !== "object" && text !== undefined ) {
			return this.empty().append( (this[0] && this[0].ownerDocument || document).createTextNode( text ) );
		}

		return jQuery.text( this );
	},

	wrapAll: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapAll( html.call(this, i) );
			});
		}

		if ( this[0] ) {
			// The elements to wrap the target around
			var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);

			if ( this[0].parentNode ) {
				wrap.insertBefore( this[0] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
					elem = elem.firstChild;
				}

				return elem;
			}).append(this);
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		return this.each(function() {
			jQuery( this ).wrapAll( html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	},

	append: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 ) {
				this.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 ) {
				this.insertBefore( elem, this.firstChild );
			}
		});
	},

	before: function() {
		if ( this[0] && this[0].parentNode ) {
			return this.domManip(arguments, false, function( elem ) {
				this.parentNode.insertBefore( elem, this );
			});
		} else if ( arguments.length ) {
			var set = jQuery(arguments[0]);
			set.push.apply( set, this.toArray() );
			return this.pushStack( set, "before", arguments );
		}
	},

	after: function() {
		if ( this[0] && this[0].parentNode ) {
			return this.domManip(arguments, false, function( elem ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			});
		} else if ( arguments.length ) {
			var set = this.pushStack( this, "after", arguments );
			set.push.apply( set, jQuery(arguments[0]).toArray() );
			return set;
		}
	},

	// keepData is for internal use only--do not document
	remove: function( selector, keepData ) {
		for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
			if ( !selector || jQuery.filter( selector, [ elem ] ).length ) {
				if ( !keepData && elem.nodeType === 1 ) {
					jQuery.cleanData( elem.getElementsByTagName("*") );
					jQuery.cleanData( [ elem ] );
				}

				if ( elem.parentNode ) {
					elem.parentNode.removeChild( elem );
				}
			}
		}

		return this;
	},

	empty: function() {
		for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
			// Remove element nodes and prevent memory leaks
			if ( elem.nodeType === 1 ) {
				jQuery.cleanData( elem.getElementsByTagName("*") );
			}

			// Remove any remaining nodes
			while ( elem.firstChild ) {
				elem.removeChild( elem.firstChild );
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function () {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		if ( value === undefined ) {
			return this[0] && this[0].nodeType === 1 ?
				this[0].innerHTML.replace(rinlinejQuery, "") :
				null;

		// See if we can take a shortcut and just use innerHTML
		} else if ( typeof value === "string" && !rnocache.test( value ) &&
			(jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value )) &&
			!wrapMap[ (rtagName.exec( value ) || ["", ""])[1].toLowerCase() ] ) {

			value = value.replace(rxhtmlTag, "<$1></$2>");

			try {
				for ( var i = 0, l = this.length; i < l; i++ ) {
					// Remove element nodes and prevent memory leaks
					if ( this[i].nodeType === 1 ) {
						jQuery.cleanData( this[i].getElementsByTagName("*") );
						this[i].innerHTML = value;
					}
				}

			// If using innerHTML throws an exception, use the fallback method
			} catch(e) {
				this.empty().append( value );
			}

		} else if ( jQuery.isFunction( value ) ) {
			this.each(function(i){
				var self = jQuery( this );

				self.html( value.call(this, i, self.html()) );
			});

		} else {
			this.empty().append( value );
		}

		return this;
	},

	replaceWith: function( value ) {
		if ( this[0] && this[0].parentNode ) {
			// Make sure that the elements are removed from the DOM before they are inserted
			// this can help fix replacing a parent with child elements
			if ( jQuery.isFunction( value ) ) {
				return this.each(function(i) {
					var self = jQuery(this), old = self.html();
					self.replaceWith( value.call( this, i, old ) );
				});
			}

			if ( typeof value !== "string" ) {
				value = jQuery( value ).detach();
			}

			return this.each(function() {
				var next = this.nextSibling,
					parent = this.parentNode;

				jQuery( this ).remove();

				if ( next ) {
					jQuery(next).before( value );
				} else {
					jQuery(parent).append( value );
				}
			});
		} else {
			return this.pushStack( jQuery(jQuery.isFunction(value) ? value() : value), "replaceWith", value );
		}
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, table, callback ) {
		var results, first, fragment, parent,
			value = args[0],
			scripts = [];

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( !jQuery.support.checkClone && arguments.length === 3 && typeof value === "string" && rchecked.test( value ) ) {
			return this.each(function() {
				jQuery(this).domManip( args, table, callback, true );
			});
		}

		if ( jQuery.isFunction(value) ) {
			return this.each(function(i) {
				var self = jQuery(this);
				args[0] = value.call(this, i, table ? self.html() : undefined);
				self.domManip( args, table, callback );
			});
		}

		if ( this[0] ) {
			parent = value && value.parentNode;

			// If we're in a fragment, just use that instead of building a new one
			if ( jQuery.support.parentNode && parent && parent.nodeType === 11 && parent.childNodes.length === this.length ) {
				results = { fragment: parent };

			} else {
				results = jQuery.buildFragment( args, this, scripts );
			}

			fragment = results.fragment;

			if ( fragment.childNodes.length === 1 ) {
				first = fragment = fragment.firstChild;
			} else {
				first = fragment.firstChild;
			}

			if ( first ) {
				table = table && jQuery.nodeName( first, "tr" );

				for ( var i = 0, l = this.length, lastIndex = l - 1; i < l; i++ ) {
					callback.call(
						table ?
							root(this[i], first) :
							this[i],
						// Make sure that we do not leak memory by inadvertently discarding
						// the original fragment (which might have attached data) instead of
						// using it; in addition, use the original fragment object for the last
						// item instead of first because it can end up being emptied incorrectly
						// in certain situations (Bug #8070).
						// Fragments from the fragment cache must always be cloned and never used
						// in place.
						results.cacheable || (l > 1 && i < lastIndex) ?
							jQuery.clone( fragment, true, true ) :
							fragment
					);
				}
			}

			if ( scripts.length ) {
				jQuery.each( scripts, evalScript );
			}
		}

		return this;
	}
});

function root( elem, cur ) {
	return jQuery.nodeName(elem, "table") ?
		(elem.getElementsByTagName("tbody")[0] ||
		elem.appendChild(elem.ownerDocument.createElement("tbody"))) :
		elem;
}

function cloneCopyEvent( src, dest ) {

	if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
		return;
	}

	var internalKey = jQuery.expando,
		oldData = jQuery.data( src ),
		curData = jQuery.data( dest, oldData );

	// Switch to use the internal data object, if it exists, for the next
	// stage of data copying
	if ( (oldData = oldData[ internalKey ]) ) {
		var events = oldData.events;
				curData = curData[ internalKey ] = jQuery.extend({}, oldData);

		if ( events ) {
			delete curData.handle;
			curData.events = {};

			for ( var type in events ) {
				for ( var i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type + ( events[ type ][ i ].namespace ? "." : "" ) + events[ type ][ i ].namespace, events[ type ][ i ], events[ type ][ i ].data );
				}
			}
		}
	}
}

function cloneFixAttributes(src, dest) {
	// We do not need to do anything for non-Elements
	if ( dest.nodeType !== 1 ) {
		return;
	}

	var nodeName = dest.nodeName.toLowerCase();

	// clearAttributes removes the attributes, which we don't want,
	// but also removes the attachEvent events, which we *do* want
	dest.clearAttributes();

	// mergeAttributes, in contrast, only merges back on the
	// original attributes, not the events
	dest.mergeAttributes(src);

	// IE6-8 fail to clone children inside object elements that use
	// the proprietary classid attribute value (rather than the type
	// attribute) to identify the type of content to display
	if ( nodeName === "object" ) {
		dest.outerHTML = src.outerHTML;

	} else if ( nodeName === "input" && (src.type === "checkbox" || src.type === "radio") ) {
		// IE6-8 fails to persist the checked state of a cloned checkbox
		// or radio button. Worse, IE6-7 fail to give the cloned element
		// a checked appearance if the defaultChecked value isn't also set
		if ( src.checked ) {
			dest.defaultChecked = dest.checked = src.checked;
		}

		// IE6-7 get confused and end up setting the value of a cloned
		// checkbox/radio button to an empty string instead of "on"
		if ( dest.value !== src.value ) {
			dest.value = src.value;
		}

	// IE6-8 fails to return the selected option to the default selected
	// state when cloning options
	} else if ( nodeName === "option" ) {
		dest.selected = src.defaultSelected;

	// IE6-8 fails to set the defaultValue to the correct value when
	// cloning other types of input fields
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}

	// Event data gets referenced instead of copied if the expando
	// gets copied too
	dest.removeAttribute( jQuery.expando );
}

jQuery.buildFragment = function( args, nodes, scripts ) {
	var fragment, cacheable, cacheresults,
		doc = (nodes && nodes[0] ? nodes[0].ownerDocument || nodes[0] : document);

	// Only cache "small" (1/2 KB) HTML strings that are associated with the main document
	// Cloning options loses the selected state, so don't cache them
	// IE 6 doesn't like it when you put <object> or <embed> elements in a fragment
	// Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache
	if ( args.length === 1 && typeof args[0] === "string" && args[0].length < 512 && doc === document &&
		args[0].charAt(0) === "<" && !rnocache.test( args[0] ) && (jQuery.support.checkClone || !rchecked.test( args[0] )) ) {

		cacheable = true;
		cacheresults = jQuery.fragments[ args[0] ];
		if ( cacheresults ) {
			if ( cacheresults !== 1 ) {
				fragment = cacheresults;
			}
		}
	}

	if ( !fragment ) {
		fragment = doc.createDocumentFragment();
		jQuery.clean( args, doc, fragment, scripts );
	}

	if ( cacheable ) {
		jQuery.fragments[ args[0] ] = cacheresults ? fragment : 1;
	}

	return { fragment: fragment, cacheable: cacheable };
};

jQuery.fragments = {};

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var ret = [],
			insert = jQuery( selector ),
			parent = this.length === 1 && this[0].parentNode;

		if ( parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1 ) {
			insert[ original ]( this[0] );
			return this;

		} else {
			for ( var i = 0, l = insert.length; i < l; i++ ) {
				var elems = (i > 0 ? this.clone(true) : this).get();
				jQuery( insert[i] )[ original ]( elems );
				ret = ret.concat( elems );
			}

			return this.pushStack( ret, name, insert.selector );
		}
	};
});

function getAll( elem ) {
	if ( "getElementsByTagName" in elem ) {
		return elem.getElementsByTagName( "*" );
	
	} else if ( "querySelectorAll" in elem ) {
		return elem.querySelectorAll( "*" );

	} else {
		return [];
	}
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var clone = elem.cloneNode(true),
				srcElements,
				destElements,
				i;

		if ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&
				(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {
			// IE copies events bound via attachEvent when using cloneNode.
			// Calling detachEvent on the clone will also remove the events
			// from the original. In order to get around this, we use some
			// proprietary methods to clear the events. Thanks to MooTools
			// guys for this hotness.

			cloneFixAttributes( elem, clone );

			// Using Sizzle here is crazy slow, so we use getElementsByTagName
			// instead
			srcElements = getAll( elem );
			destElements = getAll( clone );

			// Weird iteration because IE will replace the length property
			// with an element if you are cloning the body and one of the
			// elements on the page has a name or id of "length"
			for ( i = 0; srcElements[i]; ++i ) {
				cloneFixAttributes( srcElements[i], destElements[i] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			cloneCopyEvent( elem, clone );

			if ( deepDataAndEvents ) {
				srcElements = getAll( elem );
				destElements = getAll( clone );

				for ( i = 0; srcElements[i]; ++i ) {
					cloneCopyEvent( srcElements[i], destElements[i] );
				}
			}
		}

		// Return the cloned set
		return clone;
},
	clean: function( elems, context, fragment, scripts ) {
		context = context || document;

		// !context.createElement fails in IE with an error but returns typeof 'object'
		if ( typeof context.createElement === "undefined" ) {
			context = context.ownerDocument || context[0] && context[0].ownerDocument || document;
		}

		var ret = [];

		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
			if ( typeof elem === "number" ) {
				elem += "";
			}

			if ( !elem ) {
				continue;
			}

			// Convert html string into DOM nodes
			if ( typeof elem === "string" && !rhtml.test( elem ) ) {
				elem = context.createTextNode( elem );

			} else if ( typeof elem === "string" ) {
				// Fix "XHTML"-style tags in all browsers
				elem = elem.replace(rxhtmlTag, "<$1></$2>");

				// Trim whitespace, otherwise indexOf won't work as expected
				var tag = (rtagName.exec( elem ) || ["", ""])[1].toLowerCase(),
					wrap = wrapMap[ tag ] || wrapMap._default,
					depth = wrap[0],
					div = context.createElement("div");

				// Go to html and back, then peel off extra wrappers
				div.innerHTML = wrap[1] + elem + wrap[2];

				// Move to the right depth
				while ( depth-- ) {
					div = div.lastChild;
				}

				// Remove IE's autoinserted <tbody> from table fragments
				if ( !jQuery.support.tbody ) {

					// String was a <table>, *may* have spurious <tbody>
					var hasBody = rtbody.test(elem),
						tbody = tag === "table" && !hasBody ?
							div.firstChild && div.firstChild.childNodes :

							// String was a bare <thead> or <tfoot>
							wrap[1] === "<table>" && !hasBody ?
								div.childNodes :
								[];

					for ( var j = tbody.length - 1; j >= 0 ; --j ) {
						if ( jQuery.nodeName( tbody[ j ], "tbody" ) && !tbody[ j ].childNodes.length ) {
							tbody[ j ].parentNode.removeChild( tbody[ j ] );
						}
					}

				}

				// IE completely kills leading whitespace when innerHTML is used
				if ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
					div.insertBefore( context.createTextNode( rleadingWhitespace.exec(elem)[0] ), div.firstChild );
				}

				elem = div.childNodes;
			}

			if ( elem.nodeType ) {
				ret.push( elem );
			} else {
				ret = jQuery.merge( ret, elem );
			}
		}

		if ( fragment ) {
			for ( i = 0; ret[i]; i++ ) {
				if ( scripts && jQuery.nodeName( ret[i], "script" ) && (!ret[i].type || ret[i].type.toLowerCase() === "text/javascript") ) {
					scripts.push( ret[i].parentNode ? ret[i].parentNode.removeChild( ret[i] ) : ret[i] );

				} else {
					if ( ret[i].nodeType === 1 ) {
						ret.splice.apply( ret, [i + 1, 0].concat(jQuery.makeArray(ret[i].getElementsByTagName("script"))) );
					}
					fragment.appendChild( ret[i] );
				}
			}
		}

		return ret;
	},

	cleanData: function( elems ) {
		var data, id, cache = jQuery.cache, internalKey = jQuery.expando, special = jQuery.event.special,
			deleteExpando = jQuery.support.deleteExpando;

		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
			if ( elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()] ) {
				continue;
			}

			id = elem[ jQuery.expando ];

			if ( id ) {
				data = cache[ id ] && cache[ id ][ internalKey ];

				if ( data && data.events ) {
					for ( var type in data.events ) {
						if ( special[ type ] ) {
							jQuery.event.remove( elem, type );

						// This is a shortcut to avoid jQuery.event.remove's overhead
						} else {
							jQuery.removeEvent( elem, type, data.handle );
						}
					}

					// Null the DOM reference to avoid IE6/7/8 leak (#7054)
					if ( data.handle ) {
						data.handle.elem = null;
					}
				}

				if ( deleteExpando ) {
					delete elem[ jQuery.expando ];

				} else if ( elem.removeAttribute ) {
					elem.removeAttribute( jQuery.expando );
				}

				delete cache[ id ];
			}
		}
	}
});

function evalScript( i, elem ) {
	if ( elem.src ) {
		jQuery.ajax({
			url: elem.src,
			async: false,
			dataType: "script"
		});
	} else {
		jQuery.globalEval( elem.text || elem.textContent || elem.innerHTML || "" );
	}

	if ( elem.parentNode ) {
		elem.parentNode.removeChild( elem );
	}
}




var ralpha = /alpha\([^)]*\)/i,
	ropacity = /opacity=([^)]*)/,
	rdashAlpha = /-([a-z])/ig,
	rupper = /([A-Z])/g,
	rnumpx = /^-?\d+(?:px)?$/i,
	rnum = /^-?\d/,

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssWidth = [ "Left", "Right" ],
	cssHeight = [ "Top", "Bottom" ],
	curCSS,

	getComputedStyle,
	currentStyle,

	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn.css = function( name, value ) {
	// Setting 'undefined' is a no-op
	if ( arguments.length === 2 && value === undefined ) {
		return this;
	}

	return jQuery.access( this, name, value, true, function( elem, name, value ) {
		return value !== undefined ?
			jQuery.style( elem, name, value ) :
			jQuery.css( elem, name );
	});
};

jQuery.extend({
	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {
					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity", "opacity" );
					return ret === "" ? "1" : ret;

				} else {
					return elem.style.opacity;
				}
			}
		}
	},

	// Exclude the following css properties to add px
	cssNumber: {
		"zIndex": true,
		"fontWeight": true,
		"opacity": true,
		"zoom": true,
		"lineHeight": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		// normalize float css property
		"float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {
		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, origName = jQuery.camelCase( name ),
			style = elem.style, hooks = jQuery.cssHooks[ origName ];

		name = jQuery.cssProps[ origName ] || origName;

		// Check if we're setting a value
		if ( value !== undefined ) {
			// Make sure that NaN and null values aren't set. See: #7116
			if ( typeof value === "number" && isNaN( value ) || value == null ) {
				return;
			}

			// If a number was passed in, add 'px' to the (except for certain CSS properties)
			if ( typeof value === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value )) !== undefined ) {
				// Wrapped to prevent IE from throwing errors when 'invalid' values are provided
				// Fixes bug #5509
				try {
					style[ name ] = value;
				} catch(e) {}
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra ) {
		// Make sure that we're working with the right name
		var ret, origName = jQuery.camelCase( name ),
			hooks = jQuery.cssHooks[ origName ];

		name = jQuery.cssProps[ origName ] || origName;

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks && (ret = hooks.get( elem, true, extra )) !== undefined ) {
			return ret;

		// Otherwise, if a way to get the computed value exists, use that
		} else if ( curCSS ) {
			return curCSS( elem, name, origName );
		}
	},

	// A method for quickly swapping in/out CSS properties to get correct calculations
	swap: function( elem, options, callback ) {
		var old = {};

		// Remember the old values, and insert the new ones
		for ( var name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		callback.call( elem );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}
	},

	camelCase: function( string ) {
		return string.replace( rdashAlpha, fcamelCase );
	}
});

// DEPRECATED, Use jQuery.css() instead
jQuery.curCSS = jQuery.css;

jQuery.each(["height", "width"], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			var val;

			if ( computed ) {
				if ( elem.offsetWidth !== 0 ) {
					val = getWH( elem, name, extra );

				} else {
					jQuery.swap( elem, cssShow, function() {
						val = getWH( elem, name, extra );
					});
				}

				if ( val <= 0 ) {
					val = curCSS( elem, name, name );

					if ( val === "0px" && currentStyle ) {
						val = currentStyle( elem, name, name );
					}

					if ( val != null ) {
						// Should return "auto" instead of 0, use 0 for
						// temporary backwards-compat
						return val === "" || val === "auto" ? "0px" : val;
					}
				}

				if ( val < 0 || val == null ) {
					val = elem.style[ name ];

					// Should return "auto" instead of 0, use 0 for
					// temporary backwards-compat
					return val === "" || val === "auto" ? "0px" : val;
				}

				return typeof val === "string" ? val : val + "px";
			}
		},

		set: function( elem, value ) {
			if ( rnumpx.test( value ) ) {
				// ignore negative width and height values #1599
				value = parseFloat(value);

				if ( value >= 0 ) {
					return value + "px";
				}

			} else {
				return value;
			}
		}
	};
});

if ( !jQuery.support.opacity ) {
	jQuery.cssHooks.opacity = {
		get: function( elem, computed ) {
			// IE uses filters for opacity
			return ropacity.test((computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "") ?
				(parseFloat(RegExp.$1) / 100) + "" :
				computed ? "1" : "";
		},

		set: function( elem, value ) {
			var style = elem.style;

			// IE has trouble with opacity if it does not have layout
			// Force it by setting the zoom level
			style.zoom = 1;

			// Set the alpha filter to set the opacity
			var opacity = jQuery.isNaN(value) ?
				"" :
				"alpha(opacity=" + value * 100 + ")",
				filter = style.filter || "";

			style.filter = ralpha.test(filter) ?
				filter.replace(ralpha, opacity) :
				style.filter + ' ' + opacity;
		}
	};
}

if ( document.defaultView && document.defaultView.getComputedStyle ) {
	getComputedStyle = function( elem, newName, name ) {
		var ret, defaultView, computedStyle;

		name = name.replace( rupper, "-$1" ).toLowerCase();

		if ( !(defaultView = elem.ownerDocument.defaultView) ) {
			return undefined;
		}

		if ( (computedStyle = defaultView.getComputedStyle( elem, null )) ) {
			ret = computedStyle.getPropertyValue( name );
			if ( ret === "" && !jQuery.contains( elem.ownerDocument.documentElement, elem ) ) {
				ret = jQuery.style( elem, name );
			}
		}

		return ret;
	};
}

if ( document.documentElement.currentStyle ) {
	currentStyle = function( elem, name ) {
		var left,
			ret = elem.currentStyle && elem.currentStyle[ name ],
			rsLeft = elem.runtimeStyle && elem.runtimeStyle[ name ],
			style = elem.style;

		// From the awesome hack by Dean Edwards
		// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

		// If we're not dealing with a regular pixel number
		// but a number that has a weird ending, we need to convert it to pixels
		if ( !rnumpx.test( ret ) && rnum.test( ret ) ) {
			// Remember the original values
			left = style.left;

			// Put in the new values to get a computed value out
			if ( rsLeft ) {
				elem.runtimeStyle.left = elem.currentStyle.left;
			}
			style.left = name === "fontSize" ? "1em" : (ret || 0);
			ret = style.pixelLeft + "px";

			// Revert the changed values
			style.left = left;
			if ( rsLeft ) {
				elem.runtimeStyle.left = rsLeft;
			}
		}

		return ret === "" ? "auto" : ret;
	};
}

curCSS = getComputedStyle || currentStyle;

function getWH( elem, name, extra ) {
	var which = name === "width" ? cssWidth : cssHeight,
		val = name === "width" ? elem.offsetWidth : elem.offsetHeight;

	if ( extra === "border" ) {
		return val;
	}

	jQuery.each( which, function() {
		if ( !extra ) {
			val -= parseFloat(jQuery.css( elem, "padding" + this )) || 0;
		}

		if ( extra === "margin" ) {
			val += parseFloat(jQuery.css( elem, "margin" + this )) || 0;

		} else {
			val -= parseFloat(jQuery.css( elem, "border" + this + "Width" )) || 0;
		}
	});

	return val;
}

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.hidden = function( elem ) {
		var width = elem.offsetWidth,
			height = elem.offsetHeight;

		return (width === 0 && height === 0) || (!jQuery.support.reliableHiddenOffsets && (elem.style.display || jQuery.css( elem, "display" )) === "none");
	};

	jQuery.expr.filters.visible = function( elem ) {
		return !jQuery.expr.filters.hidden( elem );
	};
}




var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rhash = /#.*$/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
	rinput = /^(?:color|date|datetime|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /(?:^file|^widget|\-extension):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rquery = /\?/,
	rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
	rselectTextarea = /^(?:select|textarea)/i,
	rspacesAjax = /\s+/,
	rts = /([?&])_=[^&]*/,
	rucHeaders = /(^|\-)([a-z])/g,
	rucHeadersFunc = function( _, $1, $2 ) {
		return $1 + $2.toUpperCase();
	},
	rurl = /^([\w\+\.\-]+:)\/\/([^\/?#:]*)(?::(\d+))?/,

	// Keep a copy of the old load method
	_load = jQuery.fn.load,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Document location
	ajaxLocation,

	// Document location segments
	ajaxLocParts;

// #8138, IE may throw an exception when accessing
// a field from document.location if document.domain has been set
try {
	ajaxLocation = document.location.href;
} catch( e ) {
	// Use the href attribute of an A element
	// since IE will modify it given document.location
	ajaxLocation = document.createElement( "a" );
	ajaxLocation.href = "";
	ajaxLocation = ajaxLocation.href;
}

// Segment location into parts
ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() );

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		if ( jQuery.isFunction( func ) ) {
			var dataTypes = dataTypeExpression.toLowerCase().split( rspacesAjax ),
				i = 0,
				length = dataTypes.length,
				dataType,
				list,
				placeBefore;

			// For each dataType in the dataTypeExpression
			for(; i < length; i++ ) {
				dataType = dataTypes[ i ];
				// We control if we're asked to add before
				// any existing element
				placeBefore = /^\+/.test( dataType );
				if ( placeBefore ) {
					dataType = dataType.substr( 1 ) || "*";
				}
				list = structure[ dataType ] = structure[ dataType ] || [];
				// then we add to the structure accordingly
				list[ placeBefore ? "unshift" : "push" ]( func );
			}
		}
	};
}

//Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR,
		dataType /* internal */, inspected /* internal */ ) {

	dataType = dataType || options.dataTypes[ 0 ];
	inspected = inspected || {};

	inspected[ dataType ] = true;

	var list = structure[ dataType ],
		i = 0,
		length = list ? list.length : 0,
		executeOnly = ( structure === prefilters ),
		selection;

	for(; i < length && ( executeOnly || !selection ); i++ ) {
		selection = list[ i ]( options, originalOptions, jqXHR );
		// If we got redirected to another dataType
		// we try there if executing only and not done already
		if ( typeof selection === "string" ) {
			if ( !executeOnly || inspected[ selection ] ) {
				selection = undefined;
			} else {
				options.dataTypes.unshift( selection );
				selection = inspectPrefiltersOrTransports(
						structure, options, originalOptions, jqXHR, selection, inspected );
			}
		}
	}
	// If we're only executing or nothing was selected
	// we try the catchall dataType if not done already
	if ( ( executeOnly || !selection ) && !inspected[ "*" ] ) {
		selection = inspectPrefiltersOrTransports(
				structure, options, originalOptions, jqXHR, "*", inspected );
	}
	// unnecessary when only executing (prefilters)
	// but it'll be ignored by the caller in that case
	return selection;
}

jQuery.fn.extend({
	load: function( url, params, callback ) {
		if ( typeof url !== "string" && _load ) {
			return _load.apply( this, arguments );

		// Don't do a request if no elements are being requested
		} else if ( !this.length ) {
			return this;
		}

		var off = url.indexOf( " " );
		if ( off >= 0 ) {
			var selector = url.slice( off, url.length );
			url = url.slice( 0, off );
		}

		// Default to a GET request
		var type = "GET";

		// If the second parameter was provided
		if ( params ) {
			// If it's a function
			if ( jQuery.isFunction( params ) ) {
				// We assume that it's the callback
				callback = params;
				params = undefined;

			// Otherwise, build a param string
			} else if ( typeof params === "object" ) {
				params = jQuery.param( params, jQuery.ajaxSettings.traditional );
				type = "POST";
			}
		}

		var self = this;

		// Request the remote document
		jQuery.ajax({
			url: url,
			type: type,
			dataType: "html",
			data: params,
			// Complete callback (responseText is used internally)
			complete: function( jqXHR, status, responseText ) {
				// Store the response as specified by the jqXHR object
				responseText = jqXHR.responseText;
				// If successful, inject the HTML into all the matched elements
				if ( jqXHR.isResolved() ) {
					// #4825: Get the actual response in case
					// a dataFilter is present in ajaxSettings
					jqXHR.done(function( r ) {
						responseText = r;
					});
					// See if a selector was specified
					self.html( selector ?
						// Create a dummy div to hold the results
						jQuery("<div>")
							// inject the contents of the document in, removing the scripts
							// to avoid any 'Permission Denied' errors in IE
							.append(responseText.replace(rscript, ""))

							// Locate the specified elements
							.find(selector) :

						// If not, just inject the full result
						responseText );
				}

				if ( callback ) {
					self.each( callback, [ responseText, status, jqXHR ] );
				}
			}
		});

		return this;
	},

	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},

	serializeArray: function() {
		return this.map(function(){
			return this.elements ? jQuery.makeArray( this.elements ) : this;
		})
		.filter(function(){
			return this.name && !this.disabled &&
				( this.checked || rselectTextarea.test( this.nodeName ) ||
					rinput.test( this.type ) );
		})
		.map(function( i, elem ){
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val, i ){
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});

// Attach a bunch of functions for handling common AJAX events
jQuery.each( "ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split( " " ), function( i, o ){
	jQuery.fn[ o ] = function( f ){
		return this.bind( o, f );
	};
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			type: method,
			url: url,
			data: data,
			success: callback,
			dataType: type
		});
	};
} );

jQuery.extend({

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function ( target, settings ) {
		if ( !settings ) {
			// Only one parameter, we extend ajaxSettings
			settings = target;
			target = jQuery.extend( true, jQuery.ajaxSettings, settings );
		} else {
			// target was provided, we extend into it
			jQuery.extend( true, target, jQuery.ajaxSettings, settings );
		}
		// Flatten fields we don't want deep extended
		for( var field in { context: 1, url: 1 } ) {
			if ( field in settings ) {
				target[ field ] = settings[ field ];
			} else if( field in jQuery.ajaxSettings ) {
				target[ field ] = jQuery.ajaxSettings[ field ];
			}
		}
		return target;
	},

	ajaxSettings: {
		url: ajaxLocation,
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		type: "GET",
		contentType: "application/x-www-form-urlencoded",
		processData: true,
		async: true,
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		traditional: false,
		headers: {},
		crossDomain: null,
		*/

		accepts: {
			xml: "application/xml, text/xml",
			html: "text/html",
			text: "text/plain",
			json: "application/json, text/javascript",
			"*": "*/*"
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText"
		},

		// List of data converters
		// 1) key format is "source_type destination_type" (a single space in-between)
		// 2) the catchall symbol "*" can be used for source_type
		converters: {

			// Convert anything to text
			"* text": window.String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		}
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var // Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
			// Callbacks context
			callbackContext = s.context || s,
			// Context for global events
			// It's the callbackContext if one was provided in the options
			// and if it's a DOM node or a jQuery collection
			globalEventContext = callbackContext !== s &&
				( callbackContext.nodeType || callbackContext instanceof jQuery ) ?
						jQuery( callbackContext ) : jQuery.event,
			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery._Deferred(),
			// Status-dependent callbacks
			statusCode = s.statusCode || {},
			// ifModified key
			ifModifiedKey,
			// Headers (they are sent all at once)
			requestHeaders = {},
			// Response headers
			responseHeadersString,
			responseHeaders,
			// transport
			transport,
			// timeout handle
			timeoutTimer,
			// Cross-domain detection vars
			parts,
			// The jqXHR state
			state = 0,
			// To know if global events are to be dispatched
			fireGlobals,
			// Loop variable
			i,
			// Fake xhr
			jqXHR = {

				readyState: 0,

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( !state ) {
						requestHeaders[ name.toLowerCase().replace( rucHeaders, rucHeadersFunc ) ] = value;
					}
					return this;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match === undefined ? null : match;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					statusText = statusText || "abort";
					if ( transport ) {
						transport.abort( statusText );
					}
					done( 0, statusText );
					return this;
				}
			};

		// Callback for when everything is done
		// It is defined here because jslint complains if it is declared
		// at the end of the function (which would be more logical and readable)
		function done( status, statusText, responses, headers ) {

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status ? 4 : 0;

			var isSuccess,
				success,
				error,
				response = responses ? ajaxHandleResponses( s, jqXHR, responses ) : undefined,
				lastModified,
				etag;

			// If successful, handle type chaining
			if ( status >= 200 && status < 300 || status === 304 ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {

					if ( ( lastModified = jqXHR.getResponseHeader( "Last-Modified" ) ) ) {
						jQuery.lastModified[ ifModifiedKey ] = lastModified;
					}
					if ( ( etag = jqXHR.getResponseHeader( "Etag" ) ) ) {
						jQuery.etag[ ifModifiedKey ] = etag;
					}
				}

				// If not modified
				if ( status === 304 ) {

					statusText = "notmodified";
					isSuccess = true;

				// If we have data
				} else {

					try {
						success = ajaxConvert( s, response );
						statusText = "success";
						isSuccess = true;
					} catch(e) {
						// We have a parsererror
						statusText = "parsererror";
						error = e;
					}
				}
			} else {
				// We extract error from statusText
				// then normalize statusText and status for non-aborts
				error = statusText;
				if( !statusText || status ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = statusText;

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajax" + ( isSuccess ? "Success" : "Error" ),
						[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.resolveWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s] );
				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		// Attach deferreds
		deferred.promise( jqXHR );
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;
		jqXHR.complete = completeDeferred.done;

		// Status-dependent callbacks
		jqXHR.statusCode = function( map ) {
			if ( map ) {
				var tmp;
				if ( state < 2 ) {
					for( tmp in map ) {
						statusCode[ tmp ] = [ statusCode[tmp], map[tmp] ];
					}
				} else {
					tmp = map[ jqXHR.status ];
					jqXHR.then( tmp, tmp );
				}
			}
			return this;
		};

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
		// We also use the url parameter if available
		s.url = ( ( url || s.url ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().split( rspacesAjax );

		// Determine if a cross-domain request is in order
		if ( !s.crossDomain ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain = !!( parts &&
				( parts[ 1 ] != ajaxLocParts[ 1 ] || parts[ 2 ] != ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? 80 : 443 ) ) !=
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? 80 : 443 ) ) )
			);
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefiler, stop there
		if ( state === 2 ) {
			return false;
		}

		// We can fire global events as of now if asked to
		fireGlobals = s.global;

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.data;
			}

			// Get ifModifiedKey before adding the anti-cache parameter
			ifModifiedKey = s.url;

			// Add anti-cache in url if needed
			if ( s.cache === false ) {

				var ts = jQuery.now(),
					// try replacing _= if it is there
					ret = s.url.replace( rts, "$1_=" + ts );

				// if nothing was replaced, add timestamp to the end
				s.url = ret + ( (ret === s.url ) ? ( rquery.test( s.url ) ? "&" : "?" ) + "_=" + ts : "" );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			requestHeaders[ "Content-Type" ] = s.contentType;
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			ifModifiedKey = ifModifiedKey || s.url;
			if ( jQuery.lastModified[ ifModifiedKey ] ) {
				requestHeaders[ "If-Modified-Since" ] = jQuery.lastModified[ ifModifiedKey ];
			}
			if ( jQuery.etag[ ifModifiedKey ] ) {
				requestHeaders[ "If-None-Match" ] = jQuery.etag[ ifModifiedKey ];
			}
		}

		// Set the Accepts header for the server, depending on the dataType
		requestHeaders.Accept = s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
			s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", */*; q=0.01" : "" ) :
			s.accepts[ "*" ];

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
				// Abort if not done already
				jqXHR.abort();
				return false;

		}

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;
			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout( function(){
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch (e) {
				// Propagate exception as error if not done
				if ( status < 2 ) {
					done( -1, e );
				// Simply rethrow otherwise
				} else {
					jQuery.error( e );
				}
			}
		}

		return jqXHR;
	},

	// Serialize an array of form elements or a set of
	// key/values into a query string
	param: function( a, traditional ) {
		var s = [],
			add = function( key, value ) {
				// If value is a function, invoke it and return its value
				value = jQuery.isFunction( value ) ? value() : value;
				s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
			};

		// Set traditional to true for jQuery <= 1.3.2 behavior.
		if ( traditional === undefined ) {
			traditional = jQuery.ajaxSettings.traditional;
		}

		// If an array was passed in, assume that it is an array of form elements.
		if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			} );

		} else {
			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( var prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}

		// Return the resulting serialization
		return s.join( "&" ).replace( r20, "+" );
	}
});

function buildParams( prefix, obj, traditional, add ) {
	if ( jQuery.isArray( obj ) && obj.length ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// If array item is non-scalar (array or object), encode its
				// numeric index to resolve deserialization ambiguity issues.
				// Note that rack (as of 1.0.0) can't currently deserialize
				// nested arrays properly, and attempting to do so may cause
				// a server error. Possible fixes are to modify rack's
				// deserialization algorithm or to provide an option or flag
				// to force array serialization to be shallow.
				buildParams( prefix + "[" + ( typeof v === "object" || jQuery.isArray(v) ? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if ( !traditional && obj != null && typeof obj === "object" ) {
		// If we see an array here, it is empty and should be treated as an empty
		// object
		if ( jQuery.isArray( obj ) || jQuery.isEmptyObject( obj ) ) {
			add( prefix, "" );

		// Serialize object item.
		} else {
			for ( var name in obj ) {
				buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
			}
		}

	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}

// This is still on the jQuery object... for now
// Want to move this to jQuery.ajax some day
jQuery.extend({

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {}

});

/* Handles responses to an ajax request:
 * - sets all responseXXX fields accordingly
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var contents = s.contents,
		dataTypes = s.dataTypes,
		responseFields = s.responseFields,
		ct,
		type,
		finalDataType,
		firstDataType;

	// Fill responseXXX fields
	for( type in responseFields ) {
		if ( type in responses ) {
			jqXHR[ responseFields[type] ] = responses[ type ];
		}
	}

	// Remove auto dataType and get content-type in the process
	while( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "content-type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

// Chain conversions given the request and the original response
function ajaxConvert( s, response ) {

	// Apply the dataFilter if provided
	if ( s.dataFilter ) {
		response = s.dataFilter( response, s.dataType );
	}

	var dataTypes = s.dataTypes,
		converters = {},
		i,
		key,
		length = dataTypes.length,
		tmp,
		// Current and previous dataTypes
		current = dataTypes[ 0 ],
		prev,
		// Conversion expression
		conversion,
		// Conversion function
		conv,
		// Conversion functions (transitive conversion)
		conv1,
		conv2;

	// For each dataType in the chain
	for( i = 1; i < length; i++ ) {

		// Create converters map
		// with lowercased keys
		if ( i === 1 ) {
			for( key in s.converters ) {
				if( typeof key === "string" ) {
					converters[ key.toLowerCase() ] = s.converters[ key ];
				}
			}
		}

		// Get the dataTypes
		prev = current;
		current = dataTypes[ i ];

		// If current is auto dataType, update it to prev
		if( current === "*" ) {
			current = prev;
		// If no auto and dataTypes are actually different
		} else if ( prev !== "*" && prev !== current ) {

			// Get the converter
			conversion = prev + " " + current;
			conv = converters[ conversion ] || converters[ "* " + current ];

			// If there is no direct converter, search transitively
			if ( !conv ) {
				conv2 = undefined;
				for( conv1 in converters ) {
					tmp = conv1.split( " " );
					if ( tmp[ 0 ] === prev || tmp[ 0 ] === "*" ) {
						conv2 = converters[ tmp[1] + " " + current ];
						if ( conv2 ) {
							conv1 = converters[ conv1 ];
							if ( conv1 === true ) {
								conv = conv2;
							} else if ( conv2 === true ) {
								conv = conv1;
							}
							break;
						}
					}
				}
			}
			// If we found no converter, dispatch an error
			if ( !( conv || conv2 ) ) {
				jQuery.error( "No conversion from " + conversion.replace(" "," to ") );
			}
			// If found converter is not an equivalence
			if ( conv !== true ) {
				// Convert with 1 or 2 converters accordingly
				response = conv ? conv( response ) : conv2( conv1(response) );
			}
		}
	}
	return response;
}




var jsc = jQuery.now(),
	jsre = /(\=)\?(&|$)|()\?\?()/i;

// Default jsonp settings
jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		return jQuery.expando + "_" + ( jsc++ );
	}
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var dataIsString = ( typeof s.data === "string" );

	if ( s.dataTypes[ 0 ] === "jsonp" ||
		originalSettings.jsonpCallback ||
		originalSettings.jsonp != null ||
		s.jsonp !== false && ( jsre.test( s.url ) ||
				dataIsString && jsre.test( s.data ) ) ) {

		var responseContainer,
			jsonpCallback = s.jsonpCallback =
				jQuery.isFunction( s.jsonpCallback ) ? s.jsonpCallback() : s.jsonpCallback,
			previous = window[ jsonpCallback ],
			url = s.url,
			data = s.data,
			replace = "$1" + jsonpCallback + "$2",
			cleanUp = function() {
				// Set callback back to previous value
				window[ jsonpCallback ] = previous;
				// Call if it was a function and we have a response
				if ( responseContainer && jQuery.isFunction( previous ) ) {
					window[ jsonpCallback ]( responseContainer[ 0 ] );
				}
			};

		if ( s.jsonp !== false ) {
			url = url.replace( jsre, replace );
			if ( s.url === url ) {
				if ( dataIsString ) {
					data = data.replace( jsre, replace );
				}
				if ( s.data === data ) {
					// Add callback manually
					url += (/\?/.test( url ) ? "&" : "?") + s.jsonp + "=" + jsonpCallback;
				}
			}
		}

		s.url = url;
		s.data = data;

		// Install callback
		window[ jsonpCallback ] = function( response ) {
			responseContainer = [ response ];
		};

		// Install cleanUp function
		jqXHR.then( cleanUp, cleanUp );

		// Use data converter to retrieve json after script execution
		s.converters["script json"] = function() {
			if ( !responseContainer ) {
				jQuery.error( jsonpCallback + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// force json dataType
		s.dataTypes[ 0 ] = "json";

		// Delegate to script
		return "script";
	}
} );




// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /javascript|ecmascript/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache's special case and global
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
		s.global = false;
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function(s) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {

		var script,
			head = document.head || document.getElementsByTagName( "head" )[0] || document.documentElement;

		return {

			send: function( _, callback ) {

				script = document.createElement( "script" );

				script.async = "async";

				if ( s.scriptCharset ) {
					script.charset = s.scriptCharset;
				}

				script.src = s.url;

				// Attach handlers for all browsers
				script.onload = script.onreadystatechange = function( _, isAbort ) {

					if ( !script.readyState || /loaded|complete/.test( script.readyState ) ) {

						// Handle memory leak in IE
						script.onload = script.onreadystatechange = null;

						// Remove the script
						if ( head && script.parentNode ) {
							head.removeChild( script );
						}

						// Dereference the script
						script = undefined;

						// Callback if not abort
						if ( !isAbort ) {
							callback( 200, "success" );
						}
					}
				};
				// Use insertBefore instead of appendChild  to circumvent an IE6 bug.
				// This arises when a base node is used (#2709 and #4378).
				head.insertBefore( script, head.firstChild );
			},

			abort: function() {
				if ( script ) {
					script.onload( 0, 1 );
				}
			}
		};
	}
} );




var // #5280: next active xhr id and list of active xhrs' callbacks
	xhrId = jQuery.now(),
	xhrCallbacks,

	// XHR used to determine supports properties
	testXHR;

// #5280: Internet Explorer will keep connections alive if we don't abort on unload
function xhrOnUnloadAbort() {
	jQuery( window ).unload(function() {
		// Abort all pending requests
		for ( var key in xhrCallbacks ) {
			xhrCallbacks[ key ]( 0, 1 );
		}
	});
}

// Functions to create xhrs
function createStandardXHR() {
	try {
		return new window.XMLHttpRequest();
	} catch( e ) {}
}

function createActiveXHR() {
	try {
		return new window.ActiveXObject( "Microsoft.XMLHTTP" );
	} catch( e ) {}
}

// Create the request object
// (This is still attached to ajaxSettings for backward compatibility)
jQuery.ajaxSettings.xhr = window.ActiveXObject ?
	/* Microsoft failed to properly
	 * implement the XMLHttpRequest in IE7 (can't request local files),
	 * so we use the ActiveXObject when it is available
	 * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
	 * we need a fallback.
	 */
	function() {
		return !this.isLocal && createStandardXHR() || createActiveXHR();
	} :
	// For all other browsers, use the standard XMLHttpRequest object
	createStandardXHR;

// Test if we can create an xhr object
testXHR = jQuery.ajaxSettings.xhr();
jQuery.support.ajax = !!testXHR;

// Does this browser support crossDomain XHR requests
jQuery.support.cors = testXHR && ( "withCredentials" in testXHR );

// No need for the temporary xhr anymore
testXHR = undefined;

// Create transport if the browser can provide an xhr
if ( jQuery.support.ajax ) {

	jQuery.ajaxTransport(function( s ) {
		// Cross domain only allowed if supported through XMLHttpRequest
		if ( !s.crossDomain || jQuery.support.cors ) {

			var callback;

			return {
				send: function( headers, complete ) {

					// Get a new xhr
					var xhr = s.xhr(),
						handle,
						i;

					// Open the socket
					// Passing null username, generates a login popup on Opera (#2865)
					if ( s.username ) {
						xhr.open( s.type, s.url, s.async, s.username, s.password );
					} else {
						xhr.open( s.type, s.url, s.async );
					}

					// Apply custom fields if provided
					if ( s.xhrFields ) {
						for ( i in s.xhrFields ) {
							xhr[ i ] = s.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( s.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( s.mimeType );
					}

					// Requested-With header
					// Not set for crossDomain requests with no content
					// (see why at http://trac.dojotoolkit.org/ticket/9486)
					// Won't change header if already provided
					if ( !( s.crossDomain && !s.hasContent ) && !headers["X-Requested-With"] ) {
						headers[ "X-Requested-With" ] = "XMLHttpRequest";
					}

					// Need an extra try/catch for cross domain requests in Firefox 3
					try {
						for ( i in headers ) {
							xhr.setRequestHeader( i, headers[ i ] );
						}
					} catch( _ ) {}

					// Do send the request
					// This may raise an exception which is actually
					// handled in jQuery.ajax (so no try/catch here)
					xhr.send( ( s.hasContent && s.data ) || null );

					// Listener
					callback = function( _, isAbort ) {

						var status,
							statusText,
							responseHeaders,
							responses,
							xml;

						// Firefox throws exceptions when accessing properties
						// of an xhr when a network error occured
						// http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
						try {

							// Was never called and is aborted or complete
							if ( callback && ( isAbort || xhr.readyState === 4 ) ) {

								// Only called once
								callback = undefined;

								// Do not keep as active anymore
								if ( handle ) {
									xhr.onreadystatechange = jQuery.noop;
									delete xhrCallbacks[ handle ];
								}

								// If it's an abort
								if ( isAbort ) {
									// Abort it manually if needed
									if ( xhr.readyState !== 4 ) {
										xhr.abort();
									}
								} else {
									status = xhr.status;
									responseHeaders = xhr.getAllResponseHeaders();
									responses = {};
									xml = xhr.responseXML;

									// Construct response list
									if ( xml && xml.documentElement /* #4958 */ ) {
										responses.xml = xml;
									}
									responses.text = xhr.responseText;

									// Firefox throws an exception when accessing
									// statusText for faulty cross-domain requests
									try {
										statusText = xhr.statusText;
									} catch( e ) {
										// We normalize with Webkit giving an empty statusText
										statusText = "";
									}

									// Filter status for non standard behaviors

									// If the request is local and we have data: assume a success
									// (success with no data won't get notified, that's the best we
									// can do given current implementations)
									if ( !status && s.isLocal && !s.crossDomain ) {
										status = responses.text ? 200 : 404;
									// IE - #1450: sometimes returns 1223 when it should be 204
									} else if ( status === 1223 ) {
										status = 204;
									}
								}
							}
						} catch( firefoxAccessException ) {
							if ( !isAbort ) {
								complete( -1, firefoxAccessException );
							}
						}

						// Call complete if needed
						if ( responses ) {
							complete( status, statusText, responses, responseHeaders );
						}
					};

					// if we're in sync mode or it's in cache
					// and has been retrieved directly (IE6 & IE7)
					// we need to manually fire the callback
					if ( !s.async || xhr.readyState === 4 ) {
						callback();
					} else {
						// Create the active xhrs callbacks list if needed
						// and attach the unload handler
						if ( !xhrCallbacks ) {
							xhrCallbacks = {};
							xhrOnUnloadAbort();
						}
						// Add to list of active xhrs callbacks
						handle = xhrId++;
						xhr.onreadystatechange = xhrCallbacks[ handle ] = callback;
					}
				},

				abort: function() {
					if ( callback ) {
						callback(0,1);
					}
				}
			};
		}
	});
}




var elemdisplay = {},
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = /^([+\-]=)?([\d+.\-]+)([a-z%]*)$/i,
	timerId,
	fxAttrs = [
		// height animations
		[ "height", "marginTop", "marginBottom", "paddingTop", "paddingBottom" ],
		// width animations
		[ "width", "marginLeft", "marginRight", "paddingLeft", "paddingRight" ],
		// opacity animations
		[ "opacity" ]
	];

jQuery.fn.extend({
	show: function( speed, easing, callback ) {
		var elem, display;

		if ( speed || speed === 0 ) {
			return this.animate( genFx("show", 3), speed, easing, callback);

		} else {
			for ( var i = 0, j = this.length; i < j; i++ ) {
				elem = this[i];
				display = elem.style.display;

				// Reset the inline display of this element to learn if it is
				// being hidden by cascaded rules or not
				if ( !jQuery._data(elem, "olddisplay") && display === "none" ) {
					display = elem.style.display = "";
				}

				// Set elements which have been overridden with display: none
				// in a stylesheet to whatever the default browser style is
				// for such an element
				if ( display === "" && jQuery.css( elem, "display" ) === "none" ) {
					jQuery._data(elem, "olddisplay", defaultDisplay(elem.nodeName));
				}
			}

			// Set the display of most of the elements in a second loop
			// to avoid the constant reflow
			for ( i = 0; i < j; i++ ) {
				elem = this[i];
				display = elem.style.display;

				if ( display === "" || display === "none" ) {
					elem.style.display = jQuery._data(elem, "olddisplay") || "";
				}
			}

			return this;
		}
	},

	hide: function( speed, easing, callback ) {
		if ( speed || speed === 0 ) {
			return this.animate( genFx("hide", 3), speed, easing, callback);

		} else {
			for ( var i = 0, j = this.length; i < j; i++ ) {
				var display = jQuery.css( this[i], "display" );

				if ( display !== "none" && !jQuery._data( this[i], "olddisplay" ) ) {
					jQuery._data( this[i], "olddisplay", display );
				}
			}

			// Set the display of the elements in a second loop
			// to avoid the constant reflow
			for ( i = 0; i < j; i++ ) {
				this[i].style.display = "none";
			}

			return this;
		}
	},

	// Save the old toggle function
	_toggle: jQuery.fn.toggle,

	toggle: function( fn, fn2, callback ) {
		var bool = typeof fn === "boolean";

		if ( jQuery.isFunction(fn) && jQuery.isFunction(fn2) ) {
			this._toggle.apply( this, arguments );

		} else if ( fn == null || bool ) {
			this.each(function() {
				var state = bool ? fn : jQuery(this).is(":hidden");
				jQuery(this)[ state ? "show" : "hide" ]();
			});

		} else {
			this.animate(genFx("toggle", 3), fn, fn2, callback);
		}

		return this;
	},

	fadeTo: function( speed, to, easing, callback ) {
		return this.filter(":hidden").css("opacity", 0).show().end()
					.animate({opacity: to}, speed, easing, callback);
	},

	animate: function( prop, speed, easing, callback ) {
		var optall = jQuery.speed(speed, easing, callback);

		if ( jQuery.isEmptyObject( prop ) ) {
			return this.each( optall.complete );
		}

		return this[ optall.queue === false ? "each" : "queue" ](function() {
			// XXX 'this' does not always have a nodeName when running the
			// test suite

			var opt = jQuery.extend({}, optall), p,
				isElement = this.nodeType === 1,
				hidden = isElement && jQuery(this).is(":hidden"),
				self = this;

			for ( p in prop ) {
				var name = jQuery.camelCase( p );

				if ( p !== name ) {
					prop[ name ] = prop[ p ];
					delete prop[ p ];
					p = name;
				}

				if ( prop[p] === "hide" && hidden || prop[p] === "show" && !hidden ) {
					return opt.complete.call(this);
				}

				if ( isElement && ( p === "height" || p === "width" ) ) {
					// Make sure that nothing sneaks out
					// Record all 3 overflow attributes because IE does not
					// change the overflow attribute when overflowX and
					// overflowY are set to the same value
					opt.overflow = [ this.style.overflow, this.style.overflowX, this.style.overflowY ];

					// Set display property to inline-block for height/width
					// animations on inline elements that are having width/height
					// animated
					if ( jQuery.css( this, "display" ) === "inline" &&
							jQuery.css( this, "float" ) === "none" ) {
						if ( !jQuery.support.inlineBlockNeedsLayout ) {
							this.style.display = "inline-block";

						} else {
							var display = defaultDisplay(this.nodeName);

							// inline-level elements accept inline-block;
							// block-level elements need to be inline with layout
							if ( display === "inline" ) {
								this.style.display = "inline-block";

							} else {
								this.style.display = "inline";
								this.style.zoom = 1;
							}
						}
					}
				}

				if ( jQuery.isArray( prop[p] ) ) {
					// Create (if needed) and add to specialEasing
					(opt.specialEasing = opt.specialEasing || {})[p] = prop[p][1];
					prop[p] = prop[p][0];
				}
			}

			if ( opt.overflow != null ) {
				this.style.overflow = "hidden";
			}

			opt.curAnim = jQuery.extend({}, prop);

			jQuery.each( prop, function( name, val ) {
				var e = new jQuery.fx( self, opt, name );

				if ( rfxtypes.test(val) ) {
					e[ val === "toggle" ? hidden ? "show" : "hide" : val ]( prop );

				} else {
					var parts = rfxnum.exec(val),
						start = e.cur();

					if ( parts ) {
						var end = parseFloat( parts[2] ),
							unit = parts[3] || ( jQuery.cssNumber[ name ] ? "" : "px" );

						// We need to compute starting value
						if ( unit !== "px" ) {
							jQuery.style( self, name, (end || 1) + unit);
							start = ((end || 1) / e.cur()) * start;
							jQuery.style( self, name, start + unit);
						}

						// If a +=/-= token was provided, we're doing a relative animation
						if ( parts[1] ) {
							end = ((parts[1] === "-=" ? -1 : 1) * end) + start;
						}

						e.custom( start, end, unit );

					} else {
						e.custom( start, val, "" );
					}
				}
			});

			// For JS strict compliance
			return true;
		});
	},

	stop: function( clearQueue, gotoEnd ) {
		var timers = jQuery.timers;

		if ( clearQueue ) {
			this.queue([]);
		}

		this.each(function() {
			// go in reverse order so anything added to the queue during the loop is ignored
			for ( var i = timers.length - 1; i >= 0; i-- ) {
				if ( timers[i].elem === this ) {
					if (gotoEnd) {
						// force the next step to be the last
						timers[i](true);
					}

					timers.splice(i, 1);
				}
			}
		});

		// start the next in the queue if the last step wasn't forced
		if ( !gotoEnd ) {
			this.dequeue();
		}

		return this;
	}

});

function genFx( type, num ) {
	var obj = {};

	jQuery.each( fxAttrs.concat.apply([], fxAttrs.slice(0,num)), function() {
		obj[ this ] = type;
	});

	return obj;
}

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx("show", 1),
	slideUp: genFx("hide", 1),
	slideToggle: genFx("toggle", 1),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.extend({
	speed: function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
			complete: fn || !fn && easing ||
				jQuery.isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
		};

		opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
			opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;

		// Queueing
		opt.old = opt.complete;
		opt.complete = function() {
			if ( opt.queue !== false ) {
				jQuery(this).dequeue();
			}
			if ( jQuery.isFunction( opt.old ) ) {
				opt.old.call( this );
			}
		};

		return opt;
	},

	easing: {
		linear: function( p, n, firstNum, diff ) {
			return firstNum + diff * p;
		},
		swing: function( p, n, firstNum, diff ) {
			return ((-Math.cos(p*Math.PI)/2) + 0.5) * diff + firstNum;
		}
	},

	timers: [],

	fx: function( elem, options, prop ) {
		this.options = options;
		this.elem = elem;
		this.prop = prop;

		if ( !options.orig ) {
			options.orig = {};
		}
	}

});

jQuery.fx.prototype = {
	// Simple function for setting a style value
	update: function() {
		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		(jQuery.fx.step[this.prop] || jQuery.fx.step._default)( this );
	},

	// Get the current size
	cur: function() {
		if ( this.elem[this.prop] != null && (!this.elem.style || this.elem.style[this.prop] == null) ) {
			return this.elem[ this.prop ];
		}

		var parsed,
			r = jQuery.css( this.elem, this.prop );
		// Empty strings, null, undefined and "auto" are converted to 0,
		// complex values such as "rotate(1rad)" are returned as is,
		// simple values such as "10px" are parsed to Float.
		return isNaN( parsed = parseFloat( r ) ) ? !r || r === "auto" ? 0 : r : parsed;
	},

	// Start an animation from one number to another
	custom: function( from, to, unit ) {
		var self = this,
			fx = jQuery.fx;

		this.startTime = jQuery.now();
		this.start = from;
		this.end = to;
		this.unit = unit || this.unit || ( jQuery.cssNumber[ this.prop ] ? "" : "px" );
		this.now = this.start;
		this.pos = this.state = 0;

		function t( gotoEnd ) {
			return self.step(gotoEnd);
		}

		t.elem = this.elem;

		if ( t() && jQuery.timers.push(t) && !timerId ) {
			timerId = setInterval(fx.tick, fx.interval);
		}
	},

	// Simple 'show' function
	show: function() {
		// Remember where we started, so that we can go back to it later
		this.options.orig[this.prop] = jQuery.style( this.elem, this.prop );
		this.options.show = true;

		// Begin the animation
		// Make sure that we start at a small width/height to avoid any
		// flash of content
		this.custom(this.prop === "width" || this.prop === "height" ? 1 : 0, this.cur());

		// Start by showing the element
		jQuery( this.elem ).show();
	},

	// Simple 'hide' function
	hide: function() {
		// Remember where we started, so that we can go back to it later
		this.options.orig[this.prop] = jQuery.style( this.elem, this.prop );
		this.options.hide = true;

		// Begin the animation
		this.custom(this.cur(), 0);
	},

	// Each step of an animation
	step: function( gotoEnd ) {
		var t = jQuery.now(), done = true;

		if ( gotoEnd || t >= this.options.duration + this.startTime ) {
			this.now = this.end;
			this.pos = this.state = 1;
			this.update();

			this.options.curAnim[ this.prop ] = true;

			for ( var i in this.options.curAnim ) {
				if ( this.options.curAnim[i] !== true ) {
					done = false;
				}
			}

			if ( done ) {
				// Reset the overflow
				if ( this.options.overflow != null && !jQuery.support.shrinkWrapBlocks ) {
					var elem = this.elem,
						options = this.options;

					jQuery.each( [ "", "X", "Y" ], function (index, value) {
						elem.style[ "overflow" + value ] = options.overflow[index];
					} );
				}

				// Hide the element if the "hide" operation was done
				if ( this.options.hide ) {
					jQuery(this.elem).hide();
				}

				// Reset the properties, if the item has been hidden or shown
				if ( this.options.hide || this.options.show ) {
					for ( var p in this.options.curAnim ) {
						jQuery.style( this.elem, p, this.options.orig[p] );
					}
				}

				// Execute the complete function
				this.options.complete.call( this.elem );
			}

			return false;

		} else {
			var n = t - this.startTime;
			this.state = n / this.options.duration;

			// Perform the easing function, defaults to swing
			var specialEasing = this.options.specialEasing && this.options.specialEasing[this.prop];
			var defaultEasing = this.options.easing || (jQuery.easing.swing ? "swing" : "linear");
			this.pos = jQuery.easing[specialEasing || defaultEasing](this.state, n, 0, 1, this.options.duration);
			this.now = this.start + ((this.end - this.start) * this.pos);

			// Perform the next step of the animation
			this.update();
		}

		return true;
	}
};

jQuery.extend( jQuery.fx, {
	tick: function() {
		var timers = jQuery.timers;

		for ( var i = 0; i < timers.length; i++ ) {
			if ( !timers[i]() ) {
				timers.splice(i--, 1);
			}
		}

		if ( !timers.length ) {
			jQuery.fx.stop();
		}
	},

	interval: 13,

	stop: function() {
		clearInterval( timerId );
		timerId = null;
	},

	speeds: {
		slow: 600,
		fast: 200,
		// Default speed
		_default: 400
	},

	step: {
		opacity: function( fx ) {
			jQuery.style( fx.elem, "opacity", fx.now );
		},

		_default: function( fx ) {
			if ( fx.elem.style && fx.elem.style[ fx.prop ] != null ) {
				fx.elem.style[ fx.prop ] = (fx.prop === "width" || fx.prop === "height" ? Math.max(0, fx.now) : fx.now) + fx.unit;
			} else {
				fx.elem[ fx.prop ] = fx.now;
			}
		}
	}
});

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.animated = function( elem ) {
		return jQuery.grep(jQuery.timers, function( fn ) {
			return elem === fn.elem;
		}).length;
	};
}

function defaultDisplay( nodeName ) {
	if ( !elemdisplay[ nodeName ] ) {
		var elem = jQuery("<" + nodeName + ">").appendTo("body"),
			display = elem.css("display");

		elem.remove();

		if ( display === "none" || display === "" ) {
			display = "block";
		}

		elemdisplay[ nodeName ] = display;
	}

	return elemdisplay[ nodeName ];
}




var rtable = /^t(?:able|d|h)$/i,
	rroot = /^(?:body|html)$/i;

if ( "getBoundingClientRect" in document.documentElement ) {
	jQuery.fn.offset = function( options ) {
		var elem = this[0], box;

		if ( options ) {
			return this.each(function( i ) {
				jQuery.offset.setOffset( this, options, i );
			});
		}

		if ( !elem || !elem.ownerDocument ) {
			return null;
		}

		if ( elem === elem.ownerDocument.body ) {
			return jQuery.offset.bodyOffset( elem );
		}

		try {
			box = elem.getBoundingClientRect();
		} catch(e) {}

		var doc = elem.ownerDocument,
			docElem = doc.documentElement;

		// Make sure we're not dealing with a disconnected DOM node
		if ( !box || !jQuery.contains( docElem, elem ) ) {
			return box ? { top: box.top, left: box.left } : { top: 0, left: 0 };
		}

		var body = doc.body,
			win = getWindow(doc),
			clientTop  = docElem.clientTop  || body.clientTop  || 0,
			clientLeft = docElem.clientLeft || body.clientLeft || 0,
			scrollTop  = (win.pageYOffset || jQuery.support.boxModel && docElem.scrollTop  || body.scrollTop ),
			scrollLeft = (win.pageXOffset || jQuery.support.boxModel && docElem.scrollLeft || body.scrollLeft),
			top  = box.top  + scrollTop  - clientTop,
			left = box.left + scrollLeft - clientLeft;

		return { top: top, left: left };
	};

} else {
	jQuery.fn.offset = function( options ) {
		var elem = this[0];

		if ( options ) {
			return this.each(function( i ) {
				jQuery.offset.setOffset( this, options, i );
			});
		}

		if ( !elem || !elem.ownerDocument ) {
			return null;
		}

		if ( elem === elem.ownerDocument.body ) {
			return jQuery.offset.bodyOffset( elem );
		}

		jQuery.offset.initialize();

		var computedStyle,
			offsetParent = elem.offsetParent,
			prevOffsetParent = elem,
			doc = elem.ownerDocument,
			docElem = doc.documentElement,
			body = doc.body,
			defaultView = doc.defaultView,
			prevComputedStyle = defaultView ? defaultView.getComputedStyle( elem, null ) : elem.currentStyle,
			top = elem.offsetTop,
			left = elem.offsetLeft;

		while ( (elem = elem.parentNode) && elem !== body && elem !== docElem ) {
			if ( jQuery.offset.supportsFixedPosition && prevComputedStyle.position === "fixed" ) {
				break;
			}

			computedStyle = defaultView ? defaultView.getComputedStyle(elem, null) : elem.currentStyle;
			top  -= elem.scrollTop;
			left -= elem.scrollLeft;

			if ( elem === offsetParent ) {
				top  += elem.offsetTop;
				left += elem.offsetLeft;

				if ( jQuery.offset.doesNotAddBorder && !(jQuery.offset.doesAddBorderForTableAndCells && rtable.test(elem.nodeName)) ) {
					top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
					left += parseFloat( computedStyle.borderLeftWidth ) || 0;
				}

				prevOffsetParent = offsetParent;
				offsetParent = elem.offsetParent;
			}

			if ( jQuery.offset.subtractsBorderForOverflowNotVisible && computedStyle.overflow !== "visible" ) {
				top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
				left += parseFloat( computedStyle.borderLeftWidth ) || 0;
			}

			prevComputedStyle = computedStyle;
		}

		if ( prevComputedStyle.position === "relative" || prevComputedStyle.position === "static" ) {
			top  += body.offsetTop;
			left += body.offsetLeft;
		}

		if ( jQuery.offset.supportsFixedPosition && prevComputedStyle.position === "fixed" ) {
			top  += Math.max( docElem.scrollTop, body.scrollTop );
			left += Math.max( docElem.scrollLeft, body.scrollLeft );
		}

		return { top: top, left: left };
	};
}

jQuery.offset = {
	initialize: function() {
		var body = document.body, container = document.createElement("div"), innerDiv, checkDiv, table, td, bodyMarginTop = parseFloat( jQuery.css(body, "marginTop") ) || 0,
			html = "<div style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;'><div></div></div><table style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;' cellpadding='0' cellspacing='0'><tr><td></td></tr></table>";

		jQuery.extend( container.style, { position: "absolute", top: 0, left: 0, margin: 0, border: 0, width: "1px", height: "1px", visibility: "hidden" } );

		container.innerHTML = html;
		body.insertBefore( container, body.firstChild );
		innerDiv = container.firstChild;
		checkDiv = innerDiv.firstChild;
		td = innerDiv.nextSibling.firstChild.firstChild;

		this.doesNotAddBorder = (checkDiv.offsetTop !== 5);
		this.doesAddBorderForTableAndCells = (td.offsetTop === 5);

		checkDiv.style.position = "fixed";
		checkDiv.style.top = "20px";

		// safari subtracts parent border width here which is 5px
		this.supportsFixedPosition = (checkDiv.offsetTop === 20 || checkDiv.offsetTop === 15);
		checkDiv.style.position = checkDiv.style.top = "";

		innerDiv.style.overflow = "hidden";
		innerDiv.style.position = "relative";

		this.subtractsBorderForOverflowNotVisible = (checkDiv.offsetTop === -5);

		this.doesNotIncludeMarginInBodyOffset = (body.offsetTop !== bodyMarginTop);

		body.removeChild( container );
		body = container = innerDiv = checkDiv = table = td = null;
		jQuery.offset.initialize = jQuery.noop;
	},

	bodyOffset: function( body ) {
		var top = body.offsetTop,
			left = body.offsetLeft;

		jQuery.offset.initialize();

		if ( jQuery.offset.doesNotIncludeMarginInBodyOffset ) {
			top  += parseFloat( jQuery.css(body, "marginTop") ) || 0;
			left += parseFloat( jQuery.css(body, "marginLeft") ) || 0;
		}

		return { top: top, left: left };
	},

	setOffset: function( elem, options, i ) {
		var position = jQuery.css( elem, "position" );

		// set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		var curElem = jQuery( elem ),
			curOffset = curElem.offset(),
			curCSSTop = jQuery.css( elem, "top" ),
			curCSSLeft = jQuery.css( elem, "left" ),
			calculatePosition = (position === "absolute" && jQuery.inArray('auto', [curCSSTop, curCSSLeft]) > -1),
			props = {}, curPosition = {}, curTop, curLeft;

		// need to be able to calculate position if either top or left is auto and position is absolute
		if ( calculatePosition ) {
			curPosition = curElem.position();
		}

		curTop  = calculatePosition ? curPosition.top  : parseInt( curCSSTop,  10 ) || 0;
		curLeft = calculatePosition ? curPosition.left : parseInt( curCSSLeft, 10 ) || 0;

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if (options.top != null) {
			props.top = (options.top - curOffset.top) + curTop;
		}
		if (options.left != null) {
			props.left = (options.left - curOffset.left) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );
		} else {
			curElem.css( props );
		}
	}
};


jQuery.fn.extend({
	position: function() {
		if ( !this[0] ) {
			return null;
		}

		var elem = this[0],

		// Get *real* offsetParent
		offsetParent = this.offsetParent(),

		// Get correct offsets
		offset       = this.offset(),
		parentOffset = rroot.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();

		// Subtract element margins
		// note: when an element has margin: auto the offsetLeft and marginLeft
		// are the same in Safari causing offset.left to incorrectly be 0
		offset.top  -= parseFloat( jQuery.css(elem, "marginTop") ) || 0;
		offset.left -= parseFloat( jQuery.css(elem, "marginLeft") ) || 0;

		// Add offsetParent borders
		parentOffset.top  += parseFloat( jQuery.css(offsetParent[0], "borderTopWidth") ) || 0;
		parentOffset.left += parseFloat( jQuery.css(offsetParent[0], "borderLeftWidth") ) || 0;

		// Subtract the two offsets
		return {
			top:  offset.top  - parentOffset.top,
			left: offset.left - parentOffset.left
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || document.body;
			while ( offsetParent && (!rroot.test(offsetParent.nodeName) && jQuery.css(offsetParent, "position") === "static") ) {
				offsetParent = offsetParent.offsetParent;
			}
			return offsetParent;
		});
	}
});


// Create scrollLeft and scrollTop methods
jQuery.each( ["Left", "Top"], function( i, name ) {
	var method = "scroll" + name;

	jQuery.fn[ method ] = function(val) {
		var elem = this[0], win;

		if ( !elem ) {
			return null;
		}

		if ( val !== undefined ) {
			// Set the scroll offset
			return this.each(function() {
				win = getWindow( this );

				if ( win ) {
					win.scrollTo(
						!i ? val : jQuery(win).scrollLeft(),
						i ? val : jQuery(win).scrollTop()
					);

				} else {
					this[ method ] = val;
				}
			});
		} else {
			win = getWindow( elem );

			// Return the scroll offset
			return win ? ("pageXOffset" in win) ? win[ i ? "pageYOffset" : "pageXOffset" ] :
				jQuery.support.boxModel && win.document.documentElement[ method ] ||
					win.document.body[ method ] :
				elem[ method ];
		}
	};
});

function getWindow( elem ) {
	return jQuery.isWindow( elem ) ?
		elem :
		elem.nodeType === 9 ?
			elem.defaultView || elem.parentWindow :
			false;
}




// Create innerHeight, innerWidth, outerHeight and outerWidth methods
jQuery.each([ "Height", "Width" ], function( i, name ) {

	var type = name.toLowerCase();

	// innerHeight and innerWidth
	jQuery.fn["inner" + name] = function() {
		return this[0] ?
			parseFloat( jQuery.css( this[0], type, "padding" ) ) :
			null;
	};

	// outerHeight and outerWidth
	jQuery.fn["outer" + name] = function( margin ) {
		return this[0] ?
			parseFloat( jQuery.css( this[0], type, margin ? "margin" : "border" ) ) :
			null;
	};

	jQuery.fn[ type ] = function( size ) {
		// Get window width or height
		var elem = this[0];
		if ( !elem ) {
			return size == null ? null : this;
		}

		if ( jQuery.isFunction( size ) ) {
			return this.each(function( i ) {
				var self = jQuery( this );
				self[ type ]( size.call( this, i, self[ type ]() ) );
			});
		}

		if ( jQuery.isWindow( elem ) ) {
			// Everyone else use document.documentElement or document.body depending on Quirks vs Standards mode
			// 3rd condition allows Nokia support, as it supports the docElem prop but not CSS1Compat
			var docElemProp = elem.document.documentElement[ "client" + name ];
			return elem.document.compatMode === "CSS1Compat" && docElemProp ||
				elem.document.body[ "client" + name ] || docElemProp;

		// Get document width or height
		} else if ( elem.nodeType === 9 ) {
			// Either scroll[Width/Height] or offset[Width/Height], whichever is greater
			return Math.max(
				elem.documentElement["client" + name],
				elem.body["scroll" + name], elem.documentElement["scroll" + name],
				elem.body["offset" + name], elem.documentElement["offset" + name]
			);

		// Get or set width or height on the element
		} else if ( size === undefined ) {
			var orig = jQuery.css( elem, type ),
				ret = parseFloat( orig );

			return jQuery.isNaN( ret ) ? orig : ret;

		// Set the width or height on the element (default to pixels if value is unitless)
		} else {
			return this.css( type, typeof size === "string" ? size : size + "px" );
		}
	};

});


window.jQuery = window.$ = jQuery;
})(window);

//     Underscore.js 1.3.3
//     (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.
//     Underscore is freely distributable under the MIT license.
//     Portions of Underscore are inspired or borrowed from Prototype,
//     Oliver Steele's Functional, and John Resig's Micro-Templating.
//     For all details and documentation:
//     http://documentcloud.github.com/underscore

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `global` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var slice            = ArrayProto.slice,
      unshift          = ArrayProto.unshift,
      toString         = ObjProto.toString,
      hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) { return new wrapper(obj); };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root['_'] = _;
  }

  // Current version.
  _.VERSION = '1.3.3';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, l = obj.length; i < l; i++) {
        if (i in obj && iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      for (var key in obj) {
        if (_.has(obj, key)) {
          if (iterator.call(context, obj[key], key, obj) === breaker) return;
        }
      }
    }
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function(value, index, list) {
      results[results.length] = iterator.call(context, value, index, list);
    });
    if (obj.length === +obj.length) results.length = obj.length;
    return results;
  };

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError('Reduce of empty array with no initial value');
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var reversed = _.toArray(obj).reverse();
    if (context && !initial) iterator = _.bind(iterator, context);
    return initial ? _.reduce(reversed, iterator, memo, context) : _.reduce(reversed, iterator);
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, iterator, context) {
    var result;
    any(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
    each(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) results[results.length] = value;
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    each(obj, function(value, index, list) {
      if (!iterator.call(context, value, index, list)) results[results.length] = value;
    });
    return results;
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function(obj, iterator, context) {
    var result = true;
    if (obj == null) return result;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
    each(obj, function(value, index, list) {
      if (!(result = result && iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = false;
    if (obj == null) return result;
    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
    each(obj, function(value, index, list) {
      if (result || (result = iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if a given value is included in the array or object using `===`.
  // Aliased as `contains`.
  _.include = _.contains = function(obj, target) {
    var found = false;
    if (obj == null) return found;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    found = any(obj, function(value) {
      return value === target;
    });
    return found;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    return _.map(obj, function(value) {
      return (_.isFunction(method) ? method || value : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, function(value){ return value[key]; });
  };

  // Return the maximum element or (element-based computation).
  _.max = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0]) return Math.max.apply(Math, obj);
    if (!iterator && _.isEmpty(obj)) return -Infinity;
    var result = {computed : -Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed >= result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0]) return Math.min.apply(Math, obj);
    if (!iterator && _.isEmpty(obj)) return Infinity;
    var result = {computed : Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed < result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Shuffle an array.
  _.shuffle = function(obj) {
    var shuffled = [], rand;
    each(obj, function(value, index, list) {
      rand = Math.floor(Math.random() * (index + 1));
      shuffled[index] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, val, context) {
    var iterator = _.isFunction(val) ? val : function(obj) { return obj[val]; };
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value : value,
        criteria : iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria, b = right.criteria;
      if (a === void 0) return 1;
      if (b === void 0) return -1;
      return a < b ? -1 : a > b ? 1 : 0;
    }), 'value');
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = function(obj, val) {
    var result = {};
    var iterator = _.isFunction(val) ? val : function(obj) { return obj[val]; };
    each(obj, function(value, index) {
      var key = iterator(value, index);
      (result[key] || (result[key] = [])).push(value);
    });
    return result;
  };

  // Use a comparator function to figure out at what index an object should
  // be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator) {
    iterator || (iterator = _.identity);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >> 1;
      iterator(array[mid]) < iterator(obj) ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely convert anything iterable into a real, live array.
  _.toArray = function(obj) {
    if (!obj)                                     return [];
    if (_.isArray(obj))                           return slice.call(obj);
    if (_.isArguments(obj))                       return slice.call(obj);
    if (obj.toArray && _.isFunction(obj.toArray)) return obj.toArray();
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    return _.isArray(obj) ? obj.length : _.keys(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];
  };

  // Returns everything but the last entry of the array. Especcialy useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if ((n != null) && !guard) {
      return slice.call(array, Math.max(array.length - n, 0));
    } else {
      return array[array.length - 1];
    }
  };

  // Returns everything but the first entry of the array. Aliased as `tail`.
  // Especially useful on the arguments object. Passing an **index** will return
  // the rest of the values in the array from that index onward. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = function(array, index, guard) {
    return slice.call(array, (index == null) || guard ? 1 : index);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, function(value){ return !!value; });
  };

  // Return a completely flattened version of an array.
  _.flatten = function(array, shallow) {
    return _.reduce(array, function(memo, value) {
      if (_.isArray(value)) return memo.concat(shallow ? value : _.flatten(value));
      memo[memo.length] = value;
      return memo;
    }, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iterator) {
    var initial = iterator ? _.map(array, iterator) : array;
    var results = [];
    // The `isSorted` flag is irrelevant if the array only contains two elements.
    if (array.length < 3) isSorted = true;
    _.reduce(initial, function (memo, value, index) {
      if (isSorted ? _.last(memo) !== value || !memo.length : !_.include(memo, value)) {
        memo.push(value);
        results.push(array[index]);
      }
      return memo;
    }, []);
    return results;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(_.flatten(arguments, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays. (Aliased as "intersect" for back-compat.)
  _.intersection = _.intersect = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.indexOf(other, item) >= 0;
      });
    });
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = _.flatten(slice.call(arguments, 1), true);
    return _.filter(array, function(value){ return !_.include(rest, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var args = slice.call(arguments);
    var length = _.max(_.pluck(args, 'length'));
    var results = new Array(length);
    for (var i = 0; i < length; i++) results[i] = _.pluck(args, "" + i);
    return results;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i, l;
    if (isSorted) {
      i = _.sortedIndex(array, item);
      return array[i] === item ? i : -1;
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item);
    for (i = 0, l = array.length; i < l; i++) if (i in array && array[i] === item) return i;
    return -1;
  };

  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function(array, item) {
    if (array == null) return -1;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) return array.lastIndexOf(item);
    var i = array.length;
    while (i--) if (i in array && array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var len = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(len);

    while(idx < len) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Reusable constructor function for prototype setting.
  var ctor = function(){};

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Binding with arguments is also known as `curry`.
  // Delegates to **ECMAScript 5**'s native `Function.bind` if available.
  // We check for `func.bind` first, to fail fast when `func` is undefined.
  _.bind = function bind(func, context) {
    var bound, args;
    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError;
    args = slice.call(arguments, 2);
    return bound = function() {
      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
      ctor.prototype = func.prototype;
      var self = new ctor;
      var result = func.apply(self, args.concat(slice.call(arguments)));
      if (Object(result) === result) return result;
      return self;
    };
  };

  // Bind all of an object's methods to that object. Useful for ensuring that
  // all callbacks defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length == 0) funcs = _.functions(obj);
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(null, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time.
  _.throttle = function(func, wait) {
    var context, args, timeout, throttling, more, result;
    var whenDone = _.debounce(function(){ more = throttling = false; }, wait);
    return function() {
      context = this; args = arguments;
      var later = function() {
        timeout = null;
        if (more) func.apply(context, args);
        whenDone();
      };
      if (!timeout) timeout = setTimeout(later, wait);
      if (throttling) {
        more = true;
      } else {
        result = func.apply(context, args);
      }
      whenDone();
      throttling = true;
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout;
    return function() {
      var context = this, args = arguments;
      var later = function() {
        timeout = null;
        if (!immediate) func.apply(context, args);
      };
      if (immediate && !timeout) func.apply(context, args);
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      return memo = func.apply(this, arguments);
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return function() {
      var args = [func].concat(slice.call(arguments, 0));
      return wrapper.apply(this, args);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = arguments;
    return function() {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    if (times <= 0) return func();
    return function() {
      if (--times < 1) { return func.apply(this, arguments); }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = nativeKeys || function(obj) {
    if (obj !== Object(obj)) throw new TypeError('Invalid object');
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    return _.map(obj, _.identity);
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      for (var prop in source) {
        obj[prop] = source[prop];
      }
    });
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj) {
    var result = {};
    each(_.flatten(slice.call(arguments, 1)), function(key) {
      if (key in obj) result[key] = obj[key];
    });
    return result;
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      for (var prop in source) {
        if (obj[prop] == null) obj[prop] = source[prop];
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function.
  function eq(a, b, stack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a._chain) a = a._wrapped;
    if (b._chain) b = b._wrapped;
    // Invoke a custom `isEqual` method if one is provided.
    if (a.isEqual && _.isFunction(a.isEqual)) return a.isEqual(b);
    if (b.isEqual && _.isFunction(b.isEqual)) return b.isEqual(a);
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = stack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (stack[length] == a) return true;
    }
    // Add the first object to the stack of traversed objects.
    stack.push(a);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          // Ensure commutative equality for sparse arrays.
          if (!(result = size in a == size in b && eq(a[size], b[size], stack))) break;
        }
      }
    } else {
      // Objects with different constructors are not equivalent.
      if ('constructor' in a != 'constructor' in b || a.constructor != b.constructor) return false;
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], stack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    stack.pop();
    return result;
  }

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType == 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Is a given variable an arguments object?
  _.isArguments = function(obj) {
    return toString.call(obj) == '[object Arguments]';
  };
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Is a given value a function?
  _.isFunction = function(obj) {
    return toString.call(obj) == '[object Function]';
  };

  // Is a given value a string?
  _.isString = function(obj) {
    return toString.call(obj) == '[object String]';
  };

  // Is a given value a number?
  _.isNumber = function(obj) {
    return toString.call(obj) == '[object Number]';
  };

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return _.isNumber(obj) && isFinite(obj);
  };

  // Is the given value `NaN`?
  _.isNaN = function(obj) {
    // `NaN` is the only value for which `===` is not reflexive.
    return obj !== obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value a date?
  _.isDate = function(obj) {
    return toString.call(obj) == '[object Date]';
  };

  // Is the given value a regular expression?
  _.isRegExp = function(obj) {
    return toString.call(obj) == '[object RegExp]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Has own property?
  _.has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  // Run a function **n** times.
  _.times = function (n, iterator, context) {
    for (var i = 0; i < n; i++) iterator.call(context, i);
  };

  // Escape a string for HTML interpolation.
  _.escape = function(string) {
    return (''+string).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#x27;').replace(/\//g,'&#x2F;');
  };

  // If the value of the named property is a function then invoke it;
  // otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return null;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Add your own custom functions to the Underscore object, ensuring that
  // they're correctly added to the OOP wrapper as well.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name){
      addToWrapper(name, _[name] = obj[name]);
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = idCounter++;
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /.^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    '\\': '\\',
    "'": "'",
    'r': '\r',
    'n': '\n',
    't': '\t',
    'u2028': '\u2028',
    'u2029': '\u2029'
  };

  for (var p in escapes) escapes[escapes[p]] = p;
  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;
  var unescaper = /\\(\\|'|r|n|t|u2028|u2029)/g;

  // Within an interpolation, evaluation, or escaping, remove HTML escaping
  // that had been previously added.
  var unescape = function(code) {
    return code.replace(unescaper, function(match, escape) {
      return escapes[escape];
    });
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(text, data, settings) {
    settings = _.defaults(settings || {}, _.templateSettings);

    // Compile the template source, taking care to escape characters that
    // cannot be included in a string literal and then unescape them in code
    // blocks.
    var source = "__p+='" + text
      .replace(escaper, function(match) {
        return '\\' + escapes[match];
      })
      .replace(settings.escape || noMatch, function(match, code) {
        return "'+\n_.escape(" + unescape(code) + ")+\n'";
      })
      .replace(settings.interpolate || noMatch, function(match, code) {
        return "'+\n(" + unescape(code) + ")+\n'";
      })
      .replace(settings.evaluate || noMatch, function(match, code) {
        return "';\n" + unescape(code) + "\n;__p+='";
      }) + "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __p='';" +
      "var print=function(){__p+=Array.prototype.join.call(arguments, '')};\n" +
      source + "return __p;\n";

    var render = new Function(settings.variable || 'obj', '_', source);
    if (data) return render(data, _);
    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled function source as a convenience for build time
    // precompilation.
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' +
      source + '}';

    return template;
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function(obj) {
    return _(obj).chain();
  };

  // The OOP Wrapper
  // ---------------

  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.
  var wrapper = function(obj) { this._wrapped = obj; };

  // Expose `wrapper.prototype` as `_.prototype`
  _.prototype = wrapper.prototype;

  // Helper function to continue chaining intermediate results.
  var result = function(obj, chain) {
    return chain ? _(obj).chain() : obj;
  };

  // A method to easily add functions to the OOP wrapper.
  var addToWrapper = function(name, func) {
    wrapper.prototype[name] = function() {
      var args = slice.call(arguments);
      unshift.call(args, this._wrapped);
      return result(func.apply(_, args), this._chain);
    };
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    wrapper.prototype[name] = function() {
      var wrapped = this._wrapped;
      method.apply(wrapped, arguments);
      var length = wrapped.length;
      if ((name == 'shift' || name == 'splice') && length === 0) delete wrapped[0];
      return result(wrapped, this._chain);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    wrapper.prototype[name] = function() {
      return result(method.apply(this._wrapped, arguments), this._chain);
    };
  });

  // Start chaining a wrapped Underscore object.
  wrapper.prototype.chain = function() {
    this._chain = true;
    return this;
  };

  // Extracts the result from a wrapped and chained object.
  wrapper.prototype.value = function() {
    return this._wrapped;
  };

}).call(this);

//     Backbone.js 0.9.2

//     (c) 2010-2012 Jeremy Ashkenas, DocumentCloud Inc.
//     Backbone may be freely distributed under the MIT license.
//     For all details and documentation:
//     http://backbonejs.org

(function(){

  // Initial Setup
  // -------------

  // Save a reference to the global object (`window` in the browser, `global`
  // on the server).
  var root = this;

  // Save the previous value of the `Backbone` variable, so that it can be
  // restored later on, if `noConflict` is used.
  var previousBackbone = root.Backbone;

  // Create a local reference to slice/splice.
  var slice = Array.prototype.slice;
  var splice = Array.prototype.splice;

  // The top-level namespace. All public Backbone classes and modules will
  // be attached to this. Exported for both CommonJS and the browser.
  var Backbone;
  if (typeof exports !== 'undefined') {
    Backbone = exports;
  } else {
    Backbone = root.Backbone = {};
  }

  // Current version of the library. Keep in sync with `package.json`.
  Backbone.VERSION = '0.9.2';

  // Require Underscore, if we're on the server, and it's not already present.
  var _ = root._;
  if (!_ && (typeof require !== 'undefined')) _ = require('./underscore');

  // For Backbone's purposes, jQuery, Zepto, or Ender owns the `$` variable.
  var $ = root.jQuery || root.Zepto || root.ender;

  // Set the JavaScript library that will be used for DOM manipulation and
  // Ajax calls (a.k.a. the `$` variable). By default Backbone will use: jQuery,
  // Zepto, or Ender; but the `setDomLibrary()` method lets you inject an
  // alternate JavaScript library (or a mock library for testing your views
  // outside of a browser).
  Backbone.setDomLibrary = function(lib) {
    $ = lib;
  };

  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
  // to its previous owner. Returns a reference to this Backbone object.
  Backbone.noConflict = function() {
    root.Backbone = previousBackbone;
    return this;
  };

  // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
  // will fake `"PUT"` and `"DELETE"` requests via the `_method` parameter and
  // set a `X-Http-Method-Override` header.
  Backbone.emulateHTTP = false;

  // Turn on `emulateJSON` to support legacy servers that can't deal with direct
  // `application/json` requests ... will encode the body as
  // `application/x-www-form-urlencoded` instead and will send the model in a
  // form param named `model`.
  Backbone.emulateJSON = false;

  // Backbone.Events
  // -----------------

  // Regular expression used to split event strings
  var eventSplitter = /\s+/;

  // A module that can be mixed in to *any object* in order to provide it with
  // custom events. You may bind with `on` or remove with `off` callback functions
  // to an event; trigger`-ing an event fires all callbacks in succession.
  //
  //     var object = {};
  //     _.extend(object, Backbone.Events);
  //     object.on('expand', function(){ alert('expanded'); });
  //     object.trigger('expand');
  //
  var Events = Backbone.Events = {

    // Bind one or more space separated events, `events`, to a `callback`
    // function. Passing `"all"` will bind the callback to all events fired.
    on: function(events, callback, context) {

      var calls, event, node, tail, list;
      if (!callback) return this;
      events = events.split(eventSplitter);
      calls = this._callbacks || (this._callbacks = {});

      // Create an immutable callback list, allowing traversal during
      // modification.  The tail is an empty object that will always be used
      // as the next node.
      while (event = events.shift()) {
        list = calls[event];
        node = list ? list.tail : {};
        node.next = tail = {};
        node.context = context;
        node.callback = callback;
        calls[event] = {tail: tail, next: list ? list.next : node};
      }

      return this;
    },

    // Remove one or many callbacks. If `context` is null, removes all callbacks
    // with that function. If `callback` is null, removes all callbacks for the
    // event. If `events` is null, removes all bound callbacks for all events.
    off: function(events, callback, context) {
      var event, calls, node, tail, cb, ctx;

      // No events, or removing *all* events.
      if (!(calls = this._callbacks)) return;
      if (!(events || callback || context)) {
        delete this._callbacks;
        return this;
      }

      // Loop through the listed events and contexts, splicing them out of the
      // linked list of callbacks if appropriate.
      events = events ? events.split(eventSplitter) : _.keys(calls);
      while (event = events.shift()) {
        node = calls[event];
        delete calls[event];
        if (!node || !(callback || context)) continue;
        // Create a new list, omitting the indicated callbacks.
        tail = node.tail;
        while ((node = node.next) !== tail) {
          cb = node.callback;
          ctx = node.context;
          if ((callback && cb !== callback) || (context && ctx !== context)) {
            this.on(event, cb, ctx);
          }
        }
      }

      return this;
    },

    // Trigger one or many events, firing all bound callbacks. Callbacks are
    // passed the same arguments as `trigger` is, apart from the event name
    // (unless you're listening on `"all"`, which will cause your callback to
    // receive the true name of the event as the first argument).
    trigger: function(events) {
      var event, node, calls, tail, args, all, rest;
      if (!(calls = this._callbacks)) return this;
      all = calls.all;
      events = events.split(eventSplitter);
      rest = slice.call(arguments, 1);

      // For each event, walk through the linked list of callbacks twice,
      // first to trigger the event, then to trigger any `"all"` callbacks.
      while (event = events.shift()) {
        if (node = calls[event]) {
          tail = node.tail;
          while ((node = node.next) !== tail) {
            node.callback.apply(node.context || this, rest);
          }
        }
        if (node = all) {
          tail = node.tail;
          args = [event].concat(rest);
          while ((node = node.next) !== tail) {
            node.callback.apply(node.context || this, args);
          }
        }
      }

      return this;
    }

  };

  // Aliases for backwards compatibility.
  Events.bind   = Events.on;
  Events.unbind = Events.off;

  // Backbone.Model
  // --------------

  // Create a new model, with defined attributes. A client id (`cid`)
  // is automatically generated and assigned for you.
  var Model = Backbone.Model = function(attributes, options) {
    var defaults;
    attributes || (attributes = {});
    if (options && options.parse) attributes = this.parse(attributes);
    if (defaults = getValue(this, 'defaults')) {
      attributes = _.extend({}, defaults, attributes);
    }
    if (options && options.collection) this.collection = options.collection;
    this.attributes = {};
    this._escapedAttributes = {};
    this.cid = _.uniqueId('c');
    this.changed = {};
    this._silent = {};
    this._pending = {};
    this.set(attributes, {silent: true});
    // Reset change tracking.
    this.changed = {};
    this._silent = {};
    this._pending = {};
    this._previousAttributes = _.clone(this.attributes);
    this.initialize.apply(this, arguments);
  };

  // Attach all inheritable methods to the Model prototype.
  _.extend(Model.prototype, Events, {

    // A hash of attributes whose current and previous value differ.
    changed: null,

    // A hash of attributes that have silently changed since the last time
    // `change` was called.  Will become pending attributes on the next call.
    _silent: null,

    // A hash of attributes that have changed since the last `'change'` event
    // began.
    _pending: null,

    // The default name for the JSON `id` attribute is `"id"`. MongoDB and
    // CouchDB users may want to set this to `"_id"`.
    idAttribute: 'id',

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Return a copy of the model's `attributes` object.
    toJSON: function(options) {
      return _.clone(this.attributes);
    },

    // Get the value of an attribute.
    get: function(attr) {
      return this.attributes[attr];
    },

    // Get the HTML-escaped value of an attribute.
    escape: function(attr) {
      var html;
      if (html = this._escapedAttributes[attr]) return html;
      var val = this.get(attr);
      return this._escapedAttributes[attr] = _.escape(val == null ? '' : '' + val);
    },

    // Returns `true` if the attribute contains a value that is not null
    // or undefined.
    has: function(attr) {
      return this.get(attr) != null;
    },

    // Set a hash of model attributes on the object, firing `"change"` unless
    // you choose to silence it.
    set: function(key, value, options) {
      var attrs, attr, val;

      // Handle both
      if (_.isObject(key) || key == null) {
        attrs = key;
        options = value;
      } else {
        attrs = {};
        attrs[key] = value;
      }

      // Extract attributes and options.
      options || (options = {});
      if (!attrs) return this;
      if (attrs instanceof Model) attrs = attrs.attributes;
      if (options.unset) for (attr in attrs) attrs[attr] = void 0;

      // Run validation.
      if (!this._validate(attrs, options)) return false;

      // Check for changes of `id`.
      if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];

      var changes = options.changes = {};
      var now = this.attributes;
      var escaped = this._escapedAttributes;
      var prev = this._previousAttributes || {};

      // For each `set` attribute...
      for (attr in attrs) {
        val = attrs[attr];

        // If the new and current value differ, record the change.
        if (!_.isEqual(now[attr], val) || (options.unset && _.has(now, attr))) {
          delete escaped[attr];
          (options.silent ? this._silent : changes)[attr] = true;
        }

        // Update or delete the current value.
        options.unset ? delete now[attr] : now[attr] = val;

        // If the new and previous value differ, record the change.  If not,
        // then remove changes for this attribute.
        if (!_.isEqual(prev[attr], val) || (_.has(now, attr) != _.has(prev, attr))) {
          this.changed[attr] = val;
          if (!options.silent) this._pending[attr] = true;
        } else {
          delete this.changed[attr];
          delete this._pending[attr];
        }
      }

      // Fire the `"change"` events.
      if (!options.silent) this.change(options);
      return this;
    },

    // Remove an attribute from the model, firing `"change"` unless you choose
    // to silence it. `unset` is a noop if the attribute doesn't exist.
    unset: function(attr, options) {
      (options || (options = {})).unset = true;
      return this.set(attr, null, options);
    },

    // Clear all attributes on the model, firing `"change"` unless you choose
    // to silence it.
    clear: function(options) {
      (options || (options = {})).unset = true;
      return this.set(_.clone(this.attributes), options);
    },

    // Fetch the model from the server. If the server's representation of the
    // model differs from its current attributes, they will be overriden,
    // triggering a `"change"` event.
    fetch: function(options) {
      options = options ? _.clone(options) : {};
      var model = this;
      var success = options.success;
      options.success = function(resp, status, xhr) {
        if (!model.set(model.parse(resp, xhr), options)) return false;
        if (success) success(model, resp);
      };
      options.error = Backbone.wrapError(options.error, model, options);
      return (this.sync || Backbone.sync).call(this, 'read', this, options);
    },

    // Set a hash of model attributes, and sync the model to the server.
    // If the server returns an attributes hash that differs, the model's
    // state will be `set` again.
    save: function(key, value, options) {
      var attrs, current;

      // Handle both `("key", value)` and `({key: value})` -style calls.
      if (_.isObject(key) || key == null) {
        attrs = key;
        options = value;
      } else {
        attrs = {};
        attrs[key] = value;
      }
      options = options ? _.clone(options) : {};

      // If we're "wait"-ing to set changed attributes, validate early.
      if (options.wait) {
        if (!this._validate(attrs, options)) return false;
        current = _.clone(this.attributes);
      }

      // Regular saves `set` attributes before persisting to the server.
      var silentOptions = _.extend({}, options, {silent: true});
      if (attrs && !this.set(attrs, options.wait ? silentOptions : options)) {
        return false;
      }

      // After a successful server-side save, the client is (optionally)
      // updated with the server-side state.
      var model = this;
      var success = options.success;
      options.success = function(resp, status, xhr) {
        var serverAttrs = model.parse(resp, xhr);
        if (options.wait) {
          delete options.wait;
          serverAttrs = _.extend(attrs || {}, serverAttrs);
        }
        if (!model.set(serverAttrs, options)) return false;
        if (success) {
          success(model, resp);
        } else {
          model.trigger('sync', model, resp, options);
        }
      };

      // Finish configuring and sending the Ajax request.
      options.error = Backbone.wrapError(options.error, model, options);
      var method = this.isNew() ? 'create' : 'update';
      var xhr = (this.sync || Backbone.sync).call(this, method, this, options);
      if (options.wait) this.set(current, silentOptions);
      return xhr;
    },

    // Destroy this model on the server if it was already persisted.
    // Optimistically removes the model from its collection, if it has one.
    // If `wait: true` is passed, waits for the server to respond before removal.
    destroy: function(options) {
      options = options ? _.clone(options) : {};
      var model = this;
      var success = options.success;

      var triggerDestroy = function() {
        model.trigger('destroy', model, model.collection, options);
      };

      if (this.isNew()) {
        triggerDestroy();
        return false;
      }

      options.success = function(resp) {
        if (options.wait) triggerDestroy();
        if (success) {
          success(model, resp);
        } else {
          model.trigger('sync', model, resp, options);
        }
      };

      options.error = Backbone.wrapError(options.error, model, options);
      var xhr = (this.sync || Backbone.sync).call(this, 'delete', this, options);
      if (!options.wait) triggerDestroy();
      return xhr;
    },

    // Default URL for the model's representation on the server -- if you're
    // using Backbone's restful methods, override this to change the endpoint
    // that will be called.
    url: function() {
      var base = getValue(this, 'urlRoot') || getValue(this.collection, 'url') || urlError();
      if (this.isNew()) return base;
      return base + (base.charAt(base.length - 1) == '/' ? '' : '/') + encodeURIComponent(this.id);
    },

    // **parse** converts a response into the hash of attributes to be `set` on
    // the model. The default implementation is just to pass the response along.
    parse: function(resp, xhr) {
      return resp;
    },

    // Create a new model with identical attributes to this one.
    clone: function() {
      return new this.constructor(this.attributes);
    },

    // A model is new if it has never been saved to the server, and lacks an id.
    isNew: function() {
      return this.id == null;
    },

    // Call this method to manually fire a `"change"` event for this model and
    // a `"change:attribute"` event for each changed attribute.
    // Calling this will cause all objects observing the model to update.
    change: function(options) {
      options || (options = {});
      var changing = this._changing;
      this._changing = true;

      // Silent changes become pending changes.
      for (var attr in this._silent) this._pending[attr] = true;

      // Silent changes are triggered.
      var changes = _.extend({}, options.changes, this._silent);
      this._silent = {};
      for (var attr in changes) {
        this.trigger('change:' + attr, this, this.get(attr), options);
      }
      if (changing) return this;

      // Continue firing `"change"` events while there are pending changes.
      while (!_.isEmpty(this._pending)) {
        this._pending = {};
        this.trigger('change', this, options);
        // Pending and silent changes still remain.
        for (var attr in this.changed) {
          if (this._pending[attr] || this._silent[attr]) continue;
          delete this.changed[attr];
        }
        this._previousAttributes = _.clone(this.attributes);
      }

      this._changing = false;
      return this;
    },

    // Determine if the model has changed since the last `"change"` event.
    // If you specify an attribute name, determine if that attribute has changed.
    hasChanged: function(attr) {
      if (!arguments.length) return !_.isEmpty(this.changed);
      return _.has(this.changed, attr);
    },

    // Return an object containing all the attributes that have changed, or
    // false if there are no changed attributes. Useful for determining what
    // parts of a view need to be updated and/or what attributes need to be
    // persisted to the server. Unset attributes will be set to undefined.
    // You can also pass an attributes object to diff against the model,
    // determining if there *would be* a change.
    changedAttributes: function(diff) {
      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
      var val, changed = false, old = this._previousAttributes;
      for (var attr in diff) {
        if (_.isEqual(old[attr], (val = diff[attr]))) continue;
        (changed || (changed = {}))[attr] = val;
      }
      return changed;
    },

    // Get the previous value of an attribute, recorded at the time the last
    // `"change"` event was fired.
    previous: function(attr) {
      if (!arguments.length || !this._previousAttributes) return null;
      return this._previousAttributes[attr];
    },

    // Get all of the attributes of the model at the time of the previous
    // `"change"` event.
    previousAttributes: function() {
      return _.clone(this._previousAttributes);
    },

    // Check if the model is currently in a valid state. It's only possible to
    // get into an *invalid* state if you're using silent changes.
    isValid: function() {
      return !this.validate(this.attributes);
    },

    // Run validation against the next complete set of model attributes,
    // returning `true` if all is well. If a specific `error` callback has
    // been passed, call that instead of firing the general `"error"` event.
    _validate: function(attrs, options) {
      if (options.silent || !this.validate) return true;
      attrs = _.extend({}, this.attributes, attrs);
      var error = this.validate(attrs, options);
      if (!error) return true;
      if (options && options.error) {
        options.error(this, error, options);
      } else {
        this.trigger('error', this, error, options);
      }
      return false;
    }

  });

  // Backbone.Collection
  // -------------------

  // Provides a standard collection class for our sets of models, ordered
  // or unordered. If a `comparator` is specified, the Collection will maintain
  // its models in sort order, as they're added and removed.
  var Collection = Backbone.Collection = function(models, options) {
    options || (options = {});
    if (options.model) this.model = options.model;
    if (options.comparator) this.comparator = options.comparator;
    this._reset();
    this.initialize.apply(this, arguments);
    if (models) this.reset(models, {silent: true, parse: options.parse});
  };

  // Define the Collection's inheritable methods.
  _.extend(Collection.prototype, Events, {

    // The default model for a collection is just a **Backbone.Model**.
    // This should be overridden in most cases.
    model: Model,

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // The JSON representation of a Collection is an array of the
    // models' attributes.
    toJSON: function(options) {
      return this.map(function(model){ return model.toJSON(options); });
    },

    // Add a model, or list of models to the set. Pass **silent** to avoid
    // firing the `add` event for every new model.
    add: function(models, options) {
      var i, index, length, model, cid, id, cids = {}, ids = {}, dups = [];
      options || (options = {});
      models = _.isArray(models) ? models.slice() : [models];

      // Begin by turning bare objects into model references, and preventing
      // invalid models or duplicate models from being added.
      for (i = 0, length = models.length; i < length; i++) {
        if (!(model = models[i] = this._prepareModel(models[i], options))) {
          throw new Error("Can't add an invalid model to a collection");
        }
        cid = model.cid;
        id = model.id;
        if (cids[cid] || this._byCid[cid] || ((id != null) && (ids[id] || this._byId[id]))) {
          dups.push(i);
          continue;
        }
        cids[cid] = ids[id] = model;
      }

      // Remove duplicates.
      i = dups.length;
      while (i--) {
        models.splice(dups[i], 1);
      }

      // Listen to added models' events, and index models for lookup by
      // `id` and by `cid`.
      for (i = 0, length = models.length; i < length; i++) {
        (model = models[i]).on('all', this._onModelEvent, this);
        this._byCid[model.cid] = model;
        if (model.id != null) this._byId[model.id] = model;
      }

      // Insert models into the collection, re-sorting if needed, and triggering
      // `add` events unless silenced.
      this.length += length;
      index = options.at != null ? options.at : this.models.length;
      splice.apply(this.models, [index, 0].concat(models));
      if (this.comparator) this.sort({silent: true});
      if (options.silent) return this;
      for (i = 0, length = this.models.length; i < length; i++) {
        if (!cids[(model = this.models[i]).cid]) continue;
        options.index = i;
        model.trigger('add', model, this, options);
      }
      return this;
    },

    // Remove a model, or a list of models from the set. Pass silent to avoid
    // firing the `remove` event for every model removed.
    remove: function(models, options) {
      var i, l, index, model;
      options || (options = {});
      models = _.isArray(models) ? models.slice() : [models];
      for (i = 0, l = models.length; i < l; i++) {
        model = this.getByCid(models[i]) || this.get(models[i]);
        if (!model) continue;
        delete this._byId[model.id];
        delete this._byCid[model.cid];
        index = this.indexOf(model);
        this.models.splice(index, 1);
        this.length--;
        if (!options.silent) {
          options.index = index;
          model.trigger('remove', model, this, options);
        }
        this._removeReference(model);
      }
      return this;
    },

    // Add a model to the end of the collection.
    push: function(model, options) {
      model = this._prepareModel(model, options);
      this.add(model, options);
      return model;
    },

    // Remove a model from the end of the collection.
    pop: function(options) {
      var model = this.at(this.length - 1);
      this.remove(model, options);
      return model;
    },

    // Add a model to the beginning of the collection.
    unshift: function(model, options) {
      model = this._prepareModel(model, options);
      this.add(model, _.extend({at: 0}, options));
      return model;
    },

    // Remove a model from the beginning of the collection.
    shift: function(options) {
      var model = this.at(0);
      this.remove(model, options);
      return model;
    },

    // Get a model from the set by id.
    get: function(id) {
      if (id == null) return void 0;
      return this._byId[id.id != null ? id.id : id];
    },

    // Get a model from the set by client id.
    getByCid: function(cid) {
      return cid && this._byCid[cid.cid || cid];
    },

    // Get the model at the given index.
    at: function(index) {
      return this.models[index];
    },

    // Return models with matching attributes. Useful for simple cases of `filter`.
    where: function(attrs) {
      if (_.isEmpty(attrs)) return [];
      return this.filter(function(model) {
        for (var key in attrs) {
          if (attrs[key] !== model.get(key)) return false;
        }
        return true;
      });
    },

    // Force the collection to re-sort itself. You don't need to call this under
    // normal circumstances, as the set will maintain sort order as each item
    // is added.
    sort: function(options) {
      options || (options = {});
      if (!this.comparator) throw new Error('Cannot sort a set without a comparator');
      var boundComparator = _.bind(this.comparator, this);
      if (this.comparator.length == 1) {
        this.models = this.sortBy(boundComparator);
      } else {
        this.models.sort(boundComparator);
      }
      if (!options.silent) this.trigger('reset', this, options);
      return this;
    },

    // Pluck an attribute from each model in the collection.
    pluck: function(attr) {
      return _.map(this.models, function(model){ return model.get(attr); });
    },

    // When you have more items than you want to add or remove individually,
    // you can reset the entire set with a new list of models, without firing
    // any `add` or `remove` events. Fires `reset` when finished.
    reset: function(models, options) {
      models  || (models = []);
      options || (options = {});
      for (var i = 0, l = this.models.length; i < l; i++) {
        this._removeReference(this.models[i]);
      }
      this._reset();
      this.add(models, _.extend({silent: true}, options));
      if (!options.silent) this.trigger('reset', this, options);
      return this;
    },

    // Fetch the default set of models for this collection, resetting the
    // collection when they arrive. If `add: true` is passed, appends the
    // models to the collection instead of resetting.
    fetch: function(options) {
      options = options ? _.clone(options) : {};
      if (options.parse === undefined) options.parse = true;
      var collection = this;
      var success = options.success;
      options.success = function(resp, status, xhr) {
        collection[options.add ? 'add' : 'reset'](collection.parse(resp, xhr), options);
        if (success) success(collection, resp);
      };
      options.error = Backbone.wrapError(options.error, collection, options);
      return (this.sync || Backbone.sync).call(this, 'read', this, options);
    },

    // Create a new instance of a model in this collection. Add the model to the
    // collection immediately, unless `wait: true` is passed, in which case we
    // wait for the server to agree.
    create: function(model, options) {
      var coll = this;
      options = options ? _.clone(options) : {};
      model = this._prepareModel(model, options);
      if (!model) return false;
      if (!options.wait) coll.add(model, options);
      var success = options.success;
      options.success = function(nextModel, resp, xhr) {
        if (options.wait) coll.add(nextModel, options);
        if (success) {
          success(nextModel, resp);
        } else {
          nextModel.trigger('sync', model, resp, options);
        }
      };
      model.save(null, options);
      return model;
    },

    // **parse** converts a response into a list of models to be added to the
    // collection. The default implementation is just to pass it through.
    parse: function(resp, xhr) {
      return resp;
    },

    // Proxy to _'s chain. Can't be proxied the same way the rest of the
    // underscore methods are proxied because it relies on the underscore
    // constructor.
    chain: function () {
      return _(this.models).chain();
    },

    // Reset all internal state. Called when the collection is reset.
    _reset: function(options) {
      this.length = 0;
      this.models = [];
      this._byId  = {};
      this._byCid = {};
    },

    // Prepare a model or hash of attributes to be added to this collection.
    _prepareModel: function(model, options) {
      options || (options = {});
      if (!(model instanceof Model)) {
        var attrs = model;
        options.collection = this;
        model = new this.model(attrs, options);
        if (!model._validate(model.attributes, options)) model = false;
      } else if (!model.collection) {
        model.collection = this;
      }
      return model;
    },

    // Internal method to remove a model's ties to a collection.
    _removeReference: function(model) {
      if (this == model.collection) {
        delete model.collection;
      }
      model.off('all', this._onModelEvent, this);
    },

    // Internal method called every time a model in the set fires an event.
    // Sets need to update their indexes when models change ids. All other
    // events simply proxy through. "add" and "remove" events that originate
    // in other collections are ignored.
    _onModelEvent: function(event, model, collection, options) {
      if ((event == 'add' || event == 'remove') && collection != this) return;
      if (event == 'destroy') {
        this.remove(model, options);
      }
      if (model && event === 'change:' + model.idAttribute) {
        delete this._byId[model.previous(model.idAttribute)];
        this._byId[model.id] = model;
      }
      this.trigger.apply(this, arguments);
    }

  });

  // Underscore methods that we want to implement on the Collection.
  var methods = ['forEach', 'each', 'map', 'reduce', 'reduceRight', 'find',
    'detect', 'filter', 'select', 'reject', 'every', 'all', 'some', 'any',
    'include', 'contains', 'invoke', 'max', 'min', 'sortBy', 'sortedIndex',
    'toArray', 'size', 'first', 'initial', 'rest', 'last', 'without', 'indexOf',
    'shuffle', 'lastIndexOf', 'isEmpty', 'groupBy'];

  // Mix in each Underscore method as a proxy to `Collection#models`.
  _.each(methods, function(method) {
    Collection.prototype[method] = function() {
      return _[method].apply(_, [this.models].concat(_.toArray(arguments)));
    };
  });

  // Backbone.Router
  // -------------------

  // Routers map faux-URLs to actions, and fire events when routes are
  // matched. Creating a new one sets its `routes` hash, if not set statically.
  var Router = Backbone.Router = function(options) {
    options || (options = {});
    if (options.routes) this.routes = options.routes;
    this._bindRoutes();
    this.initialize.apply(this, arguments);
  };

  // Cached regular expressions for matching named param parts and splatted
  // parts of route strings.
  var namedParam    = /:\w+/g;
  var splatParam    = /\*\w+/g;
  var escapeRegExp  = /[-[\]{}()+?.,\\^$|#\s]/g;

  // Set up all inheritable **Backbone.Router** properties and methods.
  _.extend(Router.prototype, Events, {

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Manually bind a single named route to a callback. For example:
    //
    //     this.route('search/:query/p:num', 'search', function(query, num) {
    //       ...
    //     });
    //
    route: function(route, name, callback) {
      Backbone.history || (Backbone.history = new History);
      if (!_.isRegExp(route)) route = this._routeToRegExp(route);
      if (!callback) callback = this[name];
      Backbone.history.route(route, _.bind(function(fragment) {
        var args = this._extractParameters(route, fragment);
        callback && callback.apply(this, args);
        this.trigger.apply(this, ['route:' + name].concat(args));
        Backbone.history.trigger('route', this, name, args);
      }, this));
      return this;
    },

    // Simple proxy to `Backbone.history` to save a fragment into the history.
    navigate: function(fragment, options) {
      Backbone.history.navigate(fragment, options);
    },

    // Bind all defined navigates to `Backbone.history`. We have to reverse the
    // order of the routes here to support behavior where the most general
    // routes can be defined at the bottom of the route map.
    _bindRoutes: function() {
      if (!this.routes) return;
      var routes = [];
      for (var route in this.routes) {
        routes.unshift([route, this.routes[route]]);
      }
      for (var i = 0, l = routes.length; i < l; i++) {
        this.route(routes[i][0], routes[i][1], this[routes[i][1]]);
      }
    },

    // Convert a route string into a regular expression, suitable for matching
    // against the current location hash.
    _routeToRegExp: function(route) {
      route = route.replace(escapeRegExp, '\\$&')
                   .replace(namedParam, '([^\/]+)')
                   .replace(splatParam, '(.*?)');
      return new RegExp('^' + route + '$');
    },

    // Given a route, and a URL fragment that it matches, return the array of
    // extracted parameters.
    _extractParameters: function(route, fragment) {
      return route.exec(fragment).slice(1);
    }

  });

  // Backbone.History
  // ----------------

  // Handles cross-browser history management, based on URL fragments. If the
  // browser does not support `onhashchange`, falls back to polling.
  var History = Backbone.History = function() {
    this.handlers = [];
    _.bindAll(this, 'checkUrl');
  };

  // Cached regex for cleaning leading hashes and slashes .
  var routeStripper = /^[#\/]/;

  // Cached regex for detecting MSIE.
  var isExplorer = /msie [\w.]+/;

  // Has the history handling already been started?
  History.started = false;

  // Set up all inheritable **Backbone.History** properties and methods.
  _.extend(History.prototype, Events, {

    // The default interval to poll for hash changes, if necessary, is
    // twenty times a second.
    interval: 50,

    // Gets the true hash value. Cannot use location.hash directly due to bug
    // in Firefox where location.hash will always be decoded.
    getHash: function(windowOverride) {
      var loc = windowOverride ? windowOverride.location : window.location;
      var match = loc.href.match(/#(.*)$/);
      return match ? match[1] : '';
    },

    // Get the cross-browser normalized URL fragment, either from the URL,
    // the hash, or the override.
    getFragment: function(fragment, forcePushState) {
      if (fragment == null) {
        if (this._hasPushState || forcePushState) {
          fragment = window.location.pathname;
          var search = window.location.search;
          if (search) fragment += search;
        } else {
          fragment = this.getHash();
        }
      }
      if (!fragment.indexOf(this.options.root)) fragment = fragment.substr(this.options.root.length);
      return fragment.replace(routeStripper, '');
    },

    // Start the hash change handling, returning `true` if the current URL matches
    // an existing route, and `false` otherwise.
    start: function(options) {
      if (History.started) throw new Error("Backbone.history has already been started");
      History.started = true;

      // Figure out the initial configuration. Do we need an iframe?
      // Is pushState desired ... is it available?
      this.options          = _.extend({}, {root: '/'}, this.options, options);
      this._wantsHashChange = this.options.hashChange !== false;
      this._wantsPushState  = !!this.options.pushState;
      this._hasPushState    = !!(this.options.pushState && window.history && window.history.pushState);
      var fragment          = this.getFragment();
      var docMode           = document.documentMode;
      var oldIE             = (isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7));

      if (oldIE) {
        this.iframe = $('<iframe src="javascript:0" tabindex="-1" />').hide().appendTo('body')[0].contentWindow;
        this.navigate(fragment);
      }

      // Depending on whether we're using pushState or hashes, and whether
      // 'onhashchange' is supported, determine how we check the URL state.
      if (this._hasPushState) {
        $(window).bind('popstate', this.checkUrl);
      } else if (this._wantsHashChange && ('onhashchange' in window) && !oldIE) {
        $(window).bind('hashchange', this.checkUrl);
      } else if (this._wantsHashChange) {
        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
      }

      // Determine if we need to change the base url, for a pushState link
      // opened by a non-pushState browser.
      this.fragment = fragment;
      var loc = window.location;
      var atRoot  = loc.pathname == this.options.root;

      // If we've started off with a route from a `pushState`-enabled browser,
      // but we're currently in a browser that doesn't support it...
      if (this._wantsHashChange && this._wantsPushState && !this._hasPushState && !atRoot) {
        this.fragment = this.getFragment(null, true);
        window.location.replace(this.options.root + '#' + this.fragment);
        // Return immediately as browser will do redirect to new url
        return true;

      // Or if we've started out with a hash-based route, but we're currently
      // in a browser where it could be `pushState`-based instead...
      } else if (this._wantsPushState && this._hasPushState && atRoot && loc.hash) {
        this.fragment = this.getHash().replace(routeStripper, '');
        window.history.replaceState({}, document.title, loc.protocol + '//' + loc.host + this.options.root + this.fragment);
      }

      if (!this.options.silent) {
        return this.loadUrl();
      }
    },

    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
    // but possibly useful for unit testing Routers.
    stop: function() {
      $(window).unbind('popstate', this.checkUrl).unbind('hashchange', this.checkUrl);
      clearInterval(this._checkUrlInterval);
      History.started = false;
    },

    // Add a route to be tested when the fragment changes. Routes added later
    // may override previous routes.
    route: function(route, callback) {
      this.handlers.unshift({route: route, callback: callback});
    },

    // Checks the current URL to see if it has changed, and if it has,
    // calls `loadUrl`, normalizing across the hidden iframe.
    checkUrl: function(e) {
      var current = this.getFragment();
      if (current == this.fragment && this.iframe) current = this.getFragment(this.getHash(this.iframe));
      if (current == this.fragment) return false;
      if (this.iframe) this.navigate(current);
      this.loadUrl() || this.loadUrl(this.getHash());
    },

    // Attempt to load the current URL fragment. If a route succeeds with a
    // match, returns `true`. If no defined routes matches the fragment,
    // returns `false`.
    loadUrl: function(fragmentOverride) {
      var fragment = this.fragment = this.getFragment(fragmentOverride);
      var matched = _.any(this.handlers, function(handler) {
        if (handler.route.test(fragment)) {
          handler.callback(fragment);
          return true;
        }
      });
      return matched;
    },

    // Save a fragment into the hash history, or replace the URL state if the
    // 'replace' option is passed. You are responsible for properly URL-encoding
    // the fragment in advance.
    //
    // The options object can contain `trigger: true` if you wish to have the
    // route callback be fired (not usually desirable), or `replace: true`, if
    // you wish to modify the current URL without adding an entry to the history.
    navigate: function(fragment, options) {
      if (!History.started) return false;
      if (!options || options === true) options = {trigger: options};
      var frag = (fragment || '').replace(routeStripper, '');
      if (this.fragment == frag) return;

      // If pushState is available, we use it to set the fragment as a real URL.
      if (this._hasPushState) {
        if (frag.indexOf(this.options.root) != 0) frag = this.options.root + frag;
        this.fragment = frag;
        window.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, frag);

      // If hash changes haven't been explicitly disabled, update the hash
      // fragment to store history.
      } else if (this._wantsHashChange) {
        this.fragment = frag;
        this._updateHash(window.location, frag, options.replace);
        if (this.iframe && (frag != this.getFragment(this.getHash(this.iframe)))) {
          // Opening and closing the iframe tricks IE7 and earlier to push a history entry on hash-tag change.
          // When replace is true, we don't want this.
          if(!options.replace) this.iframe.document.open().close();
          this._updateHash(this.iframe.location, frag, options.replace);
        }

      // If you've told us that you explicitly don't want fallback hashchange-
      // based history, then `navigate` becomes a page refresh.
      } else {
        window.location.assign(this.options.root + fragment);
      }
      if (options.trigger) this.loadUrl(fragment);
    },

    // Update the hash location, either replacing the current entry, or adding
    // a new one to the browser history.
    _updateHash: function(location, fragment, replace) {
      if (replace) {
        location.replace(location.toString().replace(/(javascript:|#).*$/, '') + '#' + fragment);
      } else {
        location.hash = fragment;
      }
    }
  });

  // Backbone.View
  // -------------

  // Creating a Backbone.View creates its initial element outside of the DOM,
  // if an existing element is not provided...
  var View = Backbone.View = function(options) {
    this.cid = _.uniqueId('view');
    this._configure(options || {});
    this._ensureElement();
    this.initialize.apply(this, arguments);
    this.delegateEvents();
  };

  // Cached regex to split keys for `delegate`.
  var delegateEventSplitter = /^(\S+)\s*(.*)$/;

  // List of view options to be merged as properties.
  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName'];

  // Set up all inheritable **Backbone.View** properties and methods.
  _.extend(View.prototype, Events, {

    // The default `tagName` of a View's element is `"div"`.
    tagName: 'div',

    // jQuery delegate for element lookup, scoped to DOM elements within the
    // current view. This should be prefered to global lookups where possible.
    $: function(selector) {
      return this.$el.find(selector);
    },

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // **render** is the core function that your view should override, in order
    // to populate its element (`this.el`), with the appropriate HTML. The
    // convention is for **render** to always return `this`.
    render: function() {
      return this;
    },

    // Remove this view from the DOM. Note that the view isn't present in the
    // DOM by default, so calling this method may be a no-op.
    remove: function() {
      this.$el.remove();
      return this;
    },

    // For small amounts of DOM Elements, where a full-blown template isn't
    // needed, use **make** to manufacture elements, one at a time.
    //
    //     var el = this.make('li', {'class': 'row'}, this.model.escape('title'));
    //
    make: function(tagName, attributes, content) {
      var el = document.createElement(tagName);
      if (attributes) $(el).attr(attributes);
      if (content) $(el).html(content);
      return el;
    },

    // Change the view's element (`this.el` property), including event
    // re-delegation.
    setElement: function(element, delegate) {
      if (this.$el) this.undelegateEvents();
      this.$el = (element instanceof $) ? element : $(element);
      this.el = this.$el[0];
      if (delegate !== false) this.delegateEvents();
      return this;
    },

    // Set callbacks, where `this.events` is a hash of
    //
    // *{"event selector": "callback"}*
    //
    //     {
    //       'mousedown .title':  'edit',
    //       'click .button':     'save'
    //       'click .open':       function(e) { ... }
    //     }
    //
    // pairs. Callbacks will be bound to the view, with `this` set properly.
    // Uses event delegation for efficiency.
    // Omitting the selector binds the event to `this.el`.
    // This only works for delegate-able events: not `focus`, `blur`, and
    // not `change`, `submit`, and `reset` in Internet Explorer.
    delegateEvents: function(events) {
      if (!(events || (events = getValue(this, 'events')))) return;
      this.undelegateEvents();
      for (var key in events) {
        var method = events[key];
        if (!_.isFunction(method)) method = this[events[key]];
        if (!method) throw new Error('Method "' + events[key] + '" does not exist');
        var match = key.match(delegateEventSplitter);
        var eventName = match[1], selector = match[2];
        method = _.bind(method, this);
        eventName += '.delegateEvents' + this.cid;
        if (selector === '') {
          this.$el.bind(eventName, method);
        } else {
          this.$el.delegate(selector, eventName, method);
        }
      }
    },

    // Clears all callbacks previously bound to the view with `delegateEvents`.
    // You usually don't need to use this, but may wish to if you have multiple
    // Backbone views attached to the same DOM element.
    undelegateEvents: function() {
      this.$el.unbind('.delegateEvents' + this.cid);
    },

    // Performs the initial configuration of a View with a set of options.
    // Keys with special meaning *(model, collection, id, className)*, are
    // attached directly to the view.
    _configure: function(options) {
      if (this.options) options = _.extend({}, this.options, options);
      for (var i = 0, l = viewOptions.length; i < l; i++) {
        var attr = viewOptions[i];
        if (options[attr]) this[attr] = options[attr];
      }
      this.options = options;
    },

    // Ensure that the View has a DOM element to render into.
    // If `this.el` is a string, pass it through `$()`, take the first
    // matching element, and re-assign it to `el`. Otherwise, create
    // an element from the `id`, `className` and `tagName` properties.
    _ensureElement: function() {
      if (!this.el) {
        var attrs = getValue(this, 'attributes') || {};
        if (this.id) attrs.id = this.id;
        if (this.className) attrs['class'] = this.className;
        this.setElement(this.make(this.tagName, attrs), false);
      } else {
        this.setElement(this.el, false);
      }
    }

  });

  // The self-propagating extend function that Backbone classes use.
  var extend = function (protoProps, classProps) {
    var child = inherits(this, protoProps, classProps);
    child.extend = this.extend;
    return child;
  };

  // Set up inheritance for the model, collection, and view.
  Model.extend = Collection.extend = Router.extend = View.extend = extend;

  // Backbone.sync
  // -------------

  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.
  var methodMap = {
    'create': 'POST',
    'update': 'PUT',
    'delete': 'DELETE',
    'read':   'GET'
  };

  // Override this function to change the manner in which Backbone persists
  // models to the server. You will be passed the type of request, and the
  // model in question. By default, makes a RESTful Ajax request
  // to the model's `url()`. Some possible customizations could be:
  //
  // * Use `setTimeout` to batch rapid-fire updates into a single request.
  // * Send up the models as XML instead of JSON.
  // * Persist models via WebSockets instead of Ajax.
  //
  // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
  // as `POST`, with a `_method` parameter containing the true HTTP method,
  // as well as all requests with the body as `application/x-www-form-urlencoded`
  // instead of `application/json` with the model in a param named `model`.
  // Useful when interfacing with server-side languages like **PHP** that make
  // it difficult to read the body of `PUT` requests.
  Backbone.sync = function(method, model, options) {
    var type = methodMap[method];

    // Default options, unless specified.
    options || (options = {});

    // Default JSON-request options.
    var params = {type: type, dataType: 'json'};

    // Ensure that we have a URL.
    if (!options.url) {
      params.url = getValue(model, 'url') || urlError();
    }

    // Ensure that we have the appropriate request data.
    if (!options.data && model && (method == 'create' || method == 'update')) {
      params.contentType = 'application/json';
      params.data = JSON.stringify(model.toJSON());
    }

    // For older servers, emulate JSON by encoding the request into an HTML-form.
    if (Backbone.emulateJSON) {
      params.contentType = 'application/x-www-form-urlencoded';
      params.data = params.data ? {model: params.data} : {};
    }

    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
    // And an `X-HTTP-Method-Override` header.
    if (Backbone.emulateHTTP) {
      if (type === 'PUT' || type === 'DELETE') {
        if (Backbone.emulateJSON) params.data._method = type;
        params.type = 'POST';
        params.beforeSend = function(xhr) {
          xhr.setRequestHeader('X-HTTP-Method-Override', type);
        };
      }
    }

    // Don't process data on a non-GET request.
    if (params.type !== 'GET' && !Backbone.emulateJSON) {
      params.processData = false;
    }

    // Make the request, allowing the user to override any Ajax options.
    return $.ajax(_.extend(params, options));
  };

  // Wrap an optional error callback with a fallback error event.
  Backbone.wrapError = function(onError, originalModel, options) {
    return function(model, resp) {
      resp = model === originalModel ? resp : model;
      if (onError) {
        onError(originalModel, resp, options);
      } else {
        originalModel.trigger('error', originalModel, resp, options);
      }
    };
  };

  // Helpers
  // -------

  // Shared empty constructor function to aid in prototype-chain creation.
  var ctor = function(){};

  // Helper function to correctly set up the prototype chain, for subclasses.
  // Similar to `goog.inherits`, but uses a hash of prototype properties and
  // class properties to be extended.
  var inherits = function(parent, protoProps, staticProps) {
    var child;

    // The constructor function for the new subclass is either defined by you
    // (the "constructor" property in your `extend` definition), or defaulted
    // by us to simply call the parent's constructor.
    if (protoProps && protoProps.hasOwnProperty('constructor')) {
      child = protoProps.constructor;
    } else {
      child = function(){ parent.apply(this, arguments); };
    }

    // Inherit class (static) properties from parent.
    _.extend(child, parent);

    // Set the prototype chain to inherit from `parent`, without calling
    // `parent`'s constructor function.
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();

    // Add prototype properties (instance properties) to the subclass,
    // if supplied.
    if (protoProps) _.extend(child.prototype, protoProps);

    // Add static properties to the constructor function, if supplied.
    if (staticProps) _.extend(child, staticProps);

    // Correctly set child's `prototype.constructor`.
    child.prototype.constructor = child;

    // Set a convenience property in case the parent's prototype is needed later.
    child.__super__ = parent.prototype;

    return child;
  };

  // Helper function to get a value from a Backbone object as a property
  // or as a function.
  var getValue = function(object, prop) {
    if (!(object && object[prop])) return null;
    return _.isFunction(object[prop]) ? object[prop]() : object[prop];
  };

  // Throw an error when a URL is needed, and none is supplied.
  var urlError = function() {
    throw new Error('A "url" property or function must be specified');
  };

}).call(this);

/*global setTimeout: false, console: false */
(function () {

    var async = {};

    // global on the server, window in the browser
    var root = this,
        previous_async = root.async;

    if (typeof module !== 'undefined' && module.exports) {
        module.exports = async;
    }
    else {
        root.async = async;
    }

    async.noConflict = function () {
        root.async = previous_async;
        return async;
    };

    //// cross-browser compatiblity functions ////

    var _forEach = function (arr, iterator) {
        if (arr.forEach) {
            return arr.forEach(iterator);
        }
        for (var i = 0; i < arr.length; i += 1) {
            iterator(arr[i], i, arr);
        }
    };

    var _map = function (arr, iterator) {
        if (arr.map) {
            return arr.map(iterator);
        }
        var results = [];
        _forEach(arr, function (x, i, a) {
            results.push(iterator(x, i, a));
        });
        return results;
    };

    var _reduce = function (arr, iterator, memo) {
        if (arr.reduce) {
            return arr.reduce(iterator, memo);
        }
        _forEach(arr, function (x, i, a) {
            memo = iterator(memo, x, i, a);
        });
        return memo;
    };

    var _keys = function (obj) {
        if (Object.keys) {
            return Object.keys(obj);
        }
        var keys = [];
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        return keys;
    };

    //// exported async module functions ////

    //// nextTick implementation with browser-compatible fallback ////
    if (typeof process === 'undefined' || !(process.nextTick)) {
        async.nextTick = function (fn) {
            setTimeout(fn, 0);
        };
    }
    else {
        async.nextTick = process.nextTick;
    }

    async.forEach = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        _forEach(arr, function (x) {
            iterator(x, function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed === arr.length) {
                        callback(null);
                    }
                }
            });
        });
    };

    async.forEachSeries = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        var iterate = function () {
            iterator(arr[completed], function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed === arr.length) {
                        callback(null);
                    }
                    else {
                        iterate();
                    }
                }
            });
        };
        iterate();
    };

    async.forEachLimit = function (arr, limit, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length || limit <= 0) {
            return callback();
        }
        var completed = 0;
        var started = 0;
        var running = 0;

        (function replenish () {
            if (completed === arr.length) {
                return callback();
            }

            while (running < limit && started < arr.length) {
                started += 1;
                running += 1;
                iterator(arr[started - 1], function (err) {
                    if (err) {
                        callback(err);
                        callback = function () {};
                    }
                    else {
                        completed += 1;
                        running -= 1;
                        if (completed === arr.length) {
                            callback();
                        }
                        else {
                            replenish();
                        }
                    }
                });
            }
        })();
    };


    var doParallel = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.forEach].concat(args));
        };
    };
    var doSeries = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.forEachSeries].concat(args));
        };
    };


    var _asyncMap = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (err, v) {
                results[x.index] = v;
                callback(err);
            });
        }, function (err) {
            callback(err, results);
        });
    };
    async.map = doParallel(_asyncMap);
    async.mapSeries = doSeries(_asyncMap);


    // reduce only has a series version, as doing reduce in parallel won't
    // work in many situations.
    async.reduce = function (arr, memo, iterator, callback) {
        async.forEachSeries(arr, function (x, callback) {
            iterator(memo, x, function (err, v) {
                memo = v;
                callback(err);
            });
        }, function (err) {
            callback(err, memo);
        });
    };
    // inject alias
    async.inject = async.reduce;
    // foldl alias
    async.foldl = async.reduce;

    async.reduceRight = function (arr, memo, iterator, callback) {
        var reversed = _map(arr, function (x) {
            return x;
        }).reverse();
        async.reduce(reversed, memo, iterator, callback);
    };
    // foldr alias
    async.foldr = async.reduceRight;

    var _filter = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.filter = doParallel(_filter);
    async.filterSeries = doSeries(_filter);
    // select alias
    async.select = async.filter;
    async.selectSeries = async.filterSeries;

    var _reject = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (!v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.reject = doParallel(_reject);
    async.rejectSeries = doSeries(_reject);

    var _detect = function (eachfn, arr, iterator, main_callback) {
        eachfn(arr, function (x, callback) {
            iterator(x, function (result) {
                if (result) {
                    main_callback(x);
                    main_callback = function () {};
                }
                else {
                    callback();
                }
            });
        }, function (err) {
            main_callback();
        });
    };
    async.detect = doParallel(_detect);
    async.detectSeries = doSeries(_detect);

    async.some = function (arr, iterator, main_callback) {
        async.forEach(arr, function (x, callback) {
            iterator(x, function (v) {
                if (v) {
                    main_callback(true);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(false);
        });
    };
    // any alias
    async.any = async.some;

    async.every = function (arr, iterator, main_callback) {
        async.forEach(arr, function (x, callback) {
            iterator(x, function (v) {
                if (!v) {
                    main_callback(false);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(true);
        });
    };
    // all alias
    async.all = async.every;

    async.sortBy = function (arr, iterator, callback) {
        async.map(arr, function (x, callback) {
            iterator(x, function (err, criteria) {
                if (err) {
                    callback(err);
                }
                else {
                    callback(null, {value: x, criteria: criteria});
                }
            });
        }, function (err, results) {
            if (err) {
                return callback(err);
            }
            else {
                var fn = function (left, right) {
                    var a = left.criteria, b = right.criteria;
                    return a < b ? -1 : a > b ? 1 : 0;
                };
                callback(null, _map(results.sort(fn), function (x) {
                    return x.value;
                }));
            }
        });
    };

    async.auto = function (tasks, callback) {
        callback = callback || function () {};
        var keys = _keys(tasks);
        if (!keys.length) {
            return callback(null);
        }

        var results = {};

        var listeners = [];
        var addListener = function (fn) {
            listeners.unshift(fn);
        };
        var removeListener = function (fn) {
            for (var i = 0; i < listeners.length; i += 1) {
                if (listeners[i] === fn) {
                    listeners.splice(i, 1);
                    return;
                }
            }
        };
        var taskComplete = function () {
            _forEach(listeners.slice(0), function (fn) {
                fn();
            });
        };

        addListener(function () {
            if (_keys(results).length === keys.length) {
                callback(null, results);
                callback = function () {};
            }
        });

        _forEach(keys, function (k) {
            var task = (tasks[k] instanceof Function) ? [tasks[k]]: tasks[k];
            var taskCallback = function (err) {
                if (err) {
                    callback(err);
                    // stop subsequent errors hitting callback multiple times
                    callback = function () {};
                }
                else {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    taskComplete();
                }
            };
            var requires = task.slice(0, Math.abs(task.length - 1)) || [];
            var ready = function () {
                return _reduce(requires, function (a, x) {
                    return (a && results.hasOwnProperty(x));
                }, true) && !results.hasOwnProperty(k);
            };
            if (ready()) {
                task[task.length - 1](taskCallback, results);
            }
            else {
                var listener = function () {
                    if (ready()) {
                        removeListener(listener);
                        task[task.length - 1](taskCallback, results);
                    }
                };
                addListener(listener);
            }
        });
    };

    async.waterfall = function (tasks, callback) {
        callback = callback || function () {};
        if (!tasks.length) {
            return callback();
        }
        var wrapIterator = function (iterator) {
            return function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    var args = Array.prototype.slice.call(arguments, 1);
                    var next = iterator.next();
                    if (next) {
                        args.push(wrapIterator(next));
                    }
                    else {
                        args.push(callback);
                    }
                    async.nextTick(function () {
                        iterator.apply(null, args);
                    });
                }
            };
        };
        wrapIterator(async.iterator(tasks))();
    };

    async.parallel = function (tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor === Array) {
            async.map(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            async.forEach(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.series = function (tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor === Array) {
            async.mapSeries(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            async.forEachSeries(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.iterator = function (tasks) {
        var makeCallback = function (index) {
            var fn = function () {
                if (tasks.length) {
                    tasks[index].apply(null, arguments);
                }
                return fn.next();
            };
            fn.next = function () {
                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
            };
            return fn;
        };
        return makeCallback(0);
    };

    async.apply = function (fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
            return fn.apply(
                null, args.concat(Array.prototype.slice.call(arguments))
            );
        };
    };

    var _concat = function (eachfn, arr, fn, callback) {
        var r = [];
        eachfn(arr, function (x, cb) {
            fn(x, function (err, y) {
                r = r.concat(y || []);
                cb(err);
            });
        }, function (err) {
            callback(err, r);
        });
    };
    async.concat = doParallel(_concat);
    async.concatSeries = doSeries(_concat);

    async.whilst = function (test, iterator, callback) {
        if (test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.whilst(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.until = function (test, iterator, callback) {
        if (!test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.until(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.queue = function (worker, concurrency) {
        var workers = 0;
        var q = {
            tasks: [],
            concurrency: concurrency,
            saturated: null,
            empty: null,
            drain: null,
            push: function (data, callback) {
                if(data.constructor !== Array) {
                    data = [data];
                }
                _forEach(data, function(task) {
                    q.tasks.push({
                        data: task,
                        callback: typeof callback === 'function' ? callback : null
                    });
                    if (q.saturated && q.tasks.length == concurrency) {
                        q.saturated();
                    }
                    async.nextTick(q.process);
                });
            },
            process: function () {
                if (workers < q.concurrency && q.tasks.length) {
                    var task = q.tasks.shift();
                    if(q.empty && q.tasks.length == 0) q.empty();
                    workers += 1;
                    worker(task.data, function () {
                        workers -= 1;
                        if (task.callback) {
                            task.callback.apply(task, arguments);
                        }
                        if(q.drain && q.tasks.length + workers == 0) q.drain();
                        q.process();
                    });
                }
            },
            length: function () {
                return q.tasks.length;
            },
            running: function () {
                return workers;
            }
        };
        return q;
    };

    var _console_fn = function (name) {
        return function (fn) {
            var args = Array.prototype.slice.call(arguments, 1);
            fn.apply(null, args.concat([function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (typeof console !== 'undefined') {
                    if (err) {
                        if (console.error) {
                            console.error(err);
                        }
                    }
                    else if (console[name]) {
                        _forEach(args, function (x) {
                            console[name](x);
                        });
                    }
                }
            }]));
        };
    };
    async.log = _console_fn('log');
    async.dir = _console_fn('dir');
    /*async.info = _console_fn('info');
    async.warn = _console_fn('warn');
    async.error = _console_fn('error');*/

    async.memoize = function (fn, hasher) {
        var memo = {};
        var queues = {};
        hasher = hasher || function (x) {
            return x;
        };
        var memoized = function () {
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            var key = hasher.apply(null, args);
            if (key in memo) {
                callback.apply(null, memo[key]);
            }
            else if (key in queues) {
                queues[key].push(callback);
            }
            else {
                queues[key] = [callback];
                fn.apply(null, args.concat([function () {
                    memo[key] = arguments;
                    var q = queues[key];
                    delete queues[key];
                    for (var i = 0, l = q.length; i < l; i++) {
                      q[i].apply(null, arguments);
                    }
                }]));
            }
        };
        memoized.unmemoized = fn;
        return memoized;
    };

    async.unmemoize = function (fn) {
      return function () {
        return (fn.unmemoized || fn).apply(null, arguments);
      };
    };

}());

(function ($) {
	
	var SEQ = {
			'konami': [ 38, 38, 40, 40, 37, 39, 37, 39, 66, 65 ]
		},
		CODES = {'backspace':8,'tab':9,'enter':13,'shift':16,'ctrl':17,'alt':18,'pause':19,'capslock':20,'escape':27,
			' ':32,'pageup':33,'pagedown':34,'end':35,'home':36,'left':37,'up':38,'right':39,'down':40,'insert':45,
			'delete':46,'0':48,'1':49,'2':50,'3':51,'4':52,'5':53,'6':54,'7':55,'8':56,'9':57,'a':65,'b':66,'c':67,
			'd':68,'e':69,'f':70,'g':71,'h':72,'i':73,'j':74,'k':75,'l':76,'m':77,'n':78,'o':79,'p':80,'q':81,'r':82,
			's':83,'t':84,'u':85,'v':86,'w':87,'x':88,'y':89,'z':90,'winleft':91,'winright':92,'select':93,'num0':96,
			'num1':97,'num2':98,'num3':99,'num4':100,'num5':101,'num6':102,'num7':103,'num8':104,'num9':105,
			'multi':106,'add':107,'sub':109,'dec':110,'div':111,'f1':112,'f2':113,'f3':114,'f4':115,'f5':116,'f6':117,
			'f7':118,'f8':119,'f9':120,'f10':121,'f11':122,'f12':123,'numlock':144,'scrolllock':145,'num,':186,'=':187,
			',':188,'-':189,'.':190,'/':191,'`':192,'{':219,'\\':220,'}':221,'\'':222};
	
	function code2array(code) {
		var arr = [],
			i,
			len;
		
		if (typeof code === 'string') {
			code = code.split('');
		}
		
		len = code.length;
		
		for (i=0; i < len; i += 1) {
			arr.push(CODES[code[i]]);
		}
		
		return arr;
	}
	
	$.fn.cheat = function(code, fn) {
		
		var seq = SEQ[code] || code2array(code),
			len = seq.length,
			matched = [];
			
		function onKeyDown(e) {
			var keyCode = e.keyCode;
			
			// Key Code is the expected one
			if (seq[matched.length] === keyCode) {
				
				matched.push(keyCode);
				
				// We have found what we are looking for
				if (len === matched.length) {
					matched = [];
					fn(code);
				}
			} else {
				matched = [];
			}
		}
		
		return this.bind('keydown', onKeyDown);
	};
}(jQuery));
/*jshint smarttabs:true white:true*/
/**
 * @module GLOBAL
 */
(function (root) {
	"use strict";
	
	// Node support
	if (typeof require !== 'undefined') {
		if (!root._) {
			root._ = require('./../../lib/underscore');
		}

		if (!root.Backbone) {
			root.Backbone = require('./../../lib/backbone');
		}

		if (!root.async) {
			root.async = require('./../../lib/async');
		}
	}
	
	var Backbone = root.Backbone,
		_ = root._,
		async = root.async,
		/**
		 * It's basically an instance of Backbone.Events with 
		 * two added methods that allows you to easily setup 
		 * init tasks that should be run when the namespace 
		 * is "started"
		 * 
		 * Uses async.parallel internally.
		 * See [https://github.com/caolan/async#parallel](https://github.com/caolan/async#parallel)
		 * 
		 * It can also be used as event emitter :P
		 * 
		 * @example
		 *	var ns = new Namespace();
		 *	
		 *	// Add an setup task
		 *	ns.ready(function () {
		 *		// All setup tasks has been called
		 *	});
		 *	
		 *	// Add async setup task
		 *	ns.setup(function (done) {
		 *		// Do some code stuff
		 *		setTimeout(done, 1000);
		 *	});
		 *	
		 *	// Add another async setup task
		 *	ns.setup(function (done) {
		 *		// Do some other code thing
		 *		done();
		 *	});
		 *	
		 *	// Run all setup "tasks"
		 *	ns.run(function () {
		 *		// All setup tasks has been called
		 *	});
		 * 
		 * @constructor
		 * @class Namespace
		 * @extends Backbone.Events
		 */
		Namespace = root.Namespace = function () {
			this._setups = [];
		};
	
	
	_.extend(Namespace.prototype, Backbone.Events, {
		
		
		/**
		 * Holds the state for if the namespace has been started or not
		 * 
		 * @private
		 * @property _isStarted
		 * @type Boolean
		 */
		_isStarted: false,
		
		
		/**
		 * Holds the state for if the namespace is ready or not
		 *
		 * @private
		 * @property _isReady
		 * @type Boolean
		 */
		_isReady: false,
		
		
		/**
		 * Add a setup function that will be run once when namespace is started
		 * 
		 * @method setup
		 * @param {Function} fn
		 * @chainable
		 */
		setup: function (fn) {
			if (this._isStarted) {
				throw new Error('Can not add setup function, namespace already started!');
			}
			this._setups.push(fn);
			return this;
		},
		
		
		/**
		 * Run all the setup functions and call the given 
		 * callback when done or an error occurs
		 * 
		 * @method run
		 * @param {Function} [fn]
		 * @chainable
		 */
		start: function (fn) {
			this.ready(fn);
			
			if (!this._isStarted) {
				// And now it's stated
				this._isStarted = true;
				
				// Run the setup tasks
				async.parallel(this._setups, _.bind(function () {
					// And so now it's ready
					this._isReady = true;
					
					// No need to keep all those functions around
					this._setups = [];
					
					/**
					 * Triggered when the all the setup function has been started
					 * @event ready
					 * @param {Namespace} ns
					 */
					this.trigger('ready', this);
					
					// Remove all ready event listeners
					this.unbind('ready');
				}, this));
			}
			
			return this;
		},
		
		
		/**
		 * Works as jQuery.ready so it should be familiar.
		 * If not: It calls the given function once the ready 
		 * event has triggered OR if it has already been triggered
		 *
		 * @method ready
		 * @param {Function} [fn]
		 * @chainable
		 */
		ready: function (fn) {
			if (this._isReady && fn) {
				_.defer(fn);
			} else if (fn) {
				this.bind('ready', fn);
			}
			return this;
		}
	});

	/**
	 * Module support
	 */
	if (typeof module !== 'undefined' && module.exports) {
		module.exports = Namespace;
	}
}(this));
/*jshint smarttabs:true white:true*/
/**
 * @module GLOBAL
 */
(function (root) {
	"use strict";
	
	
	/**
	 * Helps to ensure and convert values ta a certain type.	 * 
	 * 
	 * @example
	 *	var personSchema = new Schema({
	 *			name	: 'string',
	 *			alive	: 'boolean',
	 *			age		: 'number',
	 *			custom	: function (value) {
	 *				if (value === 'cat') {
	 *					return 1;
	 *				}
	 *				return 0;
	 *			}
	 *		}, {
	 *			age: 50  
	 *		});
	 *	
	 *	personSchema.marshal({
	 *		name	: 1,
	 *		alive	: "yes",
	 *		age		: "23",
	 *		custom	: 'owl'
	 *	});
	 *	
	 *	// Returns
	 *	{
	 *		"name": "1",
	 *		"alive": true,
	 *		"age": 50,
	 *		"custom": 0
	 *	}
	 * 
	 * @class Schema
	 * @constructor
	 * @param {Object} types An object with the name of a value and the type that value should have
	 * @param {Object} defaults An object with the name of a value and what default value it fails "casting"
	 */
	var Schema = root.Schema = function (types, defaults) {
			types = types || {};
			defaults = defaults || {};
			
			var map = {},
				key;
			
			for (key in types) {
				if (types.hasOwnProperty(key)) {
					map[key] = {
						type: types[key]
					};
					if (defaults.hasOwnProperty(key)) {
						map[key].def = defaults[key];
					}
				}
			}
			
			this._map = map;
		},
		isArray = Array.isArray || function (arr) {
			return Object.prototype.toString.call(arr) === '[object Array]';
		};
	
	
	/**
	 * Class methods and properties
	 */
	Schema.prototype = {
		
		/**
		 * 
		 * @method cast
		 * @param key
		 * @param value
		 * @param attrs
		 * @return {*}
		 */
		cast: function (key, value, attrs) {
			attrs = attrs || {};
			
			var originalValue = value,
				map,
				type,
				defaultValue;
			
			// Value is function call it
			if (typeof value === 'function') {
				value = value();
			}
			
			
			if (this._map.hasOwnProperty(key)) {
				map = this._map[key];
				type = map.type;
				
				// Built in cast method
				if (Schema.hasOwnProperty(type)) {
					value = Schema[type](value, type, attrs, this);
					
				// Custom check
				} else if (typeof type === 'function') {
					value = Schema.custom(value, type, attrs, this);
				
				// Blank is NULL
				} else if (Schema.isBlank(value)) {
					value = null;
				}
				
			}
			
			// Default
			if (Schema.isBlank(value) && map && map.hasOwnProperty('def')) {
				defaultValue = (typeof map.def === 'function') ? map.def() : map.def;
				if (defaultValue !== originalValue) {
					value = defaultValue;
				}
			}
			
			// Invalid
			if (value instanceof Error) {
				value.key = key;
			}
			
			return value;
		},
		
		
		/**
		 * Tank a hash of values and convert it using the rules 
		 * 
		 * @method marshal
		 * @param {Object} attrs
		 * @return {Object|Error}
		 */
		marshal: function (attrs) {
			var castedAttrs = {},
				key,
				value;
			
			for (key in attrs) {
				if (attrs.hasOwnProperty(key)) {
					value = this.cast(key, attrs[key], castedAttrs);
					
					// Invalid
					if (value instanceof Error) {
						return value;
					}
					
					// Set value
					castedAttrs[key] = value;
				}
			}
			
			return castedAttrs;
		},
		
		
		/**
		 * @method test
		 * @param attrs
		 * @return {Boolean}
		 */
		test: function (attrs) {
			return !(this.marshal(attrs) instanceof Error);
		}
	};
	
	
	/**
	 * Custom error
	 * 
	 * @static
	 * @property Invalid
	 * @type {Error}
	 */
	Schema.Invalid = function (type, value) {
		this.name = "SchemaInvalidType";
		this.message = 'Unable to set type "' + type + '"';
		this.type = type;
		this.value = value;
	};
	Schema.Invalid.prototype = Error.prototype;
	
	
	/**
	 * Test if a value is  null, undefined or an empty string.
	 * 
	 * @static
	 * @method isBlank
	 * @param value
	 * @return {Boolean}
	 */
	Schema.isBlank = function (value) {
		return value === null || typeof value === 'undefined' || value === '';
	};
	
	
	/**
	 * Convert/validate value is number
	 * 
	 * @static
	 * @method Schema.number
	 * @param value
	 * @return {Number|Error}
	 */
	Schema.number = function (value) {
		var num;
		
		// A "blank" value
		if (Schema.isBlank(value)) {
			return null;
		}
		
		if (typeof value === 'number' && !isNaN(value)) {
			return value;
		}
		
		num = parseFloat(value);
		
		if (typeof num === 'number' && !isNaN(num)) {
			return num;
		}
		
		// Return invalid
		return new Schema.Invalid('number', value);
	};
	
	
	/**
	 * Convert/validate value is string
	 * 
	 * @static
	 * @method Schema.string
	 * @param value
	 * @return {String|Error}
	 */
	Schema.string = function (value) {
		var str;
		
		// A "blank" value
		if (Schema.isBlank(value)) {
			return null;
		}
		
		if (typeof value === 'string') {
			return value;
		}
		
		if (typeof value.toString === 'function') {
			str = value.toString();
		}
		
		if (typeof str === 'string') {
			return str;
		}
		
		// Return invalid
		return new Schema.Invalid('string', value);
	};


	/**
	 * Convert/validate value is boolean
	 * 
	 * @static
	 * @method Schema.boolean
	 * @param value
	 * @return {Boolean|Error}
	 */
	Schema.bool = Schema.boolean = function (value) {
		var bool;
		
		// A "blank" value
		if (Schema.isBlank(value)) {
			return null;
		}
		
		if (typeof value === 'boolean') {
			return value;
		}
		
		if (value === 0 || value === '0' || (typeof value === 'string' && (value.toLowerCase() === 'false' || value.toLowerCase() === 'no'))) {
			bool = false;
		} else if (value === 1 || value === '1' || (typeof value === 'string' && (value.toLowerCase() === 'true' || value.toLowerCase() === 'yes' || value.toLowerCase() === 'ok'))) {
			bool = true;
		}
		
		if (typeof bool === 'boolean') {
			return bool;
		}
		
		// Return invalid
		return new Schema.Invalid('boolean', value);
	};
	
	
	/**
	 * Convert/validate value is date
	 *
	 * @static
	 * @method Schema.date
	 * @param value
	 * @return {Date|Error}
	 */
	Schema.date = function (value) {
		var date;
		
		// A "blank" value
		if (Schema.isBlank(value)) {
			return null;
		}
		
		// No need to go any futher
		if (Object.prototype.toString.call(value) === '[object Date]') {
			return value;
		}
		
		// Support for timestamps
		if (typeof value === 'number') {
			date = new Date(Number(value));
			
		// Support for date strings
		} else if (typeof value.toString === 'function') {
			date = new Date(value.toString());
		}
		
		// It's a valid date?
		if (Object.prototype.toString.call(date) === '[object Date]' && date.toString() !== 'Invalid Date') {
			return date;
		}
		
		// Return invalid
		return new Schema.Invalid('date', value);
	};


	/**
	 * Convert/validate value is array
	 *
	 * @static
	 * @method Schema.array
	 * @param value
	 * @return {Array|Error}
	 */
	Schema.array = function (value) {
		var arr;
		
		// A "blank" value
		if (Schema.isBlank(value)) {
			return null;
		}
		
		if (isArray(value)) {
			return value;
		}
		
		arr = Array.prototype.slice.call(value);
		
		if (isArray(arr)) {
			return arr;
		}
		
		// Return invalid
		return new Schema.Invalid('array', value);
	};


	/**
	 * Convert/validate value is array
	 *
	 * @static
	 * @method Schema.custom
	 * @param value
	 * @param fn
	 * @param attrs
	 * @param schema
	 */
	Schema.custom = function (value, fn, attrs, schema) {
		try {
			return fn(value, attrs, schema);
		} catch (err) {
			return err;
		}
	};
	
	
	/**
	 * Module support
	 */
	if (typeof module !== 'undefined' && module.exports) {
		module.exports = Schema;
	}
}(this));
/*jshint smarttabs:true white:true*/
/**
 * @module EASY
 */
(function (root) {
	"use strict";
	
	// Node support
	if (typeof require !== 'undefined') {
		if (!root._) {
			root._ = require('./../../lib/underscore');
		}
		
		if (!root.Backbone) {
			root.Backbone = require('./../../lib/backbone');
		}

		if (!root.async) {
			root.async = require('./../../lib/async');
		}

		if (!root.Schema) {
			root.Schema = require('./schema');
		}
		
		if (!root.Namespace) {
			root.Namespace = require('./namespace');
		}
	}
	
	var EASY,
		win = root.window || {},
		doc = root.document || {},
		$ = root.Zepto || root.jQuery || {},
		_ = root._,
		Backbone = root.Backbone,
		async = root.async,
		Schema = root.Schema,
		Namespace = root.Namespace,
		
		
		isIE = $.browser && !!$.browser.msie,
		
		LANG = (function () {
			var lang = win.location && win.location.pathname.match(/\/([a-z]{2})\//);
			return lang ? lang[1] : 'en';
		}()),
		
		BASE_URL = (function () {
			var location = win.location || {
					protocol: 'http:',
					host: 'localhost'
				},
				base  = location.protocol + '//' + location.host;
			
			if (location.port && location.port !== 80) {
				base += ':' + location.port;
			}
			
			base += '/' + LANG;
			
			return base;
		}()),
		
		STATIC = {
			/**
			 * @property win
			 * @type {window}
			 */
			win: win,
			
			
			/**
			 * @property doc
			 * @type {HTMLDocumentElement}
			 */
			doc: doc,
			
			
			/**
			 * @property $
			 * @type {jQuery}
			 */
			$: $,
			
			
			/**
			 * @property _
			 * @type {underscore}
			 */
			_: _,
			
			
			/**
			 * @property Backbone
			 * @type {Backbone}
			 */
			Backbone: Backbone,
			
			
			/**
			 * @property async
			 * @type {async}
			 */
			async: async,
			
			
			/**
			 * @property Schema
			 * @type {Schema}
			 */
			Schema: Schema,
			
			
			/**
			 *
			 * @method normalizeUrl
			 * @param {String} [url]
			 * @return {String}
			 */
			normalizeUrl: function (url) {
				return (url || '').replace(BASE_URL, '');
			},
			
			
			/**
			 * @method langUrl
			 * @param {String} [path]
			 * @param {Object} [params]
			 * @param {String} [hash]
			 * @return {String}
			 */
			langUrl: function (path, params, hash) {
				var lang = this.win.location.pathname.split('/')[1],
					url = '/' + lang;
				
				if (path) {
					url += '/' + (path[0] === '/' ? path.substr(1) : path);
				}
				
				if (params) {
					url += '?' + this.$.param(params);
				}
				
				if (hash) {
					url += '#' + hash;
				}
				
				return url;
			},
			
			
			/**
			 * Make an ajax request but use node callback style (err, res)
			 *
			 * @method request
			 * @param {Object} options
			 * @param {Function} fn
			 * @chainable
			 */
			request: function (options, fn) {
				options = options || {};
				
				if (_.isString(options)) {
					options = {
						url: options || ''
					};
				}
				
				_.defaults(options, {
					dataType: 'json'
				});
				
				options.success = function (resp) {
					fn(null, resp);
				};
				
				options.error = function (err) {
					fn(err);
				};
				
				$.ajax(options);
				
				return this;
			},
			
			
			/**
			 * Will log an arbitrary number arguments to the
			 * javascript console when it's supported.
			 *
			 * @method log
			 * @chainable
			 */
			log: function () {
				if (root.EASY_DEBUG && !isIE && root.console && root.console.log) {
					root.console.log.apply(root.console, arguments);
				}
				return this;
			}
		};
	
	
	
	/**
	 * Add some more logging methods
	 */
	_.forEach([ 'warn', 'dir', 'error', 'time', 'timeEnd', 'group', 'groupEnd' ], function (method) {
		STATIC.log[method] = function () {
			if (root.EASY_DEBUG && !isIE && root.console && root.console[method]) {
				root.console[method].apply(root.console, arguments);
			}
		};
	});
	
	
	
	/**
	 * Mixed in a once to that will ensure that the callback
	 * to an event is only called once
	 * 
	 * @method once
	 * @param {String} event
	 * @param {Function} fn
	 * @param {Object} [context]
	 * @chainable
	 */
	Backbone.Events.once =
		Backbone.View.prototype.once =
		Backbone.Model.prototype.once =
		Backbone.Collection.prototype.once =
		Backbone.Router.prototype.once = function once(event, fn, context) {
			var unbinder = _.bind(function () {
				this.unbind(event, unbinder);
				fn.apply(context || this, arguments);
			}, this);
			return this.bind(event, unbinder);
		};
	
	
	/**
	 * Proxy events from one event source to another
	 */
	Backbone.Events.proxyEvents =
		Backbone.View.prototype.proxyEvents =
		Backbone.Model.prototype.proxyEvents =
		Backbone.Collection.prototype.proxyEvents =
		Backbone.Router.prototype.proxyEvents = function proxy(source, prefix) {
			source.bind('all', function () {
				var args = _.toArray(arguments);
				args[0] = (prefix ? prefix + ':' : '') + args[0];
				args.push(source);
				this.trigger.apply(this, args);
			}, this);
			return this;
		};
	
	
	/**
	 * Underscore Mixins
	 */
	_.mixin({
		/**
		 * Helper function that does the something as _.after but it handles (err, res) node callback semantics 
		 * This could possibly be replace by using the async.parallel method instead
		 */
		afterWithoutErrors: function afterWithoutErrors(afterNum, afterFn, errorFn) {
			var count = 0;
			return function (err) {
				count += 1;
				if (err) {
					afterNum = -1;
					errorFn(err);
				} else if (count === afterNum) {
					afterFn();
				}
			};
		}
	});
	
	
	/**
	 * Base EASY application
	 * 
	 * @constructor
	 * @class EASY
	 * @extends Backbone.Router
	 */
	EASY = Backbone.Router.extend(_.extend({
		constructor: function () {
			
			this._namespaces = {};
			
			// Call parent constructor
			Backbone.Router.apply(this, arguments);
		},
		
		
		/**
		 * @method namespace
		 * @param {String} name
		 * @return {Namespace}
		 */
		namespace: function (name) {
			if (!_.has(this._namespaces, name)) {
				this._namespaces[name] = new Namespace();
			}
			return this._namespaces[name];
		},

		/**
		 * @method ns
		 * @param {String} name
		 * @return {Namespace}
		 */
		ns: function () {
			return this.namespace.apply(this, arguments);
		},
		
		
		/**
		 * Boolean check that if we can use the
		 * 
		 * @method hasPushState
		 * @return {Boolean}
		 */
		hasPushState: function () {
			return (this._pushStateHistory || (this.win.history && this.win.history.pushState));
		},
		
		
		/**
		 * Create a route only on the HTML5 History API enabled browsers
		 * 
		 * @method pushStateRoute
		 * @param {String|RegExp} route
		 * @param {String} name
		 * @param {Function} callback
		 * @chainable
		 */
		pushStateRoute: function (route, name, callback) {
			if (this.hasPushState()) {
				if (!this._pushStateHistory) {
					this._pushStateHistory = new this.Backbone.History();
					this._pushStateHistory.isPushState = true;
				}
				if (!_.isRegExp(route)) {
					route = this._routeToRegExp(route);
				}
				if (!callback) {
					callback = this[name];
				}
				
				this._pushStateHistory.route(route, _.bind(function (fragment) {
					var args = this._extractParameters(route, fragment);
					if (callback) {
						callback.apply(this, args);
					}
					this.trigger.apply(this, ['route:' + name].concat(args));
					this._pushStateHistory.trigger('route', this, name, args);
				}, this));
			}
			return this;
		},
		
		
		/**
		 * Navigate only on the HTML5 History API enabled browsers
		 * 
		 * @method pushStateNavigate
		 * @param {String} fragment
		 * @param {Object} [options]
		 * @chainable
		 */
		pushStateNavigate: function (fragment, options) {
			if (this.hasPushState()) {
				this._pushStateHistory.navigate(fragment, options);
			}
			return this;
		},
		
		
		/**
		 * Start the history "watcher"
		 * Will trigger the the 
		 * 
		 * @method start
		 * @chainable
		 */
		start: function () {
			if (!this._started) {
				// Ensure that the history is started
				if (!this.Backbone.history) {
					this.Backbone.history = new this.Backbone.History();
				}
				
				// Start watching the history
				this.Backbone.history.start();
				
				if (this.win.history && this.win.history.pushState && !this._pushStateHistory) {
					this._pushStateHistory = new this.Backbone.History();
					this._pushStateHistory.isPushState = true;
				}
				
				if (this._pushStateHistory) {
					this.Backbone.History.started = false;
					this._pushStateHistory.start({
						pushState	: true,
						root		: this.langUrl('/'),
						silent		: true
					});
				}
				// Set to started
				this._started = true;
				
				// Trigger the ready event
				this.trigger('ready', this);
			}
			return this;
		},
		
		
		/**
		 * Helper function that takes an call that will be called when 
		 * is ready or if it's ready call directly
		 * 
		 * @method ready
		 * @param {Function} fn
		 * @changeable
		 */
		ready: function (fn) {
			if (this._started) {
				fn(this);
			} else {
				this.once('ready', fn);
			}
			return this;
		}
	}, STATIC), STATIC);
	
	
	
	/**
	 * Module support
	 */
	if (typeof module !== 'undefined' && module.exports) {
		module.exports = EASY;
	} else {
		root.EASY = EASY;
	}
}(this));
/*jshint smarttabs:true*/
/**
 * @module EASY
 */
(function (root) {
	"use strict";
	
	// Node support
	if (typeof require !== 'undefined') {
		if (!root.EASY) {
			root.EASY = require('./easy');
		}
	}
	
	
	// Assign some useful local variables
	var EASY = root.EASY,
		win = EASY.win,
		doc = EASY.doc,
		$ = EASY.$,
		_ = EASY._,
		Backbone = EASY.Backbone,
		storage = (root.localStorage || {
			getItem: function () {},
			setItem: function () {}
		});
	
	
	/**
	 * Base collection class which all other collection extend from
	 *
	 * @namespace EASY
	 * @class View
	 * @extends Backbone.View
	 */
	EASY.View = Backbone.View.extend({
		/**
		 * @constructor
		 */
		constructor: function () {
			if (!this.name) {
				throw new Error('Views require a "name" property!');
			}
			
			var STATIC = this.constructor,
				render = this.render,
				destroy = this.destroy;
			
			
			this._useTemplate = !!(this.template || STATIC._template || STATIC.templateText || STATIC.templateSelector || STATIC.templateUrl);
			
			
			// Store sub views in an array
			this._views = [];
			
			
			/**
			 * Catch error events
			 */
			this.bind('error', function onError(view, err) {
				EASY.error('EASY.View::Error', this, arguments);
				if (err instanceof Error) {
					EASY.log(err.stack);
				}
			});
			
			
			/**
			 * Render
			 */
			this.render = function (options) {
				options = options || {};
				
				if (!this._useTemplate) {
					this._resetRendered();
				}
				
				// Call the class render function
				render.apply(this, arguments);
				
				if (!this._useTemplate && !options.silent) {
					/**
					 * If the use does not use any templates
					 * and it's not "silent" we end up here
					 * 
					 * @event render 
					 * @param {View} view
					 */
					this.trigger('render', this);
				}
				
				return this;
			};
			
			
			/**
			 * Destroy
			 */
			this.destroy = function (options) {
				options = options || {};
				
				// Detach
				this.detach();
				
				// Destroy all sub-views
				this.destroyViews();
				
				// Remove DOM element from the DOM and clear data and event handlers
				this.remove();
				
				// Call the class destroy function
				destroy.apply(this, arguments);
				
				// Trigger "destroy" event
				if (!options.silent) {
					/**
					 * After this has been triggered you should remove 
					 * any references to this view.
					 * If it's not "silent" we end up here
					 *
					 * @event destroy
					 * @param {View} view
					 */
					this.trigger('destroy', this);
				}
				
				// Unbind all listener on this view
				this.unbind();
				
				return this;
			};
			
			// Call parent constructor
			Backbone.View.apply(this, arguments);
			
			//
			// this._resetRendered();
		},
		
		
		/**
		 * Add all the stuff that need to destroyed, de-referenced 
		 * should be done in this function
		 * 
		 * @method destroy
		 * @chainable
		 */
		destroy: function () {
			return this;
		},
		
		
		/**
		 * Helper function that will reset the root element
		 * to a clean state, this is useful before render.
		 * 
		 * @method _resetRendered
		 * @private
		 */
		_resetRendered: function () {
			var attrs = {};
			
			if (this.attributes) {
				attrs = _.isFunction(this.attributes) ? this.attributes() : this.attributes;
			}
			attrs['class'] = (attrs['class'] ? attrs['class'] + ' ' : '') + this.name;
			
			if (this.className) {
				attrs['class'] += ' ' + this.className;
			}
			
			// Destroy all sub-views
			this.destroyViews();
			
			// Empty DOM element
			this.$el.empty();
			
			// Set attributes
			this.$el.attr(attrs);
		},
		
		
		/**
		 * Helper function to render the view's template
		 * 
		 * @method _renderTemplate
		 * @private
		 * @param {Function} template
		 * @param {Object} [context]
		 * @param {Object} [options]
		 * @private
		 */
		_renderTemplate: function (template, context, options) {
			this._resetRendered();
			
			this.el.innerHTML = template(context);
			
			// Trigger "render" event
			if (!options.silent) {
				/**
				 * Call r
				 * 
				 * @event render
				 * @param {View} view
				 */
				this.trigger('render', this);
			}
		},
		
		
		/**
		 * Instantiate a new view instance and keep a reference 
		 * to it so that we can destroy it appropriately 
		 * 
		 * @method createView
		 * @param {EASY.View} View
		 * @param {Object} [options] View options
		 * @param {String} [namespace] All events triggered on the created view will be re-triggered on this
		 * @chainable
		 */
		createView: function (View, options, namespace) {
			options = options || {};
			
			if (!options.container) {
				options.container = this.el;
			}
			
			var view = new View(options);
			
			this._views.push(view);
			
			// Proxy events
			if (namespace) {
				view.bind('all', function (ev) {
					var args = _.toArray(arguments);
					args[0] = namespace + ':' + ev;
					args.push(view);
					this.trigger.apply(this, args);
				}, this);
			}
			
			return view;
		},
		
		
		/**
		 * Helper function get a sub view by it's root element
		 * 
		 * @method getViewByElement
		 * @param {HTMLElement} element
		 * @return {EASY.View} If successful
		 */
		getViewByElement: function (element) {
			
			if (_.isString(element)) {
				element = this.$(element).get(0);
			} else if (element instanceof $) {
				element = element.get(0);
			}
			
			var len,
				view,
				i;
			
			for (i = 0, len = this._views.length; i < len; i += 1) {
				view = this._views[i];
				if (view.el === element) {
					return view;
				}
			}
		},
		
		
		/**
		 * Destroy a sub view
		 * 
		 * @method destroyView
		 * @param {EASY.View} view
		 * @chainable
		 */
		destroyView: function (view) {
			var i = _.indexOf(this._views, view);
			
			if (i !== -1) {
				this._views.splice(i, 1);
				view.destroy();
			}
			
			return this;
		},
		
		
		/**
		 * Destroy all sub views
		 * 
		 * @method destroyViews
		 * @chainable
		 */
		destroyViews: function () {
			_.forEach(this._views.slice(0), this.destroyView, this);
			if (this._views.length !== 0) {
				this.trigger('error', new Error('Unable to destroy all views'));
			}
			return this;
		},
		
		
		/**
		 * Get a sub-view by either it's root element or view instance
		 * 
		 * @method getView
		 * @param by
		 * @return {EASY.View} If successful
		 */
		getView: function (by) {
			// Instance
			if (by instanceof EASY.View) {
				return this._views[_.indexOf(this._views, by)];
				
			// Element
			} else if (((by instanceof $) ? (by = by.get(0)) : by) instanceof win.HTMLElement) {
				return _.find(this._views, function findByElement(view) {
					return view.el === by;
				});
			}
			
			return this._views[by];
		},
		
		
		/**
		 * @method getContainer
		 * @return {HTMLElement}
		 */
		getContainer: function () {
			return $(this.options.container || doc.body).get(0);
		},
		
		
		/**
		 * Return true if the model is attached to it's container
		 * NOTE: jQuery seems to do things to elements parentNode when calling #empty to 
		 * we can't just call this.el.parentNode to check it node has been attached
		 * 
		 * @method isAttached
		 * @return {Boolean}
		 */
		isAttached: function () {
			return this.el.parentNode === this.getContainer();
		},
		
		
		/**
		 * Attaches the view to it's specified container
		 * 
		 * @method attach
		 * @param {Object} [options]
		 * @chainable
		 */
		attach: function (options) {
			options = options || {};
			
			var container = this.getContainer();
			
			if (!container) {
				return this.trigger('error', this, new Error('No container to append to'));
			}
			
			// ONly attach if not already attached
			if (_.indexOf(_.toArray(container.childNodes), this.el) === -1) {
				if (options.empty) {
					$(container).empty();
				}
				
				if (options.prepend) {
					container.insertBefore(this.el, container.firstChild);
				} else {
					container.appendChild(this.el);
				}
				
				if (!options.silent) {
					/**
					 * Triggered when view has been attached to it's specified container
					 * 
					 * @event attach
					 * @param {EASY.View} view
					 */
					this.trigger('attach', this);
				}
			}
			return this;
		},
		
		
		/**
		 * Detaches the view for it's parentNode
		 * 
		 * 
		 * @method detach
		 * @param {Object} [options]
		 * @chainable
		 */
		detach: function (options) {
			options = options || {};
			if (this.isAttached()) {
				this.el.parentNode.removeChild(this.el);
				if (!options.silent) {
					/**
					 * Triggered when view has been detached for it's parentNode
					 * 
					 * @event detach
					 * @param {EASY.View} view
					 */
					this.trigger('detach', this);
				}
			}
			return this;
		},
		
		
		/**
		 * @method getTemplate
		 * @param {Function} fn
		 * @chainable
		 */
		getTemplate: function (fn) {
			var STATIC = this.constructor;
			
			if (this.template) {
				fn(null, this.template);
			} else if (STATIC.templateText || STATIC.templateSelector || STATIC.templateUrl) {
				STATIC.template(fn);
			}
			
			return this;
		},
		
		
		/**
		 * Context
		 * 
		 * @method context
		 * @return {Object}
		 */
		context: function (context) {
			
			// Argument context
			if (context) {
				context = _.clone(context);
				
			// Options context
			} else if (this.options.context) {
				context = _.clone(this.options.context);
			
			// Model
			} else if (this.model) {
				context = this.model.toJSON();
			
			// Collection
			} else if (this.collection) {
				context = {
					list: this.collection.toJSON()
				};
			}
			
			context = context || {};
			
			_.defaults(context || {}, {
				renderView: _.bind(function (View, options) {
					var view = new View(options),
						html;
					
					view.render();
					
					html = view.toHTML();
					
					view.destroy();
					
					return html;
				}, this)
			});
			
			return context;
		},
		
		
		/**
		 * Render
		 */
		render: function (options) {
			options = options || {};
			
			var context;
			
			if (_.isFunction(this.context)) {
				context = this.context(options.context);
			} else if (options.context) {
				context = options.context;
			} else {
				context = this.context || {};
			}
			
			this.getTemplate(_.bind(function (err, template) {
				if (err) {
					/**
					 * Triggered when fetching the template fails
					 * @event error
					 * @param {EASY.View} view
					 * @param {Error} err
					 */
					this.trigger('error', this, err);
				} else {
					this._renderTemplate(template, context, options);
				}
			}, this));
			
			return this;
		},
		
		
		/**
		 * To HTML
		 */
		toHTML: function () {
			if (this.el.outerHTML) {
				return this.el.outerHTML;
			}
			
			var tagHTML = [],
				tagName = this.el.tagName.toLowerCase(),
				len,
				attr,
				i;
			
			for (i = 0, len = this.el.attributes.length; i < len; i += 1) {
				attr = this.el.attributes[i];
				tagHTML.push(' ' + attr.name + '="' + attr.value + '"');
			}
			
			tagHTML.unshift('<' + tagName);
			tagHTML.push('>');
			tagHTML.push(this.el.innerHTML);
			tagHTML.push('</' + tagName + '>');
			
			return tagHTML.join('');
		}
	}, {
		
		
		/**
		 * @method templateHelpers
		 * @params {Object} [helpers]
		 * @return {Object}
		 */
		templateHelpers: function (helpers) {
			if (!this._templateHelpers) {
				this._templateHelpers = {};
			}
			if (helpers) {
				_.forEach(helpers, function (helper, key) {
					if (_.has(this._templateHelpers, key)) {
						throw new Error('Template helper with the name "' + key + '" already exists!');
					} else {
						this._templateHelpers[key] = helper;
					}
				}, this);
			}
			
			return this._templateHelpers;
		},
		
		/**
		 * @static
		 * @method templateEngine
		 * @param {String} text
		 */
		templateEngine: function (text) {
			var template = _.template(text),
				helpers = this.templateHelpers();
			
			return function (context) {
				context = context || {};
				
				context.helper = helpers;
				
				context.viewPlaceholder = context.helper.viewPlaceholder = function (name, options) {
					options = _.defaults(options || {}, {
						tagName: 'div',
						loader: true
					});
					
					var className = name + ' view-placeholder' + (options.className ? ' ' + options.className : ''),
						html = '<' + options.tagName + ' class="' + className + '">';
					
					if (options.loader) {
						html += '<div class="loader"></div>';
					}
					html += '</' + options.tagName + '>';
					
					return html;
				};
				
				return template(context);
			};
		},
		
		
		/**
		 * @static
		 * @method hasTemplate
		 * @return {Boolean}
		 */
		hasTemplate: function () {
			return !!this._template;
		},
		
		
		/**
		 * @static
		 * @method template
		 * @param {Function} [fn]
		 * @return {Boolean}
		 */
		template: function (fn) {
			
			var key;
			
			// Is fetching remote template, try again later
			if (this._fetchingTemplate) {
				_.delay(_.bind(function () {
					this.template(fn);
				}, this), 100);
				
			// Has compiled template
			} else if (this.hasTemplate()) {
				if (fn) {
					fn(null, this._template);
				}
				
			// Has raw template text, go an compile it
			} else if (this.templateText) {
				this._template = this.templateEngine(this.templateText);
				this.template(fn);
				
			// Template is on the page
			} else if (this.templateSelector) {
				this._template = this.templateEngine($(this.templateSelector).html());
				this.template(fn);
				
			// Remote template
			} else if (this.templateUrl) {
				key = (root.EASY_DEBUG || root.EASY_VERSION) + ':tpl:' + EASY.langUrl(this.templateUrl);
				this.templateCache = !root.EASY_DEBUG;
				
				// Template Text in storage
				if (this.templateCache && (this.templateText = storage.getItem(key)) !== null) {
					this.template(fn);
					
				// Fetch template text from from url
				} else {
					// Set state to fetching
					this._fetchingTemplate = true;
					
					// Go fetch the template
					$.ajax({
						url: APP.langUrl(this.templateUrl),
						dataType: 'text',
						context: this,
						success: function (res) {
							if (this.templateCache) {
								storage.setItem(key, res);
							}
							this._template = this.templateEngine(res);
							this.template(fn);
						},
						error: function () {
							if (fn) {
								fn(new Error('Unable to get template from: ' + this.templateUrl));
							}
						},
						complete: function () {
							delete this._fetchingTemplate;
						}
					});
				}
			
			// Name property
			} else if (this.prototype.name) {
				this.templateUrl = '/views/' + this.prototype.name + '.mu';
				this.template(fn);
				
			// Unable to get a any kind of template
			} else if (fn) {
				fn(new Error('This View does not seem to have any kind of template!'));
			}
			
			return this;
		}
	});
	
	
	/**
	 * Module support
	 */
	if (typeof module !== 'undefined' && module.exports) {
		module.exports = EASY;
	}
}(this));
/*jshint smarttabs:true white:true*/
/**
 * @module EASY
 */
(function (root) {
	"use strict";
	
	// Node support
	if (typeof require !== 'undefined') {
		if (!root.EASY) {
			root.EASY = require('./easy');
		}
	}
	
	// Assign some useful local variables
	var EASY = root.EASY,
		win = EASY.win,
		doc = EASY.doc,
		$ = EASY.$,
		_ = EASY._,
		Backbone = EASY.Backbone,
		Schema = EASY.Schema;
	
	
	/**
	 * Base model class which all other collection extend from
	 *
	 * @constructor 
	 * @namespace EASY
	 * @class Model
	 * @extends Backbone.Model
	 * @param {Object} attrs
	 * @param {Object} options
	 */
	EASY.Model = Backbone.Model.extend({
		constructor: function (attrs, options) {
			this.options = options || {};
			
			var initError = function (model, err) {
					if (!(err instanceof Error)) {
						err = new Error('Model constructor error');
					}
					EASY.log.warn('EASY.Model::initError', err);
					throw err;
				};
			
			
			/**
			 * If this model has defined a schema, ensure that
			 * it has an instance of a Schema class on it's 
			 * constructor. So that we only need one Schema instance 
			 * per Model class and not one per model instance.
			 * 
			 * @static
			 * @property schema
			 * @type {Schema}
			 */
			if (this.schema) {
				if (!(this.schema instanceof Schema)) {
					if (!(this.constructor.schema instanceof Schema)) {
						this.constructor.schema = new Schema(this.schema, this.defaults);
					}
					this.schema = this.constructor.schema;
				}
			}
			
			// On error bind init error
			this.bind('error', initError);
			
			// Call parent constructor
			Backbone.Model.apply(this, arguments);
			
			// Unbind init error
			this.unbind('error', initError);
			
			// Bind error
			this.bind('error', function () {
				EASY.log.warn('EASY.Model::Error', arguments);
			});
		},
		
		
		/**
		 * Extended the built in backbone model #set method 
		 * with that ability to marshal, for lack of a better word, values
		 * through the models schema instance.
		 * 
		 * See: [http://backbonejs.org/#Model-sert](http://backbonejs.org/#Model-set)
		 * 
		 * @example
		 * 
		 * ### Set a single attribute
		 *	model.set('foo', 'bar');
		 * 
		 * ### Set multiple attributes
		 *	model.set({
		 *		foo: 'bar'
		 *		baz: 'boz'
		 *	});
		 * 
		 * @method set
		 * @param {String|Object} key 
		 * @param  value
		 * @param {Object} [options]
		 * @chainable
		 */
		set: function (key, value, options) {
			
			var attrs,
				marshaledAttrs;
			
			if (_.isObject(key) || key === undefined) {
				attrs = key;
				options = value;
			} else {
				attrs = {};
				attrs[key] = value;
			}
			
			options = options || {};
			if (!attrs) {
				return this;
			}
			if (attrs instanceof Backbone.Model) {
				attrs = attrs.attributes;
			}
			
			// Normalize Keys
			if (this.normalizeKeys) {
				_.forEach(this.normalizeKeys, function (to, from) {
					if (attrs.hasOwnProperty(from)) {
						attrs[to] = attrs[from];
						delete attrs[from];
					}
				});
			}
			
			// Schema
			if (this.schema && !options.unset) {
				marshaledAttrs = this.schema.marshal(attrs);
				
				if (marshaledAttrs instanceof Error) {
					if (options.error) {
						options.error(this, marshaledAttrs, options);
					}
					
					/**
					 * Triggered when it was not possible to convert a
					 * value to the type specified
					 * 
					 * @event error
					 * @param {EASY.Model} model 
					 * @param {Error} err
					 * @param {Object} options
					 */
					this.trigger('error', this, marshaledAttrs, options);
					return this;
				}
				
				attrs = marshaledAttrs;
			}
			
			// Call parent
			return Backbone.Model.prototype.set.call(this, attrs, options);
		},
		
		
		/**
		 * Converts all model values into plain objects, useful for 
		 * template contexts and serialize state by then passing 
		 * it to JSON.stringify()
		 * 
		 * @method toJSON
		 * @return {Object}
		 */
		toJSON: function toJSONModel() {
			var attrs = Backbone.Model.prototype.toJSON.apply(this, arguments);
			_.forEach(attrs, function (attr, key) {
				if (attr && typeof attr.toJSON === 'function') {
					attrs[key] = attr.toJSON();
				}
			});
			return attrs;
		}
	}, {
		/**
		 * Just a reference to the Schema class
		 * 
		 * @static
		 * @property Schema
		 * @namespace EASY.Model
		 * @type Schema
		 */
		Schema: Schema
	});
	
	/**
	 * Module support
	 */
	if (typeof module !== 'undefined' && module.exports) {
		module.exports = EASY.Model;
	}
}(this));
/*jshint smarttabs:true white:true*/
/**
 * @module EASY 
 */
(function (root) {
	"use strict";
	
	// Node support
	if (typeof require !== 'undefined') {
		if (!root.EASY) {
			root.EASY = require('./easy');
		}
		
		if (!root.EASY.Model) {
			root.EASY.Model = require('./easy.model');
		}
	}
	
	
	// Assign some useful local variables
	var EASY = root.EASY,
		win = EASY.win,
		doc = EASY.doc,
		$ = EASY.$,
		_ = EASY._,
		Backbone = EASY.Backbone;
	
	
	/**
	 * Base collection class which all other collection extend from
	 * 
	 * @namespace EASY
	 * @class Collection
	 * @extends Backbone.Collection
	 */
	EASY.Collection = Backbone.Collection.extend({
		
		
		/**
		 * See: [http://backbonejs.org/#Collection-model](http://backbonejs.org/#Collection-model)
		 * 
		 * @property model
		 * @type EASY.Model
		 */
		model: EASY.Model,
		
		
		/**
		 * @constructor
		 * @method constructor
		 * @param {Array} [models]
		 * @param {Object} [options]
		 */
		constructor: function (models, options) {
			this.options = options || {};
			
			var initError = function (model, err) {
					if (!(err instanceof Error)) {
						err = new Error('Collection constructor error');
					}
					EASY.log.warn('EASY.Collection::initError', err);
					throw err;
				};
			
			this.bind('error', initError);
			
			Backbone.Collection.apply(this, arguments);
			
			this.unbind('error', initError);
		},
		
		
		/**
		 * Reverse the order of the collection
		 * 
		 * @method reverse
		 * @chainable
		 */
		reverse: function () {
			this.models.reverse();
			return this;
		},
		
		
		/**
		 * Get items by key value
		 *
		 * @method by
		 * @param {String} key
		 * @param value
		 * @chainable
		 */
		by: function (key, value) {
			var filter = {};
			filter[key] = value;
			return this.filterBy(filter);
		},
		
		
		/**
		 * Call #set on every model in the collection with given attrs
		 * 
		 * @method setAll
		 * @param {Object} attrs
		 * @param {Object} [options]
		 * @chainable
		 */
		setAll: function (attrs, options) {
			this.invoke('set', attrs, options);
			return this;
		},
		
		
		/**
		 * Call #unset on every model in the collection with given attrs
		 *
		 * @method unsetAll
		 * @param {Object} attrs
		 * @param {Object} [options]
		 * @chainable
		 */
		unsetAll: function (attrs, options) {
			this.invoke('unset', attrs, options);
			return this;
		},
		
		
		/**
		 * Update and remove model from the collection WITHOUT create new instances of the model like #fetch does
		 * 
		 * @method updateOrRemove
		 * @param {EASY.Collection} collection
		 * @param {Function|Object} [filterBy]
		 * @chainable
		 */
		updateOrRemove: function (collection, filterBy) {
			if (_.isArray(collection)) {
				collection = new this.constructor(collection);
			} else if (!(collection instanceof this.constructor)) {
				/**
				 * Triggers error in the given collection argument is not and array or an collection
				 * 
				 * @event error
				 * @param  {EASY.Collection} collection
				 * @param  {Error} err
				 */
				this.trigger('error', this, new Error('Argument "collection" needs to be an instanceof this.constructor'));
				return this;
			}
			
			// Find and update
			var fromCollection,
				remove;
			
			if (filterBy) {
				fromCollection = this.filterBy(filterBy);
			} else {
				fromCollection = this;
			}
			
			remove = fromCollection.filter(function (model) {
				var deltaModel = collection.get(model.id),
					attrs;
				
				if (deltaModel) {
					attrs = deltaModel.toJSON();
					model.set(attrs);
					collection.remove(deltaModel);
					return false;
				}
				
				return true;
			}, this);
			
			// Remove
			if (remove.length !== 0) {
				this.remove(remove);
			}
			
			// New
			if (collection.length !== 0) {
				this.add(collection.toJSON());
			}
			
			return this;
		},
		
		
		/**
		 * Helper function used by #filterBy & #getBy.
		 * Overwrite this to all for custom #filterBy & #getBy logic
		 * 
		 * @method filterByValidator
		 * @param {String} value
		 * @param key
		 * @param {EASY.Model} model
		 * @return {Boolean}
		 */
		filterByValidator: function (value, key, model) {
			var res;
			
			if (_.isFunction(model[key])) {
				res = model[key]();
			} else {
				res = model.get(key);
			}
			
			if (_.isFunction(value)) {
				return !!value(res, key, model);
			}
			return res === value;
		},
		
		
		/**
		 * Filter the collection by key value pairs or a custom function 
		 * 
		 * @method filterBy
		 * @param {Function|Object} filter
		 * @return {EASY.Collection} new instance of this
		 */
		filterBy: function (filter) {
			filter = filter || {};
			
			var models,
				collection;
			
			if (_.isFunction(filter)) {
				models = this.filter(filter);
				
			} else {
				models = this.filter(function (model) {
					var key, valid;
					for (key in filter) {
						if (filter.hasOwnProperty(key)) {
							if (!this.filterByValidator(filter[key], key, model)) {
								return false;
							}
						}
					}
					return true;
				}, this);
			}
			
			collection = new this.constructor(models, this.options);
			
			return collection;
		},
		
		
		/**
		 * Get a model from the collection by id or a custom function
		 * 
		 * See: [http://backbonejs.org/#Collection-get](http://backbonejs.org/#Collection-get)
		 * 
		 * @method get
		 * @param {Number|String|Function} id
		 * @return {EASY.Model}
		 */
		get: function (id) {
			var model = null;
			
			if (_.isFunction(id)) {
				return this.find(id);
			}
			
			return Backbone.Collection.prototype.get.apply(this, arguments);
		},
		
		
		/**
		 * Filter the collection by key value pairs or a custom function
		 * 
		 * @method getBy
		 * @param {Object|Function} filter
		 * @return {EASY.Model}
		 */
		getBy: function (filter) {
			filter = filter || {};
			return this.find(function (model) {
				var key, valid;
				for (key in filter) {
					if (filter.hasOwnProperty(key)) {
						if (!this.filterByValidator(filter[key], key, model)) {
							return false;
						}
					}
				}
				return true;
			}, this);
		},
		
		
		/**
		 * Helper function used by #createOrderByIterator
		 * Overwrite this to all for custom #createOrderByIterator logic
		 * 
		 * @method createOrderByIterator
		 * @param {String}  key
		 * @return {Function}
		 */
		createOrderByIterator: function (key) {
			return function (model) {
				return model.get(key);
			};
		},
		
		
		/**
		 * Sort collection by given args
		 * 
		 * @method orderBy
		 * @params {String} args* Name of the attribute to sort on 
		 * @return {EASY.Collection} new instance of this
		 */
		orderBy: function () {
			var args = _.toArray(arguments),
				arg = args.shift(),
				orderByIterator = this.createOrderByIterator(arg),
				sorted = this.sortBy(orderByIterator),
				len = args.length,
				i,
				collection = new this.constructor();
			
			// Ensure the this colcetino won't be "auto" sorted
			collection.comparator = null;
			
			for (i = 0; i < len; i += 1) {
				arg = args[i];
				orderByIterator = this.createOrderByIterator(arg);
				sorted = _.sortBy(sorted, orderByIterator);
			}
			
			collection.add(sorted);
			
			return collection;
		},
		
		
		/**
		 * Just as #pluck put accepts multiple args 
		 *
		 * @method pluckMulti
		 * @params {String} args* Name of the attribute to pluck
		 * @return {Array}
		 */
		pluckMulti: function () {
			var args = _.toArray(arguments);
			return this.map(function (model) {
				var plucked = {};
				_.forEach(args, function (arg) {
					plucked[arg] = model.get(arg);
				});
				return plucked;
			});
		},
		
		
		/**
		 * Get models by an array of model id's
		 * 
		 * @method getMulti
		 * @param {Array} ids
		 * @return {EASY.Collection} new instance of this
		 */
		getMulti: function (ids) {
			var models = [],
				collection;
			
			_.forEach(ids || [], function (id) {
				var model = this.get(id);
				
				if (model) {
					models.push(models);
				}
			}, this);
			
			collection = new this.constructor(models);
			
			return collection;
		},
		
		
		/**
		 * See: [http://backbonejs.org/#Collection-fetch](http://backbonejs.org/#Collection-fetch)
		 * 
		 * Byt with the added the option "updateOrRemove" that 
		 * will update existing model instances instead of replacing
		 * 
		 * 
		 * 
		 * 
		 * @method fetch
		 * @param {Object} [options]
		 * @return {*}
		 */
		fetch: function (options) {
			options = options ? _.clone(options) : {};
			if (options.parse === undefined) {
				options.parse = true;
			}
			var collection = this,
				success = options.success;
			
			
			options.success = function (resp, status, xhr) {
				if (options.updateOrRemove) {
					collection.updateOrRemove(collection.parse(resp, xhr), options.filterBy);
				} else {
					collection[options.add ? 'add' : 'reset'](collection.parse(resp, xhr), options);
				}
				if (success) {					
					success(collection, resp);
				}
			};
			
			options.error = Backbone.wrapError(options.error, collection, options);
			
			return (this.sync || Backbone.sync).call(this, 'read', this, options);
		}
	});
	
	
	/**
	 * Module support
	 */
	if (typeof module !== 'undefined' && module.exports) {
		module.exports = EASY.Collection;
	}
}(this));


/*jshint smarttabs:true*/
/**
 * @module EASY
 */
(function (root) {
	"use strict";

	// Node support
	if (typeof require !== 'undefined') {
		if (!root.EASY) {
			root.EASY = require('./easy');
		}

		if (!root.EASY.Model) {
			root.EASY.Model = require('./easy.model');
		}
	}
	
	
	
	var EASY = root.EASY;

	/**
	 * Session model
	 *
	 * @namespace EASY
	 * @class Session
	 * @extends EASY.Model
	 */
	EASY.Session = EASY.Model.extend({
		initialize: function () {
			this.fetch();
		},
		
		fetch: function () {
			
		},
		
		save: function () {

		}
	});



	/**
	 * Module support
	 */
	if (typeof module !== 'undefined' && module.exports) {
		module.exports = EASY.Session;
	}
}(this));
/*jshint smarttabs:true white:true*/
/**
 * @module EASY
 */
(function (win) {
	"use strict";
	
	if (!win.EASY && (typeof require !== 'undefined')) {
		win.EASY = require('../easy/easy');
	}
	
	var EASY = win.EASY,
		_ = EASY._;
	
	
	/**
	 * Create beautiful buttons
	 *
	 * @namespace EASY.View
	 * @class Button
	 * @extends EASY.View
	 */
    EASY.View.Button = EASY.View.extend({
		name: 'button-view',
		tagName: 'a',
		events: {
			'click': function (e) {
				var isDisabled = !!this.$el.attr('disabled');
				
				if (!this.el.target || isDisabled) {
					e.preventDefault();
				}
				
				if (this.options.sound) {
					if (isDisabled) {
						this.sound('click:disabled');
					} else {
						this.sound('click:button');
					}
				}
				
				if (!isDisabled) {
					this.trigger('click', this, e);
				}
			},
			'mouseenter': function () {
				this.sound('hover');
			}
		},
		destroy: function destroyButtonView() {
			
		},
		text: function (text, options) {
            this.$('span').text(text);
			if (options && !options.silent) {
				this.trigger('text', this, text);
			}
			return this;
		},
		disable: function disableButtonView(options) {
			this.$el.addClass('disabled');
			this.$el.attr('disabled', 'disabled');
			if (options && !options.silent) {
				this.trigger('disable', this);
			}
			return this;
		},
		enable: function enableButtonView(options) {
			this.$el.removeClass('disabled');
			this.$el.removeAttr('disabled');
			if (options && !options.silent) {
				this.trigger('enable', this);
			}
			return this;
		},
		render: function renderButtonView() {
            this.el.appendChild(this.make('span', null, this.options.text));
            
            // Auto set properties
            if (!_.has(this.options, 'primary')) {
                this.options.primary = this.options.text && this.options.glyph;
            }
            if (!_.has(this.options, 'icon')) {
                this.options.icon = !this.options.text && this.options.glyph;
            }
            
            
			if (this.options.attrs) {
				this.$el.attr(this.options.attrs);
			}
			if (this.options.className) {
				this.$el.addClass(this.options.className);
			}
            if (this.options.primary) {
                this.$el.addClass('button-view-primary');
            }
            if (this.options.large) {
                this.$el.addClass('button-view-large');
            }
            if (this.options.icon) {
                this.$el.addClass('button-view-icon');
            }
					
            if (this.options.glyph) {
                this.el.appendChild(this.make('i', {'class': 'glyphs glyphs-' + this.options.glyph}));
            }
		}
	});
}(this));
/*jshint smarttabs:true white:true*/
/**
 * @module GLOBAL
 */
(function (root) {
	"use strict";
	
	var part1 = '({\\s*(\\-?\\d+[\\s*,\\s*\\-?\\d+]*)\\s*})',
		part2 = '([\\[\\]])\\s*(\\-Inf|\\-?\\d+)\\s*,\\s*(\\+?Inf|\\-?\\d+)\\s*([\\[\\]])',
		full = part1 + '|' + part2,
		intervalRegexp = new RegExp('^(' + full + ')\\s+(.+?)$'),
		standardRegexp = new RegExp('^\\w+\\: +(.+)$'),
		validRegexp = new RegExp('^' + full + '$'),
		pluralRules = {};


	/**
	 * Pluarlization rules for the following locales: af, az, bn, bg, ca, da, de, el, en, eo, es, et, eu, fa, fi, fo, 
	 * fur, fy, gl, gu, ha, he, hu, is, it, ku, lb, ml, mn, mrv, nah, nb, ne, nl, nn, no, om, or, pa, pap, ps, pt, so, 
	 * sq, sv, sw, ta, te, tk, ur, zu
	 *
	 * @static
	 * @method af, az, bn, bg, ca, da, de, el, en, eo, es, et, eu, fa, fi, fo, fur, fy, gl, gu, ha, he, hu, is, it, 
	 * ku, lb, ml, mn, mrv, nah, nb, ne, nl, nn, no, om, or, pa, pap, ps, pt, so, sq, sv, sw, ta, te, tk, ur, zu
	 * @param {Number} number
	 * @return {Number}
	 */
	pluralRules.af = pluralRules.az = pluralRules.bn = pluralRules.bg = pluralRules.ca = pluralRules.da =
		pluralRules.de = pluralRules.el = pluralRules.en = pluralRules.eo = pluralRules.es = pluralRules.et =
		pluralRules.eu = pluralRules.fa = pluralRules.fi = pluralRules.fo = pluralRules.fur = pluralRules.fy =
		pluralRules.gl = pluralRules.gu = pluralRules.ha = pluralRules.he = pluralRules.hu = pluralRules.is =
		pluralRules.it = pluralRules.ku = pluralRules.lb = pluralRules.ml = pluralRules.mn = pluralRules.mrv =
		pluralRules.nah = pluralRules.nb = pluralRules.ne = pluralRules.nl = pluralRules.nn = pluralRules.no =
		pluralRules.om = pluralRules.or = pluralRules.pa = pluralRules.pap = pluralRules.ps = pluralRules.pt =
		pluralRules.so = pluralRules.sq = pluralRules.sv = pluralRules.sw = pluralRules.ta = pluralRules.te =
		pluralRules.tk = pluralRules.ur = pluralRules.zu = function (number) {
			return (number === 1) ? 0 : 1;
		};
	
	
	/**
	 * Pluarlization rules for the following locales: am, bh, fil, fr, gun, hi, ln, mg, nso, xbr, ti, wa
	 *
	 * @static
	 * @method am, bh, fil, fr, gun, hi, ln, mg, nso, xbr, ti, wa
	 * @param {Number} number
	 * @return {Number}
	 */
	pluralRules.am = pluralRules.bh = pluralRules.fil = pluralRules.fr = pluralRules.gun = pluralRules.hi =
		pluralRules.ln = pluralRules.mg = pluralRules.nso = pluralRules.xbr = pluralRules.ti = pluralRules.wa = function (number) {
			return ((number === 0) || (number === 1)) ? 0 : 1;
		};
	
	
	/**
	 * Pluarlization rules for the following locales: be, bs, hr, ru, sr, uk
	 *
	 * @static
	 * @method be, bs, hr, ru, sr, uk
	 * @param {Number} number
	 * @return {Number}
	 */
	pluralRules.be = pluralRules.bs = pluralRules.hr = pluralRules.ru = pluralRules.sr = pluralRules.uk = function (number) {
		return ((number % 10 === 1) && (number % 100 !== 11)) ? 0 : (((number % 10 >= 2) && (number % 10 <= 4) && ((number % 100 < 10) || (number % 100 >= 20))) ? 1 : 2);
	};
	

	/**
	 * Pluarlization rules for the following locales: sk, cs
	 *
	 * @static
	 * @method sk, cs
	 * @param {Number} number
	 * @return {Number}
	 */
	pluralRules.cs = pluralRules.sk = function (number) {
		return ((number % 10 === 1) && (number % 100 !== 11)) ? 0 : (((number % 10 >= 2) && (number % 10 <= 4) && ((number % 100 < 10) || (number % 100 >= 20))) ? 1 : 2);
	};
	
	
	/**
	 * Pluarlization rules for the following locales: ga
	 *
	 * @static
	 * @method lt
	 * @param {Number} number
	 * @return {Number}
	 */
	pluralRules.ga = function (number) {
		return (number === 1) ? 0 : ((number === 2) ? 1 : 2);
	};
	
	
	/**
	 * Pluarlization rules for the following locales: lt
	 *
	 * @static
	 * @method lt
	 * @param {Number} number
	 * @return {Number}
	 */
	pluralRules.lt = function (number) {
		return ((number % 10 === 1) && (number % 100 !== 11)) ? 0 : (((number % 10 >= 2) && ((number % 100 < 10) || (number % 100 >= 20))) ? 1 : 2);
	};
	
	
	/**
	 * Pluarlization rules for the following locales: sl
	 *
	 * @static
	 * @method sl
	 * @param {Number} number
	 * @return {Number}
	 */
	pluralRules.sl = function (number) {
		return (number % 100 === 1) ? 0 : ((number % 100 === 2) ? 1 : (((number % 100 === 3) || (number % 100 === 4)) ? 2 : 3));
	};
	
	
	/**
	 * Pluarlization rules for the following locales: mk
	 *
	 * @static
	 * @method mk
	 * @param {Number} number
	 * @return {Number}
	 */
	pluralRules.mk = function (number) {
		return (number % 10 === 1) ? 0 : 1;
	};
	
	
	/**
	 * Pluarlization rules for the following locales: mt
	 *
	 * @static
	 * @method mt
	 * @param {Number} number
	 * @return {Number}
	 */
	pluralRules.mt = function (number) {
		return (number === 1) ? 0 : (((number === 0) || ((number % 100 > 1) && (number % 100 < 11))) ? 1 : (((number % 100 > 10) && (number % 100 < 20)) ? 2 : 3));
	};
	
	
	/**
	 * Pluarlization rules for the following locales: lv
	 *
	 * @static
	 * @method lv
	 * @param {Number} number
	 * @return {Number}
	 */
	pluralRules.lv = function (number) {
		return (number === 0) ? 0 : (((number % 10 === 1) && (number % 100 !== 11)) ? 1 : 2);
	};
	
	
	/**
	 * Pluarlization rules for the following locales: pl
	 *
	 * @static
	 * @method pl
	 * @param {Number} number
	 * @return {Number}
	 */
	pluralRules.pl = function (number) {
		return (number === 1) ? 0 : (((number % 10 >= 2) && (number % 10 <= 4) && ((number % 100 < 12) || (number % 100 > 14))) ? 1 : 2);
	};
	
	
	/**
	 * Pluarlization rules for the following locales: cy
	 *
	 * @static
	 * @method be
	 * @param {Number} number
	 * @return {Number}
	 */
	pluralRules.cy = function (number) {
		return (number === 1) ? 0 : ((number === 2) ? 1 : (((number === 8) || (number === 11)) ? 2 : 3));
	};
	
	
	/**
	 * Pluarlization rules for the following locales: ro
	 *
	 * @static
	 * @method be
	 * @param {Number} number
	 * @return {Number}
	 */
	pluralRules.ro = function (number) {
		return (number === 1) ? 0 : (((number === 0) || ((number % 100 > 0) && (number % 100 < 20))) ? 1 : 2);
	};
	
	
	/**
	 * Pluarlization rules for the following locales: ar ()
	 *
	 * @static
	 * @method be
	 * @param {Number} number
	 * @return {Number}
	 */
	pluralRules.ar = function (number) {
		return (number === 0) ? 0 : ((number === 1) ? 1 : ((number === 2) ? 2 : (((number >= 3) && (number <= 10)) ? 3 : (((number >= 11) && (number <= 99)) ? 4 : 5))));
	};
	
	
	/**
	 * Take a number and return an index to which rule to use  
	 *
	 * @private
	 * @static
	 * @method pluralization
	 * @param {Number} number
	 * @param {String} locale
	 * @return {Number}
	 */
	function pluralization(number, locale) {
		if (pluralRules.hasOwnProperty(locale)) {
			return pluralRules[locale](number);
		}
		return 0;
	}
	
	
	/**
	 * Pluarlization rules for the following locales:
	 *
	 *
	 * @private
	 * @static
	 * @method convertNumber
	 * @type {Function}
	 */
	function convertNumber(number) {
		if ('-Inf' === number) {
            return Number.NEGATIVE_INFINITY;
        } else if ('+Inf' === number || 'Inf' === number) {
            return Number.POSITIVE_INFINITY;
        }
        return parseInt(number, 10);
	}
	
	function isInterval(number, interval) {
		
		interval = interval.trim();
		
		var matches = validRegexp.exec(interval),
			leftNumber,
			rightNumber,
			numbers,
			len,
			i;
		
		if (!matches) {
			throw new Error('"' + interval + '" is not a valid interval.');
		}
		
		// Braces
		if (matches[2]) {
			numbers = matches[2].split(',');
			for (i = 0, len = numbers.length; i < len; i += 1) {
				if (number === parseInt(numbers[i], 10)) {
					return true;
				}
			}
		
		// Square
		} else {
			leftNumber = convertNumber(matches[4]);
			rightNumber = convertNumber(matches[5]);
			
			return (('[' === matches[3] ? number >= leftNumber : number > leftNumber) && (']' === matches[6] ? number <= rightNumber : number < rightNumber));	
		}
		
		return false;
    }


	/**
	 * Pluarlization rules for the following locales:
	 *
	 *
	 * @private
	 * @static
	 * @method choose
	 * @type {Function}
	 */
	function choose(message, number, locale) {
		
		locale = locale || 'en';
		
		var parts = message.split('|'),
			part,
			intervalRules = [],
			standardRules = [],
			interval,
			len,
			i,
			matches,
			position;
		
		for (i = 0, len = parts.length; i < len; i += 1) {
			part = parts[i];
			
			// Explicit
			matches = intervalRegexp.exec(part);
			if (matches) {
				intervalRules.push([
					matches[1],
					matches[8]
				]);
				continue;
			}
			
			// Standard
			matches = standardRegexp.exec(part);
			if (matches) {
				standardRules.push(matches[1]);
				continue;
			}
			
			// Fallback
			standardRules.push(part);
		}
		
		// Try to match an interval rule, then fallback to the standard ones
		for (i = 0, len = intervalRules.length; i < len; i += 1) {
			interval = intervalRules[i];
			if (isInterval(number, interval[0])) {
				return interval[1];
			}
		}
		
		position = pluralization(number, locale);
		if (standardRules[position]) {
			return standardRules[position];
		} else {
			throw new Error('Unable to choose a translation. (' + message + ')');
		}
	}
	
	
	/**
	 * Replace 
	 *
	 * @private
	 * @static
	 * @method stringReplace
	 * @param {String} str
	 * @param {Object} params
	 * @return {String}
	 */
	function stringReplace(str, params) {
		params = params || {};
		
		var key,
			value;
		
		for (key in params) {
			if (params.hasOwnProperty(key)) {
				value = params[key];
				str = str.replace(key, value);
			}
		}
		
		return str;
	}
	
	
	/**
	 * A JavaScript port of symfonys
	 * 
	 * 
	 * @example
	 *	var i18n = new Sidis('en', {
	 *		'HELLO'	: 'Hello {name}!', // Basic
	 *		'AGE'	 '{age} year| {age} year' // Pluarlization
	 *	}):
	 *	
	 *	// Simple key fetch and string replace
	 *	i18n.trans('HELLO', {
	 *	   '{name}': 'God' 
	 *	}); // Return: Hello God!
	 *	
	 *	// Pluarlization
	 *	i18n.transChoice('AGE', 1, {
	 *	   '{age}': 1
	 *	}); // Return: 1 year
	 *	
	 *	// Pluarlization
	 *	i18n.transChoice('AGE', 10, {
	 *	   '{age}': 10
	 *	}); // Return: 10 years
	 * 
	 * @constructor
	 * @class Sidis
	 * @param {String} locale
	 * @param {Object} messages
	 */
	function Sidis(locale, messages) {
		/**
		 * @property _locale
		 * @type {String}
		 */
		this._locale = locale;
		
		
		/**
		 * @property _messages
		 * @type {Object}
		 */
		this._messages = messages;
	}
	
	
	
	Sidis.prototype = {
		/**
		 * Gets the messages within a given domain.
		 *
		 * If domain is null, it returns all messages.
		 *
		 * @private
		 * @param {String} domain The domain name
		 * @return {Array} An array of messages
		 */
		_all: function _all(domain) {
			domain = domain || 'messages';
			return this._messages;
		},
		
		
		/**
		 * Checks if a message has a translation.
		 * 
		 * @private
		 * @param {String} id     The message id
		 * @param {String} domain The domain name
		 * @return {Boolean} true if the message has a translation, false otherwise
		 */
		_has: function _get(id, domain) {
			domain = domain || 'messages';
			return this._messages.hasOwnProperty(id);
		},
		
		
		/**
		 * Gets a message translation.
		 *
		 * @private
		 * @param {String} $id     The message id
		 * @param {String} $domain The domain name
		 * @return {String} The message translation
		 */
		_get: function _get(id, domain) {
			domain = domain || 'messages';
			return this._messages[id];
		},
		
		
		/**
		 * Sets a message translation.
		 *
		 * @private
		 * @chainable
		 * @param {String} id          The message id
		 * @param {String} translation The messages translation
		 * @param {String} domain      The domain name
		 */
		_set: function _set(id, translation, domain) {
			domain = domain || 'messages';
			this._messages[id] = translation;
			return this;
		},
		
		
		/**
		 * Sets translations for a given domain.
		 *
		 * @private
		 * @chainable
		 * @param {String} messages An array of translations
		 * @param {String} domain   The domain name
		 */
		_replace: function _add(messages, domain) {
			domain = domain || 'messages';
			this._messages = messages;
			return this;
		},
		
		
		/**
		 * Adds translations for a given domain.
		 *
		 * @private
		 * @chainable
		 * @param {String} messages An array of translations
		 * @param {String} sdomain   The domain name
		 */
		_add: function _add(messages, domain) {
			domain = domain || 'messages';
			return this;
		},
		
		
		/**
		 * Translates the given message.
		 *
		 * @param {String} id The message id
		 * @param {Array} parameters An array of parameters for the message
		 * @param {String} domain The domain for the message
		 * @return {String} The translated string
		 */
		trans: function trans(id, params, domain) {
			if (!this._messages.hasOwnProperty(id)) {
				return id;
			}
			
			var message = this._messages[id];
			
			return stringReplace(message, params);
		},
		
		
		/**
		 * Translates the given choice message by choosing a translation according to a number.
		 *
		 * @param {String} id The message id
		 * @param {Number} number The number to use to find the indice of the message
		 * @param {Array} parameters An array of parameters for the message
		 * @param {String} domain The domain for the message
		 * @return {String} The translated string
		 */
		transChoice: function transChoice(id, number, params, domain) {
			if (!this._messages.hasOwnProperty(id)) {
				return id;
			}
			
			var message = this._messages[id],
				choosen = choose(message, number, this._locale);
			
			return stringReplace(choosen, params);
		}
	};
	
	// Module support
	if (typeof module !== 'undefined' && module.exports) {
		module.exports = {
			Sidis: Sidis,
			convertNumber: convertNumber,
			isInterval: isInterval,
			choose: choose
		};
	} else {
		root.Sidis = Sidis;
	}
}(this));
/*!
 * jQuery UI 1.8.10
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI
 */
(function(c,j){function k(a){return!c(a).parents().andSelf().filter(function(){return c.curCSS(this,"visibility")==="hidden"||c.expr.filters.hidden(this)}).length}c.ui=c.ui||{};if(!c.ui.version){c.extend(c.ui,{version:"1.8.10",keyCode:{ALT:18,BACKSPACE:8,CAPS_LOCK:20,COMMA:188,COMMAND:91,COMMAND_LEFT:91,COMMAND_RIGHT:93,CONTROL:17,DELETE:46,DOWN:40,END:35,ENTER:13,ESCAPE:27,HOME:36,INSERT:45,LEFT:37,MENU:93,NUMPAD_ADD:107,NUMPAD_DECIMAL:110,NUMPAD_DIVIDE:111,NUMPAD_ENTER:108,NUMPAD_MULTIPLY:106,
NUMPAD_SUBTRACT:109,PAGE_DOWN:34,PAGE_UP:33,PERIOD:190,RIGHT:39,SHIFT:16,SPACE:32,TAB:9,UP:38,WINDOWS:91}});c.fn.extend({_focus:c.fn.focus,focus:function(a,b){return typeof a==="number"?this.each(function(){var d=this;setTimeout(function(){c(d).focus();b&&b.call(d)},a)}):this._focus.apply(this,arguments)},scrollParent:function(){var a;a=c.browser.msie&&/(static|relative)/.test(this.css("position"))||/absolute/.test(this.css("position"))?this.parents().filter(function(){return/(relative|absolute|fixed)/.test(c.curCSS(this,
"position",1))&&/(auto|scroll)/.test(c.curCSS(this,"overflow",1)+c.curCSS(this,"overflow-y",1)+c.curCSS(this,"overflow-x",1))}).eq(0):this.parents().filter(function(){return/(auto|scroll)/.test(c.curCSS(this,"overflow",1)+c.curCSS(this,"overflow-y",1)+c.curCSS(this,"overflow-x",1))}).eq(0);return/fixed/.test(this.css("position"))||!a.length?c(document):a},zIndex:function(a){if(a!==j)return this.css("zIndex",a);if(this.length){a=c(this[0]);for(var b;a.length&&a[0]!==document;){b=a.css("position");
if(b==="absolute"||b==="relative"||b==="fixed"){b=parseInt(a.css("zIndex"),10);if(!isNaN(b)&&b!==0)return b}a=a.parent()}}return 0},disableSelection:function(){return this.bind((c.support.selectstart?"selectstart":"mousedown")+".ui-disableSelection",function(a){a.preventDefault()})},enableSelection:function(){return this.unbind(".ui-disableSelection")}});c.each(["Width","Height"],function(a,b){function d(f,g,l,m){c.each(e,function(){g-=parseFloat(c.curCSS(f,"padding"+this,true))||0;if(l)g-=parseFloat(c.curCSS(f,
"border"+this+"Width",true))||0;if(m)g-=parseFloat(c.curCSS(f,"margin"+this,true))||0});return g}var e=b==="Width"?["Left","Right"]:["Top","Bottom"],h=b.toLowerCase(),i={innerWidth:c.fn.innerWidth,innerHeight:c.fn.innerHeight,outerWidth:c.fn.outerWidth,outerHeight:c.fn.outerHeight};c.fn["inner"+b]=function(f){if(f===j)return i["inner"+b].call(this);return this.each(function(){c(this).css(h,d(this,f)+"px")})};c.fn["outer"+b]=function(f,g){if(typeof f!=="number")return i["outer"+b].call(this,f);return this.each(function(){c(this).css(h,
d(this,f,true,g)+"px")})}});c.extend(c.expr[":"],{data:function(a,b,d){return!!c.data(a,d[3])},focusable:function(a){var b=a.nodeName.toLowerCase(),d=c.attr(a,"tabindex");if("area"===b){b=a.parentNode;d=b.name;if(!a.href||!d||b.nodeName.toLowerCase()!=="map")return false;a=c("img[usemap=#"+d+"]")[0];return!!a&&k(a)}return(/input|select|textarea|button|object/.test(b)?!a.disabled:"a"==b?a.href||!isNaN(d):!isNaN(d))&&k(a)},tabbable:function(a){var b=c.attr(a,"tabindex");return(isNaN(b)||b>=0)&&c(a).is(":focusable")}});
c(function(){var a=document.body,b=a.appendChild(b=document.createElement("div"));c.extend(b.style,{minHeight:"100px",height:"auto",padding:0,borderWidth:0});c.support.minHeight=b.offsetHeight===100;c.support.selectstart="onselectstart"in b;a.removeChild(b).style.display="none"});c.extend(c.ui,{plugin:{add:function(a,b,d){a=c.ui[a].prototype;for(var e in d){a.plugins[e]=a.plugins[e]||[];a.plugins[e].push([b,d[e]])}},call:function(a,b,d){if((b=a.plugins[b])&&a.element[0].parentNode)for(var e=0;e<b.length;e++)a.options[b[e][0]]&&
b[e][1].apply(a.element,d)}},contains:function(a,b){return document.compareDocumentPosition?a.compareDocumentPosition(b)&16:a!==b&&a.contains(b)},hasScroll:function(a,b){if(c(a).css("overflow")==="hidden")return false;b=b&&b==="left"?"scrollLeft":"scrollTop";var d=false;if(a[b]>0)return true;a[b]=1;d=a[b]>0;a[b]=0;return d},isOverAxis:function(a,b,d){return a>b&&a<b+d},isOver:function(a,b,d,e,h,i){return c.ui.isOverAxis(a,d,h)&&c.ui.isOverAxis(b,e,i)}})}})(jQuery);
;/*!
 * jQuery UI Widget 1.8.10
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Widget
 */
(function(b,j){if(b.cleanData){var k=b.cleanData;b.cleanData=function(a){for(var c=0,d;(d=a[c])!=null;c++)b(d).triggerHandler("remove");k(a)}}else{var l=b.fn.remove;b.fn.remove=function(a,c){return this.each(function(){if(!c)if(!a||b.filter(a,[this]).length)b("*",this).add([this]).each(function(){b(this).triggerHandler("remove")});return l.call(b(this),a,c)})}}b.widget=function(a,c,d){var e=a.split(".")[0],f;a=a.split(".")[1];f=e+"-"+a;if(!d){d=c;c=b.Widget}b.expr[":"][f]=function(h){return!!b.data(h,
a)};b[e]=b[e]||{};b[e][a]=function(h,g){arguments.length&&this._createWidget(h,g)};c=new c;c.options=b.extend(true,{},c.options);b[e][a].prototype=b.extend(true,c,{namespace:e,widgetName:a,widgetEventPrefix:b[e][a].prototype.widgetEventPrefix||a,widgetBaseClass:f},d);b.widget.bridge(a,b[e][a])};b.widget.bridge=function(a,c){b.fn[a]=function(d){var e=typeof d==="string",f=Array.prototype.slice.call(arguments,1),h=this;d=!e&&f.length?b.extend.apply(null,[true,d].concat(f)):d;if(e&&d.charAt(0)==="_")return h;
e?this.each(function(){var g=b.data(this,a),i=g&&b.isFunction(g[d])?g[d].apply(g,f):g;if(i!==g&&i!==j){h=i;return false}}):this.each(function(){var g=b.data(this,a);g?g.option(d||{})._init():b.data(this,a,new c(d,this))});return h}};b.Widget=function(a,c){arguments.length&&this._createWidget(a,c)};b.Widget.prototype={widgetName:"widget",widgetEventPrefix:"",options:{disabled:false},_createWidget:function(a,c){b.data(c,this.widgetName,this);this.element=b(c);this.options=b.extend(true,{},this.options,
this._getCreateOptions(),a);var d=this;this.element.bind("remove."+this.widgetName,function(){d.destroy()});this._create();this._trigger("create");this._init()},_getCreateOptions:function(){return b.metadata&&b.metadata.get(this.element[0])[this.widgetName]},_create:function(){},_init:function(){},destroy:function(){this.element.unbind("."+this.widgetName).removeData(this.widgetName);this.widget().unbind("."+this.widgetName).removeAttr("aria-disabled").removeClass(this.widgetBaseClass+"-disabled ui-state-disabled")},
widget:function(){return this.element},option:function(a,c){var d=a;if(arguments.length===0)return b.extend({},this.options);if(typeof a==="string"){if(c===j)return this.options[a];d={};d[a]=c}this._setOptions(d);return this},_setOptions:function(a){var c=this;b.each(a,function(d,e){c._setOption(d,e)});return this},_setOption:function(a,c){this.options[a]=c;if(a==="disabled")this.widget()[c?"addClass":"removeClass"](this.widgetBaseClass+"-disabled ui-state-disabled").attr("aria-disabled",c);return this},
enable:function(){return this._setOption("disabled",false)},disable:function(){return this._setOption("disabled",true)},_trigger:function(a,c,d){var e=this.options[a];c=b.Event(c);c.type=(a===this.widgetEventPrefix?a:this.widgetEventPrefix+a).toLowerCase();d=d||{};if(c.originalEvent){a=b.event.props.length;for(var f;a;){f=b.event.props[--a];c[f]=c.originalEvent[f]}}this.element.trigger(c,d);return!(b.isFunction(e)&&e.call(this.element[0],c,d)===false||c.isDefaultPrevented())}}})(jQuery);
;/*!
 * jQuery UI Mouse 1.8.10
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Mouse
 *
 * Depends:
 *	jquery.ui.widget.js
 */
(function(c){c.widget("ui.mouse",{options:{cancel:":input,option",distance:1,delay:0},_mouseInit:function(){var a=this;this.element.bind("mousedown."+this.widgetName,function(b){return a._mouseDown(b)}).bind("click."+this.widgetName,function(b){if(true===c.data(b.target,a.widgetName+".preventClickEvent")){c.removeData(b.target,a.widgetName+".preventClickEvent");b.stopImmediatePropagation();return false}});this.started=false},_mouseDestroy:function(){this.element.unbind("."+this.widgetName)},_mouseDown:function(a){a.originalEvent=
a.originalEvent||{};if(!a.originalEvent.mouseHandled){this._mouseStarted&&this._mouseUp(a);this._mouseDownEvent=a;var b=this,e=a.which==1,f=typeof this.options.cancel=="string"?c(a.target).parents().add(a.target).filter(this.options.cancel).length:false;if(!e||f||!this._mouseCapture(a))return true;this.mouseDelayMet=!this.options.delay;if(!this.mouseDelayMet)this._mouseDelayTimer=setTimeout(function(){b.mouseDelayMet=true},this.options.delay);if(this._mouseDistanceMet(a)&&this._mouseDelayMet(a)){this._mouseStarted=
this._mouseStart(a)!==false;if(!this._mouseStarted){a.preventDefault();return true}}this._mouseMoveDelegate=function(d){return b._mouseMove(d)};this._mouseUpDelegate=function(d){return b._mouseUp(d)};c(document).bind("mousemove."+this.widgetName,this._mouseMoveDelegate).bind("mouseup."+this.widgetName,this._mouseUpDelegate);a.preventDefault();return a.originalEvent.mouseHandled=true}},_mouseMove:function(a){if(c.browser.msie&&!(document.documentMode>=9)&&!a.button)return this._mouseUp(a);if(this._mouseStarted){this._mouseDrag(a);
return a.preventDefault()}if(this._mouseDistanceMet(a)&&this._mouseDelayMet(a))(this._mouseStarted=this._mouseStart(this._mouseDownEvent,a)!==false)?this._mouseDrag(a):this._mouseUp(a);return!this._mouseStarted},_mouseUp:function(a){c(document).unbind("mousemove."+this.widgetName,this._mouseMoveDelegate).unbind("mouseup."+this.widgetName,this._mouseUpDelegate);if(this._mouseStarted){this._mouseStarted=false;a.target==this._mouseDownEvent.target&&c.data(a.target,this.widgetName+".preventClickEvent",
true);this._mouseStop(a)}return false},_mouseDistanceMet:function(a){return Math.max(Math.abs(this._mouseDownEvent.pageX-a.pageX),Math.abs(this._mouseDownEvent.pageY-a.pageY))>=this.options.distance},_mouseDelayMet:function(){return this.mouseDelayMet},_mouseStart:function(){},_mouseDrag:function(){},_mouseStop:function(){},_mouseCapture:function(){return true}})})(jQuery);
;/*
 * jQuery UI Position 1.8.10
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Position
 */
(function(c){c.ui=c.ui||{};var n=/left|center|right/,o=/top|center|bottom/,t=c.fn.position,u=c.fn.offset;c.fn.position=function(b){if(!b||!b.of)return t.apply(this,arguments);b=c.extend({},b);var a=c(b.of),d=a[0],g=(b.collision||"flip").split(" "),e=b.offset?b.offset.split(" "):[0,0],h,k,j;if(d.nodeType===9){h=a.width();k=a.height();j={top:0,left:0}}else if(d.setTimeout){h=a.width();k=a.height();j={top:a.scrollTop(),left:a.scrollLeft()}}else if(d.preventDefault){b.at="left top";h=k=0;j={top:b.of.pageY,
left:b.of.pageX}}else{h=a.outerWidth();k=a.outerHeight();j=a.offset()}c.each(["my","at"],function(){var f=(b[this]||"").split(" ");if(f.length===1)f=n.test(f[0])?f.concat(["center"]):o.test(f[0])?["center"].concat(f):["center","center"];f[0]=n.test(f[0])?f[0]:"center";f[1]=o.test(f[1])?f[1]:"center";b[this]=f});if(g.length===1)g[1]=g[0];e[0]=parseInt(e[0],10)||0;if(e.length===1)e[1]=e[0];e[1]=parseInt(e[1],10)||0;if(b.at[0]==="right")j.left+=h;else if(b.at[0]==="center")j.left+=h/2;if(b.at[1]==="bottom")j.top+=
k;else if(b.at[1]==="center")j.top+=k/2;j.left+=e[0];j.top+=e[1];return this.each(function(){var f=c(this),l=f.outerWidth(),m=f.outerHeight(),p=parseInt(c.curCSS(this,"marginLeft",true))||0,q=parseInt(c.curCSS(this,"marginTop",true))||0,v=l+p+(parseInt(c.curCSS(this,"marginRight",true))||0),w=m+q+(parseInt(c.curCSS(this,"marginBottom",true))||0),i=c.extend({},j),r;if(b.my[0]==="right")i.left-=l;else if(b.my[0]==="center")i.left-=l/2;if(b.my[1]==="bottom")i.top-=m;else if(b.my[1]==="center")i.top-=
m/2;i.left=Math.round(i.left);i.top=Math.round(i.top);r={left:i.left-p,top:i.top-q};c.each(["left","top"],function(s,x){c.ui.position[g[s]]&&c.ui.position[g[s]][x](i,{targetWidth:h,targetHeight:k,elemWidth:l,elemHeight:m,collisionPosition:r,collisionWidth:v,collisionHeight:w,offset:e,my:b.my,at:b.at})});c.fn.bgiframe&&f.bgiframe();f.offset(c.extend(i,{using:b.using}))})};c.ui.position={fit:{left:function(b,a){var d=c(window);d=a.collisionPosition.left+a.collisionWidth-d.width()-d.scrollLeft();b.left=
d>0?b.left-d:Math.max(b.left-a.collisionPosition.left,b.left)},top:function(b,a){var d=c(window);d=a.collisionPosition.top+a.collisionHeight-d.height()-d.scrollTop();b.top=d>0?b.top-d:Math.max(b.top-a.collisionPosition.top,b.top)}},flip:{left:function(b,a){if(a.at[0]!=="center"){var d=c(window);d=a.collisionPosition.left+a.collisionWidth-d.width()-d.scrollLeft();var g=a.my[0]==="left"?-a.elemWidth:a.my[0]==="right"?a.elemWidth:0,e=a.at[0]==="left"?a.targetWidth:-a.targetWidth,h=-2*a.offset[0];b.left+=
a.collisionPosition.left<0?g+e+h:d>0?g+e+h:0}},top:function(b,a){if(a.at[1]!=="center"){var d=c(window);d=a.collisionPosition.top+a.collisionHeight-d.height()-d.scrollTop();var g=a.my[1]==="top"?-a.elemHeight:a.my[1]==="bottom"?a.elemHeight:0,e=a.at[1]==="top"?a.targetHeight:-a.targetHeight,h=-2*a.offset[1];b.top+=a.collisionPosition.top<0?g+e+h:d>0?g+e+h:0}}}};if(!c.offset.setOffset){c.offset.setOffset=function(b,a){if(/static/.test(c.curCSS(b,"position")))b.style.position="relative";var d=c(b),
g=d.offset(),e=parseInt(c.curCSS(b,"top",true),10)||0,h=parseInt(c.curCSS(b,"left",true),10)||0;g={top:a.top-g.top+e,left:a.left-g.left+h};"using"in a?a.using.call(b,g):d.css(g)};c.fn.offset=function(b){var a=this[0];if(!a||!a.ownerDocument)return null;if(b)return this.each(function(){c.offset.setOffset(this,b)});return u.call(this)}}})(jQuery);
;/*
 * jQuery UI Draggable 1.8.10
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Draggables
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function(d){d.widget("ui.draggable",d.ui.mouse,{widgetEventPrefix:"drag",options:{addClasses:true,appendTo:"parent",axis:false,connectToSortable:false,containment:false,cursor:"auto",cursorAt:false,grid:false,handle:false,helper:"original",iframeFix:false,opacity:false,refreshPositions:false,revert:false,revertDuration:500,scope:"default",scroll:true,scrollSensitivity:20,scrollSpeed:20,snap:false,snapMode:"both",snapTolerance:20,stack:false,zIndex:false},_create:function(){if(this.options.helper==
"original"&&!/^(?:r|a|f)/.test(this.element.css("position")))this.element[0].style.position="relative";this.options.addClasses&&this.element.addClass("ui-draggable");this.options.disabled&&this.element.addClass("ui-draggable-disabled");this._mouseInit()},destroy:function(){if(this.element.data("draggable")){this.element.removeData("draggable").unbind(".draggable").removeClass("ui-draggable ui-draggable-dragging ui-draggable-disabled");this._mouseDestroy();return this}},_mouseCapture:function(a){var b=
this.options;if(this.helper||b.disabled||d(a.target).is(".ui-resizable-handle"))return false;this.handle=this._getHandle(a);if(!this.handle)return false;return true},_mouseStart:function(a){var b=this.options;this.helper=this._createHelper(a);this._cacheHelperProportions();if(d.ui.ddmanager)d.ui.ddmanager.current=this;this._cacheMargins();this.cssPosition=this.helper.css("position");this.scrollParent=this.helper.scrollParent();this.offset=this.positionAbs=this.element.offset();this.offset={top:this.offset.top-
this.margins.top,left:this.offset.left-this.margins.left};d.extend(this.offset,{click:{left:a.pageX-this.offset.left,top:a.pageY-this.offset.top},parent:this._getParentOffset(),relative:this._getRelativeOffset()});this.originalPosition=this.position=this._generatePosition(a);this.originalPageX=a.pageX;this.originalPageY=a.pageY;b.cursorAt&&this._adjustOffsetFromHelper(b.cursorAt);b.containment&&this._setContainment();if(this._trigger("start",a)===false){this._clear();return false}this._cacheHelperProportions();
d.ui.ddmanager&&!b.dropBehaviour&&d.ui.ddmanager.prepareOffsets(this,a);this.helper.addClass("ui-draggable-dragging");this._mouseDrag(a,true);return true},_mouseDrag:function(a,b){this.position=this._generatePosition(a);this.positionAbs=this._convertPositionTo("absolute");if(!b){b=this._uiHash();if(this._trigger("drag",a,b)===false){this._mouseUp({});return false}this.position=b.position}if(!this.options.axis||this.options.axis!="y")this.helper[0].style.left=this.position.left+"px";if(!this.options.axis||
this.options.axis!="x")this.helper[0].style.top=this.position.top+"px";d.ui.ddmanager&&d.ui.ddmanager.drag(this,a);return false},_mouseStop:function(a){var b=false;if(d.ui.ddmanager&&!this.options.dropBehaviour)b=d.ui.ddmanager.drop(this,a);if(this.dropped){b=this.dropped;this.dropped=false}if((!this.element[0]||!this.element[0].parentNode)&&this.options.helper=="original")return false;if(this.options.revert=="invalid"&&!b||this.options.revert=="valid"&&b||this.options.revert===true||d.isFunction(this.options.revert)&&
this.options.revert.call(this.element,b)){var c=this;d(this.helper).animate(this.originalPosition,parseInt(this.options.revertDuration,10),function(){c._trigger("stop",a)!==false&&c._clear()})}else this._trigger("stop",a)!==false&&this._clear();return false},cancel:function(){this.helper.is(".ui-draggable-dragging")?this._mouseUp({}):this._clear();return this},_getHandle:function(a){var b=!this.options.handle||!d(this.options.handle,this.element).length?true:false;d(this.options.handle,this.element).find("*").andSelf().each(function(){if(this==
a.target)b=true});return b},_createHelper:function(a){var b=this.options;a=d.isFunction(b.helper)?d(b.helper.apply(this.element[0],[a])):b.helper=="clone"?this.element.clone():this.element;a.parents("body").length||a.appendTo(b.appendTo=="parent"?this.element[0].parentNode:b.appendTo);a[0]!=this.element[0]&&!/(fixed|absolute)/.test(a.css("position"))&&a.css("position","absolute");return a},_adjustOffsetFromHelper:function(a){if(typeof a=="string")a=a.split(" ");if(d.isArray(a))a={left:+a[0],top:+a[1]||
0};if("left"in a)this.offset.click.left=a.left+this.margins.left;if("right"in a)this.offset.click.left=this.helperProportions.width-a.right+this.margins.left;if("top"in a)this.offset.click.top=a.top+this.margins.top;if("bottom"in a)this.offset.click.top=this.helperProportions.height-a.bottom+this.margins.top},_getParentOffset:function(){this.offsetParent=this.helper.offsetParent();var a=this.offsetParent.offset();if(this.cssPosition=="absolute"&&this.scrollParent[0]!=document&&d.ui.contains(this.scrollParent[0],
this.offsetParent[0])){a.left+=this.scrollParent.scrollLeft();a.top+=this.scrollParent.scrollTop()}if(this.offsetParent[0]==document.body||this.offsetParent[0].tagName&&this.offsetParent[0].tagName.toLowerCase()=="html"&&d.browser.msie)a={top:0,left:0};return{top:a.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:a.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if(this.cssPosition=="relative"){var a=this.element.position();return{top:a.top-
(parseInt(this.helper.css("top"),10)||0)+this.scrollParent.scrollTop(),left:a.left-(parseInt(this.helper.css("left"),10)||0)+this.scrollParent.scrollLeft()}}else return{top:0,left:0}},_cacheMargins:function(){this.margins={left:parseInt(this.element.css("marginLeft"),10)||0,top:parseInt(this.element.css("marginTop"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var a=this.options;if(a.containment==
"parent")a.containment=this.helper[0].parentNode;if(a.containment=="document"||a.containment=="window")this.containment=[(a.containment=="document"?0:d(window).scrollLeft())-this.offset.relative.left-this.offset.parent.left,(a.containment=="document"?0:d(window).scrollTop())-this.offset.relative.top-this.offset.parent.top,(a.containment=="document"?0:d(window).scrollLeft())+d(a.containment=="document"?document:window).width()-this.helperProportions.width-this.margins.left,(a.containment=="document"?
0:d(window).scrollTop())+(d(a.containment=="document"?document:window).height()||document.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top];if(!/^(document|window|parent)$/.test(a.containment)&&a.containment.constructor!=Array){var b=d(a.containment)[0];if(b){a=d(a.containment).offset();var c=d(b).css("overflow")!="hidden";this.containment=[a.left+(parseInt(d(b).css("borderLeftWidth"),10)||0)+(parseInt(d(b).css("paddingLeft"),10)||0)-this.margins.left,a.top+(parseInt(d(b).css("borderTopWidth"),
10)||0)+(parseInt(d(b).css("paddingTop"),10)||0)-this.margins.top,a.left+(c?Math.max(b.scrollWidth,b.offsetWidth):b.offsetWidth)-(parseInt(d(b).css("borderLeftWidth"),10)||0)-(parseInt(d(b).css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left,a.top+(c?Math.max(b.scrollHeight,b.offsetHeight):b.offsetHeight)-(parseInt(d(b).css("borderTopWidth"),10)||0)-(parseInt(d(b).css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top]}}else if(a.containment.constructor==
Array)this.containment=a.containment},_convertPositionTo:function(a,b){if(!b)b=this.position;a=a=="absolute"?1:-1;var c=this.cssPosition=="absolute"&&!(this.scrollParent[0]!=document&&d.ui.contains(this.scrollParent[0],this.offsetParent[0]))?this.offsetParent:this.scrollParent,f=/(html|body)/i.test(c[0].tagName);return{top:b.top+this.offset.relative.top*a+this.offset.parent.top*a-(d.browser.safari&&d.browser.version<526&&this.cssPosition=="fixed"?0:(this.cssPosition=="fixed"?-this.scrollParent.scrollTop():
f?0:c.scrollTop())*a),left:b.left+this.offset.relative.left*a+this.offset.parent.left*a-(d.browser.safari&&d.browser.version<526&&this.cssPosition=="fixed"?0:(this.cssPosition=="fixed"?-this.scrollParent.scrollLeft():f?0:c.scrollLeft())*a)}},_generatePosition:function(a){var b=this.options,c=this.cssPosition=="absolute"&&!(this.scrollParent[0]!=document&&d.ui.contains(this.scrollParent[0],this.offsetParent[0]))?this.offsetParent:this.scrollParent,f=/(html|body)/i.test(c[0].tagName),e=a.pageX,g=a.pageY;
if(this.originalPosition){if(this.containment){if(a.pageX-this.offset.click.left<this.containment[0])e=this.containment[0]+this.offset.click.left;if(a.pageY-this.offset.click.top<this.containment[1])g=this.containment[1]+this.offset.click.top;if(a.pageX-this.offset.click.left>this.containment[2])e=this.containment[2]+this.offset.click.left;if(a.pageY-this.offset.click.top>this.containment[3])g=this.containment[3]+this.offset.click.top}if(b.grid){g=this.originalPageY+Math.round((g-this.originalPageY)/
b.grid[1])*b.grid[1];g=this.containment?!(g-this.offset.click.top<this.containment[1]||g-this.offset.click.top>this.containment[3])?g:!(g-this.offset.click.top<this.containment[1])?g-b.grid[1]:g+b.grid[1]:g;e=this.originalPageX+Math.round((e-this.originalPageX)/b.grid[0])*b.grid[0];e=this.containment?!(e-this.offset.click.left<this.containment[0]||e-this.offset.click.left>this.containment[2])?e:!(e-this.offset.click.left<this.containment[0])?e-b.grid[0]:e+b.grid[0]:e}}return{top:g-this.offset.click.top-
this.offset.relative.top-this.offset.parent.top+(d.browser.safari&&d.browser.version<526&&this.cssPosition=="fixed"?0:this.cssPosition=="fixed"?-this.scrollParent.scrollTop():f?0:c.scrollTop()),left:e-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+(d.browser.safari&&d.browser.version<526&&this.cssPosition=="fixed"?0:this.cssPosition=="fixed"?-this.scrollParent.scrollLeft():f?0:c.scrollLeft())}},_clear:function(){this.helper.removeClass("ui-draggable-dragging");this.helper[0]!=
this.element[0]&&!this.cancelHelperRemoval&&this.helper.remove();this.helper=null;this.cancelHelperRemoval=false},_trigger:function(a,b,c){c=c||this._uiHash();d.ui.plugin.call(this,a,[b,c]);if(a=="drag")this.positionAbs=this._convertPositionTo("absolute");return d.Widget.prototype._trigger.call(this,a,b,c)},plugins:{},_uiHash:function(){return{helper:this.helper,position:this.position,originalPosition:this.originalPosition,offset:this.positionAbs}}});d.extend(d.ui.draggable,{version:"1.8.10"});
d.ui.plugin.add("draggable","connectToSortable",{start:function(a,b){var c=d(this).data("draggable"),f=c.options,e=d.extend({},b,{item:c.element});c.sortables=[];d(f.connectToSortable).each(function(){var g=d.data(this,"sortable");if(g&&!g.options.disabled){c.sortables.push({instance:g,shouldRevert:g.options.revert});g._refreshItems();g._trigger("activate",a,e)}})},stop:function(a,b){var c=d(this).data("draggable"),f=d.extend({},b,{item:c.element});d.each(c.sortables,function(){if(this.instance.isOver){this.instance.isOver=
0;c.cancelHelperRemoval=true;this.instance.cancelHelperRemoval=false;if(this.shouldRevert)this.instance.options.revert=true;this.instance._mouseStop(a);this.instance.options.helper=this.instance.options._helper;c.options.helper=="original"&&this.instance.currentItem.css({top:"auto",left:"auto"})}else{this.instance.cancelHelperRemoval=false;this.instance._trigger("deactivate",a,f)}})},drag:function(a,b){var c=d(this).data("draggable"),f=this;d.each(c.sortables,function(){this.instance.positionAbs=
c.positionAbs;this.instance.helperProportions=c.helperProportions;this.instance.offset.click=c.offset.click;if(this.instance._intersectsWith(this.instance.containerCache)){if(!this.instance.isOver){this.instance.isOver=1;this.instance.currentItem=d(f).clone().appendTo(this.instance.element).data("sortable-item",true);this.instance.options._helper=this.instance.options.helper;this.instance.options.helper=function(){return b.helper[0]};a.target=this.instance.currentItem[0];this.instance._mouseCapture(a,
true);this.instance._mouseStart(a,true,true);this.instance.offset.click.top=c.offset.click.top;this.instance.offset.click.left=c.offset.click.left;this.instance.offset.parent.left-=c.offset.parent.left-this.instance.offset.parent.left;this.instance.offset.parent.top-=c.offset.parent.top-this.instance.offset.parent.top;c._trigger("toSortable",a);c.dropped=this.instance.element;c.currentItem=c.element;this.instance.fromOutside=c}this.instance.currentItem&&this.instance._mouseDrag(a)}else if(this.instance.isOver){this.instance.isOver=
0;this.instance.cancelHelperRemoval=true;this.instance.options.revert=false;this.instance._trigger("out",a,this.instance._uiHash(this.instance));this.instance._mouseStop(a,true);this.instance.options.helper=this.instance.options._helper;this.instance.currentItem.remove();this.instance.placeholder&&this.instance.placeholder.remove();c._trigger("fromSortable",a);c.dropped=false}})}});d.ui.plugin.add("draggable","cursor",{start:function(){var a=d("body"),b=d(this).data("draggable").options;if(a.css("cursor"))b._cursor=
a.css("cursor");a.css("cursor",b.cursor)},stop:function(){var a=d(this).data("draggable").options;a._cursor&&d("body").css("cursor",a._cursor)}});d.ui.plugin.add("draggable","iframeFix",{start:function(){var a=d(this).data("draggable").options;d(a.iframeFix===true?"iframe":a.iframeFix).each(function(){d('<div class="ui-draggable-iframeFix" style="background: #fff;"></div>').css({width:this.offsetWidth+"px",height:this.offsetHeight+"px",position:"absolute",opacity:"0.001",zIndex:1E3}).css(d(this).offset()).appendTo("body")})},
stop:function(){d("div.ui-draggable-iframeFix").each(function(){this.parentNode.removeChild(this)})}});d.ui.plugin.add("draggable","opacity",{start:function(a,b){a=d(b.helper);b=d(this).data("draggable").options;if(a.css("opacity"))b._opacity=a.css("opacity");a.css("opacity",b.opacity)},stop:function(a,b){a=d(this).data("draggable").options;a._opacity&&d(b.helper).css("opacity",a._opacity)}});d.ui.plugin.add("draggable","scroll",{start:function(){var a=d(this).data("draggable");if(a.scrollParent[0]!=
document&&a.scrollParent[0].tagName!="HTML")a.overflowOffset=a.scrollParent.offset()},drag:function(a){var b=d(this).data("draggable"),c=b.options,f=false;if(b.scrollParent[0]!=document&&b.scrollParent[0].tagName!="HTML"){if(!c.axis||c.axis!="x")if(b.overflowOffset.top+b.scrollParent[0].offsetHeight-a.pageY<c.scrollSensitivity)b.scrollParent[0].scrollTop=f=b.scrollParent[0].scrollTop+c.scrollSpeed;else if(a.pageY-b.overflowOffset.top<c.scrollSensitivity)b.scrollParent[0].scrollTop=f=b.scrollParent[0].scrollTop-
c.scrollSpeed;if(!c.axis||c.axis!="y")if(b.overflowOffset.left+b.scrollParent[0].offsetWidth-a.pageX<c.scrollSensitivity)b.scrollParent[0].scrollLeft=f=b.scrollParent[0].scrollLeft+c.scrollSpeed;else if(a.pageX-b.overflowOffset.left<c.scrollSensitivity)b.scrollParent[0].scrollLeft=f=b.scrollParent[0].scrollLeft-c.scrollSpeed}else{if(!c.axis||c.axis!="x")if(a.pageY-d(document).scrollTop()<c.scrollSensitivity)f=d(document).scrollTop(d(document).scrollTop()-c.scrollSpeed);else if(d(window).height()-
(a.pageY-d(document).scrollTop())<c.scrollSensitivity)f=d(document).scrollTop(d(document).scrollTop()+c.scrollSpeed);if(!c.axis||c.axis!="y")if(a.pageX-d(document).scrollLeft()<c.scrollSensitivity)f=d(document).scrollLeft(d(document).scrollLeft()-c.scrollSpeed);else if(d(window).width()-(a.pageX-d(document).scrollLeft())<c.scrollSensitivity)f=d(document).scrollLeft(d(document).scrollLeft()+c.scrollSpeed)}f!==false&&d.ui.ddmanager&&!c.dropBehaviour&&d.ui.ddmanager.prepareOffsets(b,a)}});d.ui.plugin.add("draggable",
"snap",{start:function(){var a=d(this).data("draggable"),b=a.options;a.snapElements=[];d(b.snap.constructor!=String?b.snap.items||":data(draggable)":b.snap).each(function(){var c=d(this),f=c.offset();this!=a.element[0]&&a.snapElements.push({item:this,width:c.outerWidth(),height:c.outerHeight(),top:f.top,left:f.left})})},drag:function(a,b){for(var c=d(this).data("draggable"),f=c.options,e=f.snapTolerance,g=b.offset.left,n=g+c.helperProportions.width,m=b.offset.top,o=m+c.helperProportions.height,h=
c.snapElements.length-1;h>=0;h--){var i=c.snapElements[h].left,k=i+c.snapElements[h].width,j=c.snapElements[h].top,l=j+c.snapElements[h].height;if(i-e<g&&g<k+e&&j-e<m&&m<l+e||i-e<g&&g<k+e&&j-e<o&&o<l+e||i-e<n&&n<k+e&&j-e<m&&m<l+e||i-e<n&&n<k+e&&j-e<o&&o<l+e){if(f.snapMode!="inner"){var p=Math.abs(j-o)<=e,q=Math.abs(l-m)<=e,r=Math.abs(i-n)<=e,s=Math.abs(k-g)<=e;if(p)b.position.top=c._convertPositionTo("relative",{top:j-c.helperProportions.height,left:0}).top-c.margins.top;if(q)b.position.top=c._convertPositionTo("relative",
{top:l,left:0}).top-c.margins.top;if(r)b.position.left=c._convertPositionTo("relative",{top:0,left:i-c.helperProportions.width}).left-c.margins.left;if(s)b.position.left=c._convertPositionTo("relative",{top:0,left:k}).left-c.margins.left}var t=p||q||r||s;if(f.snapMode!="outer"){p=Math.abs(j-m)<=e;q=Math.abs(l-o)<=e;r=Math.abs(i-g)<=e;s=Math.abs(k-n)<=e;if(p)b.position.top=c._convertPositionTo("relative",{top:j,left:0}).top-c.margins.top;if(q)b.position.top=c._convertPositionTo("relative",{top:l-c.helperProportions.height,
left:0}).top-c.margins.top;if(r)b.position.left=c._convertPositionTo("relative",{top:0,left:i}).left-c.margins.left;if(s)b.position.left=c._convertPositionTo("relative",{top:0,left:k-c.helperProportions.width}).left-c.margins.left}if(!c.snapElements[h].snapping&&(p||q||r||s||t))c.options.snap.snap&&c.options.snap.snap.call(c.element,a,d.extend(c._uiHash(),{snapItem:c.snapElements[h].item}));c.snapElements[h].snapping=p||q||r||s||t}else{c.snapElements[h].snapping&&c.options.snap.release&&c.options.snap.release.call(c.element,
a,d.extend(c._uiHash(),{snapItem:c.snapElements[h].item}));c.snapElements[h].snapping=false}}}});d.ui.plugin.add("draggable","stack",{start:function(){var a=d(this).data("draggable").options;a=d.makeArray(d(a.stack)).sort(function(c,f){return(parseInt(d(c).css("zIndex"),10)||0)-(parseInt(d(f).css("zIndex"),10)||0)});if(a.length){var b=parseInt(a[0].style.zIndex)||0;d(a).each(function(c){this.style.zIndex=b+c});this[0].style.zIndex=b+a.length}}});d.ui.plugin.add("draggable","zIndex",{start:function(a,
b){a=d(b.helper);b=d(this).data("draggable").options;if(a.css("zIndex"))b._zIndex=a.css("zIndex");a.css("zIndex",b.zIndex)},stop:function(a,b){a=d(this).data("draggable").options;a._zIndex&&d(b.helper).css("zIndex",a._zIndex)}})})(jQuery);
;/*
 * jQuery UI Droppable 1.8.10
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Droppables
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 *	jquery.ui.mouse.js
 *	jquery.ui.draggable.js
 */
(function(d){d.widget("ui.droppable",{widgetEventPrefix:"drop",options:{accept:"*",activeClass:false,addClasses:true,greedy:false,hoverClass:false,scope:"default",tolerance:"intersect"},_create:function(){var a=this.options,b=a.accept;this.isover=0;this.isout=1;this.accept=d.isFunction(b)?b:function(c){return c.is(b)};this.proportions={width:this.element[0].offsetWidth,height:this.element[0].offsetHeight};d.ui.ddmanager.droppables[a.scope]=d.ui.ddmanager.droppables[a.scope]||[];d.ui.ddmanager.droppables[a.scope].push(this);
a.addClasses&&this.element.addClass("ui-droppable")},destroy:function(){for(var a=d.ui.ddmanager.droppables[this.options.scope],b=0;b<a.length;b++)a[b]==this&&a.splice(b,1);this.element.removeClass("ui-droppable ui-droppable-disabled").removeData("droppable").unbind(".droppable");return this},_setOption:function(a,b){if(a=="accept")this.accept=d.isFunction(b)?b:function(c){return c.is(b)};d.Widget.prototype._setOption.apply(this,arguments)},_activate:function(a){var b=d.ui.ddmanager.current;this.options.activeClass&&
this.element.addClass(this.options.activeClass);b&&this._trigger("activate",a,this.ui(b))},_deactivate:function(a){var b=d.ui.ddmanager.current;this.options.activeClass&&this.element.removeClass(this.options.activeClass);b&&this._trigger("deactivate",a,this.ui(b))},_over:function(a){var b=d.ui.ddmanager.current;if(!(!b||(b.currentItem||b.element)[0]==this.element[0]))if(this.accept.call(this.element[0],b.currentItem||b.element)){this.options.hoverClass&&this.element.addClass(this.options.hoverClass);
this._trigger("over",a,this.ui(b))}},_out:function(a){var b=d.ui.ddmanager.current;if(!(!b||(b.currentItem||b.element)[0]==this.element[0]))if(this.accept.call(this.element[0],b.currentItem||b.element)){this.options.hoverClass&&this.element.removeClass(this.options.hoverClass);this._trigger("out",a,this.ui(b))}},_drop:function(a,b){var c=b||d.ui.ddmanager.current;if(!c||(c.currentItem||c.element)[0]==this.element[0])return false;var e=false;this.element.find(":data(droppable)").not(".ui-draggable-dragging").each(function(){var g=
d.data(this,"droppable");if(g.options.greedy&&!g.options.disabled&&g.options.scope==c.options.scope&&g.accept.call(g.element[0],c.currentItem||c.element)&&d.ui.intersect(c,d.extend(g,{offset:g.element.offset()}),g.options.tolerance)){e=true;return false}});if(e)return false;if(this.accept.call(this.element[0],c.currentItem||c.element)){this.options.activeClass&&this.element.removeClass(this.options.activeClass);this.options.hoverClass&&this.element.removeClass(this.options.hoverClass);this._trigger("drop",
a,this.ui(c));return this.element}return false},ui:function(a){return{draggable:a.currentItem||a.element,helper:a.helper,position:a.position,offset:a.positionAbs}}});d.extend(d.ui.droppable,{version:"1.8.10"});d.ui.intersect=function(a,b,c){if(!b.offset)return false;var e=(a.positionAbs||a.position.absolute).left,g=e+a.helperProportions.width,f=(a.positionAbs||a.position.absolute).top,h=f+a.helperProportions.height,i=b.offset.left,k=i+b.proportions.width,j=b.offset.top,l=j+b.proportions.height;
switch(c){case "fit":return i<=e&&g<=k&&j<=f&&h<=l;case "intersect":return i<e+a.helperProportions.width/2&&g-a.helperProportions.width/2<k&&j<f+a.helperProportions.height/2&&h-a.helperProportions.height/2<l;case "pointer":return d.ui.isOver((a.positionAbs||a.position.absolute).top+(a.clickOffset||a.offset.click).top,(a.positionAbs||a.position.absolute).left+(a.clickOffset||a.offset.click).left,j,i,b.proportions.height,b.proportions.width);case "touch":return(f>=j&&f<=l||h>=j&&h<=l||f<j&&h>l)&&(e>=
i&&e<=k||g>=i&&g<=k||e<i&&g>k);default:return false}};d.ui.ddmanager={current:null,droppables:{"default":[]},prepareOffsets:function(a,b){var c=d.ui.ddmanager.droppables[a.options.scope]||[],e=b?b.type:null,g=(a.currentItem||a.element).find(":data(droppable)").andSelf(),f=0;a:for(;f<c.length;f++)if(!(c[f].options.disabled||a&&!c[f].accept.call(c[f].element[0],a.currentItem||a.element))){for(var h=0;h<g.length;h++)if(g[h]==c[f].element[0]){c[f].proportions.height=0;continue a}c[f].visible=c[f].element.css("display")!=
"none";if(c[f].visible){c[f].offset=c[f].element.offset();c[f].proportions={width:c[f].element[0].offsetWidth,height:c[f].element[0].offsetHeight};e=="mousedown"&&c[f]._activate.call(c[f],b)}}},drop:function(a,b){var c=false;d.each(d.ui.ddmanager.droppables[a.options.scope]||[],function(){if(this.options){if(!this.options.disabled&&this.visible&&d.ui.intersect(a,this,this.options.tolerance))c=c||this._drop.call(this,b);if(!this.options.disabled&&this.visible&&this.accept.call(this.element[0],a.currentItem||
a.element)){this.isout=1;this.isover=0;this._deactivate.call(this,b)}}});return c},drag:function(a,b){a.options.refreshPositions&&d.ui.ddmanager.prepareOffsets(a,b);d.each(d.ui.ddmanager.droppables[a.options.scope]||[],function(){if(!(this.options.disabled||this.greedyChild||!this.visible)){var c=d.ui.intersect(a,this,this.options.tolerance);if(c=!c&&this.isover==1?"isout":c&&this.isover==0?"isover":null){var e;if(this.options.greedy){var g=this.element.parents(":data(droppable):eq(0)");if(g.length){e=
d.data(g[0],"droppable");e.greedyChild=c=="isover"?1:0}}if(e&&c=="isover"){e.isover=0;e.isout=1;e._out.call(e,b)}this[c]=1;this[c=="isout"?"isover":"isout"]=0;this[c=="isover"?"_over":"_out"].call(this,b);if(e&&c=="isout"){e.isout=0;e.isover=1;e._over.call(e,b)}}}})}}})(jQuery);
;/*
 * jQuery UI Resizable 1.8.10
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Resizables
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function(e){e.widget("ui.resizable",e.ui.mouse,{widgetEventPrefix:"resize",options:{alsoResize:false,animate:false,animateDuration:"slow",animateEasing:"swing",aspectRatio:false,autoHide:false,containment:false,ghost:false,grid:false,handles:"e,s,se",helper:false,maxHeight:null,maxWidth:null,minHeight:10,minWidth:10,zIndex:1E3},_create:function(){var b=this,a=this.options;this.element.addClass("ui-resizable");e.extend(this,{_aspectRatio:!!a.aspectRatio,aspectRatio:a.aspectRatio,originalElement:this.element,
_proportionallyResizeElements:[],_helper:a.helper||a.ghost||a.animate?a.helper||"ui-resizable-helper":null});if(this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/i)){/relative/.test(this.element.css("position"))&&e.browser.opera&&this.element.css({position:"relative",top:"auto",left:"auto"});this.element.wrap(e('<div class="ui-wrapper" style="overflow: hidden;"></div>').css({position:this.element.css("position"),width:this.element.outerWidth(),height:this.element.outerHeight(),
top:this.element.css("top"),left:this.element.css("left")}));this.element=this.element.parent().data("resizable",this.element.data("resizable"));this.elementIsWrapper=true;this.element.css({marginLeft:this.originalElement.css("marginLeft"),marginTop:this.originalElement.css("marginTop"),marginRight:this.originalElement.css("marginRight"),marginBottom:this.originalElement.css("marginBottom")});this.originalElement.css({marginLeft:0,marginTop:0,marginRight:0,marginBottom:0});this.originalResizeStyle=
this.originalElement.css("resize");this.originalElement.css("resize","none");this._proportionallyResizeElements.push(this.originalElement.css({position:"static",zoom:1,display:"block"}));this.originalElement.css({margin:this.originalElement.css("margin")});this._proportionallyResize()}this.handles=a.handles||(!e(".ui-resizable-handle",this.element).length?"e,s,se":{n:".ui-resizable-n",e:".ui-resizable-e",s:".ui-resizable-s",w:".ui-resizable-w",se:".ui-resizable-se",sw:".ui-resizable-sw",ne:".ui-resizable-ne",
nw:".ui-resizable-nw"});if(this.handles.constructor==String){if(this.handles=="all")this.handles="n,e,s,w,se,sw,ne,nw";var c=this.handles.split(",");this.handles={};for(var d=0;d<c.length;d++){var f=e.trim(c[d]),g=e('<div class="ui-resizable-handle '+("ui-resizable-"+f)+'"></div>');/sw|se|ne|nw/.test(f)&&g.css({zIndex:++a.zIndex});"se"==f&&g.addClass("ui-icon ui-icon-gripsmall-diagonal-se");this.handles[f]=".ui-resizable-"+f;this.element.append(g)}}this._renderAxis=function(h){h=h||this.element;for(var i in this.handles){if(this.handles[i].constructor==
String)this.handles[i]=e(this.handles[i],this.element).show();if(this.elementIsWrapper&&this.originalElement[0].nodeName.match(/textarea|input|select|button/i)){var j=e(this.handles[i],this.element),k=0;k=/sw|ne|nw|se|n|s/.test(i)?j.outerHeight():j.outerWidth();j=["padding",/ne|nw|n/.test(i)?"Top":/se|sw|s/.test(i)?"Bottom":/^e$/.test(i)?"Right":"Left"].join("");h.css(j,k);this._proportionallyResize()}e(this.handles[i])}};this._renderAxis(this.element);this._handles=e(".ui-resizable-handle",this.element).disableSelection();
this._handles.mouseover(function(){if(!b.resizing){if(this.className)var h=this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);b.axis=h&&h[1]?h[1]:"se"}});if(a.autoHide){this._handles.hide();e(this.element).addClass("ui-resizable-autohide").hover(function(){e(this).removeClass("ui-resizable-autohide");b._handles.show()},function(){if(!b.resizing){e(this).addClass("ui-resizable-autohide");b._handles.hide()}})}this._mouseInit()},destroy:function(){this._mouseDestroy();var b=function(c){e(c).removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing").removeData("resizable").unbind(".resizable").find(".ui-resizable-handle").remove()};
if(this.elementIsWrapper){b(this.element);var a=this.element;a.after(this.originalElement.css({position:a.css("position"),width:a.outerWidth(),height:a.outerHeight(),top:a.css("top"),left:a.css("left")})).remove()}this.originalElement.css("resize",this.originalResizeStyle);b(this.originalElement);return this},_mouseCapture:function(b){var a=false;for(var c in this.handles)if(e(this.handles[c])[0]==b.target)a=true;return!this.options.disabled&&a},_mouseStart:function(b){var a=this.options,c=this.element.position(),
d=this.element;this.resizing=true;this.documentScroll={top:e(document).scrollTop(),left:e(document).scrollLeft()};if(d.is(".ui-draggable")||/absolute/.test(d.css("position")))d.css({position:"absolute",top:c.top,left:c.left});e.browser.opera&&/relative/.test(d.css("position"))&&d.css({position:"relative",top:"auto",left:"auto"});this._renderProxy();c=m(this.helper.css("left"));var f=m(this.helper.css("top"));if(a.containment){c+=e(a.containment).scrollLeft()||0;f+=e(a.containment).scrollTop()||0}this.offset=
this.helper.offset();this.position={left:c,top:f};this.size=this._helper?{width:d.outerWidth(),height:d.outerHeight()}:{width:d.width(),height:d.height()};this.originalSize=this._helper?{width:d.outerWidth(),height:d.outerHeight()}:{width:d.width(),height:d.height()};this.originalPosition={left:c,top:f};this.sizeDiff={width:d.outerWidth()-d.width(),height:d.outerHeight()-d.height()};this.originalMousePosition={left:b.pageX,top:b.pageY};this.aspectRatio=typeof a.aspectRatio=="number"?a.aspectRatio:
this.originalSize.width/this.originalSize.height||1;a=e(".ui-resizable-"+this.axis).css("cursor");e("body").css("cursor",a=="auto"?this.axis+"-resize":a);d.addClass("ui-resizable-resizing");this._propagate("start",b);return true},_mouseDrag:function(b){var a=this.helper,c=this.originalMousePosition,d=this._change[this.axis];if(!d)return false;c=d.apply(this,[b,b.pageX-c.left||0,b.pageY-c.top||0]);if(this._aspectRatio||b.shiftKey)c=this._updateRatio(c,b);c=this._respectSize(c,b);this._propagate("resize",
b);a.css({top:this.position.top+"px",left:this.position.left+"px",width:this.size.width+"px",height:this.size.height+"px"});!this._helper&&this._proportionallyResizeElements.length&&this._proportionallyResize();this._updateCache(c);this._trigger("resize",b,this.ui());return false},_mouseStop:function(b){this.resizing=false;var a=this.options,c=this;if(this._helper){var d=this._proportionallyResizeElements,f=d.length&&/textarea/i.test(d[0].nodeName);d=f&&e.ui.hasScroll(d[0],"left")?0:c.sizeDiff.height;
f=f?0:c.sizeDiff.width;f={width:c.helper.width()-f,height:c.helper.height()-d};d=parseInt(c.element.css("left"),10)+(c.position.left-c.originalPosition.left)||null;var g=parseInt(c.element.css("top"),10)+(c.position.top-c.originalPosition.top)||null;a.animate||this.element.css(e.extend(f,{top:g,left:d}));c.helper.height(c.size.height);c.helper.width(c.size.width);this._helper&&!a.animate&&this._proportionallyResize()}e("body").css("cursor","auto");this.element.removeClass("ui-resizable-resizing");
this._propagate("stop",b);this._helper&&this.helper.remove();return false},_updateCache:function(b){this.offset=this.helper.offset();if(l(b.left))this.position.left=b.left;if(l(b.top))this.position.top=b.top;if(l(b.height))this.size.height=b.height;if(l(b.width))this.size.width=b.width},_updateRatio:function(b){var a=this.position,c=this.size,d=this.axis;if(b.height)b.width=c.height*this.aspectRatio;else if(b.width)b.height=c.width/this.aspectRatio;if(d=="sw"){b.left=a.left+(c.width-b.width);b.top=
null}if(d=="nw"){b.top=a.top+(c.height-b.height);b.left=a.left+(c.width-b.width)}return b},_respectSize:function(b){var a=this.options,c=this.axis,d=l(b.width)&&a.maxWidth&&a.maxWidth<b.width,f=l(b.height)&&a.maxHeight&&a.maxHeight<b.height,g=l(b.width)&&a.minWidth&&a.minWidth>b.width,h=l(b.height)&&a.minHeight&&a.minHeight>b.height;if(g)b.width=a.minWidth;if(h)b.height=a.minHeight;if(d)b.width=a.maxWidth;if(f)b.height=a.maxHeight;var i=this.originalPosition.left+this.originalSize.width,j=this.position.top+
this.size.height,k=/sw|nw|w/.test(c);c=/nw|ne|n/.test(c);if(g&&k)b.left=i-a.minWidth;if(d&&k)b.left=i-a.maxWidth;if(h&&c)b.top=j-a.minHeight;if(f&&c)b.top=j-a.maxHeight;if((a=!b.width&&!b.height)&&!b.left&&b.top)b.top=null;else if(a&&!b.top&&b.left)b.left=null;return b},_proportionallyResize:function(){if(this._proportionallyResizeElements.length)for(var b=this.helper||this.element,a=0;a<this._proportionallyResizeElements.length;a++){var c=this._proportionallyResizeElements[a];if(!this.borderDif){var d=
[c.css("borderTopWidth"),c.css("borderRightWidth"),c.css("borderBottomWidth"),c.css("borderLeftWidth")],f=[c.css("paddingTop"),c.css("paddingRight"),c.css("paddingBottom"),c.css("paddingLeft")];this.borderDif=e.map(d,function(g,h){g=parseInt(g,10)||0;h=parseInt(f[h],10)||0;return g+h})}e.browser.msie&&(e(b).is(":hidden")||e(b).parents(":hidden").length)||c.css({height:b.height()-this.borderDif[0]-this.borderDif[2]||0,width:b.width()-this.borderDif[1]-this.borderDif[3]||0})}},_renderProxy:function(){var b=
this.options;this.elementOffset=this.element.offset();if(this._helper){this.helper=this.helper||e('<div style="overflow:hidden;"></div>');var a=e.browser.msie&&e.browser.version<7,c=a?1:0;a=a?2:-1;this.helper.addClass(this._helper).css({width:this.element.outerWidth()+a,height:this.element.outerHeight()+a,position:"absolute",left:this.elementOffset.left-c+"px",top:this.elementOffset.top-c+"px",zIndex:++b.zIndex});this.helper.appendTo("body").disableSelection()}else this.helper=this.element},_change:{e:function(b,
a){return{width:this.originalSize.width+a}},w:function(b,a){return{left:this.originalPosition.left+a,width:this.originalSize.width-a}},n:function(b,a,c){return{top:this.originalPosition.top+c,height:this.originalSize.height-c}},s:function(b,a,c){return{height:this.originalSize.height+c}},se:function(b,a,c){return e.extend(this._change.s.apply(this,arguments),this._change.e.apply(this,[b,a,c]))},sw:function(b,a,c){return e.extend(this._change.s.apply(this,arguments),this._change.w.apply(this,[b,a,
c]))},ne:function(b,a,c){return e.extend(this._change.n.apply(this,arguments),this._change.e.apply(this,[b,a,c]))},nw:function(b,a,c){return e.extend(this._change.n.apply(this,arguments),this._change.w.apply(this,[b,a,c]))}},_propagate:function(b,a){e.ui.plugin.call(this,b,[a,this.ui()]);b!="resize"&&this._trigger(b,a,this.ui())},plugins:{},ui:function(){return{originalElement:this.originalElement,element:this.element,helper:this.helper,position:this.position,size:this.size,originalSize:this.originalSize,
originalPosition:this.originalPosition}}});e.extend(e.ui.resizable,{version:"1.8.10"});e.ui.plugin.add("resizable","alsoResize",{start:function(){var b=e(this).data("resizable").options,a=function(c){e(c).each(function(){var d=e(this);d.data("resizable-alsoresize",{width:parseInt(d.width(),10),height:parseInt(d.height(),10),left:parseInt(d.css("left"),10),top:parseInt(d.css("top"),10),position:d.css("position")})})};if(typeof b.alsoResize=="object"&&!b.alsoResize.parentNode)if(b.alsoResize.length){b.alsoResize=
b.alsoResize[0];a(b.alsoResize)}else e.each(b.alsoResize,function(c){a(c)});else a(b.alsoResize)},resize:function(b,a){var c=e(this).data("resizable");b=c.options;var d=c.originalSize,f=c.originalPosition,g={height:c.size.height-d.height||0,width:c.size.width-d.width||0,top:c.position.top-f.top||0,left:c.position.left-f.left||0},h=function(i,j){e(i).each(function(){var k=e(this),q=e(this).data("resizable-alsoresize"),p={},r=j&&j.length?j:k.parents(a.originalElement[0]).length?["width","height"]:["width",
"height","top","left"];e.each(r,function(n,o){if((n=(q[o]||0)+(g[o]||0))&&n>=0)p[o]=n||null});if(e.browser.opera&&/relative/.test(k.css("position"))){c._revertToRelativePosition=true;k.css({position:"absolute",top:"auto",left:"auto"})}k.css(p)})};typeof b.alsoResize=="object"&&!b.alsoResize.nodeType?e.each(b.alsoResize,function(i,j){h(i,j)}):h(b.alsoResize)},stop:function(){var b=e(this).data("resizable"),a=b.options,c=function(d){e(d).each(function(){var f=e(this);f.css({position:f.data("resizable-alsoresize").position})})};
if(b._revertToRelativePosition){b._revertToRelativePosition=false;typeof a.alsoResize=="object"&&!a.alsoResize.nodeType?e.each(a.alsoResize,function(d){c(d)}):c(a.alsoResize)}e(this).removeData("resizable-alsoresize")}});e.ui.plugin.add("resizable","animate",{stop:function(b){var a=e(this).data("resizable"),c=a.options,d=a._proportionallyResizeElements,f=d.length&&/textarea/i.test(d[0].nodeName),g=f&&e.ui.hasScroll(d[0],"left")?0:a.sizeDiff.height;f={width:a.size.width-(f?0:a.sizeDiff.width),height:a.size.height-
g};g=parseInt(a.element.css("left"),10)+(a.position.left-a.originalPosition.left)||null;var h=parseInt(a.element.css("top"),10)+(a.position.top-a.originalPosition.top)||null;a.element.animate(e.extend(f,h&&g?{top:h,left:g}:{}),{duration:c.animateDuration,easing:c.animateEasing,step:function(){var i={width:parseInt(a.element.css("width"),10),height:parseInt(a.element.css("height"),10),top:parseInt(a.element.css("top"),10),left:parseInt(a.element.css("left"),10)};d&&d.length&&e(d[0]).css({width:i.width,
height:i.height});a._updateCache(i);a._propagate("resize",b)}})}});e.ui.plugin.add("resizable","containment",{start:function(){var b=e(this).data("resizable"),a=b.element,c=b.options.containment;if(a=c instanceof e?c.get(0):/parent/.test(c)?a.parent().get(0):c){b.containerElement=e(a);if(/document/.test(c)||c==document){b.containerOffset={left:0,top:0};b.containerPosition={left:0,top:0};b.parentData={element:e(document),left:0,top:0,width:e(document).width(),height:e(document).height()||document.body.parentNode.scrollHeight}}else{var d=
e(a),f=[];e(["Top","Right","Left","Bottom"]).each(function(i,j){f[i]=m(d.css("padding"+j))});b.containerOffset=d.offset();b.containerPosition=d.position();b.containerSize={height:d.innerHeight()-f[3],width:d.innerWidth()-f[1]};c=b.containerOffset;var g=b.containerSize.height,h=b.containerSize.width;h=e.ui.hasScroll(a,"left")?a.scrollWidth:h;g=e.ui.hasScroll(a)?a.scrollHeight:g;b.parentData={element:a,left:c.left,top:c.top,width:h,height:g}}}},resize:function(b){var a=e(this).data("resizable"),c=a.options,
d=a.containerOffset,f=a.position;b=a._aspectRatio||b.shiftKey;var g={top:0,left:0},h=a.containerElement;if(h[0]!=document&&/static/.test(h.css("position")))g=d;if(f.left<(a._helper?d.left:0)){a.size.width+=a._helper?a.position.left-d.left:a.position.left-g.left;if(b)a.size.height=a.size.width/c.aspectRatio;a.position.left=c.helper?d.left:0}if(f.top<(a._helper?d.top:0)){a.size.height+=a._helper?a.position.top-d.top:a.position.top;if(b)a.size.width=a.size.height*c.aspectRatio;a.position.top=a._helper?
d.top:0}a.offset.left=a.parentData.left+a.position.left;a.offset.top=a.parentData.top+a.position.top;c=Math.abs((a._helper?a.offset.left-g.left:a.offset.left-g.left)+a.sizeDiff.width);d=Math.abs((a._helper?a.offset.top-g.top:a.offset.top-d.top)+a.sizeDiff.height);f=a.containerElement.get(0)==a.element.parent().get(0);g=/relative|absolute/.test(a.containerElement.css("position"));if(f&&g)c-=a.parentData.left;if(c+a.size.width>=a.parentData.width){a.size.width=a.parentData.width-c;if(b)a.size.height=
a.size.width/a.aspectRatio}if(d+a.size.height>=a.parentData.height){a.size.height=a.parentData.height-d;if(b)a.size.width=a.size.height*a.aspectRatio}},stop:function(){var b=e(this).data("resizable"),a=b.options,c=b.containerOffset,d=b.containerPosition,f=b.containerElement,g=e(b.helper),h=g.offset(),i=g.outerWidth()-b.sizeDiff.width;g=g.outerHeight()-b.sizeDiff.height;b._helper&&!a.animate&&/relative/.test(f.css("position"))&&e(this).css({left:h.left-d.left-c.left,width:i,height:g});b._helper&&!a.animate&&
/static/.test(f.css("position"))&&e(this).css({left:h.left-d.left-c.left,width:i,height:g})}});e.ui.plugin.add("resizable","ghost",{start:function(){var b=e(this).data("resizable"),a=b.options,c=b.size;b.ghost=b.originalElement.clone();b.ghost.css({opacity:0.25,display:"block",position:"relative",height:c.height,width:c.width,margin:0,left:0,top:0}).addClass("ui-resizable-ghost").addClass(typeof a.ghost=="string"?a.ghost:"");b.ghost.appendTo(b.helper)},resize:function(){var b=e(this).data("resizable");
b.ghost&&b.ghost.css({position:"relative",height:b.size.height,width:b.size.width})},stop:function(){var b=e(this).data("resizable");b.ghost&&b.helper&&b.helper.get(0).removeChild(b.ghost.get(0))}});e.ui.plugin.add("resizable","grid",{resize:function(){var b=e(this).data("resizable"),a=b.options,c=b.size,d=b.originalSize,f=b.originalPosition,g=b.axis;a.grid=typeof a.grid=="number"?[a.grid,a.grid]:a.grid;var h=Math.round((c.width-d.width)/(a.grid[0]||1))*(a.grid[0]||1);a=Math.round((c.height-d.height)/
(a.grid[1]||1))*(a.grid[1]||1);if(/^(se|s|e)$/.test(g)){b.size.width=d.width+h;b.size.height=d.height+a}else if(/^(ne)$/.test(g)){b.size.width=d.width+h;b.size.height=d.height+a;b.position.top=f.top-a}else{if(/^(sw)$/.test(g)){b.size.width=d.width+h;b.size.height=d.height+a}else{b.size.width=d.width+h;b.size.height=d.height+a;b.position.top=f.top-a}b.position.left=f.left-h}}});var m=function(b){return parseInt(b,10)||0},l=function(b){return!isNaN(parseInt(b,10))}})(jQuery);
;/*
 * jQuery UI Selectable 1.8.10
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Selectables
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function(e){e.widget("ui.selectable",e.ui.mouse,{options:{appendTo:"body",autoRefresh:true,distance:0,filter:"*",tolerance:"touch"},_create:function(){var c=this;this.element.addClass("ui-selectable");this.dragged=false;var f;this.refresh=function(){f=e(c.options.filter,c.element[0]);f.each(function(){var d=e(this),b=d.offset();e.data(this,"selectable-item",{element:this,$element:d,left:b.left,top:b.top,right:b.left+d.outerWidth(),bottom:b.top+d.outerHeight(),startselected:false,selected:d.hasClass("ui-selected"),
selecting:d.hasClass("ui-selecting"),unselecting:d.hasClass("ui-unselecting")})})};this.refresh();this.selectees=f.addClass("ui-selectee");this._mouseInit();this.helper=e("<div class='ui-selectable-helper'></div>")},destroy:function(){this.selectees.removeClass("ui-selectee").removeData("selectable-item");this.element.removeClass("ui-selectable ui-selectable-disabled").removeData("selectable").unbind(".selectable");this._mouseDestroy();return this},_mouseStart:function(c){var f=this;this.opos=[c.pageX,
c.pageY];if(!this.options.disabled){var d=this.options;this.selectees=e(d.filter,this.element[0]);this._trigger("start",c);e(d.appendTo).append(this.helper);this.helper.css({left:c.clientX,top:c.clientY,width:0,height:0});d.autoRefresh&&this.refresh();this.selectees.filter(".ui-selected").each(function(){var b=e.data(this,"selectable-item");b.startselected=true;if(!c.metaKey){b.$element.removeClass("ui-selected");b.selected=false;b.$element.addClass("ui-unselecting");b.unselecting=true;f._trigger("unselecting",
c,{unselecting:b.element})}});e(c.target).parents().andSelf().each(function(){var b=e.data(this,"selectable-item");if(b){var g=!c.metaKey||!b.$element.hasClass("ui-selected");b.$element.removeClass(g?"ui-unselecting":"ui-selected").addClass(g?"ui-selecting":"ui-unselecting");b.unselecting=!g;b.selecting=g;(b.selected=g)?f._trigger("selecting",c,{selecting:b.element}):f._trigger("unselecting",c,{unselecting:b.element});return false}})}},_mouseDrag:function(c){var f=this;this.dragged=true;if(!this.options.disabled){var d=
this.options,b=this.opos[0],g=this.opos[1],h=c.pageX,i=c.pageY;if(b>h){var j=h;h=b;b=j}if(g>i){j=i;i=g;g=j}this.helper.css({left:b,top:g,width:h-b,height:i-g});this.selectees.each(function(){var a=e.data(this,"selectable-item");if(!(!a||a.element==f.element[0])){var k=false;if(d.tolerance=="touch")k=!(a.left>h||a.right<b||a.top>i||a.bottom<g);else if(d.tolerance=="fit")k=a.left>b&&a.right<h&&a.top>g&&a.bottom<i;if(k){if(a.selected){a.$element.removeClass("ui-selected");a.selected=false}if(a.unselecting){a.$element.removeClass("ui-unselecting");
a.unselecting=false}if(!a.selecting){a.$element.addClass("ui-selecting");a.selecting=true;f._trigger("selecting",c,{selecting:a.element})}}else{if(a.selecting)if(c.metaKey&&a.startselected){a.$element.removeClass("ui-selecting");a.selecting=false;a.$element.addClass("ui-selected");a.selected=true}else{a.$element.removeClass("ui-selecting");a.selecting=false;if(a.startselected){a.$element.addClass("ui-unselecting");a.unselecting=true}f._trigger("unselecting",c,{unselecting:a.element})}if(a.selected)if(!c.metaKey&&
!a.startselected){a.$element.removeClass("ui-selected");a.selected=false;a.$element.addClass("ui-unselecting");a.unselecting=true;f._trigger("unselecting",c,{unselecting:a.element})}}}});return false}},_mouseStop:function(c){var f=this;this.dragged=false;e(".ui-unselecting",this.element[0]).each(function(){var d=e.data(this,"selectable-item");d.$element.removeClass("ui-unselecting");d.unselecting=false;d.startselected=false;f._trigger("unselected",c,{unselected:d.element})});e(".ui-selecting",this.element[0]).each(function(){var d=
e.data(this,"selectable-item");d.$element.removeClass("ui-selecting").addClass("ui-selected");d.selecting=false;d.selected=true;d.startselected=true;f._trigger("selected",c,{selected:d.element})});this._trigger("stop",c);this.helper.remove();return false}});e.extend(e.ui.selectable,{version:"1.8.10"})})(jQuery);
;/*
 * jQuery UI Sortable 1.8.10
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Sortables
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function(d){d.widget("ui.sortable",d.ui.mouse,{widgetEventPrefix:"sort",options:{appendTo:"parent",axis:false,connectWith:false,containment:false,cursor:"auto",cursorAt:false,dropOnEmpty:true,forcePlaceholderSize:false,forceHelperSize:false,grid:false,handle:false,helper:"original",items:"> *",opacity:false,placeholder:false,revert:false,scroll:true,scrollSensitivity:20,scrollSpeed:20,scope:"default",tolerance:"intersect",zIndex:1E3},_create:function(){this.containerCache={};this.element.addClass("ui-sortable");
this.refresh();this.floating=this.items.length?/left|right/.test(this.items[0].item.css("float")):false;this.offset=this.element.offset();this._mouseInit()},destroy:function(){this.element.removeClass("ui-sortable ui-sortable-disabled").removeData("sortable").unbind(".sortable");this._mouseDestroy();for(var a=this.items.length-1;a>=0;a--)this.items[a].item.removeData("sortable-item");return this},_setOption:function(a,b){if(a==="disabled"){this.options[a]=b;this.widget()[b?"addClass":"removeClass"]("ui-sortable-disabled")}else d.Widget.prototype._setOption.apply(this,
arguments)},_mouseCapture:function(a,b){if(this.reverting)return false;if(this.options.disabled||this.options.type=="static")return false;this._refreshItems(a);var c=null,e=this;d(a.target).parents().each(function(){if(d.data(this,"sortable-item")==e){c=d(this);return false}});if(d.data(a.target,"sortable-item")==e)c=d(a.target);if(!c)return false;if(this.options.handle&&!b){var f=false;d(this.options.handle,c).find("*").andSelf().each(function(){if(this==a.target)f=true});if(!f)return false}this.currentItem=
c;this._removeCurrentsFromItems();return true},_mouseStart:function(a,b,c){b=this.options;var e=this;this.currentContainer=this;this.refreshPositions();this.helper=this._createHelper(a);this._cacheHelperProportions();this._cacheMargins();this.scrollParent=this.helper.scrollParent();this.offset=this.currentItem.offset();this.offset={top:this.offset.top-this.margins.top,left:this.offset.left-this.margins.left};this.helper.css("position","absolute");this.cssPosition=this.helper.css("position");d.extend(this.offset,
{click:{left:a.pageX-this.offset.left,top:a.pageY-this.offset.top},parent:this._getParentOffset(),relative:this._getRelativeOffset()});this.originalPosition=this._generatePosition(a);this.originalPageX=a.pageX;this.originalPageY=a.pageY;b.cursorAt&&this._adjustOffsetFromHelper(b.cursorAt);this.domPosition={prev:this.currentItem.prev()[0],parent:this.currentItem.parent()[0]};this.helper[0]!=this.currentItem[0]&&this.currentItem.hide();this._createPlaceholder();b.containment&&this._setContainment();
if(b.cursor){if(d("body").css("cursor"))this._storedCursor=d("body").css("cursor");d("body").css("cursor",b.cursor)}if(b.opacity){if(this.helper.css("opacity"))this._storedOpacity=this.helper.css("opacity");this.helper.css("opacity",b.opacity)}if(b.zIndex){if(this.helper.css("zIndex"))this._storedZIndex=this.helper.css("zIndex");this.helper.css("zIndex",b.zIndex)}if(this.scrollParent[0]!=document&&this.scrollParent[0].tagName!="HTML")this.overflowOffset=this.scrollParent.offset();this._trigger("start",
a,this._uiHash());this._preserveHelperProportions||this._cacheHelperProportions();if(!c)for(c=this.containers.length-1;c>=0;c--)this.containers[c]._trigger("activate",a,e._uiHash(this));if(d.ui.ddmanager)d.ui.ddmanager.current=this;d.ui.ddmanager&&!b.dropBehaviour&&d.ui.ddmanager.prepareOffsets(this,a);this.dragging=true;this.helper.addClass("ui-sortable-helper");this._mouseDrag(a);return true},_mouseDrag:function(a){this.position=this._generatePosition(a);this.positionAbs=this._convertPositionTo("absolute");
if(!this.lastPositionAbs)this.lastPositionAbs=this.positionAbs;if(this.options.scroll){var b=this.options,c=false;if(this.scrollParent[0]!=document&&this.scrollParent[0].tagName!="HTML"){if(this.overflowOffset.top+this.scrollParent[0].offsetHeight-a.pageY<b.scrollSensitivity)this.scrollParent[0].scrollTop=c=this.scrollParent[0].scrollTop+b.scrollSpeed;else if(a.pageY-this.overflowOffset.top<b.scrollSensitivity)this.scrollParent[0].scrollTop=c=this.scrollParent[0].scrollTop-b.scrollSpeed;if(this.overflowOffset.left+
this.scrollParent[0].offsetWidth-a.pageX<b.scrollSensitivity)this.scrollParent[0].scrollLeft=c=this.scrollParent[0].scrollLeft+b.scrollSpeed;else if(a.pageX-this.overflowOffset.left<b.scrollSensitivity)this.scrollParent[0].scrollLeft=c=this.scrollParent[0].scrollLeft-b.scrollSpeed}else{if(a.pageY-d(document).scrollTop()<b.scrollSensitivity)c=d(document).scrollTop(d(document).scrollTop()-b.scrollSpeed);else if(d(window).height()-(a.pageY-d(document).scrollTop())<b.scrollSensitivity)c=d(document).scrollTop(d(document).scrollTop()+
b.scrollSpeed);if(a.pageX-d(document).scrollLeft()<b.scrollSensitivity)c=d(document).scrollLeft(d(document).scrollLeft()-b.scrollSpeed);else if(d(window).width()-(a.pageX-d(document).scrollLeft())<b.scrollSensitivity)c=d(document).scrollLeft(d(document).scrollLeft()+b.scrollSpeed)}c!==false&&d.ui.ddmanager&&!b.dropBehaviour&&d.ui.ddmanager.prepareOffsets(this,a)}this.positionAbs=this._convertPositionTo("absolute");if(!this.options.axis||this.options.axis!="y")this.helper[0].style.left=this.position.left+
"px";if(!this.options.axis||this.options.axis!="x")this.helper[0].style.top=this.position.top+"px";for(b=this.items.length-1;b>=0;b--){c=this.items[b];var e=c.item[0],f=this._intersectsWithPointer(c);if(f)if(e!=this.currentItem[0]&&this.placeholder[f==1?"next":"prev"]()[0]!=e&&!d.ui.contains(this.placeholder[0],e)&&(this.options.type=="semi-dynamic"?!d.ui.contains(this.element[0],e):true)){this.direction=f==1?"down":"up";if(this.options.tolerance=="pointer"||this._intersectsWithSides(c))this._rearrange(a,
c);else break;this._trigger("change",a,this._uiHash());break}}this._contactContainers(a);d.ui.ddmanager&&d.ui.ddmanager.drag(this,a);this._trigger("sort",a,this._uiHash());this.lastPositionAbs=this.positionAbs;return false},_mouseStop:function(a,b){if(a){d.ui.ddmanager&&!this.options.dropBehaviour&&d.ui.ddmanager.drop(this,a);if(this.options.revert){var c=this;b=c.placeholder.offset();c.reverting=true;d(this.helper).animate({left:b.left-this.offset.parent.left-c.margins.left+(this.offsetParent[0]==
document.body?0:this.offsetParent[0].scrollLeft),top:b.top-this.offset.parent.top-c.margins.top+(this.offsetParent[0]==document.body?0:this.offsetParent[0].scrollTop)},parseInt(this.options.revert,10)||500,function(){c._clear(a)})}else this._clear(a,b);return false}},cancel:function(){var a=this;if(this.dragging){this._mouseUp({target:null});this.options.helper=="original"?this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper"):this.currentItem.show();for(var b=this.containers.length-
1;b>=0;b--){this.containers[b]._trigger("deactivate",null,a._uiHash(this));if(this.containers[b].containerCache.over){this.containers[b]._trigger("out",null,a._uiHash(this));this.containers[b].containerCache.over=0}}}if(this.placeholder){this.placeholder[0].parentNode&&this.placeholder[0].parentNode.removeChild(this.placeholder[0]);this.options.helper!="original"&&this.helper&&this.helper[0].parentNode&&this.helper.remove();d.extend(this,{helper:null,dragging:false,reverting:false,_noFinalSort:null});
this.domPosition.prev?d(this.domPosition.prev).after(this.currentItem):d(this.domPosition.parent).prepend(this.currentItem)}return this},serialize:function(a){var b=this._getItemsAsjQuery(a&&a.connected),c=[];a=a||{};d(b).each(function(){var e=(d(a.item||this).attr(a.attribute||"id")||"").match(a.expression||/(.+)[-=_](.+)/);if(e)c.push((a.key||e[1]+"[]")+"="+(a.key&&a.expression?e[1]:e[2]))});!c.length&&a.key&&c.push(a.key+"=");return c.join("&")},toArray:function(a){var b=this._getItemsAsjQuery(a&&
a.connected),c=[];a=a||{};b.each(function(){c.push(d(a.item||this).attr(a.attribute||"id")||"")});return c},_intersectsWith:function(a){var b=this.positionAbs.left,c=b+this.helperProportions.width,e=this.positionAbs.top,f=e+this.helperProportions.height,g=a.left,h=g+a.width,i=a.top,k=i+a.height,j=this.offset.click.top,l=this.offset.click.left;j=e+j>i&&e+j<k&&b+l>g&&b+l<h;return this.options.tolerance=="pointer"||this.options.forcePointerForContainers||this.options.tolerance!="pointer"&&this.helperProportions[this.floating?
"width":"height"]>a[this.floating?"width":"height"]?j:g<b+this.helperProportions.width/2&&c-this.helperProportions.width/2<h&&i<e+this.helperProportions.height/2&&f-this.helperProportions.height/2<k},_intersectsWithPointer:function(a){var b=d.ui.isOverAxis(this.positionAbs.top+this.offset.click.top,a.top,a.height);a=d.ui.isOverAxis(this.positionAbs.left+this.offset.click.left,a.left,a.width);b=b&&a;a=this._getDragVerticalDirection();var c=this._getDragHorizontalDirection();if(!b)return false;return this.floating?
c&&c=="right"||a=="down"?2:1:a&&(a=="down"?2:1)},_intersectsWithSides:function(a){var b=d.ui.isOverAxis(this.positionAbs.top+this.offset.click.top,a.top+a.height/2,a.height);a=d.ui.isOverAxis(this.positionAbs.left+this.offset.click.left,a.left+a.width/2,a.width);var c=this._getDragVerticalDirection(),e=this._getDragHorizontalDirection();return this.floating&&e?e=="right"&&a||e=="left"&&!a:c&&(c=="down"&&b||c=="up"&&!b)},_getDragVerticalDirection:function(){var a=this.positionAbs.top-this.lastPositionAbs.top;
return a!=0&&(a>0?"down":"up")},_getDragHorizontalDirection:function(){var a=this.positionAbs.left-this.lastPositionAbs.left;return a!=0&&(a>0?"right":"left")},refresh:function(a){this._refreshItems(a);this.refreshPositions();return this},_connectWith:function(){var a=this.options;return a.connectWith.constructor==String?[a.connectWith]:a.connectWith},_getItemsAsjQuery:function(a){var b=[],c=[],e=this._connectWith();if(e&&a)for(a=e.length-1;a>=0;a--)for(var f=d(e[a]),g=f.length-1;g>=0;g--){var h=
d.data(f[g],"sortable");if(h&&h!=this&&!h.options.disabled)c.push([d.isFunction(h.options.items)?h.options.items.call(h.element):d(h.options.items,h.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),h])}c.push([d.isFunction(this.options.items)?this.options.items.call(this.element,null,{options:this.options,item:this.currentItem}):d(this.options.items,this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),this]);for(a=c.length-1;a>=0;a--)c[a][0].each(function(){b.push(this)});
return d(b)},_removeCurrentsFromItems:function(){for(var a=this.currentItem.find(":data(sortable-item)"),b=0;b<this.items.length;b++)for(var c=0;c<a.length;c++)a[c]==this.items[b].item[0]&&this.items.splice(b,1)},_refreshItems:function(a){this.items=[];this.containers=[this];var b=this.items,c=[[d.isFunction(this.options.items)?this.options.items.call(this.element[0],a,{item:this.currentItem}):d(this.options.items,this.element),this]],e=this._connectWith();if(e)for(var f=e.length-1;f>=0;f--)for(var g=
d(e[f]),h=g.length-1;h>=0;h--){var i=d.data(g[h],"sortable");if(i&&i!=this&&!i.options.disabled){c.push([d.isFunction(i.options.items)?i.options.items.call(i.element[0],a,{item:this.currentItem}):d(i.options.items,i.element),i]);this.containers.push(i)}}for(f=c.length-1;f>=0;f--){a=c[f][1];e=c[f][0];h=0;for(g=e.length;h<g;h++){i=d(e[h]);i.data("sortable-item",a);b.push({item:i,instance:a,width:0,height:0,left:0,top:0})}}},refreshPositions:function(a){if(this.offsetParent&&this.helper)this.offset.parent=
this._getParentOffset();for(var b=this.items.length-1;b>=0;b--){var c=this.items[b],e=this.options.toleranceElement?d(this.options.toleranceElement,c.item):c.item;if(!a){c.width=e.outerWidth();c.height=e.outerHeight()}e=e.offset();c.left=e.left;c.top=e.top}if(this.options.custom&&this.options.custom.refreshContainers)this.options.custom.refreshContainers.call(this);else for(b=this.containers.length-1;b>=0;b--){e=this.containers[b].element.offset();this.containers[b].containerCache.left=e.left;this.containers[b].containerCache.top=
e.top;this.containers[b].containerCache.width=this.containers[b].element.outerWidth();this.containers[b].containerCache.height=this.containers[b].element.outerHeight()}return this},_createPlaceholder:function(a){var b=a||this,c=b.options;if(!c.placeholder||c.placeholder.constructor==String){var e=c.placeholder;c.placeholder={element:function(){var f=d(document.createElement(b.currentItem[0].nodeName)).addClass(e||b.currentItem[0].className+" ui-sortable-placeholder").removeClass("ui-sortable-helper")[0];
if(!e)f.style.visibility="hidden";return f},update:function(f,g){if(!(e&&!c.forcePlaceholderSize)){g.height()||g.height(b.currentItem.innerHeight()-parseInt(b.currentItem.css("paddingTop")||0,10)-parseInt(b.currentItem.css("paddingBottom")||0,10));g.width()||g.width(b.currentItem.innerWidth()-parseInt(b.currentItem.css("paddingLeft")||0,10)-parseInt(b.currentItem.css("paddingRight")||0,10))}}}}b.placeholder=d(c.placeholder.element.call(b.element,b.currentItem));b.currentItem.after(b.placeholder);
c.placeholder.update(b,b.placeholder)},_contactContainers:function(a){for(var b=null,c=null,e=this.containers.length-1;e>=0;e--)if(!d.ui.contains(this.currentItem[0],this.containers[e].element[0]))if(this._intersectsWith(this.containers[e].containerCache)){if(!(b&&d.ui.contains(this.containers[e].element[0],b.element[0]))){b=this.containers[e];c=e}}else if(this.containers[e].containerCache.over){this.containers[e]._trigger("out",a,this._uiHash(this));this.containers[e].containerCache.over=0}if(b)if(this.containers.length===
1){this.containers[c]._trigger("over",a,this._uiHash(this));this.containers[c].containerCache.over=1}else if(this.currentContainer!=this.containers[c]){b=1E4;e=null;for(var f=this.positionAbs[this.containers[c].floating?"left":"top"],g=this.items.length-1;g>=0;g--)if(d.ui.contains(this.containers[c].element[0],this.items[g].item[0])){var h=this.items[g][this.containers[c].floating?"left":"top"];if(Math.abs(h-f)<b){b=Math.abs(h-f);e=this.items[g]}}if(e||this.options.dropOnEmpty){this.currentContainer=
this.containers[c];e?this._rearrange(a,e,null,true):this._rearrange(a,null,this.containers[c].element,true);this._trigger("change",a,this._uiHash());this.containers[c]._trigger("change",a,this._uiHash(this));this.options.placeholder.update(this.currentContainer,this.placeholder);this.containers[c]._trigger("over",a,this._uiHash(this));this.containers[c].containerCache.over=1}}},_createHelper:function(a){var b=this.options;a=d.isFunction(b.helper)?d(b.helper.apply(this.element[0],[a,this.currentItem])):
b.helper=="clone"?this.currentItem.clone():this.currentItem;a.parents("body").length||d(b.appendTo!="parent"?b.appendTo:this.currentItem[0].parentNode)[0].appendChild(a[0]);if(a[0]==this.currentItem[0])this._storedCSS={width:this.currentItem[0].style.width,height:this.currentItem[0].style.height,position:this.currentItem.css("position"),top:this.currentItem.css("top"),left:this.currentItem.css("left")};if(a[0].style.width==""||b.forceHelperSize)a.width(this.currentItem.width());if(a[0].style.height==
""||b.forceHelperSize)a.height(this.currentItem.height());return a},_adjustOffsetFromHelper:function(a){if(typeof a=="string")a=a.split(" ");if(d.isArray(a))a={left:+a[0],top:+a[1]||0};if("left"in a)this.offset.click.left=a.left+this.margins.left;if("right"in a)this.offset.click.left=this.helperProportions.width-a.right+this.margins.left;if("top"in a)this.offset.click.top=a.top+this.margins.top;if("bottom"in a)this.offset.click.top=this.helperProportions.height-a.bottom+this.margins.top},_getParentOffset:function(){this.offsetParent=
this.helper.offsetParent();var a=this.offsetParent.offset();if(this.cssPosition=="absolute"&&this.scrollParent[0]!=document&&d.ui.contains(this.scrollParent[0],this.offsetParent[0])){a.left+=this.scrollParent.scrollLeft();a.top+=this.scrollParent.scrollTop()}if(this.offsetParent[0]==document.body||this.offsetParent[0].tagName&&this.offsetParent[0].tagName.toLowerCase()=="html"&&d.browser.msie)a={top:0,left:0};return{top:a.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:a.left+(parseInt(this.offsetParent.css("borderLeftWidth"),
10)||0)}},_getRelativeOffset:function(){if(this.cssPosition=="relative"){var a=this.currentItem.position();return{top:a.top-(parseInt(this.helper.css("top"),10)||0)+this.scrollParent.scrollTop(),left:a.left-(parseInt(this.helper.css("left"),10)||0)+this.scrollParent.scrollLeft()}}else return{top:0,left:0}},_cacheMargins:function(){this.margins={left:parseInt(this.currentItem.css("marginLeft"),10)||0,top:parseInt(this.currentItem.css("marginTop"),10)||0}},_cacheHelperProportions:function(){this.helperProportions=
{width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var a=this.options;if(a.containment=="parent")a.containment=this.helper[0].parentNode;if(a.containment=="document"||a.containment=="window")this.containment=[0-this.offset.relative.left-this.offset.parent.left,0-this.offset.relative.top-this.offset.parent.top,d(a.containment=="document"?document:window).width()-this.helperProportions.width-this.margins.left,(d(a.containment=="document"?document:window).height()||
document.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top];if(!/^(document|window|parent)$/.test(a.containment)){var b=d(a.containment)[0];a=d(a.containment).offset();var c=d(b).css("overflow")!="hidden";this.containment=[a.left+(parseInt(d(b).css("borderLeftWidth"),10)||0)+(parseInt(d(b).css("paddingLeft"),10)||0)-this.margins.left,a.top+(parseInt(d(b).css("borderTopWidth"),10)||0)+(parseInt(d(b).css("paddingTop"),10)||0)-this.margins.top,a.left+(c?Math.max(b.scrollWidth,
b.offsetWidth):b.offsetWidth)-(parseInt(d(b).css("borderLeftWidth"),10)||0)-(parseInt(d(b).css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left,a.top+(c?Math.max(b.scrollHeight,b.offsetHeight):b.offsetHeight)-(parseInt(d(b).css("borderTopWidth"),10)||0)-(parseInt(d(b).css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top]}},_convertPositionTo:function(a,b){if(!b)b=this.position;a=a=="absolute"?1:-1;var c=this.cssPosition=="absolute"&&!(this.scrollParent[0]!=
document&&d.ui.contains(this.scrollParent[0],this.offsetParent[0]))?this.offsetParent:this.scrollParent,e=/(html|body)/i.test(c[0].tagName);return{top:b.top+this.offset.relative.top*a+this.offset.parent.top*a-(d.browser.safari&&this.cssPosition=="fixed"?0:(this.cssPosition=="fixed"?-this.scrollParent.scrollTop():e?0:c.scrollTop())*a),left:b.left+this.offset.relative.left*a+this.offset.parent.left*a-(d.browser.safari&&this.cssPosition=="fixed"?0:(this.cssPosition=="fixed"?-this.scrollParent.scrollLeft():
e?0:c.scrollLeft())*a)}},_generatePosition:function(a){var b=this.options,c=this.cssPosition=="absolute"&&!(this.scrollParent[0]!=document&&d.ui.contains(this.scrollParent[0],this.offsetParent[0]))?this.offsetParent:this.scrollParent,e=/(html|body)/i.test(c[0].tagName);if(this.cssPosition=="relative"&&!(this.scrollParent[0]!=document&&this.scrollParent[0]!=this.offsetParent[0]))this.offset.relative=this._getRelativeOffset();var f=a.pageX,g=a.pageY;if(this.originalPosition){if(this.containment){if(a.pageX-
this.offset.click.left<this.containment[0])f=this.containment[0]+this.offset.click.left;if(a.pageY-this.offset.click.top<this.containment[1])g=this.containment[1]+this.offset.click.top;if(a.pageX-this.offset.click.left>this.containment[2])f=this.containment[2]+this.offset.click.left;if(a.pageY-this.offset.click.top>this.containment[3])g=this.containment[3]+this.offset.click.top}if(b.grid){g=this.originalPageY+Math.round((g-this.originalPageY)/b.grid[1])*b.grid[1];g=this.containment?!(g-this.offset.click.top<
this.containment[1]||g-this.offset.click.top>this.containment[3])?g:!(g-this.offset.click.top<this.containment[1])?g-b.grid[1]:g+b.grid[1]:g;f=this.originalPageX+Math.round((f-this.originalPageX)/b.grid[0])*b.grid[0];f=this.containment?!(f-this.offset.click.left<this.containment[0]||f-this.offset.click.left>this.containment[2])?f:!(f-this.offset.click.left<this.containment[0])?f-b.grid[0]:f+b.grid[0]:f}}return{top:g-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+(d.browser.safari&&
this.cssPosition=="fixed"?0:this.cssPosition=="fixed"?-this.scrollParent.scrollTop():e?0:c.scrollTop()),left:f-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+(d.browser.safari&&this.cssPosition=="fixed"?0:this.cssPosition=="fixed"?-this.scrollParent.scrollLeft():e?0:c.scrollLeft())}},_rearrange:function(a,b,c,e){c?c[0].appendChild(this.placeholder[0]):b.item[0].parentNode.insertBefore(this.placeholder[0],this.direction=="down"?b.item[0]:b.item[0].nextSibling);this.counter=
this.counter?++this.counter:1;var f=this,g=this.counter;window.setTimeout(function(){g==f.counter&&f.refreshPositions(!e)},0)},_clear:function(a,b){this.reverting=false;var c=[];!this._noFinalSort&&this.currentItem[0].parentNode&&this.placeholder.before(this.currentItem);this._noFinalSort=null;if(this.helper[0]==this.currentItem[0]){for(var e in this._storedCSS)if(this._storedCSS[e]=="auto"||this._storedCSS[e]=="static")this._storedCSS[e]="";this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper")}else this.currentItem.show();
this.fromOutside&&!b&&c.push(function(f){this._trigger("receive",f,this._uiHash(this.fromOutside))});if((this.fromOutside||this.domPosition.prev!=this.currentItem.prev().not(".ui-sortable-helper")[0]||this.domPosition.parent!=this.currentItem.parent()[0])&&!b)c.push(function(f){this._trigger("update",f,this._uiHash())});if(!d.ui.contains(this.element[0],this.currentItem[0])){b||c.push(function(f){this._trigger("remove",f,this._uiHash())});for(e=this.containers.length-1;e>=0;e--)if(d.ui.contains(this.containers[e].element[0],
this.currentItem[0])&&!b){c.push(function(f){return function(g){f._trigger("receive",g,this._uiHash(this))}}.call(this,this.containers[e]));c.push(function(f){return function(g){f._trigger("update",g,this._uiHash(this))}}.call(this,this.containers[e]))}}for(e=this.containers.length-1;e>=0;e--){b||c.push(function(f){return function(g){f._trigger("deactivate",g,this._uiHash(this))}}.call(this,this.containers[e]));if(this.containers[e].containerCache.over){c.push(function(f){return function(g){f._trigger("out",
g,this._uiHash(this))}}.call(this,this.containers[e]));this.containers[e].containerCache.over=0}}this._storedCursor&&d("body").css("cursor",this._storedCursor);this._storedOpacity&&this.helper.css("opacity",this._storedOpacity);if(this._storedZIndex)this.helper.css("zIndex",this._storedZIndex=="auto"?"":this._storedZIndex);this.dragging=false;if(this.cancelHelperRemoval){if(!b){this._trigger("beforeStop",a,this._uiHash());for(e=0;e<c.length;e++)c[e].call(this,a);this._trigger("stop",a,this._uiHash())}return false}b||
this._trigger("beforeStop",a,this._uiHash());this.placeholder[0].parentNode.removeChild(this.placeholder[0]);this.helper[0]!=this.currentItem[0]&&this.helper.remove();this.helper=null;if(!b){for(e=0;e<c.length;e++)c[e].call(this,a);this._trigger("stop",a,this._uiHash())}this.fromOutside=false;return true},_trigger:function(){d.Widget.prototype._trigger.apply(this,arguments)===false&&this.cancel()},_uiHash:function(a){var b=a||this;return{helper:b.helper,placeholder:b.placeholder||d([]),position:b.position,
originalPosition:b.originalPosition,offset:b.positionAbs,item:b.currentItem,sender:a?a.element:null}}});d.extend(d.ui.sortable,{version:"1.8.10"})})(jQuery);
;/*
 * jQuery UI Accordion 1.8.10
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Accordion
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 */
(function(c){c.widget("ui.accordion",{options:{active:0,animated:"slide",autoHeight:true,clearStyle:false,collapsible:false,event:"click",fillSpace:false,header:"> li > :first-child,> :not(li):even",icons:{header:"ui-icon-triangle-1-e",headerSelected:"ui-icon-triangle-1-s"},navigation:false,navigationFilter:function(){return this.href.toLowerCase()===location.href.toLowerCase()}},_create:function(){var a=this,b=a.options;a.running=0;a.element.addClass("ui-accordion ui-widget ui-helper-reset").children("li").addClass("ui-accordion-li-fix");
a.headers=a.element.find(b.header).addClass("ui-accordion-header ui-helper-reset ui-state-default ui-corner-all").bind("mouseenter.accordion",function(){b.disabled||c(this).addClass("ui-state-hover")}).bind("mouseleave.accordion",function(){b.disabled||c(this).removeClass("ui-state-hover")}).bind("focus.accordion",function(){b.disabled||c(this).addClass("ui-state-focus")}).bind("blur.accordion",function(){b.disabled||c(this).removeClass("ui-state-focus")});a.headers.next().addClass("ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom");
if(b.navigation){var d=a.element.find("a").filter(b.navigationFilter).eq(0);if(d.length){var h=d.closest(".ui-accordion-header");a.active=h.length?h:d.closest(".ui-accordion-content").prev()}}a.active=a._findActive(a.active||b.active).addClass("ui-state-default ui-state-active").toggleClass("ui-corner-all").toggleClass("ui-corner-top");a.active.next().addClass("ui-accordion-content-active");a._createIcons();a.resize();a.element.attr("role","tablist");a.headers.attr("role","tab").bind("keydown.accordion",
function(f){return a._keydown(f)}).next().attr("role","tabpanel");a.headers.not(a.active||"").attr({"aria-expanded":"false",tabIndex:-1}).next().hide();a.active.length?a.active.attr({"aria-expanded":"true",tabIndex:0}):a.headers.eq(0).attr("tabIndex",0);c.browser.safari||a.headers.find("a").attr("tabIndex",-1);b.event&&a.headers.bind(b.event.split(" ").join(".accordion ")+".accordion",function(f){a._clickHandler.call(a,f,this);f.preventDefault()})},_createIcons:function(){var a=this.options;if(a.icons){c("<span></span>").addClass("ui-icon "+
a.icons.header).prependTo(this.headers);this.active.children(".ui-icon").toggleClass(a.icons.header).toggleClass(a.icons.headerSelected);this.element.addClass("ui-accordion-icons")}},_destroyIcons:function(){this.headers.children(".ui-icon").remove();this.element.removeClass("ui-accordion-icons")},destroy:function(){var a=this.options;this.element.removeClass("ui-accordion ui-widget ui-helper-reset").removeAttr("role");this.headers.unbind(".accordion").removeClass("ui-accordion-header ui-accordion-disabled ui-helper-reset ui-state-default ui-corner-all ui-state-active ui-state-disabled ui-corner-top").removeAttr("role").removeAttr("aria-expanded").removeAttr("tabIndex");
this.headers.find("a").removeAttr("tabIndex");this._destroyIcons();var b=this.headers.next().css("display","").removeAttr("role").removeClass("ui-helper-reset ui-widget-content ui-corner-bottom ui-accordion-content ui-accordion-content-active ui-accordion-disabled ui-state-disabled");if(a.autoHeight||a.fillHeight)b.css("height","");return c.Widget.prototype.destroy.call(this)},_setOption:function(a,b){c.Widget.prototype._setOption.apply(this,arguments);a=="active"&&this.activate(b);if(a=="icons"){this._destroyIcons();
b&&this._createIcons()}if(a=="disabled")this.headers.add(this.headers.next())[b?"addClass":"removeClass"]("ui-accordion-disabled ui-state-disabled")},_keydown:function(a){if(!(this.options.disabled||a.altKey||a.ctrlKey)){var b=c.ui.keyCode,d=this.headers.length,h=this.headers.index(a.target),f=false;switch(a.keyCode){case b.RIGHT:case b.DOWN:f=this.headers[(h+1)%d];break;case b.LEFT:case b.UP:f=this.headers[(h-1+d)%d];break;case b.SPACE:case b.ENTER:this._clickHandler({target:a.target},a.target);
a.preventDefault()}if(f){c(a.target).attr("tabIndex",-1);c(f).attr("tabIndex",0);f.focus();return false}return true}},resize:function(){var a=this.options,b;if(a.fillSpace){if(c.browser.msie){var d=this.element.parent().css("overflow");this.element.parent().css("overflow","hidden")}b=this.element.parent().height();c.browser.msie&&this.element.parent().css("overflow",d);this.headers.each(function(){b-=c(this).outerHeight(true)});this.headers.next().each(function(){c(this).height(Math.max(0,b-c(this).innerHeight()+
c(this).height()))}).css("overflow","auto")}else if(a.autoHeight){b=0;this.headers.next().each(function(){b=Math.max(b,c(this).height("").height())}).height(b)}return this},activate:function(a){this.options.active=a;a=this._findActive(a)[0];this._clickHandler({target:a},a);return this},_findActive:function(a){return a?typeof a==="number"?this.headers.filter(":eq("+a+")"):this.headers.not(this.headers.not(a)):a===false?c([]):this.headers.filter(":eq(0)")},_clickHandler:function(a,b){var d=this.options;
if(!d.disabled)if(a.target){a=c(a.currentTarget||b);b=a[0]===this.active[0];d.active=d.collapsible&&b?false:this.headers.index(a);if(!(this.running||!d.collapsible&&b)){var h=this.active;j=a.next();g=this.active.next();e={options:d,newHeader:b&&d.collapsible?c([]):a,oldHeader:this.active,newContent:b&&d.collapsible?c([]):j,oldContent:g};var f=this.headers.index(this.active[0])>this.headers.index(a[0]);this.active=b?c([]):a;this._toggle(j,g,e,b,f);h.removeClass("ui-state-active ui-corner-top").addClass("ui-state-default ui-corner-all").children(".ui-icon").removeClass(d.icons.headerSelected).addClass(d.icons.header);
if(!b){a.removeClass("ui-state-default ui-corner-all").addClass("ui-state-active ui-corner-top").children(".ui-icon").removeClass(d.icons.header).addClass(d.icons.headerSelected);a.next().addClass("ui-accordion-content-active")}}}else if(d.collapsible){this.active.removeClass("ui-state-active ui-corner-top").addClass("ui-state-default ui-corner-all").children(".ui-icon").removeClass(d.icons.headerSelected).addClass(d.icons.header);this.active.next().addClass("ui-accordion-content-active");var g=this.active.next(),
e={options:d,newHeader:c([]),oldHeader:d.active,newContent:c([]),oldContent:g},j=this.active=c([]);this._toggle(j,g,e)}},_toggle:function(a,b,d,h,f){var g=this,e=g.options;g.toShow=a;g.toHide=b;g.data=d;var j=function(){if(g)return g._completed.apply(g,arguments)};g._trigger("changestart",null,g.data);g.running=b.size()===0?a.size():b.size();if(e.animated){d={};d=e.collapsible&&h?{toShow:c([]),toHide:b,complete:j,down:f,autoHeight:e.autoHeight||e.fillSpace}:{toShow:a,toHide:b,complete:j,down:f,autoHeight:e.autoHeight||
e.fillSpace};if(!e.proxied)e.proxied=e.animated;if(!e.proxiedDuration)e.proxiedDuration=e.duration;e.animated=c.isFunction(e.proxied)?e.proxied(d):e.proxied;e.duration=c.isFunction(e.proxiedDuration)?e.proxiedDuration(d):e.proxiedDuration;h=c.ui.accordion.animations;var i=e.duration,k=e.animated;if(k&&!h[k]&&!c.easing[k])k="slide";h[k]||(h[k]=function(l){this.slide(l,{easing:k,duration:i||700})});h[k](d)}else{if(e.collapsible&&h)a.toggle();else{b.hide();a.show()}j(true)}b.prev().attr({"aria-expanded":"false",
tabIndex:-1}).blur();a.prev().attr({"aria-expanded":"true",tabIndex:0}).focus()},_completed:function(a){this.running=a?0:--this.running;if(!this.running){this.options.clearStyle&&this.toShow.add(this.toHide).css({height:"",overflow:""});this.toHide.removeClass("ui-accordion-content-active");if(this.toHide.length)this.toHide.parent()[0].className=this.toHide.parent()[0].className;this._trigger("change",null,this.data)}}});c.extend(c.ui.accordion,{version:"1.8.10",animations:{slide:function(a,b){a=
c.extend({easing:"swing",duration:300},a,b);if(a.toHide.size())if(a.toShow.size()){var d=a.toShow.css("overflow"),h=0,f={},g={},e;b=a.toShow;e=b[0].style.width;b.width(parseInt(b.parent().width(),10)-parseInt(b.css("paddingLeft"),10)-parseInt(b.css("paddingRight"),10)-(parseInt(b.css("borderLeftWidth"),10)||0)-(parseInt(b.css("borderRightWidth"),10)||0));c.each(["height","paddingTop","paddingBottom"],function(j,i){g[i]="hide";j=(""+c.css(a.toShow[0],i)).match(/^([\d+-.]+)(.*)$/);f[i]={value:j[1],
unit:j[2]||"px"}});a.toShow.css({height:0,overflow:"hidden"}).show();a.toHide.filter(":hidden").each(a.complete).end().filter(":visible").animate(g,{step:function(j,i){if(i.prop=="height")h=i.end-i.start===0?0:(i.now-i.start)/(i.end-i.start);a.toShow[0].style[i.prop]=h*f[i.prop].value+f[i.prop].unit},duration:a.duration,easing:a.easing,complete:function(){a.autoHeight||a.toShow.css("height","");a.toShow.css({width:e,overflow:d});a.complete()}})}else a.toHide.animate({height:"hide",paddingTop:"hide",
paddingBottom:"hide"},a);else a.toShow.animate({height:"show",paddingTop:"show",paddingBottom:"show"},a)},bounceslide:function(a){this.slide(a,{easing:a.down?"easeOutBounce":"swing",duration:a.down?1E3:200})}}})})(jQuery);
;/*
 * jQuery UI Autocomplete 1.8.10
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Autocomplete
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 *	jquery.ui.position.js
 */
(function(d){var e=0;d.widget("ui.autocomplete",{options:{appendTo:"body",delay:300,minLength:1,position:{my:"left top",at:"left bottom",collision:"none"},source:null},pending:0,_create:function(){var a=this,b=this.element[0].ownerDocument,g;this.element.addClass("ui-autocomplete-input").attr("autocomplete","off").attr({role:"textbox","aria-autocomplete":"list","aria-haspopup":"true"}).bind("keydown.autocomplete",function(c){if(!(a.options.disabled||a.element.attr("readonly"))){g=false;var f=d.ui.keyCode;
switch(c.keyCode){case f.PAGE_UP:a._move("previousPage",c);break;case f.PAGE_DOWN:a._move("nextPage",c);break;case f.UP:a._move("previous",c);c.preventDefault();break;case f.DOWN:a._move("next",c);c.preventDefault();break;case f.ENTER:case f.NUMPAD_ENTER:if(a.menu.active){g=true;c.preventDefault()}case f.TAB:if(!a.menu.active)return;a.menu.select(c);break;case f.ESCAPE:a.element.val(a.term);a.close(c);break;default:clearTimeout(a.searching);a.searching=setTimeout(function(){if(a.term!=a.element.val()){a.selectedItem=
null;a.search(null,c)}},a.options.delay);break}}}).bind("keypress.autocomplete",function(c){if(g){g=false;c.preventDefault()}}).bind("focus.autocomplete",function(){if(!a.options.disabled){a.selectedItem=null;a.previous=a.element.val()}}).bind("blur.autocomplete",function(c){if(!a.options.disabled){clearTimeout(a.searching);a.closing=setTimeout(function(){a.close(c);a._change(c)},150)}});this._initSource();this.response=function(){return a._response.apply(a,arguments)};this.menu=d("<ul></ul>").addClass("ui-autocomplete").appendTo(d(this.options.appendTo||
"body",b)[0]).mousedown(function(c){var f=a.menu.element[0];d(c.target).closest(".ui-menu-item").length||setTimeout(function(){d(document).one("mousedown",function(h){h.target!==a.element[0]&&h.target!==f&&!d.ui.contains(f,h.target)&&a.close()})},1);setTimeout(function(){clearTimeout(a.closing)},13)}).menu({focus:function(c,f){f=f.item.data("item.autocomplete");false!==a._trigger("focus",c,{item:f})&&/^key/.test(c.originalEvent.type)&&a.element.val(f.value)},selected:function(c,f){var h=f.item.data("item.autocomplete"),
i=a.previous;if(a.element[0]!==b.activeElement){a.element.focus();a.previous=i;setTimeout(function(){a.previous=i;a.selectedItem=h},1)}false!==a._trigger("select",c,{item:h})&&a.element.val(h.value);a.term=a.element.val();a.close(c);a.selectedItem=h},blur:function(){a.menu.element.is(":visible")&&a.element.val()!==a.term&&a.element.val(a.term)}}).zIndex(this.element.zIndex()+1).css({top:0,left:0}).hide().data("menu");d.fn.bgiframe&&this.menu.element.bgiframe()},destroy:function(){this.element.removeClass("ui-autocomplete-input").removeAttr("autocomplete").removeAttr("role").removeAttr("aria-autocomplete").removeAttr("aria-haspopup");
this.menu.element.remove();d.Widget.prototype.destroy.call(this)},_setOption:function(a,b){d.Widget.prototype._setOption.apply(this,arguments);a==="source"&&this._initSource();if(a==="appendTo")this.menu.element.appendTo(d(b||"body",this.element[0].ownerDocument)[0]);a==="disabled"&&b&&this.xhr&&this.xhr.abort()},_initSource:function(){var a=this,b,g;if(d.isArray(this.options.source)){b=this.options.source;this.source=function(c,f){f(d.ui.autocomplete.filter(b,c.term))}}else if(typeof this.options.source===
"string"){g=this.options.source;this.source=function(c,f){a.xhr&&a.xhr.abort();a.xhr=d.ajax({url:g,data:c,dataType:"json",autocompleteRequest:++e,success:function(h){this.autocompleteRequest===e&&f(h)},error:function(){this.autocompleteRequest===e&&f([])}})}}else this.source=this.options.source},search:function(a,b){a=a!=null?a:this.element.val();this.term=this.element.val();if(a.length<this.options.minLength)return this.close(b);clearTimeout(this.closing);if(this._trigger("search",b)!==false)return this._search(a)},
_search:function(a){this.pending++;this.element.addClass("ui-autocomplete-loading");this.source({term:a},this.response)},_response:function(a){if(!this.options.disabled&&a&&a.length){a=this._normalize(a);this._suggest(a);this._trigger("open")}else this.close();this.pending--;this.pending||this.element.removeClass("ui-autocomplete-loading")},close:function(a){clearTimeout(this.closing);if(this.menu.element.is(":visible")){this.menu.element.hide();this.menu.deactivate();this._trigger("close",a)}},_change:function(a){this.previous!==
this.element.val()&&this._trigger("change",a,{item:this.selectedItem})},_normalize:function(a){if(a.length&&a[0].label&&a[0].value)return a;return d.map(a,function(b){if(typeof b==="string")return{label:b,value:b};return d.extend({label:b.label||b.value,value:b.value||b.label},b)})},_suggest:function(a){var b=this.menu.element.empty().zIndex(this.element.zIndex()+1);this._renderMenu(b,a);this.menu.deactivate();this.menu.refresh();b.show();this._resizeMenu();b.position(d.extend({of:this.element},this.options.position))},
_resizeMenu:function(){var a=this.menu.element;a.outerWidth(Math.max(a.width("").outerWidth(),this.element.outerWidth()))},_renderMenu:function(a,b){var g=this;d.each(b,function(c,f){g._renderItem(a,f)})},_renderItem:function(a,b){return d("<li></li>").data("item.autocomplete",b).append(d("<a></a>").text(b.label)).appendTo(a)},_move:function(a,b){if(this.menu.element.is(":visible"))if(this.menu.first()&&/^previous/.test(a)||this.menu.last()&&/^next/.test(a)){this.element.val(this.term);this.menu.deactivate()}else this.menu[a](b);
else this.search(null,b)},widget:function(){return this.menu.element}});d.extend(d.ui.autocomplete,{escapeRegex:function(a){return a.replace(/[-[\]{}()*+?.,\\^$|#\s]/g,"\\$&")},filter:function(a,b){var g=new RegExp(d.ui.autocomplete.escapeRegex(b),"i");return d.grep(a,function(c){return g.test(c.label||c.value||c)})}})})(jQuery);
(function(d){d.widget("ui.menu",{_create:function(){var e=this;this.element.addClass("ui-menu ui-widget ui-widget-content ui-corner-all").attr({role:"listbox","aria-activedescendant":"ui-active-menuitem"}).click(function(a){if(d(a.target).closest(".ui-menu-item a").length){a.preventDefault();e.select(a)}});this.refresh()},refresh:function(){var e=this;this.element.children("li:not(.ui-menu-item):has(a)").addClass("ui-menu-item").attr("role","menuitem").children("a").addClass("ui-corner-all").attr("tabindex",
-1).mouseenter(function(a){e.activate(a,d(this).parent())}).mouseleave(function(){e.deactivate()})},activate:function(e,a){this.deactivate();if(this.hasScroll()){var b=a.offset().top-this.element.offset().top,g=this.element.attr("scrollTop"),c=this.element.height();if(b<0)this.element.attr("scrollTop",g+b);else b>=c&&this.element.attr("scrollTop",g+b-c+a.height())}this.active=a.eq(0).children("a").addClass("ui-state-hover").attr("id","ui-active-menuitem").end();this._trigger("focus",e,{item:a})},
deactivate:function(){if(this.active){this.active.children("a").removeClass("ui-state-hover").removeAttr("id");this._trigger("blur");this.active=null}},next:function(e){this.move("next",".ui-menu-item:first",e)},previous:function(e){this.move("prev",".ui-menu-item:last",e)},first:function(){return this.active&&!this.active.prevAll(".ui-menu-item").length},last:function(){return this.active&&!this.active.nextAll(".ui-menu-item").length},move:function(e,a,b){if(this.active){e=this.active[e+"All"](".ui-menu-item").eq(0);
e.length?this.activate(b,e):this.activate(b,this.element.children(a))}else this.activate(b,this.element.children(a))},nextPage:function(e){if(this.hasScroll())if(!this.active||this.last())this.activate(e,this.element.children(".ui-menu-item:first"));else{var a=this.active.offset().top,b=this.element.height(),g=this.element.children(".ui-menu-item").filter(function(){var c=d(this).offset().top-a-b+d(this).height();return c<10&&c>-10});g.length||(g=this.element.children(".ui-menu-item:last"));this.activate(e,
g)}else this.activate(e,this.element.children(".ui-menu-item").filter(!this.active||this.last()?":first":":last"))},previousPage:function(e){if(this.hasScroll())if(!this.active||this.first())this.activate(e,this.element.children(".ui-menu-item:last"));else{var a=this.active.offset().top,b=this.element.height();result=this.element.children(".ui-menu-item").filter(function(){var g=d(this).offset().top-a+b-d(this).height();return g<10&&g>-10});result.length||(result=this.element.children(".ui-menu-item:first"));
this.activate(e,result)}else this.activate(e,this.element.children(".ui-menu-item").filter(!this.active||this.first()?":last":":first"))},hasScroll:function(){return this.element.height()<this.element.attr("scrollHeight")},select:function(e){this._trigger("selected",e,{item:this.active})}})})(jQuery);
;/*
 * jQuery UI Button 1.8.10
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Button
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 */
(function(a){var g,i=function(b){a(":ui-button",b.target.form).each(function(){var c=a(this).data("button");setTimeout(function(){c.refresh()},1)})},h=function(b){var c=b.name,d=b.form,f=a([]);if(c)f=d?a(d).find("[name='"+c+"']"):a("[name='"+c+"']",b.ownerDocument).filter(function(){return!this.form});return f};a.widget("ui.button",{options:{disabled:null,text:true,label:null,icons:{primary:null,secondary:null}},_create:function(){this.element.closest("form").unbind("reset.button").bind("reset.button",
i);if(typeof this.options.disabled!=="boolean")this.options.disabled=this.element.attr("disabled");this._determineButtonType();this.hasTitle=!!this.buttonElement.attr("title");var b=this,c=this.options,d=this.type==="checkbox"||this.type==="radio",f="ui-state-hover"+(!d?" ui-state-active":"");if(c.label===null)c.label=this.buttonElement.html();if(this.element.is(":disabled"))c.disabled=true;this.buttonElement.addClass("ui-button ui-widget ui-state-default ui-corner-all").attr("role","button").bind("mouseenter.button",
function(){if(!c.disabled){a(this).addClass("ui-state-hover");this===g&&a(this).addClass("ui-state-active")}}).bind("mouseleave.button",function(){c.disabled||a(this).removeClass(f)}).bind("focus.button",function(){a(this).addClass("ui-state-focus")}).bind("blur.button",function(){a(this).removeClass("ui-state-focus")});d&&this.element.bind("change.button",function(){b.refresh()});if(this.type==="checkbox")this.buttonElement.bind("click.button",function(){if(c.disabled)return false;a(this).toggleClass("ui-state-active");
b.buttonElement.attr("aria-pressed",b.element[0].checked)});else if(this.type==="radio")this.buttonElement.bind("click.button",function(){if(c.disabled)return false;a(this).addClass("ui-state-active");b.buttonElement.attr("aria-pressed",true);var e=b.element[0];h(e).not(e).map(function(){return a(this).button("widget")[0]}).removeClass("ui-state-active").attr("aria-pressed",false)});else{this.buttonElement.bind("mousedown.button",function(){if(c.disabled)return false;a(this).addClass("ui-state-active");
g=this;a(document).one("mouseup",function(){g=null})}).bind("mouseup.button",function(){if(c.disabled)return false;a(this).removeClass("ui-state-active")}).bind("keydown.button",function(e){if(c.disabled)return false;if(e.keyCode==a.ui.keyCode.SPACE||e.keyCode==a.ui.keyCode.ENTER)a(this).addClass("ui-state-active")}).bind("keyup.button",function(){a(this).removeClass("ui-state-active")});this.buttonElement.is("a")&&this.buttonElement.keyup(function(e){e.keyCode===a.ui.keyCode.SPACE&&a(this).click()})}this._setOption("disabled",
c.disabled)},_determineButtonType:function(){this.type=this.element.is(":checkbox")?"checkbox":this.element.is(":radio")?"radio":this.element.is("input")?"input":"button";if(this.type==="checkbox"||this.type==="radio"){this.buttonElement=this.element.parents().last().find("label[for="+this.element.attr("id")+"]");this.element.addClass("ui-helper-hidden-accessible");var b=this.element.is(":checked");b&&this.buttonElement.addClass("ui-state-active");this.buttonElement.attr("aria-pressed",b)}else this.buttonElement=
this.element},widget:function(){return this.buttonElement},destroy:function(){this.element.removeClass("ui-helper-hidden-accessible");this.buttonElement.removeClass("ui-button ui-widget ui-state-default ui-corner-all ui-state-hover ui-state-active  ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only").removeAttr("role").removeAttr("aria-pressed").html(this.buttonElement.find(".ui-button-text").html());this.hasTitle||
this.buttonElement.removeAttr("title");a.Widget.prototype.destroy.call(this)},_setOption:function(b,c){a.Widget.prototype._setOption.apply(this,arguments);if(b==="disabled")c?this.element.attr("disabled",true):this.element.removeAttr("disabled");this._resetButton()},refresh:function(){var b=this.element.is(":disabled");b!==this.options.disabled&&this._setOption("disabled",b);if(this.type==="radio")h(this.element[0]).each(function(){a(this).is(":checked")?a(this).button("widget").addClass("ui-state-active").attr("aria-pressed",
true):a(this).button("widget").removeClass("ui-state-active").attr("aria-pressed",false)});else if(this.type==="checkbox")this.element.is(":checked")?this.buttonElement.addClass("ui-state-active").attr("aria-pressed",true):this.buttonElement.removeClass("ui-state-active").attr("aria-pressed",false)},_resetButton:function(){if(this.type==="input")this.options.label&&this.element.val(this.options.label);else{var b=this.buttonElement.removeClass("ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only"),
c=a("<span></span>").addClass("ui-button-text").html(this.options.label).appendTo(b.empty()).text(),d=this.options.icons,f=d.primary&&d.secondary,e=[];if(d.primary||d.secondary){e.push("ui-button-text-icon"+(f?"s":d.primary?"-primary":"-secondary"));d.primary&&b.prepend("<span class='ui-button-icon-primary ui-icon "+d.primary+"'></span>");d.secondary&&b.append("<span class='ui-button-icon-secondary ui-icon "+d.secondary+"'></span>");if(!this.options.text){e.push(f?"ui-button-icons-only":"ui-button-icon-only");
b.removeClass("ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary");this.hasTitle||b.attr("title",c)}}else e.push("ui-button-text-only");b.addClass(e.join(" "))}}});a.widget("ui.buttonset",{options:{items:":button, :submit, :reset, :checkbox, :radio, a, :data(button)"},_create:function(){this.element.addClass("ui-buttonset")},_init:function(){this.refresh()},_setOption:function(b,c){b==="disabled"&&this.buttons.button("option",b,c);a.Widget.prototype._setOption.apply(this,
arguments)},refresh:function(){this.buttons=this.element.find(this.options.items).filter(":ui-button").button("refresh").end().not(":ui-button").button().end().map(function(){return a(this).button("widget")[0]}).removeClass("ui-corner-all ui-corner-left ui-corner-right").filter(":first").addClass("ui-corner-left").end().filter(":last").addClass("ui-corner-right").end().end()},destroy:function(){this.element.removeClass("ui-buttonset");this.buttons.map(function(){return a(this).button("widget")[0]}).removeClass("ui-corner-left ui-corner-right").end().button("destroy");
a.Widget.prototype.destroy.call(this)}})})(jQuery);
;/*
 * jQuery UI Dialog 1.8.10
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Dialog
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 *  jquery.ui.button.js
 *	jquery.ui.draggable.js
 *	jquery.ui.mouse.js
 *	jquery.ui.position.js
 *	jquery.ui.resizable.js
 */
(function(c,j){var k={buttons:true,height:true,maxHeight:true,maxWidth:true,minHeight:true,minWidth:true,width:true},l={maxHeight:true,maxWidth:true,minHeight:true,minWidth:true};c.widget("ui.dialog",{options:{autoOpen:true,buttons:{},closeOnEscape:true,closeText:"close",dialogClass:"",draggable:true,hide:null,height:"auto",maxHeight:false,maxWidth:false,minHeight:150,minWidth:150,modal:false,position:{my:"center",at:"center",collision:"fit",using:function(a){var b=c(this).css(a).offset().top;b<0&&
c(this).css("top",a.top-b)}},resizable:true,show:null,stack:true,title:"",width:300,zIndex:1E3},_create:function(){this.originalTitle=this.element.attr("title");if(typeof this.originalTitle!=="string")this.originalTitle="";this.options.title=this.options.title||this.originalTitle;var a=this,b=a.options,d=b.title||"&#160;",e=c.ui.dialog.getTitleId(a.element),g=(a.uiDialog=c("<div></div>")).appendTo(document.body).hide().addClass("ui-dialog ui-widget ui-widget-content ui-corner-all "+b.dialogClass).css({zIndex:b.zIndex}).attr("tabIndex",
-1).css("outline",0).keydown(function(i){if(b.closeOnEscape&&i.keyCode&&i.keyCode===c.ui.keyCode.ESCAPE){a.close(i);i.preventDefault()}}).attr({role:"dialog","aria-labelledby":e}).mousedown(function(i){a.moveToTop(false,i)});a.element.show().removeAttr("title").addClass("ui-dialog-content ui-widget-content").appendTo(g);var f=(a.uiDialogTitlebar=c("<div></div>")).addClass("ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix").prependTo(g),h=c('<a href="#"></a>').addClass("ui-dialog-titlebar-close ui-corner-all").attr("role",
"button").hover(function(){h.addClass("ui-state-hover")},function(){h.removeClass("ui-state-hover")}).focus(function(){h.addClass("ui-state-focus")}).blur(function(){h.removeClass("ui-state-focus")}).click(function(i){a.close(i);return false}).appendTo(f);(a.uiDialogTitlebarCloseText=c("<span></span>")).addClass("ui-icon ui-icon-closethick").text(b.closeText).appendTo(h);c("<span></span>").addClass("ui-dialog-title").attr("id",e).html(d).prependTo(f);if(c.isFunction(b.beforeclose)&&!c.isFunction(b.beforeClose))b.beforeClose=
b.beforeclose;f.find("*").add(f).disableSelection();b.draggable&&c.fn.draggable&&a._makeDraggable();b.resizable&&c.fn.resizable&&a._makeResizable();a._createButtons(b.buttons);a._isOpen=false;c.fn.bgiframe&&g.bgiframe()},_init:function(){this.options.autoOpen&&this.open()},destroy:function(){var a=this;a.overlay&&a.overlay.destroy();a.uiDialog.hide();a.element.unbind(".dialog").removeData("dialog").removeClass("ui-dialog-content ui-widget-content").hide().appendTo("body");a.uiDialog.remove();a.originalTitle&&
a.element.attr("title",a.originalTitle);return a},widget:function(){return this.uiDialog},close:function(a){var b=this,d,e;if(false!==b._trigger("beforeClose",a)){b.overlay&&b.overlay.destroy();b.uiDialog.unbind("keypress.ui-dialog");b._isOpen=false;if(b.options.hide)b.uiDialog.hide(b.options.hide,function(){b._trigger("close",a)});else{b.uiDialog.hide();b._trigger("close",a)}c.ui.dialog.overlay.resize();if(b.options.modal){d=0;c(".ui-dialog").each(function(){if(this!==b.uiDialog[0]){e=c(this).css("z-index");
isNaN(e)||(d=Math.max(d,e))}});c.ui.dialog.maxZ=d}return b}},isOpen:function(){return this._isOpen},moveToTop:function(a,b){var d=this,e=d.options;if(e.modal&&!a||!e.stack&&!e.modal)return d._trigger("focus",b);if(e.zIndex>c.ui.dialog.maxZ)c.ui.dialog.maxZ=e.zIndex;if(d.overlay){c.ui.dialog.maxZ+=1;d.overlay.$el.css("z-index",c.ui.dialog.overlay.maxZ=c.ui.dialog.maxZ)}a={scrollTop:d.element.attr("scrollTop"),scrollLeft:d.element.attr("scrollLeft")};c.ui.dialog.maxZ+=1;d.uiDialog.css("z-index",c.ui.dialog.maxZ);
d.element.attr(a);d._trigger("focus",b);return d},open:function(){if(!this._isOpen){var a=this,b=a.options,d=a.uiDialog;a.overlay=b.modal?new c.ui.dialog.overlay(a):null;a._size();a._position(b.position);d.show(b.show);a.moveToTop(true);b.modal&&d.bind("keypress.ui-dialog",function(e){if(e.keyCode===c.ui.keyCode.TAB){var g=c(":tabbable",this),f=g.filter(":first");g=g.filter(":last");if(e.target===g[0]&&!e.shiftKey){f.focus(1);return false}else if(e.target===f[0]&&e.shiftKey){g.focus(1);return false}}});
c(a.element.find(":tabbable").get().concat(d.find(".ui-dialog-buttonpane :tabbable").get().concat(d.get()))).eq(0).focus();a._isOpen=true;a._trigger("open");return a}},_createButtons:function(a){var b=this,d=false,e=c("<div></div>").addClass("ui-dialog-buttonpane ui-widget-content ui-helper-clearfix"),g=c("<div></div>").addClass("ui-dialog-buttonset").appendTo(e);b.uiDialog.find(".ui-dialog-buttonpane").remove();typeof a==="object"&&a!==null&&c.each(a,function(){return!(d=true)});if(d){c.each(a,function(f,
h){h=c.isFunction(h)?{click:h,text:f}:h;f=c('<button type="button"></button>').attr(h,true).unbind("click").click(function(){h.click.apply(b.element[0],arguments)}).appendTo(g);c.fn.button&&f.button()});e.appendTo(b.uiDialog)}},_makeDraggable:function(){function a(f){return{position:f.position,offset:f.offset}}var b=this,d=b.options,e=c(document),g;b.uiDialog.draggable({cancel:".ui-dialog-content, .ui-dialog-titlebar-close",handle:".ui-dialog-titlebar",containment:"document",start:function(f,h){g=
d.height==="auto"?"auto":c(this).height();c(this).height(c(this).height()).addClass("ui-dialog-dragging");b._trigger("dragStart",f,a(h))},drag:function(f,h){b._trigger("drag",f,a(h))},stop:function(f,h){d.position=[h.position.left-e.scrollLeft(),h.position.top-e.scrollTop()];c(this).removeClass("ui-dialog-dragging").height(g);b._trigger("dragStop",f,a(h));c.ui.dialog.overlay.resize()}})},_makeResizable:function(a){function b(f){return{originalPosition:f.originalPosition,originalSize:f.originalSize,
position:f.position,size:f.size}}a=a===j?this.options.resizable:a;var d=this,e=d.options,g=d.uiDialog.css("position");a=typeof a==="string"?a:"n,e,s,w,se,sw,ne,nw";d.uiDialog.resizable({cancel:".ui-dialog-content",containment:"document",alsoResize:d.element,maxWidth:e.maxWidth,maxHeight:e.maxHeight,minWidth:e.minWidth,minHeight:d._minHeight(),handles:a,start:function(f,h){c(this).addClass("ui-dialog-resizing");d._trigger("resizeStart",f,b(h))},resize:function(f,h){d._trigger("resize",f,b(h))},stop:function(f,
h){c(this).removeClass("ui-dialog-resizing");e.height=c(this).height();e.width=c(this).width();d._trigger("resizeStop",f,b(h));c.ui.dialog.overlay.resize()}}).css("position",g).find(".ui-resizable-se").addClass("ui-icon ui-icon-grip-diagonal-se")},_minHeight:function(){var a=this.options;return a.height==="auto"?a.minHeight:Math.min(a.minHeight,a.height)},_position:function(a){var b=[],d=[0,0],e;if(a){if(typeof a==="string"||typeof a==="object"&&"0"in a){b=a.split?a.split(" "):[a[0],a[1]];if(b.length===
1)b[1]=b[0];c.each(["left","top"],function(g,f){if(+b[g]===b[g]){d[g]=b[g];b[g]=f}});a={my:b.join(" "),at:b.join(" "),offset:d.join(" ")}}a=c.extend({},c.ui.dialog.prototype.options.position,a)}else a=c.ui.dialog.prototype.options.position;(e=this.uiDialog.is(":visible"))||this.uiDialog.show();this.uiDialog.css({top:0,left:0}).position(c.extend({of:window},a));e||this.uiDialog.hide()},_setOptions:function(a){var b=this,d={},e=false;c.each(a,function(g,f){b._setOption(g,f);if(g in k)e=true;if(g in
l)d[g]=f});e&&this._size();this.uiDialog.is(":data(resizable)")&&this.uiDialog.resizable("option",d)},_setOption:function(a,b){var d=this,e=d.uiDialog;switch(a){case "beforeclose":a="beforeClose";break;case "buttons":d._createButtons(b);break;case "closeText":d.uiDialogTitlebarCloseText.text(""+b);break;case "dialogClass":e.removeClass(d.options.dialogClass).addClass("ui-dialog ui-widget ui-widget-content ui-corner-all "+b);break;case "disabled":b?e.addClass("ui-dialog-disabled"):e.removeClass("ui-dialog-disabled");
break;case "draggable":var g=e.is(":data(draggable)");g&&!b&&e.draggable("destroy");!g&&b&&d._makeDraggable();break;case "position":d._position(b);break;case "resizable":(g=e.is(":data(resizable)"))&&!b&&e.resizable("destroy");g&&typeof b==="string"&&e.resizable("option","handles",b);!g&&b!==false&&d._makeResizable(b);break;case "title":c(".ui-dialog-title",d.uiDialogTitlebar).html(""+(b||"&#160;"));break}c.Widget.prototype._setOption.apply(d,arguments)},_size:function(){var a=this.options,b,d,e=
this.uiDialog.is(":visible");this.element.show().css({width:"auto",minHeight:0,height:0});if(a.minWidth>a.width)a.width=a.minWidth;b=this.uiDialog.css({height:"auto",width:a.width}).height();d=Math.max(0,a.minHeight-b);if(a.height==="auto")if(c.support.minHeight)this.element.css({minHeight:d,height:"auto"});else{this.uiDialog.show();a=this.element.css("height","auto").height();e||this.uiDialog.hide();this.element.height(Math.max(a,d))}else this.element.height(Math.max(a.height-b,0));this.uiDialog.is(":data(resizable)")&&
this.uiDialog.resizable("option","minHeight",this._minHeight())}});c.extend(c.ui.dialog,{version:"1.8.10",uuid:0,maxZ:0,getTitleId:function(a){a=a.attr("id");if(!a){this.uuid+=1;a=this.uuid}return"ui-dialog-title-"+a},overlay:function(a){this.$el=c.ui.dialog.overlay.create(a)}});c.extend(c.ui.dialog.overlay,{instances:[],oldInstances:[],maxZ:0,events:c.map("focus,mousedown,mouseup,keydown,keypress,click".split(","),function(a){return a+".dialog-overlay"}).join(" "),create:function(a){if(this.instances.length===
0){setTimeout(function(){c.ui.dialog.overlay.instances.length&&c(document).bind(c.ui.dialog.overlay.events,function(d){if(c(d.target).zIndex()<c.ui.dialog.overlay.maxZ)return false})},1);c(document).bind("keydown.dialog-overlay",function(d){if(a.options.closeOnEscape&&d.keyCode&&d.keyCode===c.ui.keyCode.ESCAPE){a.close(d);d.preventDefault()}});c(window).bind("resize.dialog-overlay",c.ui.dialog.overlay.resize)}var b=(this.oldInstances.pop()||c("<div></div>").addClass("ui-widget-overlay")).appendTo(document.body).css({width:this.width(),
height:this.height()});c.fn.bgiframe&&b.bgiframe();this.instances.push(b);return b},destroy:function(a){var b=c.inArray(a,this.instances);b!=-1&&this.oldInstances.push(this.instances.splice(b,1)[0]);this.instances.length===0&&c([document,window]).unbind(".dialog-overlay");a.remove();var d=0;c.each(this.instances,function(){d=Math.max(d,this.css("z-index"))});this.maxZ=d},height:function(){var a,b;if(c.browser.msie&&c.browser.version<7){a=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight);
b=Math.max(document.documentElement.offsetHeight,document.body.offsetHeight);return a<b?c(window).height()+"px":a+"px"}else return c(document).height()+"px"},width:function(){var a,b;if(c.browser.msie&&c.browser.version<7){a=Math.max(document.documentElement.scrollWidth,document.body.scrollWidth);b=Math.max(document.documentElement.offsetWidth,document.body.offsetWidth);return a<b?c(window).width()+"px":a+"px"}else return c(document).width()+"px"},resize:function(){var a=c([]);c.each(c.ui.dialog.overlay.instances,
function(){a=a.add(this)});a.css({width:0,height:0}).css({width:c.ui.dialog.overlay.width(),height:c.ui.dialog.overlay.height()})}});c.extend(c.ui.dialog.overlay.prototype,{destroy:function(){c.ui.dialog.overlay.destroy(this.$el)}})})(jQuery);
;/*
 * jQuery UI Slider 1.8.10
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Slider
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function(d){d.widget("ui.slider",d.ui.mouse,{widgetEventPrefix:"slide",options:{animate:false,distance:0,max:100,min:0,orientation:"horizontal",range:false,step:1,value:0,values:null},_create:function(){var b=this,a=this.options;this._mouseSliding=this._keySliding=false;this._animateOff=true;this._handleIndex=null;this._detectOrientation();this._mouseInit();this.element.addClass("ui-slider ui-slider-"+this.orientation+" ui-widget ui-widget-content ui-corner-all");a.disabled&&this.element.addClass("ui-slider-disabled ui-disabled");
this.range=d([]);if(a.range){if(a.range===true){this.range=d("<div></div>");if(!a.values)a.values=[this._valueMin(),this._valueMin()];if(a.values.length&&a.values.length!==2)a.values=[a.values[0],a.values[0]]}else this.range=d("<div></div>");this.range.appendTo(this.element).addClass("ui-slider-range");if(a.range==="min"||a.range==="max")this.range.addClass("ui-slider-range-"+a.range);this.range.addClass("ui-widget-header")}d(".ui-slider-handle",this.element).length===0&&d("<a href='#'></a>").appendTo(this.element).addClass("ui-slider-handle");
if(a.values&&a.values.length)for(;d(".ui-slider-handle",this.element).length<a.values.length;)d("<a href='#'></a>").appendTo(this.element).addClass("ui-slider-handle");this.handles=d(".ui-slider-handle",this.element).addClass("ui-state-default ui-corner-all");this.handle=this.handles.eq(0);this.handles.add(this.range).filter("a").click(function(c){c.preventDefault()}).hover(function(){a.disabled||d(this).addClass("ui-state-hover")},function(){d(this).removeClass("ui-state-hover")}).focus(function(){if(a.disabled)d(this).blur();
else{d(".ui-slider .ui-state-focus").removeClass("ui-state-focus");d(this).addClass("ui-state-focus")}}).blur(function(){d(this).removeClass("ui-state-focus")});this.handles.each(function(c){d(this).data("index.ui-slider-handle",c)});this.handles.keydown(function(c){var e=true,f=d(this).data("index.ui-slider-handle"),h,g,i;if(!b.options.disabled){switch(c.keyCode){case d.ui.keyCode.HOME:case d.ui.keyCode.END:case d.ui.keyCode.PAGE_UP:case d.ui.keyCode.PAGE_DOWN:case d.ui.keyCode.UP:case d.ui.keyCode.RIGHT:case d.ui.keyCode.DOWN:case d.ui.keyCode.LEFT:e=
false;if(!b._keySliding){b._keySliding=true;d(this).addClass("ui-state-active");h=b._start(c,f);if(h===false)return}break}i=b.options.step;h=b.options.values&&b.options.values.length?(g=b.values(f)):(g=b.value());switch(c.keyCode){case d.ui.keyCode.HOME:g=b._valueMin();break;case d.ui.keyCode.END:g=b._valueMax();break;case d.ui.keyCode.PAGE_UP:g=b._trimAlignValue(h+(b._valueMax()-b._valueMin())/5);break;case d.ui.keyCode.PAGE_DOWN:g=b._trimAlignValue(h-(b._valueMax()-b._valueMin())/5);break;case d.ui.keyCode.UP:case d.ui.keyCode.RIGHT:if(h===
b._valueMax())return;g=b._trimAlignValue(h+i);break;case d.ui.keyCode.DOWN:case d.ui.keyCode.LEFT:if(h===b._valueMin())return;g=b._trimAlignValue(h-i);break}b._slide(c,f,g);return e}}).keyup(function(c){var e=d(this).data("index.ui-slider-handle");if(b._keySliding){b._keySliding=false;b._stop(c,e);b._change(c,e);d(this).removeClass("ui-state-active")}});this._refreshValue();this._animateOff=false},destroy:function(){this.handles.remove();this.range.remove();this.element.removeClass("ui-slider ui-slider-horizontal ui-slider-vertical ui-slider-disabled ui-widget ui-widget-content ui-corner-all").removeData("slider").unbind(".slider");
this._mouseDestroy();return this},_mouseCapture:function(b){var a=this.options,c,e,f,h,g;if(a.disabled)return false;this.elementSize={width:this.element.outerWidth(),height:this.element.outerHeight()};this.elementOffset=this.element.offset();c=this._normValueFromMouse({x:b.pageX,y:b.pageY});e=this._valueMax()-this._valueMin()+1;h=this;this.handles.each(function(i){var j=Math.abs(c-h.values(i));if(e>j){e=j;f=d(this);g=i}});if(a.range===true&&this.values(1)===a.min){g+=1;f=d(this.handles[g])}if(this._start(b,
g)===false)return false;this._mouseSliding=true;h._handleIndex=g;f.addClass("ui-state-active").focus();a=f.offset();this._clickOffset=!d(b.target).parents().andSelf().is(".ui-slider-handle")?{left:0,top:0}:{left:b.pageX-a.left-f.width()/2,top:b.pageY-a.top-f.height()/2-(parseInt(f.css("borderTopWidth"),10)||0)-(parseInt(f.css("borderBottomWidth"),10)||0)+(parseInt(f.css("marginTop"),10)||0)};this.handles.hasClass("ui-state-hover")||this._slide(b,g,c);return this._animateOff=true},_mouseStart:function(){return true},
_mouseDrag:function(b){var a=this._normValueFromMouse({x:b.pageX,y:b.pageY});this._slide(b,this._handleIndex,a);return false},_mouseStop:function(b){this.handles.removeClass("ui-state-active");this._mouseSliding=false;this._stop(b,this._handleIndex);this._change(b,this._handleIndex);this._clickOffset=this._handleIndex=null;return this._animateOff=false},_detectOrientation:function(){this.orientation=this.options.orientation==="vertical"?"vertical":"horizontal"},_normValueFromMouse:function(b){var a;
if(this.orientation==="horizontal"){a=this.elementSize.width;b=b.x-this.elementOffset.left-(this._clickOffset?this._clickOffset.left:0)}else{a=this.elementSize.height;b=b.y-this.elementOffset.top-(this._clickOffset?this._clickOffset.top:0)}a=b/a;if(a>1)a=1;if(a<0)a=0;if(this.orientation==="vertical")a=1-a;b=this._valueMax()-this._valueMin();return this._trimAlignValue(this._valueMin()+a*b)},_start:function(b,a){var c={handle:this.handles[a],value:this.value()};if(this.options.values&&this.options.values.length){c.value=
this.values(a);c.values=this.values()}return this._trigger("start",b,c)},_slide:function(b,a,c){var e;if(this.options.values&&this.options.values.length){e=this.values(a?0:1);if(this.options.values.length===2&&this.options.range===true&&(a===0&&c>e||a===1&&c<e))c=e;if(c!==this.values(a)){e=this.values();e[a]=c;b=this._trigger("slide",b,{handle:this.handles[a],value:c,values:e});this.values(a?0:1);b!==false&&this.values(a,c,true)}}else if(c!==this.value()){b=this._trigger("slide",b,{handle:this.handles[a],
value:c});b!==false&&this.value(c)}},_stop:function(b,a){var c={handle:this.handles[a],value:this.value()};if(this.options.values&&this.options.values.length){c.value=this.values(a);c.values=this.values()}this._trigger("stop",b,c)},_change:function(b,a){if(!this._keySliding&&!this._mouseSliding){var c={handle:this.handles[a],value:this.value()};if(this.options.values&&this.options.values.length){c.value=this.values(a);c.values=this.values()}this._trigger("change",b,c)}},value:function(b){if(arguments.length){this.options.value=
this._trimAlignValue(b);this._refreshValue();this._change(null,0)}return this._value()},values:function(b,a){var c,e,f;if(arguments.length>1){this.options.values[b]=this._trimAlignValue(a);this._refreshValue();this._change(null,b)}if(arguments.length)if(d.isArray(arguments[0])){c=this.options.values;e=arguments[0];for(f=0;f<c.length;f+=1){c[f]=this._trimAlignValue(e[f]);this._change(null,f)}this._refreshValue()}else return this.options.values&&this.options.values.length?this._values(b):this.value();
else return this._values()},_setOption:function(b,a){var c,e=0;if(d.isArray(this.options.values))e=this.options.values.length;d.Widget.prototype._setOption.apply(this,arguments);switch(b){case "disabled":if(a){this.handles.filter(".ui-state-focus").blur();this.handles.removeClass("ui-state-hover");this.handles.attr("disabled","disabled");this.element.addClass("ui-disabled")}else{this.handles.removeAttr("disabled");this.element.removeClass("ui-disabled")}break;case "orientation":this._detectOrientation();
this.element.removeClass("ui-slider-horizontal ui-slider-vertical").addClass("ui-slider-"+this.orientation);this._refreshValue();break;case "value":this._animateOff=true;this._refreshValue();this._change(null,0);this._animateOff=false;break;case "values":this._animateOff=true;this._refreshValue();for(c=0;c<e;c+=1)this._change(null,c);this._animateOff=false;break}},_value:function(){var b=this.options.value;return b=this._trimAlignValue(b)},_values:function(b){var a,c;if(arguments.length){a=this.options.values[b];
return a=this._trimAlignValue(a)}else{a=this.options.values.slice();for(c=0;c<a.length;c+=1)a[c]=this._trimAlignValue(a[c]);return a}},_trimAlignValue:function(b){if(b<=this._valueMin())return this._valueMin();if(b>=this._valueMax())return this._valueMax();var a=this.options.step>0?this.options.step:1,c=(b-this._valueMin())%a;alignValue=b-c;if(Math.abs(c)*2>=a)alignValue+=c>0?a:-a;return parseFloat(alignValue.toFixed(5))},_valueMin:function(){return this.options.min},_valueMax:function(){return this.options.max},
_refreshValue:function(){var b=this.options.range,a=this.options,c=this,e=!this._animateOff?a.animate:false,f,h={},g,i,j,l;if(this.options.values&&this.options.values.length)this.handles.each(function(k){f=(c.values(k)-c._valueMin())/(c._valueMax()-c._valueMin())*100;h[c.orientation==="horizontal"?"left":"bottom"]=f+"%";d(this).stop(1,1)[e?"animate":"css"](h,a.animate);if(c.options.range===true)if(c.orientation==="horizontal"){if(k===0)c.range.stop(1,1)[e?"animate":"css"]({left:f+"%"},a.animate);
if(k===1)c.range[e?"animate":"css"]({width:f-g+"%"},{queue:false,duration:a.animate})}else{if(k===0)c.range.stop(1,1)[e?"animate":"css"]({bottom:f+"%"},a.animate);if(k===1)c.range[e?"animate":"css"]({height:f-g+"%"},{queue:false,duration:a.animate})}g=f});else{i=this.value();j=this._valueMin();l=this._valueMax();f=l!==j?(i-j)/(l-j)*100:0;h[c.orientation==="horizontal"?"left":"bottom"]=f+"%";this.handle.stop(1,1)[e?"animate":"css"](h,a.animate);if(b==="min"&&this.orientation==="horizontal")this.range.stop(1,
1)[e?"animate":"css"]({width:f+"%"},a.animate);if(b==="max"&&this.orientation==="horizontal")this.range[e?"animate":"css"]({width:100-f+"%"},{queue:false,duration:a.animate});if(b==="min"&&this.orientation==="vertical")this.range.stop(1,1)[e?"animate":"css"]({height:f+"%"},a.animate);if(b==="max"&&this.orientation==="vertical")this.range[e?"animate":"css"]({height:100-f+"%"},{queue:false,duration:a.animate})}}});d.extend(d.ui.slider,{version:"1.8.10"})})(jQuery);
;/*
 * jQuery UI Tabs 1.8.10
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Tabs
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 */
(function(d,p){function u(){return++v}function w(){return++x}var v=0,x=0;d.widget("ui.tabs",{options:{add:null,ajaxOptions:null,cache:false,cookie:null,collapsible:false,disable:null,disabled:[],enable:null,event:"click",fx:null,idPrefix:"ui-tabs-",load:null,panelTemplate:"<div></div>",remove:null,select:null,show:null,spinner:"<em>Loading&#8230;</em>",tabTemplate:"<li><a href='#{href}'><span>#{label}</span></a></li>"},_create:function(){this._tabify(true)},_setOption:function(b,e){if(b=="selected")this.options.collapsible&&
e==this.options.selected||this.select(e);else{this.options[b]=e;this._tabify()}},_tabId:function(b){return b.title&&b.title.replace(/\s/g,"_").replace(/[^\w\u00c0-\uFFFF-]/g,"")||this.options.idPrefix+u()},_sanitizeSelector:function(b){return b.replace(/:/g,"\\:")},_cookie:function(){var b=this.cookie||(this.cookie=this.options.cookie.name||"ui-tabs-"+w());return d.cookie.apply(null,[b].concat(d.makeArray(arguments)))},_ui:function(b,e){return{tab:b,panel:e,index:this.anchors.index(b)}},_cleanup:function(){this.lis.filter(".ui-state-processing").removeClass("ui-state-processing").find("span:data(label.tabs)").each(function(){var b=
d(this);b.html(b.data("label.tabs")).removeData("label.tabs")})},_tabify:function(b){function e(g,f){g.css("display","");!d.support.opacity&&f.opacity&&g[0].style.removeAttribute("filter")}var a=this,c=this.options,h=/^#.+/;this.list=this.element.find("ol,ul").eq(0);this.lis=d(" > li:has(a[href])",this.list);this.anchors=this.lis.map(function(){return d("a",this)[0]});this.panels=d([]);this.anchors.each(function(g,f){var i=d(f).attr("href"),l=i.split("#")[0],q;if(l&&(l===location.toString().split("#")[0]||
(q=d("base")[0])&&l===q.href)){i=f.hash;f.href=i}if(h.test(i))a.panels=a.panels.add(a.element.find(a._sanitizeSelector(i)));else if(i&&i!=="#"){d.data(f,"href.tabs",i);d.data(f,"load.tabs",i.replace(/#.*$/,""));i=a._tabId(f);f.href="#"+i;f=a.element.find("#"+i);if(!f.length){f=d(c.panelTemplate).attr("id",i).addClass("ui-tabs-panel ui-widget-content ui-corner-bottom").insertAfter(a.panels[g-1]||a.list);f.data("destroy.tabs",true)}a.panels=a.panels.add(f)}else c.disabled.push(g)});if(b){this.element.addClass("ui-tabs ui-widget ui-widget-content ui-corner-all");
this.list.addClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all");this.lis.addClass("ui-state-default ui-corner-top");this.panels.addClass("ui-tabs-panel ui-widget-content ui-corner-bottom");if(c.selected===p){location.hash&&this.anchors.each(function(g,f){if(f.hash==location.hash){c.selected=g;return false}});if(typeof c.selected!=="number"&&c.cookie)c.selected=parseInt(a._cookie(),10);if(typeof c.selected!=="number"&&this.lis.filter(".ui-tabs-selected").length)c.selected=
this.lis.index(this.lis.filter(".ui-tabs-selected"));c.selected=c.selected||(this.lis.length?0:-1)}else if(c.selected===null)c.selected=-1;c.selected=c.selected>=0&&this.anchors[c.selected]||c.selected<0?c.selected:0;c.disabled=d.unique(c.disabled.concat(d.map(this.lis.filter(".ui-state-disabled"),function(g){return a.lis.index(g)}))).sort();d.inArray(c.selected,c.disabled)!=-1&&c.disabled.splice(d.inArray(c.selected,c.disabled),1);this.panels.addClass("ui-tabs-hide");this.lis.removeClass("ui-tabs-selected ui-state-active");
if(c.selected>=0&&this.anchors.length){a.element.find(a._sanitizeSelector(a.anchors[c.selected].hash)).removeClass("ui-tabs-hide");this.lis.eq(c.selected).addClass("ui-tabs-selected ui-state-active");a.element.queue("tabs",function(){a._trigger("show",null,a._ui(a.anchors[c.selected],a.element.find(a._sanitizeSelector(a.anchors[c.selected].hash))[0]))});this.load(c.selected)}d(window).bind("unload",function(){a.lis.add(a.anchors).unbind(".tabs");a.lis=a.anchors=a.panels=null})}else c.selected=this.lis.index(this.lis.filter(".ui-tabs-selected"));
this.element[c.collapsible?"addClass":"removeClass"]("ui-tabs-collapsible");c.cookie&&this._cookie(c.selected,c.cookie);b=0;for(var j;j=this.lis[b];b++)d(j)[d.inArray(b,c.disabled)!=-1&&!d(j).hasClass("ui-tabs-selected")?"addClass":"removeClass"]("ui-state-disabled");c.cache===false&&this.anchors.removeData("cache.tabs");this.lis.add(this.anchors).unbind(".tabs");if(c.event!=="mouseover"){var k=function(g,f){f.is(":not(.ui-state-disabled)")&&f.addClass("ui-state-"+g)},n=function(g,f){f.removeClass("ui-state-"+
g)};this.lis.bind("mouseover.tabs",function(){k("hover",d(this))});this.lis.bind("mouseout.tabs",function(){n("hover",d(this))});this.anchors.bind("focus.tabs",function(){k("focus",d(this).closest("li"))});this.anchors.bind("blur.tabs",function(){n("focus",d(this).closest("li"))})}var m,o;if(c.fx)if(d.isArray(c.fx)){m=c.fx[0];o=c.fx[1]}else m=o=c.fx;var r=o?function(g,f){d(g).closest("li").addClass("ui-tabs-selected ui-state-active");f.hide().removeClass("ui-tabs-hide").animate(o,o.duration||"normal",
function(){e(f,o);a._trigger("show",null,a._ui(g,f[0]))})}:function(g,f){d(g).closest("li").addClass("ui-tabs-selected ui-state-active");f.removeClass("ui-tabs-hide");a._trigger("show",null,a._ui(g,f[0]))},s=m?function(g,f){f.animate(m,m.duration||"normal",function(){a.lis.removeClass("ui-tabs-selected ui-state-active");f.addClass("ui-tabs-hide");e(f,m);a.element.dequeue("tabs")})}:function(g,f){a.lis.removeClass("ui-tabs-selected ui-state-active");f.addClass("ui-tabs-hide");a.element.dequeue("tabs")};
this.anchors.bind(c.event+".tabs",function(){var g=this,f=d(g).closest("li"),i=a.panels.filter(":not(.ui-tabs-hide)"),l=a.element.find(a._sanitizeSelector(g.hash));if(f.hasClass("ui-tabs-selected")&&!c.collapsible||f.hasClass("ui-state-disabled")||f.hasClass("ui-state-processing")||a.panels.filter(":animated").length||a._trigger("select",null,a._ui(this,l[0]))===false){this.blur();return false}c.selected=a.anchors.index(this);a.abort();if(c.collapsible)if(f.hasClass("ui-tabs-selected")){c.selected=
-1;c.cookie&&a._cookie(c.selected,c.cookie);a.element.queue("tabs",function(){s(g,i)}).dequeue("tabs");this.blur();return false}else if(!i.length){c.cookie&&a._cookie(c.selected,c.cookie);a.element.queue("tabs",function(){r(g,l)});a.load(a.anchors.index(this));this.blur();return false}c.cookie&&a._cookie(c.selected,c.cookie);if(l.length){i.length&&a.element.queue("tabs",function(){s(g,i)});a.element.queue("tabs",function(){r(g,l)});a.load(a.anchors.index(this))}else throw"jQuery UI Tabs: Mismatching fragment identifier.";
d.browser.msie&&this.blur()});this.anchors.bind("click.tabs",function(){return false})},_getIndex:function(b){if(typeof b=="string")b=this.anchors.index(this.anchors.filter("[href$="+b+"]"));return b},destroy:function(){var b=this.options;this.abort();this.element.unbind(".tabs").removeClass("ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible").removeData("tabs");this.list.removeClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all");this.anchors.each(function(){var e=
d.data(this,"href.tabs");if(e)this.href=e;var a=d(this).unbind(".tabs");d.each(["href","load","cache"],function(c,h){a.removeData(h+".tabs")})});this.lis.unbind(".tabs").add(this.panels).each(function(){d.data(this,"destroy.tabs")?d(this).remove():d(this).removeClass("ui-state-default ui-corner-top ui-tabs-selected ui-state-active ui-state-hover ui-state-focus ui-state-disabled ui-tabs-panel ui-widget-content ui-corner-bottom ui-tabs-hide")});b.cookie&&this._cookie(null,b.cookie);return this},add:function(b,
e,a){if(a===p)a=this.anchors.length;var c=this,h=this.options;e=d(h.tabTemplate.replace(/#\{href\}/g,b).replace(/#\{label\}/g,e));b=!b.indexOf("#")?b.replace("#",""):this._tabId(d("a",e)[0]);e.addClass("ui-state-default ui-corner-top").data("destroy.tabs",true);var j=c.element.find("#"+b);j.length||(j=d(h.panelTemplate).attr("id",b).data("destroy.tabs",true));j.addClass("ui-tabs-panel ui-widget-content ui-corner-bottom ui-tabs-hide");if(a>=this.lis.length){e.appendTo(this.list);j.appendTo(this.list[0].parentNode)}else{e.insertBefore(this.lis[a]);
j.insertBefore(this.panels[a])}h.disabled=d.map(h.disabled,function(k){return k>=a?++k:k});this._tabify();if(this.anchors.length==1){h.selected=0;e.addClass("ui-tabs-selected ui-state-active");j.removeClass("ui-tabs-hide");this.element.queue("tabs",function(){c._trigger("show",null,c._ui(c.anchors[0],c.panels[0]))});this.load(0)}this._trigger("add",null,this._ui(this.anchors[a],this.panels[a]));return this},remove:function(b){b=this._getIndex(b);var e=this.options,a=this.lis.eq(b).remove(),c=this.panels.eq(b).remove();
if(a.hasClass("ui-tabs-selected")&&this.anchors.length>1)this.select(b+(b+1<this.anchors.length?1:-1));e.disabled=d.map(d.grep(e.disabled,function(h){return h!=b}),function(h){return h>=b?--h:h});this._tabify();this._trigger("remove",null,this._ui(a.find("a")[0],c[0]));return this},enable:function(b){b=this._getIndex(b);var e=this.options;if(d.inArray(b,e.disabled)!=-1){this.lis.eq(b).removeClass("ui-state-disabled");e.disabled=d.grep(e.disabled,function(a){return a!=b});this._trigger("enable",null,
this._ui(this.anchors[b],this.panels[b]));return this}},disable:function(b){b=this._getIndex(b);var e=this.options;if(b!=e.selected){this.lis.eq(b).addClass("ui-state-disabled");e.disabled.push(b);e.disabled.sort();this._trigger("disable",null,this._ui(this.anchors[b],this.panels[b]))}return this},select:function(b){b=this._getIndex(b);if(b==-1)if(this.options.collapsible&&this.options.selected!=-1)b=this.options.selected;else return this;this.anchors.eq(b).trigger(this.options.event+".tabs");return this},
load:function(b){b=this._getIndex(b);var e=this,a=this.options,c=this.anchors.eq(b)[0],h=d.data(c,"load.tabs");this.abort();if(!h||this.element.queue("tabs").length!==0&&d.data(c,"cache.tabs"))this.element.dequeue("tabs");else{this.lis.eq(b).addClass("ui-state-processing");if(a.spinner){var j=d("span",c);j.data("label.tabs",j.html()).html(a.spinner)}this.xhr=d.ajax(d.extend({},a.ajaxOptions,{url:h,success:function(k,n){e.element.find(e._sanitizeSelector(c.hash)).html(k);e._cleanup();a.cache&&d.data(c,
"cache.tabs",true);e._trigger("load",null,e._ui(e.anchors[b],e.panels[b]));try{a.ajaxOptions.success(k,n)}catch(m){}},error:function(k,n){e._cleanup();e._trigger("load",null,e._ui(e.anchors[b],e.panels[b]));try{a.ajaxOptions.error(k,n,b,c)}catch(m){}}}));e.element.dequeue("tabs");return this}},abort:function(){this.element.queue([]);this.panels.stop(false,true);this.element.queue("tabs",this.element.queue("tabs").splice(-2,2));if(this.xhr){this.xhr.abort();delete this.xhr}this._cleanup();return this},
url:function(b,e){this.anchors.eq(b).removeData("cache.tabs").data("load.tabs",e);return this},length:function(){return this.anchors.length}});d.extend(d.ui.tabs,{version:"1.8.10"});d.extend(d.ui.tabs.prototype,{rotation:null,rotate:function(b,e){var a=this,c=this.options,h=a._rotate||(a._rotate=function(j){clearTimeout(a.rotation);a.rotation=setTimeout(function(){var k=c.selected;a.select(++k<a.anchors.length?k:0)},b);j&&j.stopPropagation()});e=a._unrotate||(a._unrotate=!e?function(j){j.clientX&&
a.rotate(null)}:function(){t=c.selected;h()});if(b){this.element.bind("tabsshow",h);this.anchors.bind(c.event+".tabs",e);h()}else{clearTimeout(a.rotation);this.element.unbind("tabsshow",h);this.anchors.unbind(c.event+".tabs",e);delete this._rotate;delete this._unrotate}return this}})})(jQuery);
;/*
 * jQuery UI Datepicker 1.8.10
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Datepicker
 *
 * Depends:
 *	jquery.ui.core.js
 */
(function(d,G){function K(){this.debug=false;this._curInst=null;this._keyEvent=false;this._disabledInputs=[];this._inDialog=this._datepickerShowing=false;this._mainDivId="ui-datepicker-div";this._inlineClass="ui-datepicker-inline";this._appendClass="ui-datepicker-append";this._triggerClass="ui-datepicker-trigger";this._dialogClass="ui-datepicker-dialog";this._disableClass="ui-datepicker-disabled";this._unselectableClass="ui-datepicker-unselectable";this._currentClass="ui-datepicker-current-day";this._dayOverClass=
"ui-datepicker-days-cell-over";this.regional=[];this.regional[""]={closeText:"Done",prevText:"Prev",nextText:"Next",currentText:"Today",monthNames:["January","February","March","April","May","June","July","August","September","October","November","December"],monthNamesShort:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],dayNames:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],dayNamesShort:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],dayNamesMin:["Su",
"Mo","Tu","We","Th","Fr","Sa"],weekHeader:"Wk",dateFormat:"mm/dd/yy",firstDay:0,isRTL:false,showMonthAfterYear:false,yearSuffix:""};this._defaults={showOn:"focus",showAnim:"fadeIn",showOptions:{},defaultDate:null,appendText:"",buttonText:"...",buttonImage:"",buttonImageOnly:false,hideIfNoPrevNext:false,navigationAsDateFormat:false,gotoCurrent:false,changeMonth:false,changeYear:false,yearRange:"c-10:c+10",showOtherMonths:false,selectOtherMonths:false,showWeek:false,calculateWeek:this.iso8601Week,shortYearCutoff:"+10",
minDate:null,maxDate:null,duration:"fast",beforeShowDay:null,beforeShow:null,onSelect:null,onChangeMonthYear:null,onClose:null,numberOfMonths:1,showCurrentAtPos:0,stepMonths:1,stepBigMonths:12,altField:"",altFormat:"",constrainInput:true,showButtonPanel:false,autoSize:false};d.extend(this._defaults,this.regional[""]);this.dpDiv=d('<div id="'+this._mainDivId+'" class="ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all"></div>')}function E(a,b){d.extend(a,b);for(var c in b)if(b[c]==
null||b[c]==G)a[c]=b[c];return a}d.extend(d.ui,{datepicker:{version:"1.8.10"}});var y=(new Date).getTime();d.extend(K.prototype,{markerClassName:"hasDatepicker",log:function(){this.debug&&console.log.apply("",arguments)},_widgetDatepicker:function(){return this.dpDiv},setDefaults:function(a){E(this._defaults,a||{});return this},_attachDatepicker:function(a,b){var c=null;for(var e in this._defaults){var f=a.getAttribute("date:"+e);if(f){c=c||{};try{c[e]=eval(f)}catch(h){c[e]=f}}}e=a.nodeName.toLowerCase();
f=e=="div"||e=="span";if(!a.id){this.uuid+=1;a.id="dp"+this.uuid}var i=this._newInst(d(a),f);i.settings=d.extend({},b||{},c||{});if(e=="input")this._connectDatepicker(a,i);else f&&this._inlineDatepicker(a,i)},_newInst:function(a,b){return{id:a[0].id.replace(/([^A-Za-z0-9_-])/g,"\\\\$1"),input:a,selectedDay:0,selectedMonth:0,selectedYear:0,drawMonth:0,drawYear:0,inline:b,dpDiv:!b?this.dpDiv:d('<div class="'+this._inlineClass+' ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all"></div>')}},
_connectDatepicker:function(a,b){var c=d(a);b.append=d([]);b.trigger=d([]);if(!c.hasClass(this.markerClassName)){this._attachments(c,b);c.addClass(this.markerClassName).keydown(this._doKeyDown).keypress(this._doKeyPress).keyup(this._doKeyUp).bind("setData.datepicker",function(e,f,h){b.settings[f]=h}).bind("getData.datepicker",function(e,f){return this._get(b,f)});this._autoSize(b);d.data(a,"datepicker",b)}},_attachments:function(a,b){var c=this._get(b,"appendText"),e=this._get(b,"isRTL");b.append&&
b.append.remove();if(c){b.append=d('<span class="'+this._appendClass+'">'+c+"</span>");a[e?"before":"after"](b.append)}a.unbind("focus",this._showDatepicker);b.trigger&&b.trigger.remove();c=this._get(b,"showOn");if(c=="focus"||c=="both")a.focus(this._showDatepicker);if(c=="button"||c=="both"){c=this._get(b,"buttonText");var f=this._get(b,"buttonImage");b.trigger=d(this._get(b,"buttonImageOnly")?d("<img/>").addClass(this._triggerClass).attr({src:f,alt:c,title:c}):d('<button type="button"></button>').addClass(this._triggerClass).html(f==
""?c:d("<img/>").attr({src:f,alt:c,title:c})));a[e?"before":"after"](b.trigger);b.trigger.click(function(){d.datepicker._datepickerShowing&&d.datepicker._lastInput==a[0]?d.datepicker._hideDatepicker():d.datepicker._showDatepicker(a[0]);return false})}},_autoSize:function(a){if(this._get(a,"autoSize")&&!a.inline){var b=new Date(2009,11,20),c=this._get(a,"dateFormat");if(c.match(/[DM]/)){var e=function(f){for(var h=0,i=0,g=0;g<f.length;g++)if(f[g].length>h){h=f[g].length;i=g}return i};b.setMonth(e(this._get(a,
c.match(/MM/)?"monthNames":"monthNamesShort")));b.setDate(e(this._get(a,c.match(/DD/)?"dayNames":"dayNamesShort"))+20-b.getDay())}a.input.attr("size",this._formatDate(a,b).length)}},_inlineDatepicker:function(a,b){var c=d(a);if(!c.hasClass(this.markerClassName)){c.addClass(this.markerClassName).append(b.dpDiv).bind("setData.datepicker",function(e,f,h){b.settings[f]=h}).bind("getData.datepicker",function(e,f){return this._get(b,f)});d.data(a,"datepicker",b);this._setDate(b,this._getDefaultDate(b),
true);this._updateDatepicker(b);this._updateAlternate(b);b.dpDiv.show()}},_dialogDatepicker:function(a,b,c,e,f){a=this._dialogInst;if(!a){this.uuid+=1;this._dialogInput=d('<input type="text" id="'+("dp"+this.uuid)+'" style="position: absolute; top: -100px; width: 0px; z-index: -10;"/>');this._dialogInput.keydown(this._doKeyDown);d("body").append(this._dialogInput);a=this._dialogInst=this._newInst(this._dialogInput,false);a.settings={};d.data(this._dialogInput[0],"datepicker",a)}E(a.settings,e||{});
b=b&&b.constructor==Date?this._formatDate(a,b):b;this._dialogInput.val(b);this._pos=f?f.length?f:[f.pageX,f.pageY]:null;if(!this._pos)this._pos=[document.documentElement.clientWidth/2-100+(document.documentElement.scrollLeft||document.body.scrollLeft),document.documentElement.clientHeight/2-150+(document.documentElement.scrollTop||document.body.scrollTop)];this._dialogInput.css("left",this._pos[0]+20+"px").css("top",this._pos[1]+"px");a.settings.onSelect=c;this._inDialog=true;this.dpDiv.addClass(this._dialogClass);
this._showDatepicker(this._dialogInput[0]);d.blockUI&&d.blockUI(this.dpDiv);d.data(this._dialogInput[0],"datepicker",a);return this},_destroyDatepicker:function(a){var b=d(a),c=d.data(a,"datepicker");if(b.hasClass(this.markerClassName)){var e=a.nodeName.toLowerCase();d.removeData(a,"datepicker");if(e=="input"){c.append.remove();c.trigger.remove();b.removeClass(this.markerClassName).unbind("focus",this._showDatepicker).unbind("keydown",this._doKeyDown).unbind("keypress",this._doKeyPress).unbind("keyup",
this._doKeyUp)}else if(e=="div"||e=="span")b.removeClass(this.markerClassName).empty()}},_enableDatepicker:function(a){var b=d(a),c=d.data(a,"datepicker");if(b.hasClass(this.markerClassName)){var e=a.nodeName.toLowerCase();if(e=="input"){a.disabled=false;c.trigger.filter("button").each(function(){this.disabled=false}).end().filter("img").css({opacity:"1.0",cursor:""})}else if(e=="div"||e=="span")b.children("."+this._inlineClass).children().removeClass("ui-state-disabled");this._disabledInputs=d.map(this._disabledInputs,
function(f){return f==a?null:f})}},_disableDatepicker:function(a){var b=d(a),c=d.data(a,"datepicker");if(b.hasClass(this.markerClassName)){var e=a.nodeName.toLowerCase();if(e=="input"){a.disabled=true;c.trigger.filter("button").each(function(){this.disabled=true}).end().filter("img").css({opacity:"0.5",cursor:"default"})}else if(e=="div"||e=="span")b.children("."+this._inlineClass).children().addClass("ui-state-disabled");this._disabledInputs=d.map(this._disabledInputs,function(f){return f==a?null:
f});this._disabledInputs[this._disabledInputs.length]=a}},_isDisabledDatepicker:function(a){if(!a)return false;for(var b=0;b<this._disabledInputs.length;b++)if(this._disabledInputs[b]==a)return true;return false},_getInst:function(a){try{return d.data(a,"datepicker")}catch(b){throw"Missing instance data for this datepicker";}},_optionDatepicker:function(a,b,c){var e=this._getInst(a);if(arguments.length==2&&typeof b=="string")return b=="defaults"?d.extend({},d.datepicker._defaults):e?b=="all"?d.extend({},
e.settings):this._get(e,b):null;var f=b||{};if(typeof b=="string"){f={};f[b]=c}if(e){this._curInst==e&&this._hideDatepicker();var h=this._getDateDatepicker(a,true);E(e.settings,f);this._attachments(d(a),e);this._autoSize(e);this._setDateDatepicker(a,h);this._updateDatepicker(e)}},_changeDatepicker:function(a,b,c){this._optionDatepicker(a,b,c)},_refreshDatepicker:function(a){(a=this._getInst(a))&&this._updateDatepicker(a)},_setDateDatepicker:function(a,b){if(a=this._getInst(a)){this._setDate(a,b);
this._updateDatepicker(a);this._updateAlternate(a)}},_getDateDatepicker:function(a,b){(a=this._getInst(a))&&!a.inline&&this._setDateFromField(a,b);return a?this._getDate(a):null},_doKeyDown:function(a){var b=d.datepicker._getInst(a.target),c=true,e=b.dpDiv.is(".ui-datepicker-rtl");b._keyEvent=true;if(d.datepicker._datepickerShowing)switch(a.keyCode){case 9:d.datepicker._hideDatepicker();c=false;break;case 13:c=d("td."+d.datepicker._dayOverClass+":not(."+d.datepicker._currentClass+")",b.dpDiv);c[0]?
d.datepicker._selectDay(a.target,b.selectedMonth,b.selectedYear,c[0]):d.datepicker._hideDatepicker();return false;case 27:d.datepicker._hideDatepicker();break;case 33:d.datepicker._adjustDate(a.target,a.ctrlKey?-d.datepicker._get(b,"stepBigMonths"):-d.datepicker._get(b,"stepMonths"),"M");break;case 34:d.datepicker._adjustDate(a.target,a.ctrlKey?+d.datepicker._get(b,"stepBigMonths"):+d.datepicker._get(b,"stepMonths"),"M");break;case 35:if(a.ctrlKey||a.metaKey)d.datepicker._clearDate(a.target);c=a.ctrlKey||
a.metaKey;break;case 36:if(a.ctrlKey||a.metaKey)d.datepicker._gotoToday(a.target);c=a.ctrlKey||a.metaKey;break;case 37:if(a.ctrlKey||a.metaKey)d.datepicker._adjustDate(a.target,e?+1:-1,"D");c=a.ctrlKey||a.metaKey;if(a.originalEvent.altKey)d.datepicker._adjustDate(a.target,a.ctrlKey?-d.datepicker._get(b,"stepBigMonths"):-d.datepicker._get(b,"stepMonths"),"M");break;case 38:if(a.ctrlKey||a.metaKey)d.datepicker._adjustDate(a.target,-7,"D");c=a.ctrlKey||a.metaKey;break;case 39:if(a.ctrlKey||a.metaKey)d.datepicker._adjustDate(a.target,
e?-1:+1,"D");c=a.ctrlKey||a.metaKey;if(a.originalEvent.altKey)d.datepicker._adjustDate(a.target,a.ctrlKey?+d.datepicker._get(b,"stepBigMonths"):+d.datepicker._get(b,"stepMonths"),"M");break;case 40:if(a.ctrlKey||a.metaKey)d.datepicker._adjustDate(a.target,+7,"D");c=a.ctrlKey||a.metaKey;break;default:c=false}else if(a.keyCode==36&&a.ctrlKey)d.datepicker._showDatepicker(this);else c=false;if(c){a.preventDefault();a.stopPropagation()}},_doKeyPress:function(a){var b=d.datepicker._getInst(a.target);if(d.datepicker._get(b,
"constrainInput")){b=d.datepicker._possibleChars(d.datepicker._get(b,"dateFormat"));var c=String.fromCharCode(a.charCode==G?a.keyCode:a.charCode);return a.ctrlKey||a.metaKey||c<" "||!b||b.indexOf(c)>-1}},_doKeyUp:function(a){a=d.datepicker._getInst(a.target);if(a.input.val()!=a.lastVal)try{if(d.datepicker.parseDate(d.datepicker._get(a,"dateFormat"),a.input?a.input.val():null,d.datepicker._getFormatConfig(a))){d.datepicker._setDateFromField(a);d.datepicker._updateAlternate(a);d.datepicker._updateDatepicker(a)}}catch(b){d.datepicker.log(b)}return true},
_showDatepicker:function(a){a=a.target||a;if(a.nodeName.toLowerCase()!="input")a=d("input",a.parentNode)[0];if(!(d.datepicker._isDisabledDatepicker(a)||d.datepicker._lastInput==a)){var b=d.datepicker._getInst(a);d.datepicker._curInst&&d.datepicker._curInst!=b&&d.datepicker._curInst.dpDiv.stop(true,true);var c=d.datepicker._get(b,"beforeShow");E(b.settings,c?c.apply(a,[a,b]):{});b.lastVal=null;d.datepicker._lastInput=a;d.datepicker._setDateFromField(b);if(d.datepicker._inDialog)a.value="";if(!d.datepicker._pos){d.datepicker._pos=
d.datepicker._findPos(a);d.datepicker._pos[1]+=a.offsetHeight}var e=false;d(a).parents().each(function(){e|=d(this).css("position")=="fixed";return!e});if(e&&d.browser.opera){d.datepicker._pos[0]-=document.documentElement.scrollLeft;d.datepicker._pos[1]-=document.documentElement.scrollTop}c={left:d.datepicker._pos[0],top:d.datepicker._pos[1]};d.datepicker._pos=null;b.dpDiv.empty();b.dpDiv.css({position:"absolute",display:"block",top:"-1000px"});d.datepicker._updateDatepicker(b);c=d.datepicker._checkOffset(b,
c,e);b.dpDiv.css({position:d.datepicker._inDialog&&d.blockUI?"static":e?"fixed":"absolute",display:"none",left:c.left+"px",top:c.top+"px"});if(!b.inline){c=d.datepicker._get(b,"showAnim");var f=d.datepicker._get(b,"duration"),h=function(){d.datepicker._datepickerShowing=true;var i=b.dpDiv.find("iframe.ui-datepicker-cover");if(i.length){var g=d.datepicker._getBorders(b.dpDiv);i.css({left:-g[0],top:-g[1],width:b.dpDiv.outerWidth(),height:b.dpDiv.outerHeight()})}};b.dpDiv.zIndex(d(a).zIndex()+1);d.effects&&
d.effects[c]?b.dpDiv.show(c,d.datepicker._get(b,"showOptions"),f,h):b.dpDiv[c||"show"](c?f:null,h);if(!c||!f)h();b.input.is(":visible")&&!b.input.is(":disabled")&&b.input.focus();d.datepicker._curInst=b}}},_updateDatepicker:function(a){var b=this,c=d.datepicker._getBorders(a.dpDiv);a.dpDiv.empty().append(this._generateHTML(a));var e=a.dpDiv.find("iframe.ui-datepicker-cover");e.length&&e.css({left:-c[0],top:-c[1],width:a.dpDiv.outerWidth(),height:a.dpDiv.outerHeight()});a.dpDiv.find("button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a").bind("mouseout",
function(){d(this).removeClass("ui-state-hover");this.className.indexOf("ui-datepicker-prev")!=-1&&d(this).removeClass("ui-datepicker-prev-hover");this.className.indexOf("ui-datepicker-next")!=-1&&d(this).removeClass("ui-datepicker-next-hover")}).bind("mouseover",function(){if(!b._isDisabledDatepicker(a.inline?a.dpDiv.parent()[0]:a.input[0])){d(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover");d(this).addClass("ui-state-hover");this.className.indexOf("ui-datepicker-prev")!=
-1&&d(this).addClass("ui-datepicker-prev-hover");this.className.indexOf("ui-datepicker-next")!=-1&&d(this).addClass("ui-datepicker-next-hover")}}).end().find("."+this._dayOverClass+" a").trigger("mouseover").end();c=this._getNumberOfMonths(a);e=c[1];e>1?a.dpDiv.addClass("ui-datepicker-multi-"+e).css("width",17*e+"em"):a.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width("");a.dpDiv[(c[0]!=1||c[1]!=1?"add":"remove")+"Class"]("ui-datepicker-multi");a.dpDiv[(this._get(a,
"isRTL")?"add":"remove")+"Class"]("ui-datepicker-rtl");a==d.datepicker._curInst&&d.datepicker._datepickerShowing&&a.input&&a.input.is(":visible")&&!a.input.is(":disabled")&&a.input[0]!=document.activeElement&&a.input.focus();if(a.yearshtml){var f=a.yearshtml;setTimeout(function(){f===a.yearshtml&&a.dpDiv.find("select.ui-datepicker-year:first").replaceWith(a.yearshtml);f=a.yearshtml=null},0)}},_getBorders:function(a){var b=function(c){return{thin:1,medium:2,thick:3}[c]||c};return[parseFloat(b(a.css("border-left-width"))),
parseFloat(b(a.css("border-top-width")))]},_checkOffset:function(a,b,c){var e=a.dpDiv.outerWidth(),f=a.dpDiv.outerHeight(),h=a.input?a.input.outerWidth():0,i=a.input?a.input.outerHeight():0,g=document.documentElement.clientWidth+d(document).scrollLeft(),j=document.documentElement.clientHeight+d(document).scrollTop();b.left-=this._get(a,"isRTL")?e-h:0;b.left-=c&&b.left==a.input.offset().left?d(document).scrollLeft():0;b.top-=c&&b.top==a.input.offset().top+i?d(document).scrollTop():0;b.left-=Math.min(b.left,
b.left+e>g&&g>e?Math.abs(b.left+e-g):0);b.top-=Math.min(b.top,b.top+f>j&&j>f?Math.abs(f+i):0);return b},_findPos:function(a){for(var b=this._get(this._getInst(a),"isRTL");a&&(a.type=="hidden"||a.nodeType!=1||d.expr.filters.hidden(a));)a=a[b?"previousSibling":"nextSibling"];a=d(a).offset();return[a.left,a.top]},_hideDatepicker:function(a){var b=this._curInst;if(!(!b||a&&b!=d.data(a,"datepicker")))if(this._datepickerShowing){a=this._get(b,"showAnim");var c=this._get(b,"duration"),e=function(){d.datepicker._tidyDialog(b);
this._curInst=null};d.effects&&d.effects[a]?b.dpDiv.hide(a,d.datepicker._get(b,"showOptions"),c,e):b.dpDiv[a=="slideDown"?"slideUp":a=="fadeIn"?"fadeOut":"hide"](a?c:null,e);a||e();if(a=this._get(b,"onClose"))a.apply(b.input?b.input[0]:null,[b.input?b.input.val():"",b]);this._datepickerShowing=false;this._lastInput=null;if(this._inDialog){this._dialogInput.css({position:"absolute",left:"0",top:"-100px"});if(d.blockUI){d.unblockUI();d("body").append(this.dpDiv)}}this._inDialog=false}},_tidyDialog:function(a){a.dpDiv.removeClass(this._dialogClass).unbind(".ui-datepicker-calendar")},
_checkExternalClick:function(a){if(d.datepicker._curInst){a=d(a.target);a[0].id!=d.datepicker._mainDivId&&a.parents("#"+d.datepicker._mainDivId).length==0&&!a.hasClass(d.datepicker.markerClassName)&&!a.hasClass(d.datepicker._triggerClass)&&d.datepicker._datepickerShowing&&!(d.datepicker._inDialog&&d.blockUI)&&d.datepicker._hideDatepicker()}},_adjustDate:function(a,b,c){a=d(a);var e=this._getInst(a[0]);if(!this._isDisabledDatepicker(a[0])){this._adjustInstDate(e,b+(c=="M"?this._get(e,"showCurrentAtPos"):
0),c);this._updateDatepicker(e)}},_gotoToday:function(a){a=d(a);var b=this._getInst(a[0]);if(this._get(b,"gotoCurrent")&&b.currentDay){b.selectedDay=b.currentDay;b.drawMonth=b.selectedMonth=b.currentMonth;b.drawYear=b.selectedYear=b.currentYear}else{var c=new Date;b.selectedDay=c.getDate();b.drawMonth=b.selectedMonth=c.getMonth();b.drawYear=b.selectedYear=c.getFullYear()}this._notifyChange(b);this._adjustDate(a)},_selectMonthYear:function(a,b,c){a=d(a);var e=this._getInst(a[0]);e._selectingMonthYear=
false;e["selected"+(c=="M"?"Month":"Year")]=e["draw"+(c=="M"?"Month":"Year")]=parseInt(b.options[b.selectedIndex].value,10);this._notifyChange(e);this._adjustDate(a)},_clickMonthYear:function(a){var b=this._getInst(d(a)[0]);b.input&&b._selectingMonthYear&&setTimeout(function(){b.input.focus()},0);b._selectingMonthYear=!b._selectingMonthYear},_selectDay:function(a,b,c,e){var f=d(a);if(!(d(e).hasClass(this._unselectableClass)||this._isDisabledDatepicker(f[0]))){f=this._getInst(f[0]);f.selectedDay=f.currentDay=
d("a",e).html();f.selectedMonth=f.currentMonth=b;f.selectedYear=f.currentYear=c;this._selectDate(a,this._formatDate(f,f.currentDay,f.currentMonth,f.currentYear))}},_clearDate:function(a){a=d(a);this._getInst(a[0]);this._selectDate(a,"")},_selectDate:function(a,b){a=this._getInst(d(a)[0]);b=b!=null?b:this._formatDate(a);a.input&&a.input.val(b);this._updateAlternate(a);var c=this._get(a,"onSelect");if(c)c.apply(a.input?a.input[0]:null,[b,a]);else a.input&&a.input.trigger("change");if(a.inline)this._updateDatepicker(a);
else{this._hideDatepicker();this._lastInput=a.input[0];typeof a.input[0]!="object"&&a.input.focus();this._lastInput=null}},_updateAlternate:function(a){var b=this._get(a,"altField");if(b){var c=this._get(a,"altFormat")||this._get(a,"dateFormat"),e=this._getDate(a),f=this.formatDate(c,e,this._getFormatConfig(a));d(b).each(function(){d(this).val(f)})}},noWeekends:function(a){a=a.getDay();return[a>0&&a<6,""]},iso8601Week:function(a){a=new Date(a.getTime());a.setDate(a.getDate()+4-(a.getDay()||7));var b=
a.getTime();a.setMonth(0);a.setDate(1);return Math.floor(Math.round((b-a)/864E5)/7)+1},parseDate:function(a,b,c){if(a==null||b==null)throw"Invalid arguments";b=typeof b=="object"?b.toString():b+"";if(b=="")return null;var e=(c?c.shortYearCutoff:null)||this._defaults.shortYearCutoff;e=typeof e!="string"?e:(new Date).getFullYear()%100+parseInt(e,10);for(var f=(c?c.dayNamesShort:null)||this._defaults.dayNamesShort,h=(c?c.dayNames:null)||this._defaults.dayNames,i=(c?c.monthNamesShort:null)||this._defaults.monthNamesShort,
g=(c?c.monthNames:null)||this._defaults.monthNames,j=c=-1,l=-1,u=-1,k=false,o=function(p){(p=z+1<a.length&&a.charAt(z+1)==p)&&z++;return p},m=function(p){var v=o(p);p=new RegExp("^\\d{1,"+(p=="@"?14:p=="!"?20:p=="y"&&v?4:p=="o"?3:2)+"}");p=b.substring(s).match(p);if(!p)throw"Missing number at position "+s;s+=p[0].length;return parseInt(p[0],10)},n=function(p,v,H){p=o(p)?H:v;for(v=0;v<p.length;v++)if(b.substr(s,p[v].length).toLowerCase()==p[v].toLowerCase()){s+=p[v].length;return v+1}throw"Unknown name at position "+
s;},r=function(){if(b.charAt(s)!=a.charAt(z))throw"Unexpected literal at position "+s;s++},s=0,z=0;z<a.length;z++)if(k)if(a.charAt(z)=="'"&&!o("'"))k=false;else r();else switch(a.charAt(z)){case "d":l=m("d");break;case "D":n("D",f,h);break;case "o":u=m("o");break;case "m":j=m("m");break;case "M":j=n("M",i,g);break;case "y":c=m("y");break;case "@":var w=new Date(m("@"));c=w.getFullYear();j=w.getMonth()+1;l=w.getDate();break;case "!":w=new Date((m("!")-this._ticksTo1970)/1E4);c=w.getFullYear();j=w.getMonth()+
1;l=w.getDate();break;case "'":if(o("'"))r();else k=true;break;default:r()}if(c==-1)c=(new Date).getFullYear();else if(c<100)c+=(new Date).getFullYear()-(new Date).getFullYear()%100+(c<=e?0:-100);if(u>-1){j=1;l=u;do{e=this._getDaysInMonth(c,j-1);if(l<=e)break;j++;l-=e}while(1)}w=this._daylightSavingAdjust(new Date(c,j-1,l));if(w.getFullYear()!=c||w.getMonth()+1!=j||w.getDate()!=l)throw"Invalid date";return w},ATOM:"yy-mm-dd",COOKIE:"D, dd M yy",ISO_8601:"yy-mm-dd",RFC_822:"D, d M y",RFC_850:"DD, dd-M-y",
RFC_1036:"D, d M y",RFC_1123:"D, d M yy",RFC_2822:"D, d M yy",RSS:"D, d M y",TICKS:"!",TIMESTAMP:"@",W3C:"yy-mm-dd",_ticksTo1970:(718685+Math.floor(492.5)-Math.floor(19.7)+Math.floor(4.925))*24*60*60*1E7,formatDate:function(a,b,c){if(!b)return"";var e=(c?c.dayNamesShort:null)||this._defaults.dayNamesShort,f=(c?c.dayNames:null)||this._defaults.dayNames,h=(c?c.monthNamesShort:null)||this._defaults.monthNamesShort;c=(c?c.monthNames:null)||this._defaults.monthNames;var i=function(o){(o=k+1<a.length&&
a.charAt(k+1)==o)&&k++;return o},g=function(o,m,n){m=""+m;if(i(o))for(;m.length<n;)m="0"+m;return m},j=function(o,m,n,r){return i(o)?r[m]:n[m]},l="",u=false;if(b)for(var k=0;k<a.length;k++)if(u)if(a.charAt(k)=="'"&&!i("'"))u=false;else l+=a.charAt(k);else switch(a.charAt(k)){case "d":l+=g("d",b.getDate(),2);break;case "D":l+=j("D",b.getDay(),e,f);break;case "o":l+=g("o",(b.getTime()-(new Date(b.getFullYear(),0,0)).getTime())/864E5,3);break;case "m":l+=g("m",b.getMonth()+1,2);break;case "M":l+=j("M",
b.getMonth(),h,c);break;case "y":l+=i("y")?b.getFullYear():(b.getYear()%100<10?"0":"")+b.getYear()%100;break;case "@":l+=b.getTime();break;case "!":l+=b.getTime()*1E4+this._ticksTo1970;break;case "'":if(i("'"))l+="'";else u=true;break;default:l+=a.charAt(k)}return l},_possibleChars:function(a){for(var b="",c=false,e=function(h){(h=f+1<a.length&&a.charAt(f+1)==h)&&f++;return h},f=0;f<a.length;f++)if(c)if(a.charAt(f)=="'"&&!e("'"))c=false;else b+=a.charAt(f);else switch(a.charAt(f)){case "d":case "m":case "y":case "@":b+=
"0123456789";break;case "D":case "M":return null;case "'":if(e("'"))b+="'";else c=true;break;default:b+=a.charAt(f)}return b},_get:function(a,b){return a.settings[b]!==G?a.settings[b]:this._defaults[b]},_setDateFromField:function(a,b){if(a.input.val()!=a.lastVal){var c=this._get(a,"dateFormat"),e=a.lastVal=a.input?a.input.val():null,f,h;f=h=this._getDefaultDate(a);var i=this._getFormatConfig(a);try{f=this.parseDate(c,e,i)||h}catch(g){this.log(g);e=b?"":e}a.selectedDay=f.getDate();a.drawMonth=a.selectedMonth=
f.getMonth();a.drawYear=a.selectedYear=f.getFullYear();a.currentDay=e?f.getDate():0;a.currentMonth=e?f.getMonth():0;a.currentYear=e?f.getFullYear():0;this._adjustInstDate(a)}},_getDefaultDate:function(a){return this._restrictMinMax(a,this._determineDate(a,this._get(a,"defaultDate"),new Date))},_determineDate:function(a,b,c){var e=function(h){var i=new Date;i.setDate(i.getDate()+h);return i},f=function(h){try{return d.datepicker.parseDate(d.datepicker._get(a,"dateFormat"),h,d.datepicker._getFormatConfig(a))}catch(i){}var g=
(h.toLowerCase().match(/^c/)?d.datepicker._getDate(a):null)||new Date,j=g.getFullYear(),l=g.getMonth();g=g.getDate();for(var u=/([+-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,k=u.exec(h);k;){switch(k[2]||"d"){case "d":case "D":g+=parseInt(k[1],10);break;case "w":case "W":g+=parseInt(k[1],10)*7;break;case "m":case "M":l+=parseInt(k[1],10);g=Math.min(g,d.datepicker._getDaysInMonth(j,l));break;case "y":case "Y":j+=parseInt(k[1],10);g=Math.min(g,d.datepicker._getDaysInMonth(j,l));break}k=u.exec(h)}return new Date(j,
l,g)};if(b=(b=b==null||b===""?c:typeof b=="string"?f(b):typeof b=="number"?isNaN(b)?c:e(b):new Date(b.getTime()))&&b.toString()=="Invalid Date"?c:b){b.setHours(0);b.setMinutes(0);b.setSeconds(0);b.setMilliseconds(0)}return this._daylightSavingAdjust(b)},_daylightSavingAdjust:function(a){if(!a)return null;a.setHours(a.getHours()>12?a.getHours()+2:0);return a},_setDate:function(a,b,c){var e=!b,f=a.selectedMonth,h=a.selectedYear;b=this._restrictMinMax(a,this._determineDate(a,b,new Date));a.selectedDay=
a.currentDay=b.getDate();a.drawMonth=a.selectedMonth=a.currentMonth=b.getMonth();a.drawYear=a.selectedYear=a.currentYear=b.getFullYear();if((f!=a.selectedMonth||h!=a.selectedYear)&&!c)this._notifyChange(a);this._adjustInstDate(a);if(a.input)a.input.val(e?"":this._formatDate(a))},_getDate:function(a){return!a.currentYear||a.input&&a.input.val()==""?null:this._daylightSavingAdjust(new Date(a.currentYear,a.currentMonth,a.currentDay))},_generateHTML:function(a){var b=new Date;b=this._daylightSavingAdjust(new Date(b.getFullYear(),
b.getMonth(),b.getDate()));var c=this._get(a,"isRTL"),e=this._get(a,"showButtonPanel"),f=this._get(a,"hideIfNoPrevNext"),h=this._get(a,"navigationAsDateFormat"),i=this._getNumberOfMonths(a),g=this._get(a,"showCurrentAtPos"),j=this._get(a,"stepMonths"),l=i[0]!=1||i[1]!=1,u=this._daylightSavingAdjust(!a.currentDay?new Date(9999,9,9):new Date(a.currentYear,a.currentMonth,a.currentDay)),k=this._getMinMaxDate(a,"min"),o=this._getMinMaxDate(a,"max");g=a.drawMonth-g;var m=a.drawYear;if(g<0){g+=12;m--}if(o){var n=
this._daylightSavingAdjust(new Date(o.getFullYear(),o.getMonth()-i[0]*i[1]+1,o.getDate()));for(n=k&&n<k?k:n;this._daylightSavingAdjust(new Date(m,g,1))>n;){g--;if(g<0){g=11;m--}}}a.drawMonth=g;a.drawYear=m;n=this._get(a,"prevText");n=!h?n:this.formatDate(n,this._daylightSavingAdjust(new Date(m,g-j,1)),this._getFormatConfig(a));n=this._canAdjustMonth(a,-1,m,g)?'<a class="ui-datepicker-prev ui-corner-all" onclick="DP_jQuery_'+y+".datepicker._adjustDate('#"+a.id+"', -"+j+", 'M');\" title=\""+n+'"><span class="ui-icon ui-icon-circle-triangle-'+
(c?"e":"w")+'">'+n+"</span></a>":f?"":'<a class="ui-datepicker-prev ui-corner-all ui-state-disabled" title="'+n+'"><span class="ui-icon ui-icon-circle-triangle-'+(c?"e":"w")+'">'+n+"</span></a>";var r=this._get(a,"nextText");r=!h?r:this.formatDate(r,this._daylightSavingAdjust(new Date(m,g+j,1)),this._getFormatConfig(a));f=this._canAdjustMonth(a,+1,m,g)?'<a class="ui-datepicker-next ui-corner-all" onclick="DP_jQuery_'+y+".datepicker._adjustDate('#"+a.id+"', +"+j+", 'M');\" title=\""+r+'"><span class="ui-icon ui-icon-circle-triangle-'+
(c?"w":"e")+'">'+r+"</span></a>":f?"":'<a class="ui-datepicker-next ui-corner-all ui-state-disabled" title="'+r+'"><span class="ui-icon ui-icon-circle-triangle-'+(c?"w":"e")+'">'+r+"</span></a>";j=this._get(a,"currentText");r=this._get(a,"gotoCurrent")&&a.currentDay?u:b;j=!h?j:this.formatDate(j,r,this._getFormatConfig(a));h=!a.inline?'<button type="button" class="ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all" onclick="DP_jQuery_'+y+'.datepicker._hideDatepicker();">'+this._get(a,
"closeText")+"</button>":"";e=e?'<div class="ui-datepicker-buttonpane ui-widget-content">'+(c?h:"")+(this._isInRange(a,r)?'<button type="button" class="ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all" onclick="DP_jQuery_'+y+".datepicker._gotoToday('#"+a.id+"');\">"+j+"</button>":"")+(c?"":h)+"</div>":"";h=parseInt(this._get(a,"firstDay"),10);h=isNaN(h)?0:h;j=this._get(a,"showWeek");r=this._get(a,"dayNames");this._get(a,"dayNamesShort");var s=this._get(a,"dayNamesMin"),z=
this._get(a,"monthNames"),w=this._get(a,"monthNamesShort"),p=this._get(a,"beforeShowDay"),v=this._get(a,"showOtherMonths"),H=this._get(a,"selectOtherMonths");this._get(a,"calculateWeek");for(var L=this._getDefaultDate(a),I="",C=0;C<i[0];C++){for(var M="",D=0;D<i[1];D++){var N=this._daylightSavingAdjust(new Date(m,g,a.selectedDay)),t=" ui-corner-all",x="";if(l){x+='<div class="ui-datepicker-group';if(i[1]>1)switch(D){case 0:x+=" ui-datepicker-group-first";t=" ui-corner-"+(c?"right":"left");break;case i[1]-
1:x+=" ui-datepicker-group-last";t=" ui-corner-"+(c?"left":"right");break;default:x+=" ui-datepicker-group-middle";t="";break}x+='">'}x+='<div class="ui-datepicker-header ui-widget-header ui-helper-clearfix'+t+'">'+(/all|left/.test(t)&&C==0?c?f:n:"")+(/all|right/.test(t)&&C==0?c?n:f:"")+this._generateMonthYearHeader(a,g,m,k,o,C>0||D>0,z,w)+'</div><table class="ui-datepicker-calendar"><thead><tr>';var A=j?'<th class="ui-datepicker-week-col">'+this._get(a,"weekHeader")+"</th>":"";for(t=0;t<7;t++){var q=
(t+h)%7;A+="<th"+((t+h+6)%7>=5?' class="ui-datepicker-week-end"':"")+'><span title="'+r[q]+'">'+s[q]+"</span></th>"}x+=A+"</tr></thead><tbody>";A=this._getDaysInMonth(m,g);if(m==a.selectedYear&&g==a.selectedMonth)a.selectedDay=Math.min(a.selectedDay,A);t=(this._getFirstDayOfMonth(m,g)-h+7)%7;A=l?6:Math.ceil((t+A)/7);q=this._daylightSavingAdjust(new Date(m,g,1-t));for(var O=0;O<A;O++){x+="<tr>";var P=!j?"":'<td class="ui-datepicker-week-col">'+this._get(a,"calculateWeek")(q)+"</td>";for(t=0;t<7;t++){var F=
p?p.apply(a.input?a.input[0]:null,[q]):[true,""],B=q.getMonth()!=g,J=B&&!H||!F[0]||k&&q<k||o&&q>o;P+='<td class="'+((t+h+6)%7>=5?" ui-datepicker-week-end":"")+(B?" ui-datepicker-other-month":"")+(q.getTime()==N.getTime()&&g==a.selectedMonth&&a._keyEvent||L.getTime()==q.getTime()&&L.getTime()==N.getTime()?" "+this._dayOverClass:"")+(J?" "+this._unselectableClass+" ui-state-disabled":"")+(B&&!v?"":" "+F[1]+(q.getTime()==u.getTime()?" "+this._currentClass:"")+(q.getTime()==b.getTime()?" ui-datepicker-today":
""))+'"'+((!B||v)&&F[2]?' title="'+F[2]+'"':"")+(J?"":' onclick="DP_jQuery_'+y+".datepicker._selectDay('#"+a.id+"',"+q.getMonth()+","+q.getFullYear()+', this);return false;"')+">"+(B&&!v?"&#xa0;":J?'<span class="ui-state-default">'+q.getDate()+"</span>":'<a class="ui-state-default'+(q.getTime()==b.getTime()?" ui-state-highlight":"")+(q.getTime()==u.getTime()?" ui-state-active":"")+(B?" ui-priority-secondary":"")+'" href="#">'+q.getDate()+"</a>")+"</td>";q.setDate(q.getDate()+1);q=this._daylightSavingAdjust(q)}x+=
P+"</tr>"}g++;if(g>11){g=0;m++}x+="</tbody></table>"+(l?"</div>"+(i[0]>0&&D==i[1]-1?'<div class="ui-datepicker-row-break"></div>':""):"");M+=x}I+=M}I+=e+(d.browser.msie&&parseInt(d.browser.version,10)<7&&!a.inline?'<iframe src="javascript:false;" class="ui-datepicker-cover" frameborder="0"></iframe>':"");a._keyEvent=false;return I},_generateMonthYearHeader:function(a,b,c,e,f,h,i,g){var j=this._get(a,"changeMonth"),l=this._get(a,"changeYear"),u=this._get(a,"showMonthAfterYear"),k='<div class="ui-datepicker-title">',
o="";if(h||!j)o+='<span class="ui-datepicker-month">'+i[b]+"</span>";else{i=e&&e.getFullYear()==c;var m=f&&f.getFullYear()==c;o+='<select class="ui-datepicker-month" onchange="DP_jQuery_'+y+".datepicker._selectMonthYear('#"+a.id+"', this, 'M');\" onclick=\"DP_jQuery_"+y+".datepicker._clickMonthYear('#"+a.id+"');\">";for(var n=0;n<12;n++)if((!i||n>=e.getMonth())&&(!m||n<=f.getMonth()))o+='<option value="'+n+'"'+(n==b?' selected="selected"':"")+">"+g[n]+"</option>";o+="</select>"}u||(k+=o+(h||!(j&&
l)?"&#xa0;":""));a.yearshtml="";if(h||!l)k+='<span class="ui-datepicker-year">'+c+"</span>";else{g=this._get(a,"yearRange").split(":");var r=(new Date).getFullYear();i=function(s){s=s.match(/c[+-].*/)?c+parseInt(s.substring(1),10):s.match(/[+-].*/)?r+parseInt(s,10):parseInt(s,10);return isNaN(s)?r:s};b=i(g[0]);g=Math.max(b,i(g[1]||""));b=e?Math.max(b,e.getFullYear()):b;g=f?Math.min(g,f.getFullYear()):g;for(a.yearshtml+='<select class="ui-datepicker-year" onchange="DP_jQuery_'+y+".datepicker._selectMonthYear('#"+
a.id+"', this, 'Y');\" onclick=\"DP_jQuery_"+y+".datepicker._clickMonthYear('#"+a.id+"');\">";b<=g;b++)a.yearshtml+='<option value="'+b+'"'+(b==c?' selected="selected"':"")+">"+b+"</option>";a.yearshtml+="</select>";if(d.browser.mozilla)k+='<select class="ui-datepicker-year"><option value="'+c+'" selected="selected">'+c+"</option></select>";else{k+=a.yearshtml;a.yearshtml=null}}k+=this._get(a,"yearSuffix");if(u)k+=(h||!(j&&l)?"&#xa0;":"")+o;k+="</div>";return k},_adjustInstDate:function(a,b,c){var e=
a.drawYear+(c=="Y"?b:0),f=a.drawMonth+(c=="M"?b:0);b=Math.min(a.selectedDay,this._getDaysInMonth(e,f))+(c=="D"?b:0);e=this._restrictMinMax(a,this._daylightSavingAdjust(new Date(e,f,b)));a.selectedDay=e.getDate();a.drawMonth=a.selectedMonth=e.getMonth();a.drawYear=a.selectedYear=e.getFullYear();if(c=="M"||c=="Y")this._notifyChange(a)},_restrictMinMax:function(a,b){var c=this._getMinMaxDate(a,"min");a=this._getMinMaxDate(a,"max");b=c&&b<c?c:b;return b=a&&b>a?a:b},_notifyChange:function(a){var b=this._get(a,
"onChangeMonthYear");if(b)b.apply(a.input?a.input[0]:null,[a.selectedYear,a.selectedMonth+1,a])},_getNumberOfMonths:function(a){a=this._get(a,"numberOfMonths");return a==null?[1,1]:typeof a=="number"?[1,a]:a},_getMinMaxDate:function(a,b){return this._determineDate(a,this._get(a,b+"Date"),null)},_getDaysInMonth:function(a,b){return 32-this._daylightSavingAdjust(new Date(a,b,32)).getDate()},_getFirstDayOfMonth:function(a,b){return(new Date(a,b,1)).getDay()},_canAdjustMonth:function(a,b,c,e){var f=this._getNumberOfMonths(a);
c=this._daylightSavingAdjust(new Date(c,e+(b<0?b:f[0]*f[1]),1));b<0&&c.setDate(this._getDaysInMonth(c.getFullYear(),c.getMonth()));return this._isInRange(a,c)},_isInRange:function(a,b){var c=this._getMinMaxDate(a,"min");a=this._getMinMaxDate(a,"max");return(!c||b.getTime()>=c.getTime())&&(!a||b.getTime()<=a.getTime())},_getFormatConfig:function(a){var b=this._get(a,"shortYearCutoff");b=typeof b!="string"?b:(new Date).getFullYear()%100+parseInt(b,10);return{shortYearCutoff:b,dayNamesShort:this._get(a,
"dayNamesShort"),dayNames:this._get(a,"dayNames"),monthNamesShort:this._get(a,"monthNamesShort"),monthNames:this._get(a,"monthNames")}},_formatDate:function(a,b,c,e){if(!b){a.currentDay=a.selectedDay;a.currentMonth=a.selectedMonth;a.currentYear=a.selectedYear}b=b?typeof b=="object"?b:this._daylightSavingAdjust(new Date(e,c,b)):this._daylightSavingAdjust(new Date(a.currentYear,a.currentMonth,a.currentDay));return this.formatDate(this._get(a,"dateFormat"),b,this._getFormatConfig(a))}});d.fn.datepicker=
function(a){if(!this.length)return this;if(!d.datepicker.initialized){d(document).mousedown(d.datepicker._checkExternalClick).find("body").append(d.datepicker.dpDiv);d.datepicker.initialized=true}var b=Array.prototype.slice.call(arguments,1);if(typeof a=="string"&&(a=="isDisabled"||a=="getDate"||a=="widget"))return d.datepicker["_"+a+"Datepicker"].apply(d.datepicker,[this[0]].concat(b));if(a=="option"&&arguments.length==2&&typeof arguments[1]=="string")return d.datepicker["_"+a+"Datepicker"].apply(d.datepicker,
[this[0]].concat(b));return this.each(function(){typeof a=="string"?d.datepicker["_"+a+"Datepicker"].apply(d.datepicker,[this].concat(b)):d.datepicker._attachDatepicker(this,a)})};d.datepicker=new K;d.datepicker.initialized=false;d.datepicker.uuid=(new Date).getTime();d.datepicker.version="1.8.10";window["DP_jQuery_"+y]=d})(jQuery);
;/*
 * jQuery UI Progressbar 1.8.10
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Progressbar
 *
 * Depends:
 *   jquery.ui.core.js
 *   jquery.ui.widget.js
 */
(function(b,d){b.widget("ui.progressbar",{options:{value:0,max:100},min:0,_create:function(){this.element.addClass("ui-progressbar ui-widget ui-widget-content ui-corner-all").attr({role:"progressbar","aria-valuemin":this.min,"aria-valuemax":this.options.max,"aria-valuenow":this._value()});this.valueDiv=b("<div class='ui-progressbar-value ui-widget-header ui-corner-left'></div>").appendTo(this.element);this.oldValue=this._value();this._refreshValue()},destroy:function(){this.element.removeClass("ui-progressbar ui-widget ui-widget-content ui-corner-all").removeAttr("role").removeAttr("aria-valuemin").removeAttr("aria-valuemax").removeAttr("aria-valuenow");
this.valueDiv.remove();b.Widget.prototype.destroy.apply(this,arguments)},value:function(a){if(a===d)return this._value();this._setOption("value",a);return this},_setOption:function(a,c){if(a==="value"){this.options.value=c;this._refreshValue();this._value()===this.options.max&&this._trigger("complete")}b.Widget.prototype._setOption.apply(this,arguments)},_value:function(){var a=this.options.value;if(typeof a!=="number")a=0;return Math.min(this.options.max,Math.max(this.min,a))},_percentage:function(){return 100*
this._value()/this.options.max},_refreshValue:function(){var a=this.value(),c=this._percentage();if(this.oldValue!==a){this.oldValue=a;this._trigger("change")}this.valueDiv.toggleClass("ui-corner-right",a===this.options.max).width(c.toFixed(0)+"%");this.element.attr("aria-valuenow",a)}});b.extend(b.ui.progressbar,{version:"1.8.10"})})(jQuery);
;/*
 * jQuery UI Effects 1.8.10
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/
 */
jQuery.effects||function(f,j){function n(c){var a;if(c&&c.constructor==Array&&c.length==3)return c;if(a=/rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/.exec(c))return[parseInt(a[1],10),parseInt(a[2],10),parseInt(a[3],10)];if(a=/rgb\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*\)/.exec(c))return[parseFloat(a[1])*2.55,parseFloat(a[2])*2.55,parseFloat(a[3])*2.55];if(a=/#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(c))return[parseInt(a[1],
16),parseInt(a[2],16),parseInt(a[3],16)];if(a=/#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(c))return[parseInt(a[1]+a[1],16),parseInt(a[2]+a[2],16),parseInt(a[3]+a[3],16)];if(/rgba\(0, 0, 0, 0\)/.exec(c))return o.transparent;return o[f.trim(c).toLowerCase()]}function s(c,a){var b;do{b=f.curCSS(c,a);if(b!=""&&b!="transparent"||f.nodeName(c,"body"))break;a="backgroundColor"}while(c=c.parentNode);return n(b)}function p(){var c=document.defaultView?document.defaultView.getComputedStyle(this,null):this.currentStyle,
a={},b,d;if(c&&c.length&&c[0]&&c[c[0]])for(var e=c.length;e--;){b=c[e];if(typeof c[b]=="string"){d=b.replace(/\-(\w)/g,function(g,h){return h.toUpperCase()});a[d]=c[b]}}else for(b in c)if(typeof c[b]==="string")a[b]=c[b];return a}function q(c){var a,b;for(a in c){b=c[a];if(b==null||f.isFunction(b)||a in t||/scrollbar/.test(a)||!/color/i.test(a)&&isNaN(parseFloat(b)))delete c[a]}return c}function u(c,a){var b={_:0},d;for(d in a)if(c[d]!=a[d])b[d]=a[d];return b}function k(c,a,b,d){if(typeof c=="object"){d=
a;b=null;a=c;c=a.effect}if(f.isFunction(a)){d=a;b=null;a={}}if(typeof a=="number"||f.fx.speeds[a]){d=b;b=a;a={}}if(f.isFunction(b)){d=b;b=null}a=a||{};b=b||a.duration;b=f.fx.off?0:typeof b=="number"?b:b in f.fx.speeds?f.fx.speeds[b]:f.fx.speeds._default;d=d||a.complete;return[c,a,b,d]}function m(c){if(!c||typeof c==="number"||f.fx.speeds[c])return true;if(typeof c==="string"&&!f.effects[c])return true;return false}f.effects={};f.each(["backgroundColor","borderBottomColor","borderLeftColor","borderRightColor",
"borderTopColor","borderColor","color","outlineColor"],function(c,a){f.fx.step[a]=function(b){if(!b.colorInit){b.start=s(b.elem,a);b.end=n(b.end);b.colorInit=true}b.elem.style[a]="rgb("+Math.max(Math.min(parseInt(b.pos*(b.end[0]-b.start[0])+b.start[0],10),255),0)+","+Math.max(Math.min(parseInt(b.pos*(b.end[1]-b.start[1])+b.start[1],10),255),0)+","+Math.max(Math.min(parseInt(b.pos*(b.end[2]-b.start[2])+b.start[2],10),255),0)+")"}});var o={aqua:[0,255,255],azure:[240,255,255],beige:[245,245,220],black:[0,
0,0],blue:[0,0,255],brown:[165,42,42],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgrey:[169,169,169],darkgreen:[0,100,0],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkviolet:[148,0,211],fuchsia:[255,0,255],gold:[255,215,0],green:[0,128,0],indigo:[75,0,130],khaki:[240,230,140],lightblue:[173,216,230],lightcyan:[224,255,255],lightgreen:[144,238,144],lightgrey:[211,
211,211],lightpink:[255,182,193],lightyellow:[255,255,224],lime:[0,255,0],magenta:[255,0,255],maroon:[128,0,0],navy:[0,0,128],olive:[128,128,0],orange:[255,165,0],pink:[255,192,203],purple:[128,0,128],violet:[128,0,128],red:[255,0,0],silver:[192,192,192],white:[255,255,255],yellow:[255,255,0],transparent:[255,255,255]},r=["add","remove","toggle"],t={border:1,borderBottom:1,borderColor:1,borderLeft:1,borderRight:1,borderTop:1,borderWidth:1,margin:1,padding:1};f.effects.animateClass=function(c,a,b,
d){if(f.isFunction(b)){d=b;b=null}return this.queue("fx",function(){var e=f(this),g=e.attr("style")||" ",h=q(p.call(this)),l,v=e.attr("className");f.each(r,function(w,i){c[i]&&e[i+"Class"](c[i])});l=q(p.call(this));e.attr("className",v);e.animate(u(h,l),a,b,function(){f.each(r,function(w,i){c[i]&&e[i+"Class"](c[i])});if(typeof e.attr("style")=="object"){e.attr("style").cssText="";e.attr("style").cssText=g}else e.attr("style",g);d&&d.apply(this,arguments)});h=f.queue(this);l=h.splice(h.length-1,1)[0];
h.splice(1,0,l);f.dequeue(this)})};f.fn.extend({_addClass:f.fn.addClass,addClass:function(c,a,b,d){return a?f.effects.animateClass.apply(this,[{add:c},a,b,d]):this._addClass(c)},_removeClass:f.fn.removeClass,removeClass:function(c,a,b,d){return a?f.effects.animateClass.apply(this,[{remove:c},a,b,d]):this._removeClass(c)},_toggleClass:f.fn.toggleClass,toggleClass:function(c,a,b,d,e){return typeof a=="boolean"||a===j?b?f.effects.animateClass.apply(this,[a?{add:c}:{remove:c},b,d,e]):this._toggleClass(c,
a):f.effects.animateClass.apply(this,[{toggle:c},a,b,d])},switchClass:function(c,a,b,d,e){return f.effects.animateClass.apply(this,[{add:a,remove:c},b,d,e])}});f.extend(f.effects,{version:"1.8.10",save:function(c,a){for(var b=0;b<a.length;b++)a[b]!==null&&c.data("ec.storage."+a[b],c[0].style[a[b]])},restore:function(c,a){for(var b=0;b<a.length;b++)a[b]!==null&&c.css(a[b],c.data("ec.storage."+a[b]))},setMode:function(c,a){if(a=="toggle")a=c.is(":hidden")?"show":"hide";return a},getBaseline:function(c,
a){var b;switch(c[0]){case "top":b=0;break;case "middle":b=0.5;break;case "bottom":b=1;break;default:b=c[0]/a.height}switch(c[1]){case "left":c=0;break;case "center":c=0.5;break;case "right":c=1;break;default:c=c[1]/a.width}return{x:c,y:b}},createWrapper:function(c){if(c.parent().is(".ui-effects-wrapper"))return c.parent();var a={width:c.outerWidth(true),height:c.outerHeight(true),"float":c.css("float")},b=f("<div></div>").addClass("ui-effects-wrapper").css({fontSize:"100%",background:"transparent",
border:"none",margin:0,padding:0});c.wrap(b);b=c.parent();if(c.css("position")=="static"){b.css({position:"relative"});c.css({position:"relative"})}else{f.extend(a,{position:c.css("position"),zIndex:c.css("z-index")});f.each(["top","left","bottom","right"],function(d,e){a[e]=c.css(e);if(isNaN(parseInt(a[e],10)))a[e]="auto"});c.css({position:"relative",top:0,left:0,right:"auto",bottom:"auto"})}return b.css(a).show()},removeWrapper:function(c){if(c.parent().is(".ui-effects-wrapper"))return c.parent().replaceWith(c);
return c},setTransition:function(c,a,b,d){d=d||{};f.each(a,function(e,g){unit=c.cssUnit(g);if(unit[0]>0)d[g]=unit[0]*b+unit[1]});return d}});f.fn.extend({effect:function(c){var a=k.apply(this,arguments),b={options:a[1],duration:a[2],callback:a[3]};a=b.options.mode;var d=f.effects[c];if(f.fx.off||!d)return a?this[a](b.duration,b.callback):this.each(function(){b.callback&&b.callback.call(this)});return d.call(this,b)},_show:f.fn.show,show:function(c){if(m(c))return this._show.apply(this,arguments);
else{var a=k.apply(this,arguments);a[1].mode="show";return this.effect.apply(this,a)}},_hide:f.fn.hide,hide:function(c){if(m(c))return this._hide.apply(this,arguments);else{var a=k.apply(this,arguments);a[1].mode="hide";return this.effect.apply(this,a)}},__toggle:f.fn.toggle,toggle:function(c){if(m(c)||typeof c==="boolean"||f.isFunction(c))return this.__toggle.apply(this,arguments);else{var a=k.apply(this,arguments);a[1].mode="toggle";return this.effect.apply(this,a)}},cssUnit:function(c){var a=this.css(c),
b=[];f.each(["em","px","%","pt"],function(d,e){if(a.indexOf(e)>0)b=[parseFloat(a),e]});return b}});f.easing.jswing=f.easing.swing;f.extend(f.easing,{def:"easeOutQuad",swing:function(c,a,b,d,e){return f.easing[f.easing.def](c,a,b,d,e)},easeInQuad:function(c,a,b,d,e){return d*(a/=e)*a+b},easeOutQuad:function(c,a,b,d,e){return-d*(a/=e)*(a-2)+b},easeInOutQuad:function(c,a,b,d,e){if((a/=e/2)<1)return d/2*a*a+b;return-d/2*(--a*(a-2)-1)+b},easeInCubic:function(c,a,b,d,e){return d*(a/=e)*a*a+b},easeOutCubic:function(c,
a,b,d,e){return d*((a=a/e-1)*a*a+1)+b},easeInOutCubic:function(c,a,b,d,e){if((a/=e/2)<1)return d/2*a*a*a+b;return d/2*((a-=2)*a*a+2)+b},easeInQuart:function(c,a,b,d,e){return d*(a/=e)*a*a*a+b},easeOutQuart:function(c,a,b,d,e){return-d*((a=a/e-1)*a*a*a-1)+b},easeInOutQuart:function(c,a,b,d,e){if((a/=e/2)<1)return d/2*a*a*a*a+b;return-d/2*((a-=2)*a*a*a-2)+b},easeInQuint:function(c,a,b,d,e){return d*(a/=e)*a*a*a*a+b},easeOutQuint:function(c,a,b,d,e){return d*((a=a/e-1)*a*a*a*a+1)+b},easeInOutQuint:function(c,
a,b,d,e){if((a/=e/2)<1)return d/2*a*a*a*a*a+b;return d/2*((a-=2)*a*a*a*a+2)+b},easeInSine:function(c,a,b,d,e){return-d*Math.cos(a/e*(Math.PI/2))+d+b},easeOutSine:function(c,a,b,d,e){return d*Math.sin(a/e*(Math.PI/2))+b},easeInOutSine:function(c,a,b,d,e){return-d/2*(Math.cos(Math.PI*a/e)-1)+b},easeInExpo:function(c,a,b,d,e){return a==0?b:d*Math.pow(2,10*(a/e-1))+b},easeOutExpo:function(c,a,b,d,e){return a==e?b+d:d*(-Math.pow(2,-10*a/e)+1)+b},easeInOutExpo:function(c,a,b,d,e){if(a==0)return b;if(a==
e)return b+d;if((a/=e/2)<1)return d/2*Math.pow(2,10*(a-1))+b;return d/2*(-Math.pow(2,-10*--a)+2)+b},easeInCirc:function(c,a,b,d,e){return-d*(Math.sqrt(1-(a/=e)*a)-1)+b},easeOutCirc:function(c,a,b,d,e){return d*Math.sqrt(1-(a=a/e-1)*a)+b},easeInOutCirc:function(c,a,b,d,e){if((a/=e/2)<1)return-d/2*(Math.sqrt(1-a*a)-1)+b;return d/2*(Math.sqrt(1-(a-=2)*a)+1)+b},easeInElastic:function(c,a,b,d,e){c=1.70158;var g=0,h=d;if(a==0)return b;if((a/=e)==1)return b+d;g||(g=e*0.3);if(h<Math.abs(d)){h=d;c=g/4}else c=
g/(2*Math.PI)*Math.asin(d/h);return-(h*Math.pow(2,10*(a-=1))*Math.sin((a*e-c)*2*Math.PI/g))+b},easeOutElastic:function(c,a,b,d,e){c=1.70158;var g=0,h=d;if(a==0)return b;if((a/=e)==1)return b+d;g||(g=e*0.3);if(h<Math.abs(d)){h=d;c=g/4}else c=g/(2*Math.PI)*Math.asin(d/h);return h*Math.pow(2,-10*a)*Math.sin((a*e-c)*2*Math.PI/g)+d+b},easeInOutElastic:function(c,a,b,d,e){c=1.70158;var g=0,h=d;if(a==0)return b;if((a/=e/2)==2)return b+d;g||(g=e*0.3*1.5);if(h<Math.abs(d)){h=d;c=g/4}else c=g/(2*Math.PI)*Math.asin(d/
h);if(a<1)return-0.5*h*Math.pow(2,10*(a-=1))*Math.sin((a*e-c)*2*Math.PI/g)+b;return h*Math.pow(2,-10*(a-=1))*Math.sin((a*e-c)*2*Math.PI/g)*0.5+d+b},easeInBack:function(c,a,b,d,e,g){if(g==j)g=1.70158;return d*(a/=e)*a*((g+1)*a-g)+b},easeOutBack:function(c,a,b,d,e,g){if(g==j)g=1.70158;return d*((a=a/e-1)*a*((g+1)*a+g)+1)+b},easeInOutBack:function(c,a,b,d,e,g){if(g==j)g=1.70158;if((a/=e/2)<1)return d/2*a*a*(((g*=1.525)+1)*a-g)+b;return d/2*((a-=2)*a*(((g*=1.525)+1)*a+g)+2)+b},easeInBounce:function(c,
a,b,d,e){return d-f.easing.easeOutBounce(c,e-a,0,d,e)+b},easeOutBounce:function(c,a,b,d,e){return(a/=e)<1/2.75?d*7.5625*a*a+b:a<2/2.75?d*(7.5625*(a-=1.5/2.75)*a+0.75)+b:a<2.5/2.75?d*(7.5625*(a-=2.25/2.75)*a+0.9375)+b:d*(7.5625*(a-=2.625/2.75)*a+0.984375)+b},easeInOutBounce:function(c,a,b,d,e){if(a<e/2)return f.easing.easeInBounce(c,a*2,0,d,e)*0.5+b;return f.easing.easeOutBounce(c,a*2-e,0,d,e)*0.5+d*0.5+b}})}(jQuery);
;/*
 * jQuery UI Effects Blind 1.8.10
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Blind
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function(b){b.effects.blind=function(c){return this.queue(function(){var a=b(this),g=["position","top","bottom","left","right"],f=b.effects.setMode(a,c.options.mode||"hide"),d=c.options.direction||"vertical";b.effects.save(a,g);a.show();var e=b.effects.createWrapper(a).css({overflow:"hidden"}),h=d=="vertical"?"height":"width";d=d=="vertical"?e.height():e.width();f=="show"&&e.css(h,0);var i={};i[h]=f=="show"?d:0;e.animate(i,c.duration,c.options.easing,function(){f=="hide"&&a.hide();b.effects.restore(a,
g);b.effects.removeWrapper(a);c.callback&&c.callback.apply(a[0],arguments);a.dequeue()})})}})(jQuery);
;/*
 * jQuery UI Effects Bounce 1.8.10
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Bounce
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function(e){e.effects.bounce=function(b){return this.queue(function(){var a=e(this),l=["position","top","bottom","left","right"],h=e.effects.setMode(a,b.options.mode||"effect"),d=b.options.direction||"up",c=b.options.distance||20,m=b.options.times||5,i=b.duration||250;/show|hide/.test(h)&&l.push("opacity");e.effects.save(a,l);a.show();e.effects.createWrapper(a);var f=d=="up"||d=="down"?"top":"left";d=d=="up"||d=="left"?"pos":"neg";c=b.options.distance||(f=="top"?a.outerHeight({margin:true})/3:a.outerWidth({margin:true})/
3);if(h=="show")a.css("opacity",0).css(f,d=="pos"?-c:c);if(h=="hide")c/=m*2;h!="hide"&&m--;if(h=="show"){var g={opacity:1};g[f]=(d=="pos"?"+=":"-=")+c;a.animate(g,i/2,b.options.easing);c/=2;m--}for(g=0;g<m;g++){var j={},k={};j[f]=(d=="pos"?"-=":"+=")+c;k[f]=(d=="pos"?"+=":"-=")+c;a.animate(j,i/2,b.options.easing).animate(k,i/2,b.options.easing);c=h=="hide"?c*2:c/2}if(h=="hide"){g={opacity:0};g[f]=(d=="pos"?"-=":"+=")+c;a.animate(g,i/2,b.options.easing,function(){a.hide();e.effects.restore(a,l);e.effects.removeWrapper(a);
b.callback&&b.callback.apply(this,arguments)})}else{j={};k={};j[f]=(d=="pos"?"-=":"+=")+c;k[f]=(d=="pos"?"+=":"-=")+c;a.animate(j,i/2,b.options.easing).animate(k,i/2,b.options.easing,function(){e.effects.restore(a,l);e.effects.removeWrapper(a);b.callback&&b.callback.apply(this,arguments)})}a.queue("fx",function(){a.dequeue()});a.dequeue()})}})(jQuery);
;/*
 * jQuery UI Effects Clip 1.8.10
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Clip
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function(b){b.effects.clip=function(e){return this.queue(function(){var a=b(this),i=["position","top","bottom","left","right","height","width"],f=b.effects.setMode(a,e.options.mode||"hide"),c=e.options.direction||"vertical";b.effects.save(a,i);a.show();var d=b.effects.createWrapper(a).css({overflow:"hidden"});d=a[0].tagName=="IMG"?d:a;var g={size:c=="vertical"?"height":"width",position:c=="vertical"?"top":"left"};c=c=="vertical"?d.height():d.width();if(f=="show"){d.css(g.size,0);d.css(g.position,
c/2)}var h={};h[g.size]=f=="show"?c:0;h[g.position]=f=="show"?0:c/2;d.animate(h,{queue:false,duration:e.duration,easing:e.options.easing,complete:function(){f=="hide"&&a.hide();b.effects.restore(a,i);b.effects.removeWrapper(a);e.callback&&e.callback.apply(a[0],arguments);a.dequeue()}})})}})(jQuery);
;/*
 * jQuery UI Effects Drop 1.8.10
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Drop
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function(c){c.effects.drop=function(d){return this.queue(function(){var a=c(this),h=["position","top","bottom","left","right","opacity"],e=c.effects.setMode(a,d.options.mode||"hide"),b=d.options.direction||"left";c.effects.save(a,h);a.show();c.effects.createWrapper(a);var f=b=="up"||b=="down"?"top":"left";b=b=="up"||b=="left"?"pos":"neg";var g=d.options.distance||(f=="top"?a.outerHeight({margin:true})/2:a.outerWidth({margin:true})/2);if(e=="show")a.css("opacity",0).css(f,b=="pos"?-g:g);var i={opacity:e==
"show"?1:0};i[f]=(e=="show"?b=="pos"?"+=":"-=":b=="pos"?"-=":"+=")+g;a.animate(i,{queue:false,duration:d.duration,easing:d.options.easing,complete:function(){e=="hide"&&a.hide();c.effects.restore(a,h);c.effects.removeWrapper(a);d.callback&&d.callback.apply(this,arguments);a.dequeue()}})})}})(jQuery);
;/*
 * jQuery UI Effects Explode 1.8.10
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Explode
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function(j){j.effects.explode=function(a){return this.queue(function(){var c=a.options.pieces?Math.round(Math.sqrt(a.options.pieces)):3,d=a.options.pieces?Math.round(Math.sqrt(a.options.pieces)):3;a.options.mode=a.options.mode=="toggle"?j(this).is(":visible")?"hide":"show":a.options.mode;var b=j(this).show().css("visibility","hidden"),g=b.offset();g.top-=parseInt(b.css("marginTop"),10)||0;g.left-=parseInt(b.css("marginLeft"),10)||0;for(var h=b.outerWidth(true),i=b.outerHeight(true),e=0;e<c;e++)for(var f=
0;f<d;f++)b.clone().appendTo("body").wrap("<div></div>").css({position:"absolute",visibility:"visible",left:-f*(h/d),top:-e*(i/c)}).parent().addClass("ui-effects-explode").css({position:"absolute",overflow:"hidden",width:h/d,height:i/c,left:g.left+f*(h/d)+(a.options.mode=="show"?(f-Math.floor(d/2))*(h/d):0),top:g.top+e*(i/c)+(a.options.mode=="show"?(e-Math.floor(c/2))*(i/c):0),opacity:a.options.mode=="show"?0:1}).animate({left:g.left+f*(h/d)+(a.options.mode=="show"?0:(f-Math.floor(d/2))*(h/d)),top:g.top+
e*(i/c)+(a.options.mode=="show"?0:(e-Math.floor(c/2))*(i/c)),opacity:a.options.mode=="show"?1:0},a.duration||500);setTimeout(function(){a.options.mode=="show"?b.css({visibility:"visible"}):b.css({visibility:"visible"}).hide();a.callback&&a.callback.apply(b[0]);b.dequeue();j("div.ui-effects-explode").remove()},a.duration||500)})}})(jQuery);
;/*
 * jQuery UI Effects Fade 1.8.10
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Fade
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function(b){b.effects.fade=function(a){return this.queue(function(){var c=b(this),d=b.effects.setMode(c,a.options.mode||"hide");c.animate({opacity:d},{queue:false,duration:a.duration,easing:a.options.easing,complete:function(){a.callback&&a.callback.apply(this,arguments);c.dequeue()}})})}})(jQuery);
;/*
 * jQuery UI Effects Fold 1.8.10
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Fold
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function(c){c.effects.fold=function(a){return this.queue(function(){var b=c(this),j=["position","top","bottom","left","right"],d=c.effects.setMode(b,a.options.mode||"hide"),g=a.options.size||15,h=!!a.options.horizFirst,k=a.duration?a.duration/2:c.fx.speeds._default/2;c.effects.save(b,j);b.show();var e=c.effects.createWrapper(b).css({overflow:"hidden"}),f=d=="show"!=h,l=f?["width","height"]:["height","width"];f=f?[e.width(),e.height()]:[e.height(),e.width()];var i=/([0-9]+)%/.exec(g);if(i)g=parseInt(i[1],
10)/100*f[d=="hide"?0:1];if(d=="show")e.css(h?{height:0,width:g}:{height:g,width:0});h={};i={};h[l[0]]=d=="show"?f[0]:g;i[l[1]]=d=="show"?f[1]:0;e.animate(h,k,a.options.easing).animate(i,k,a.options.easing,function(){d=="hide"&&b.hide();c.effects.restore(b,j);c.effects.removeWrapper(b);a.callback&&a.callback.apply(b[0],arguments);b.dequeue()})})}})(jQuery);
;/*
 * jQuery UI Effects Highlight 1.8.10
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Highlight
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function(b){b.effects.highlight=function(c){return this.queue(function(){var a=b(this),e=["backgroundImage","backgroundColor","opacity"],d=b.effects.setMode(a,c.options.mode||"show"),f={backgroundColor:a.css("backgroundColor")};if(d=="hide")f.opacity=0;b.effects.save(a,e);a.show().css({backgroundImage:"none",backgroundColor:c.options.color||"#ffff99"}).animate(f,{queue:false,duration:c.duration,easing:c.options.easing,complete:function(){d=="hide"&&a.hide();b.effects.restore(a,e);d=="show"&&!b.support.opacity&&
this.style.removeAttribute("filter");c.callback&&c.callback.apply(this,arguments);a.dequeue()}})})}})(jQuery);
;/*
 * jQuery UI Effects Pulsate 1.8.10
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Pulsate
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function(d){d.effects.pulsate=function(a){return this.queue(function(){var b=d(this),c=d.effects.setMode(b,a.options.mode||"show");times=(a.options.times||5)*2-1;duration=a.duration?a.duration/2:d.fx.speeds._default/2;isVisible=b.is(":visible");animateTo=0;if(!isVisible){b.css("opacity",0).show();animateTo=1}if(c=="hide"&&isVisible||c=="show"&&!isVisible)times--;for(c=0;c<times;c++){b.animate({opacity:animateTo},duration,a.options.easing);animateTo=(animateTo+1)%2}b.animate({opacity:animateTo},duration,
a.options.easing,function(){animateTo==0&&b.hide();a.callback&&a.callback.apply(this,arguments)});b.queue("fx",function(){b.dequeue()}).dequeue()})}})(jQuery);
;/*
 * jQuery UI Effects Scale 1.8.10
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Scale
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function(c){c.effects.puff=function(b){return this.queue(function(){var a=c(this),e=c.effects.setMode(a,b.options.mode||"hide"),g=parseInt(b.options.percent,10)||150,h=g/100,i={height:a.height(),width:a.width()};c.extend(b.options,{fade:true,mode:e,percent:e=="hide"?g:100,from:e=="hide"?i:{height:i.height*h,width:i.width*h}});a.effect("scale",b.options,b.duration,b.callback);a.dequeue()})};c.effects.scale=function(b){return this.queue(function(){var a=c(this),e=c.extend(true,{},b.options),g=c.effects.setMode(a,
b.options.mode||"effect"),h=parseInt(b.options.percent,10)||(parseInt(b.options.percent,10)==0?0:g=="hide"?0:100),i=b.options.direction||"both",f=b.options.origin;if(g!="effect"){e.origin=f||["middle","center"];e.restore=true}f={height:a.height(),width:a.width()};a.from=b.options.from||(g=="show"?{height:0,width:0}:f);h={y:i!="horizontal"?h/100:1,x:i!="vertical"?h/100:1};a.to={height:f.height*h.y,width:f.width*h.x};if(b.options.fade){if(g=="show"){a.from.opacity=0;a.to.opacity=1}if(g=="hide"){a.from.opacity=
1;a.to.opacity=0}}e.from=a.from;e.to=a.to;e.mode=g;a.effect("size",e,b.duration,b.callback);a.dequeue()})};c.effects.size=function(b){return this.queue(function(){var a=c(this),e=["position","top","bottom","left","right","width","height","overflow","opacity"],g=["position","top","bottom","left","right","overflow","opacity"],h=["width","height","overflow"],i=["fontSize"],f=["borderTopWidth","borderBottomWidth","paddingTop","paddingBottom"],k=["borderLeftWidth","borderRightWidth","paddingLeft","paddingRight"],
p=c.effects.setMode(a,b.options.mode||"effect"),n=b.options.restore||false,m=b.options.scale||"both",l=b.options.origin,j={height:a.height(),width:a.width()};a.from=b.options.from||j;a.to=b.options.to||j;if(l){l=c.effects.getBaseline(l,j);a.from.top=(j.height-a.from.height)*l.y;a.from.left=(j.width-a.from.width)*l.x;a.to.top=(j.height-a.to.height)*l.y;a.to.left=(j.width-a.to.width)*l.x}var d={from:{y:a.from.height/j.height,x:a.from.width/j.width},to:{y:a.to.height/j.height,x:a.to.width/j.width}};
if(m=="box"||m=="both"){if(d.from.y!=d.to.y){e=e.concat(f);a.from=c.effects.setTransition(a,f,d.from.y,a.from);a.to=c.effects.setTransition(a,f,d.to.y,a.to)}if(d.from.x!=d.to.x){e=e.concat(k);a.from=c.effects.setTransition(a,k,d.from.x,a.from);a.to=c.effects.setTransition(a,k,d.to.x,a.to)}}if(m=="content"||m=="both")if(d.from.y!=d.to.y){e=e.concat(i);a.from=c.effects.setTransition(a,i,d.from.y,a.from);a.to=c.effects.setTransition(a,i,d.to.y,a.to)}c.effects.save(a,n?e:g);a.show();c.effects.createWrapper(a);
a.css("overflow","hidden").css(a.from);if(m=="content"||m=="both"){f=f.concat(["marginTop","marginBottom"]).concat(i);k=k.concat(["marginLeft","marginRight"]);h=e.concat(f).concat(k);a.find("*[width]").each(function(){child=c(this);n&&c.effects.save(child,h);var o={height:child.height(),width:child.width()};child.from={height:o.height*d.from.y,width:o.width*d.from.x};child.to={height:o.height*d.to.y,width:o.width*d.to.x};if(d.from.y!=d.to.y){child.from=c.effects.setTransition(child,f,d.from.y,child.from);
child.to=c.effects.setTransition(child,f,d.to.y,child.to)}if(d.from.x!=d.to.x){child.from=c.effects.setTransition(child,k,d.from.x,child.from);child.to=c.effects.setTransition(child,k,d.to.x,child.to)}child.css(child.from);child.animate(child.to,b.duration,b.options.easing,function(){n&&c.effects.restore(child,h)})})}a.animate(a.to,{queue:false,duration:b.duration,easing:b.options.easing,complete:function(){a.to.opacity===0&&a.css("opacity",a.from.opacity);p=="hide"&&a.hide();c.effects.restore(a,
n?e:g);c.effects.removeWrapper(a);b.callback&&b.callback.apply(this,arguments);a.dequeue()}})})}})(jQuery);
;/*
 * jQuery UI Effects Shake 1.8.10
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Shake
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function(d){d.effects.shake=function(a){return this.queue(function(){var b=d(this),j=["position","top","bottom","left","right"];d.effects.setMode(b,a.options.mode||"effect");var c=a.options.direction||"left",e=a.options.distance||20,l=a.options.times||3,f=a.duration||a.options.duration||140;d.effects.save(b,j);b.show();d.effects.createWrapper(b);var g=c=="up"||c=="down"?"top":"left",h=c=="up"||c=="left"?"pos":"neg";c={};var i={},k={};c[g]=(h=="pos"?"-=":"+=")+e;i[g]=(h=="pos"?"+=":"-=")+e*2;k[g]=
(h=="pos"?"-=":"+=")+e*2;b.animate(c,f,a.options.easing);for(e=1;e<l;e++)b.animate(i,f,a.options.easing).animate(k,f,a.options.easing);b.animate(i,f,a.options.easing).animate(c,f/2,a.options.easing,function(){d.effects.restore(b,j);d.effects.removeWrapper(b);a.callback&&a.callback.apply(this,arguments)});b.queue("fx",function(){b.dequeue()});b.dequeue()})}})(jQuery);
;/*
 * jQuery UI Effects Slide 1.8.10
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Slide
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function(c){c.effects.slide=function(d){return this.queue(function(){var a=c(this),h=["position","top","bottom","left","right"],f=c.effects.setMode(a,d.options.mode||"show"),b=d.options.direction||"left";c.effects.save(a,h);a.show();c.effects.createWrapper(a).css({overflow:"hidden"});var g=b=="up"||b=="down"?"top":"left";b=b=="up"||b=="left"?"pos":"neg";var e=d.options.distance||(g=="top"?a.outerHeight({margin:true}):a.outerWidth({margin:true}));if(f=="show")a.css(g,b=="pos"?isNaN(e)?"-"+e:-e:e);
var i={};i[g]=(f=="show"?b=="pos"?"+=":"-=":b=="pos"?"-=":"+=")+e;a.animate(i,{queue:false,duration:d.duration,easing:d.options.easing,complete:function(){f=="hide"&&a.hide();c.effects.restore(a,h);c.effects.removeWrapper(a);d.callback&&d.callback.apply(this,arguments);a.dequeue()}})})}})(jQuery);
;/*
 * jQuery UI Effects Transfer 1.8.10
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Transfer
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function(e){e.effects.transfer=function(a){return this.queue(function(){var b=e(this),c=e(a.options.to),d=c.offset();c={top:d.top,left:d.left,height:c.innerHeight(),width:c.innerWidth()};d=b.offset();var f=e('<div class="ui-effects-transfer"></div>').appendTo(document.body).addClass(a.options.className).css({top:d.top,left:d.left,height:b.innerHeight(),width:b.innerWidth(),position:"absolute"}).animate(c,a.duration,a.options.easing,function(){f.remove();a.callback&&a.callback.apply(b[0],arguments);
b.dequeue()})})}})(jQuery);
;
/*-------------------------------------------------------------------- 
 * jQuery plugin: customInput()
 * by Maggie Wachs and Scott Jehl, http://www.filamentgroup.com
 * Copyright (c) 2009 Filament Group
 * Dual licensed under the MIT (filamentgroup.com/examples/mit-license.txt) and GPL (filamentgroup.com/examples/gpl-license.txt) licenses.
 * Article: http://www.filamentgroup.com/lab/accessible_custom_designed_checkbox_radio_button_inputs_styled_css_jquery/  
 * Usage example below (see comment "Run the script...").
--------------------------------------------------------------------*/


jQuery.fn.customInput = function(){
	var context = this.context;
	$(this).each(function(i){	
		if($(this).is('[type=checkbox],[type=radio]')){
			var input = $(this);
			
			// get the associated label using the input's id
			var label = $('label[for='+input.attr('id')+']', context);
			
			//get type, for classname suffix 
			var inputType = (input.is('[type=checkbox]')) ? 'checkbox' : 'radio';
			
			// wrap the input + label in a div 
			$('<div class="custom-'+ inputType +'"></div>').insertBefore(input).append(input, label);
			
			// find all inputs in this set using the shared name attribute
			var allInputs = $('input[name='+input.attr('name')+']', context);
			
			if (input.not('[disabled]').size() === 0) {
				
				input.parent().addClass('disabled');
				
			} else {
				// necessary for browsers that don't support the :hover pseudo class on labels
				label.hover(
					function(){ 
						$(this).addClass('hover'); 
						if(inputType == 'checkbox' && input.is(':checked')){ 
							$(this).addClass('checkedHover'); 
						} 
					},
					function(){ $(this).removeClass('hover checkedHover'); }
				);
				
				//bind custom event, trigger it, bind click,focus,blur events					
				input.bind('updateState', function(){	
					if (input.is(':checked')) {
						if (input.is(':radio')) {				
							allInputs.each(function(){
								$('label[for='+$(this).attr('id')+']').removeClass('checked');
							});		
						};
						label.addClass('checked');
					}
					else { label.removeClass('checked checkedHover checkedFocus'); }
											
				})
				.trigger('updateState')
				.click(function(){ 
					$(this).trigger('updateState'); 
				})
				.focus(function(){ 
					label.addClass('focus'); 
					if(inputType == 'checkbox' && input.is(':checked')){ 
						$(this).addClass('checkedFocus'); 
					} 
				})
				.blur(function(){ label.removeClass('focus checkedFocus'); });
			}
		}
	});
};

	
	

/**
 * jQuery.ScrollTo
 * Copyright (c) 2007-2009 Ariel Flesler - aflesler(at)gmail(dot)com | http://flesler.blogspot.com
 * Dual licensed under MIT and GPL.
 * Date: 5/25/2009
 *
 * @projectDescription Easy element scrolling using jQuery.
 * http://flesler.blogspot.com/2007/10/jqueryscrollto.html
 * Works with jQuery +1.2.6. Tested on FF 2/3, IE 6/7/8, Opera 9.5/6, Safari 3, Chrome 1 on WinXP.
 *
 * @author Ariel Flesler
 * @version 1.4.2
 *
 * @id jQuery.scrollTo
 * @id jQuery.fn.scrollTo
 * @param {String, Number, DOMElement, jQuery, Object} target Where to scroll the matched elements.
 *	  The different options for target are:
 *		- A number position (will be applied to all axes).
 *		- A string position ('44', '100px', '+=90', etc ) will be applied to all axes
 *		- A jQuery/DOM element ( logically, child of the element to scroll )
 *		- A string selector, that will be relative to the element to scroll ( 'li:eq(2)', etc )
 *		- A hash { top:x, left:y }, x and y can be any kind of number/string like above.
*		- A percentage of the container's dimension/s, for example: 50% to go to the middle.
 *		- The string 'max' for go-to-end. 
 * @param {Number} duration The OVERALL length of the animation, this argument can be the settings object instead.
 * @param {Object,Function} settings Optional set of settings or the onAfter callback.
 *	 @option {String} axis Which axis must be scrolled, use 'x', 'y', 'xy' or 'yx'.
 *	 @option {Number} duration The OVERALL length of the animation.
 *	 @option {String} easing The easing method for the animation.
 *	 @option {Boolean} margin If true, the margin of the target element will be deducted from the final position.
 *	 @option {Object, Number} offset Add/deduct from the end position. One number for both axes or { top:x, left:y }.
 *	 @option {Object, Number} over Add/deduct the height/width multiplied by 'over', can be { top:x, left:y } when using both axes.
 *	 @option {Boolean} queue If true, and both axis are given, the 2nd axis will only be animated after the first one ends.
 *	 @option {Function} onAfter Function to be called after the scrolling ends. 
 *	 @option {Function} onAfterFirst If queuing is activated, this function will be called after the first scrolling ends.
 * @return {jQuery} Returns the same jQuery object, for chaining.
 *
 * @desc Scroll to a fixed position
 * @example $('div').scrollTo( 340 );
 *
 * @desc Scroll relatively to the actual position
 * @example $('div').scrollTo( '+=340px', { axis:'y' } );
 *
 * @dec Scroll using a selector (relative to the scrolled element)
 * @example $('div').scrollTo( 'p.paragraph:eq(2)', 500, { easing:'swing', queue:true, axis:'xy' } );
 *
 * @ Scroll to a DOM element (same for jQuery object)
 * @example var second_child = document.getElementById('container').firstChild.nextSibling;
 *			$('#container').scrollTo( second_child, { duration:500, axis:'x', onAfter:function(){
 *				alert('scrolled!!');																   
 *			}});
 *
 * @desc Scroll on both axes, to different values
 * @example $('div').scrollTo( { top: 300, left:'+=200' }, { axis:'xy', offset:-20 } );
 */
;(function( $ ){
	
	var $scrollTo = $.scrollTo = function( target, duration, settings ){
		$(window).scrollTo( target, duration, settings );
	};

	$scrollTo.defaults = {
		axis:'xy',
		duration: parseFloat($.fn.jquery) >= 1.3 ? 0 : 1
	};

	// Returns the element that needs to be animated to scroll the window.
	// Kept for backwards compatibility (specially for localScroll & serialScroll)
	$scrollTo.window = function( scope ){
		return $(window)._scrollable();
	};

	// Hack, hack, hack :)
	// Returns the real elements to scroll (supports window/iframes, documents and regular nodes)
	$.fn._scrollable = function(){
		return this.map(function(){
			var elem = this,
				isWin = !elem.nodeName || $.inArray( elem.nodeName.toLowerCase(), ['iframe','#document','html','body'] ) != -1;

				if( !isWin )
					return elem;

			var doc = (elem.contentWindow || elem).document || elem.ownerDocument || elem;
			
			return $.browser.safari || doc.compatMode == 'BackCompat' ?
				doc.body : 
				doc.documentElement;
		});
	};

	$.fn.scrollTo = function( target, duration, settings ){
		if( typeof duration == 'object' ){
			settings = duration;
			duration = 0;
		}
		if( typeof settings == 'function' )
			settings = { onAfter:settings };
			
		if( target == 'max' )
			target = 9e9;
			
		settings = $.extend( {}, $scrollTo.defaults, settings );
		// Speed is still recognized for backwards compatibility
		duration = duration || settings.speed || settings.duration;
		// Make sure the settings are given right
		settings.queue = settings.queue && settings.axis.length > 1;
		
		if( settings.queue )
			// Let's keep the overall duration
			duration /= 2;
		settings.offset = both( settings.offset );
		settings.over = both( settings.over );

		return this._scrollable().each(function(){
			var elem = this,
				$elem = $(elem),
				targ = target, toff, attr = {},
				win = $elem.is('html,body');
                
                
            
                

			switch( typeof targ ){
				// A number will pass the regex
				case 'number':
				case 'string':
					if( /^([+-]=)?\d+(\.\d+)?(px|%)?$/.test(targ) ){
						targ = both( targ );
						// We are done
						break;
					}
					// Relative selector, no break!
					targ = $(targ,this);
				case 'object':
					// DOMElement / jQuery
					if( targ.is || targ.style )
						// Get the real position of the target 
						toff = (targ = $(targ)).offset();
			}
			$.each( settings.axis.split(''), function( i, axis ){
				var Pos	= axis == 'x' ? 'Left' : 'Top',
					pos = Pos.toLowerCase(),
					key = 'scroll' + Pos,
					old = elem[key],
					max = $scrollTo.max(elem, axis),
                    panelNr = targ.attr('id').replace('panel','');

				if( toff ){// jQuery / DOMElement
					attr[key] = toff[pos] + ( win ? 0 : old - $elem.offset()[pos] );

					// If it's a dom element, reduce the margin
					if( settings.margin ){
						attr[key] -= parseInt(targ.css('margin'+Pos)) || 0;
						attr[key] -= parseInt(targ.css('border'+Pos+'Width')) || 0;
					}
					
					attr[key] += settings.offset[pos] || 0;
					
					if( settings.over[pos] )
						// Scroll to a fraction of its width/height
						attr[key] += targ[axis=='x'?'width':'height']() * settings.over[pos];
				}else{ 
					var val = targ[pos];
					// Handle percentage values
					attr[key] = val.slice && val.slice(-1) == '%' ? 
						parseFloat(val) / 100 * max
						: val;
				}

				// Number or 'number'
				if( /^\d+$/.test(attr[key]) ){
                    if($('#frontend').hasClass('scaled')){                    
                        // Fix for scaled frontend
                        attr[key] = 290 * (panelNr-1);           
                    }
                    
                    // Check the limits
                    attr[key] = attr[key] <= 0 ? 0 : Math.min( attr[key], max );
                }
                
				// Queueing axes
				if( !i && settings.queue ){
					// Don't waste time animating, if there's no need.
					if( old != attr[key] )
						// Intermediate animation
						animate( settings.onAfterFirst );
					// Don't animate this axis again in the next iteration.
					delete attr[key];
				}
			});

			animate( settings.onAfter );			

			function animate( callback ){
				$elem.animate( attr, duration, settings.easing, callback && function(){
					callback.call(this, target, settings);
				});
			};

		}).end();
	};
	
	// Max scrolling position, works on quirks mode
	// It only fails (not too badly) on IE, quirks mode.
	$scrollTo.max = function( elem, axis ){
		var Dim = axis == 'x' ? 'Width' : 'Height',
			scroll = 'scroll'+Dim;
		
		if( !$(elem).is('html,body') )
			return elem[scroll] - $(elem)[Dim.toLowerCase()]();
		
		var size = 'client' + Dim,
			html = elem.ownerDocument.documentElement,
			body = elem.ownerDocument.body;

		return Math.max( html[scroll], body[scroll] ) 
			 - Math.min( html[size]  , body[size]   );
			
	};

	function both( val ){
		return typeof val == 'object' ? val : { top:val, left:val };
	};

})( jQuery );
/**
 * jQuery.LocalScroll - Animated scrolling navigation, using anchors.
 * Copyright (c) 2007-2009 Ariel Flesler - aflesler(at)gmail(dot)com | http://flesler.blogspot.com
 * Dual licensed under MIT and GPL.
 * Date: 3/11/2009
 * @author Ariel Flesler
 * @version 1.2.7
 **/
;(function($){var l=location.href.replace(/#.*/,'');var g=$.localScroll=function(a){$('body').localScroll(a)};g.defaults={duration:1e3,axis:'y',event:'click',stop:true,target:window,reset:true};g.hash=function(a){if(location.hash){a=$.extend({},g.defaults,a);a.hash=false;if(a.reset){var e=a.duration;delete a.duration;$(a.target).scrollTo(0,a);a.duration=e}i(0,location,a)}};$.fn.localScroll=function(b){b=$.extend({},g.defaults,b);return b.lazy?this.bind(b.event,function(a){var e=$([a.target,a.target.parentNode]).filter(d)[0];if(e)i(a,e,b)}):this.find('a,area').filter(d).bind(b.event,function(a){i(a,this,b)}).end().end();function d(){return!!this.href&&!!this.hash&&this.href.replace(this.hash,'')==l&&(!b.filter||$(this).is(b.filter))}};function i(a,e,b){var d=e.hash.slice(1),f=document.getElementById(d)||document.getElementsByName(d)[0];if(!f)return;if(a)a.preventDefault();var h=$(b.target);if(b.lock&&h.is(':animated')||b.onBefore&&b.onBefore.call(b,a,f,h)===false)return;if(b.stop)h.stop(true);if(b.hash){var j=f.id==d?'id':'name',k=$('<a> </a>').attr(j,d).css({position:'absolute',top:$(window).scrollTop(),left:$(window).scrollLeft()});f[j]='';$('body').prepend(k);location=e.hash;k.remove();f[j]=d}h.scrollTo(f,b).trigger('notify.serialScroll',[f])}})(jQuery);
/*
 * jQuery.SerialScroll - Animated scrolling of series
 * Copyright (c) 2007-2009 Ariel Flesler - aflesler(at)gmail(dot)com | http://flesler.blogspot.com
 * Dual licensed under MIT and GPL.
 * Date: 06/14/2009
 * @author Ariel Flesler
 * @version 1.2.2
 * http://flesler.blogspot.com/2008/02/jqueryserialscroll.html
 */
;(function(a){var b=a.serialScroll=function(c){return a(window).serialScroll(c)};b.defaults={duration:1e3,axis:"x",event:"click",start:0,step:1,lock:!0,cycle:!0,constant:!0};a.fn.serialScroll=function(c){return this.each(function(){var t=a.extend({},b.defaults,c),s=t.event,i=t.step,r=t.lazy,e=t.target?this:document,u=a(t.target||this,e),p=u[0],m=t.items,h=t.start,g=t.interval,k=t.navigation,l;if(!r){m=d()}if(t.force){f({},h)}a(t.prev||[],e).bind(s,-i,q);a(t.next||[],e).bind(s,i,q);if(!p.ssbound){u.bind("prev.serialScroll",-i,q).bind("next.serialScroll",i,q).bind("goto.serialScroll",f)}if(g){u.bind("start.serialScroll",function(v){if(!g){o();g=!0;n()}}).bind("stop.serialScroll",function(){o();g=!1})}u.bind("notify.serialScroll",function(x,w){var v=j(w);if(v>-1){h=v}});p.ssbound=!0;if(t.jump){(r?u:d()).bind(s,function(v){f(v,j(v.target))})}if(k){k=a(k,e).bind(s,function(v){v.data=Math.round(d().length/k.length)*k.index(this);f(v,this)})}function q(v){v.data+=h;f(v,this)}function f(B,z){if(!isNaN(z)){B.data=z;z=p}var C=B.data,v,D=B.type,A=t.exclude?d().slice(0,-t.exclude):d(),y=A.length,w=A[C],x=t.duration;if(D){B.preventDefault()}if(g){o();l=setTimeout(n,t.interval)}if(!w){v=C<0?0:y-1;if(h!=v){C=v}else{if(!t.cycle){return}else{C=y-v-1}}w=A[C]}if(!w||t.lock&&u.is(":animated")||D&&t.onBefore&&t.onBefore(B,w,u,d(),C)===!1){return}if(t.stop){u.queue("fx",[]).stop()}if(t.constant){x=Math.abs(x/i*(h-C))}u.scrollTo(w,x,t).trigger("notify.serialScroll",[C])}function n(){u.trigger("next.serialScroll")}function o(){clearTimeout(l)}function d(){return a(m,p)}function j(w){if(!isNaN(w)){return w}var x=d(),v;while((v=x.index(w))==-1&&w!=p){w=w.parentNode}return v}})}})(jQuery);(function (root) {
	var EASY = root.EASY;
	root.EASY_DEBUG = EASY.debug = false;
	root.EASY_VERSION = EASY.version = 20140225100054;
}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 */
(function (root) {
	"use strict";
	
	
	// Node support
	if (typeof require !== 'undefined') {
		if (!root.EASY) {
			root.EASY = require('./../../../../common/js/components/easy/easy');
		}
	}
	
	var APP,
		EASY = root.EASY,
		win = EASY.win,
		doc = EASY.doc,
		$ = EASY.$,
		Backbone = EASY.Backbone,
		_ = EASY._,
		tasks = {},
		isReady = false,
		isStarted = false,
		domReady = false,
		TASK_STATUS_WAITING = 'waiting',
		TASK_STATUS_DEFERED = 'defered',
		TASK_STATUS_RUNNING = 'running',
		TASK_STATUS_DONE = 'done',
		
		/**
		 * Run tasks
		 */
		runTasks = function runTasks() {
			if (runTasks.halt === true) {
				return false;
			}
			
			_.forEach(tasks, function runTask(fn, name) {
				if (fn.status === TASK_STATUS_WAITING) {
					
					// Set status deferred
					tasks[name].status = TASK_STATUS_DEFERED;
					
					_.defer(function deferRunTask() {
						
						// Set status running
						tasks[name].status = TASK_STATUS_RUNNING;
						
						fn(function done(err) {
							// Done with error should cause the loading to fail
							if (err instanceof Error) {
								runTasks.halt = true;
								APP.log.error(err);
								APP.trigger('error', err.message);
								return;
							}
							
							// Mark as done
							tasks[name].status = TASK_STATUS_DONE;
							
							var allDone = _.unique(_.pluck(tasks, 'status'));
							
							// Trigger task APP event
							APP.trigger('task', APP, name);
							APP.trigger('task:' + name, APP);
							
							// Queue done?
							if (allDone.length === 1 && allDone[0] === TASK_STATUS_DONE) {
								// TODO: The "this.isReady" should not be needed!
								isReady = APP.isReady = true;
								
								// Trigger APP event
								setTimeout(function onTimeout() {
									APP.trigger('ready');
								}, 1000);
							}
						});
					});
				}
			});
		},
		
		gameLog = function () {
			if (win.log && win.log.debug) {
				try {
					win.log.debug((new Date().toJSON()) + ' - ' + _.chain(arguments).toArray().map(function (val) {
						if (val !== null && val !== undefined && val.toString) {
							return val.toString();
						}
						return JSON.stringify(val);
					}).value().join(' '));
				} catch (e) {
					win.log.debug((new Date().toJSON()) + ' - ' + e.message);
				}
			}
		};
	
	
	/**
	 * Create APP which is a subclass of Backbone.Events
	 * TODO: Change APP to be an instance of Backbone.Router
	 * 
	 * @class APP
	 * @extends EASY
	 * @namespace GAME
	 */
	APP = root.APP = new (EASY.extend({
		
		constructor: function () {
			// Call parent constructor
			EASY.apply(this, arguments);
			
			var easyLog = this.log;
			
			this.log = function () {
				if (this.debug) {
					gameLog();
				}
				return easyLog.apply(this, arguments);
			};
			
			_.forEach(_.keys(easyLog), function (method) {
				this.log[method] = easyLog[method];
			}, this);
		},
				
		sidis: {
			trans: function (msg) {
				return msg;
			}
		},
		
		/**
		 * Task
		 */
		task: function taskApplication() {
			
			var args = _.toArray(arguments),
				name = args.shift(),
				fn = args.pop(),
				waitForTasks = args.shift() || [];
			
			if (!_.isArray(waitForTasks)) {
				waitForTasks = [ waitForTasks ];
			}
			
			// Check so the we don't add duplicates
			if (tasks.hasOwnProperty(name)) {
				throw new Error('Task with name "' + name + '" already defined');
			}
			
			// Check so the we don't add non functions
			if (fn === 'function') {
				throw new Error('Task with name "' + name + '" must to be a function!');
			}
			
			// We aren't done yet
			isReady = this.isReady = false;
			
			// Add to task queue
			if (waitForTasks.length === 0) {
				tasks[name] = fn;
			} else {
				tasks[name] = function (done) {
					APP.onTask(waitForTasks, function () {
						fn(done);
					});
				};
			}
			tasks[name].status = TASK_STATUS_WAITING;
			tasks[name].dependsOn = waitForTasks; 
			
			// Run tasks
			if (isStarted) {
				runTasks();
			}
			
			return this;
		},
		
		/**
		 * DOM Task
		 */
		domTask: function domTaskApplication() {
			var args = _.toArray(arguments),
				name = args.shift(),
				fn = args.pop(),
				waitForTasks = args.shift() || [];
			
			if (!_.isArray(waitForTasks)) {
				waitForTasks = [ waitForTasks ];
			}
			
			waitForTasks.unshift('dom');
			
			APP.task(name, waitForTasks, fn);
			
			return this;
		},
		
		/**
		 * On Task
		 */
		onTask: function onTaskApplication() {
			
			var args = _.toArray(arguments),
				fn = args.pop(),
				len,
				name,
				i,
				isWaiting = true,
				check = function check() {
					var len = args.length,
						name,
						i;
					
					// Loops over each task
					for (i = 0; i < len; i += 1) {
						name = args[i];
						// If the task does not exists or not got the done status
						// it has not yet been completed so we can't trigger
						// the task listener callback
						if (!tasks.hasOwnProperty(name) || tasks[name].status !== TASK_STATUS_DONE) {
							return;
						}
					}
					
					// Make sure it's async
					setTimeout(function triggerTaskListener() {
						if (runTasks.halt !== true && isWaiting) {
							fn();
							isWaiting = false;
						}
					}, 0);
				};
			
			if (args.length === 1 && _.isArray(args[0])) {
				args = args[0];
			} 
			
			// Loops over each task
			for (i = 0, len = args.length; i < len; i += 1) {
				name = args[i];
				// If the task does not exists or not got the done status
				// it has not yet been completed so we can't trigger
				// the task listener callback
				if (!tasks.hasOwnProperty(name) || tasks[name].status !== TASK_STATUS_DONE) {
					APP.once('task:' + name, check);
				}
			}
			
			// Run a check
			check();
			
			return this;
		},
		
		
		/**
		 * Ready
		 */
		ready: function readyApplication(fn) {
			if (isReady) {
				_.defer(fn);
			} else {
				this.once('ready', fn);
			}
			return this;
		},
		
		
		/**
		 * Start
		 */
		start: function startApplication() {
			if (isStarted) {
				return this;
			}
			
			this.log.time('APPLICATION :: START');
			
			isStarted = true;
			
			var msReadyTimeout = 2 * 60 * 1000, // the time we will wait for the ready event
				readyTimer = setTimeout(function onReadyTimeout() {
					runTasks.halt = true;
					
					var uncompletedTasks = [],
						error = 'Failed to get the ready event in time'; // TODO: Localize
					
					_.forEach(tasks, function eachTaskName(task, name) {
						if (task.status !== TASK_STATUS_DONE) {
							uncompletedTasks.push(JSON.stringify({
								task: name,
								status: task.status,
								dependsOn: _.map(task.dependsOn, function (dep) {
									return dep + '=' + tasks[dep].status;
								}).join(', ')
							}));
						}
					});
					
					APP.log.warn('Remaining Tasks:\n' + uncompletedTasks.join('\n'));
					
					APP.trigger('error', {
						body: error,
						close: false
					});
				}, msReadyTimeout),
				onError,
				onReady,
				onTask,
				$progress = this.$splash.find('div.progress-meter'),
				totalTaskCount = _.keys(tasks).length + 1,
				taskCount = 0;
			
			
			// On Error
			onError = _.bind(function onErrorStartApplication() {
				// Clear ready timer
				if (readyTimer) {
					clearTimeout(readyTimer);
				}
				
				// Halt tasks
				runTasks.halt = true;
				
				// Unbind stuff
				this.unbind('error', onError);
				this.unbind('ready', onReady);
				this.unbind('task', onTask);
				
				this.$splash.addClass('error');
				
			}, this);
			
			
			// On Ready
			onReady = _.bind(function onReadyStartApplication() {
				var $win = $(APP.win);
				
				// Clear ready timer
				if (readyTimer) {
					clearTimeout(readyTimer);
				}
				
				APP.win.playSound('LoadedSoldier', 'Login is complete');
				
				this.$main.addClass('loaded');
				
				// Unbind stuff
				this.unbind('error', onError);
				this.unbind('ready', onReady);
				this.unbind('task', onTask);
				
				// F5 reloads in front-end
				if (APP.win.game && APP.ns('config').debug) {
					$win.bind('keydown', function onKeyDown(e) {
						if (e.keyCode === 116) {
							APP.reload();
						}
					});
				}
				
				// On before unload
				$win.one('beforeunload', _.bind(function () {
					this.showSplash();
				}, this));
				
				// We start on the home page
				win.location.hash = 'home';
				
				// Start watching the history
				Backbone.history.start();
				
				// Everything is ready. Show frontend
				$progress.css('width', '100%');
				_.delay(_.bind(function () {
					this.hideSplash();
					this.$splash.find('div.progress-bar').remove();
					this.log.timeEnd('APPLICATION :: START');
					this.log.timeEnd('APPLICATION :: START');
				}, this), 200);
				
			}, this);
			
			
			// On task
			onTask = function () {
				taskCount += 1;
				var progress = (taskCount / totalTaskCount) * 100;
				$progress.css('width', progress + '%');
			};
			
			// Handle errors while loading
			this.bind('error', onError);
			
			// Handle ready
			this.bind('ready', onReady);
			
			// Handle task progress
			this.bind('task', onTask);
			
			// Hide pages
			this.$main.find('div.main').addClass('hidden');
			
			// Run tasks
			runTasks();
			
			return this;
		},
		
		/**
		 * Page
		 */
		page: function pageApplication(page, data) {
			data = data || {};
			
			var $mains = this.$main.find('div.main'),
				from = (($mains.not('.hidden').attr('class') || '').match(/main_([^\s]+)/) || []).pop(),
				found = false;
			
			if (page === true) {
				from = page;
			}
			
			if (page === from) {
				found = true;
			} else {
				$mains.each(function () {
					var $page = $(this);
					if ($page.hasClass('main_' + page)) {
						found = true;
						if (!$page.is(':visible')) {
							$page.hide().removeClass('hidden').fadeIn('slow');
						}
					} else {
						$page.addClass('hidden');
					}
				});
			}
			
			if (found) {
				this.trigger('page', page, from, data);
				this.trigger('page:' + page, from, data);
			} else {
				throw new Error('Unable to show page "' + page + '"');
			}
			
			return this;
		},
		currentPage: function () {
			var $mains = this.$frontend.find('div.main'),
				from = (($mains.not('.hidden').attr('class') || '').match(/main_([^\s]+)/) || []).pop();
				
			return from;
		},
		
		/**
		 * Show splash
		 */
		showSplash: function showSplashApplication() {
			this.$splash.show();
			this.$main.hide();
			APP.win.hideDoll();
			return this;
		},
		
		
		/**
		 * Hide splash
		 */
		hideSplash: function hideSplashApplication() {
			this.$splash.hide();
			this.$main.show();
			return this;
		},
		
		
		/**
		 * Reload
		 */
		reload: function reloadApplication(delay) {
			delay = delay || 0;
			
			_.delay(function () {
				APP.win.location.reload();
			}, delay);
			
			return this;
		}
	}))();
	
	
	/**
	 * Catch all route that will navigate home
	 */
	APP.route(/.*/, 'catch-all', function routeCatchAll() {
		APP.log.warn('Unhandled route', APP.win.location.hash);
		// APP.navigate('/home'), true;
	});
	
	
	/**
	 * Default simpel page route
	 */
	APP.route('page/:page', 'page', APP.page);
	
	
	/**
	 * Add a DOM ready task
	 */
	APP.task('dom', function initDOMReady(done) {
		$(function jQueryDOMReady() {
			domReady = true;
			done();
		});
	});
	
	
	/**
	 * Random
	 */
	APP.randomInt = function randomInt(min, max) {
		min = min || 0;
		max = max || (new Date()).getTime();
		return Math.floor(Math.random() * (max - min + 1)) + min;
	};


	APP.doll = {};
	
	/**
	 * Game API
	 */
	APP.api = {
		general: root.general || {
			autoReload: true,
			cameraShake: false,
			getWindowSize: function () {
				// return '{ "width": 1024, "height": 768 }';
				// return '{ "width": 800, "height": 600 }';
				if (win.innerWidth < 1024 || win.innerHeight < 768) {
					return '{ "width": 800, "height": 600 }';
				}
				return '{ "width": 1024, "height": 768 }';
			},
			reset: function () {
				APP.api.general.autoReload = true;
				APP.api.general.cameraShake = false;
			},
			cancel: function () {},
			apply: function () {}
		},
		video: root.video || {
			selectedResolution: '1280x1024@60Hz',
			getScreenResolutions: function () {
				return '[ { "resolution" : "640x480@60Hz", "recommended" : "false" }, ' +
					'{ "resolution" : "720x480@60Hz", "recommended" : "false" },' +
					'{ "resolution" : "720x576@60Hz", "recommended" : "false" },' +
					'{ "resolution" : "800x600@60Hz", "recommended" : "true"  },' +
					'{ "resolution" : "1024x768@60Hz", "recommended" : "true" },' +
					'{ "resolution" : "1152x864@60Hz", "recommended" : "false" },' +
					'{ "resolution" : "1280x720@60Hz", "recommended" : "false" },' +
					'{ "resolution" : "1280x768@60Hz", "recommended" : "false" },' +
					'{ "resolution" : "1280x800@60Hz", "recommended" : "false" },' +
					'{ "resolution" : "1280x960@60Hz", "recommended" : "false" },' +
					'{ "resolution" : "1280x1024@60Hz", "recommended" : "true" },' +
					'{ "resolution" : "1360x768@60Hz", "recommended" : "false" },' +
					'{ "resolution" : "1366x768@60Hz", "recommended" : "false" },' +
					'{ "resolution" : "1600x900@60Hz", "recommended" : "false" },' +
					'{ "resolution" : "1600x1024@60Hz", "recommended" : "false" },' +
					'{ "resolution" : "1600x1200@60Hz", "recommended" : "true" }]';
			},
			scheme: 2,
			detectScheme: function () {
				return 2;
			},
			getAvailableAntialiasing: function () {
				return '[ { "value" : "Off", "text" : "VIDEOSETTINGS_Off" }, ' +
					'{ "value" : "2Samples", "text" : "VIDEOSETTINGS_2Samples" }, ' +
					'{ "value" : "4Samples", "text" : "VIDEOSETTINGS_4Samples" }, ' +
					'{ "value" : "8Samples", "text" : "VIDEOSETTINGS_8Samples" } ]';
			},
			reset: function () {
				APP.api.video.selectedResolution = '1280x1024@60Hz';
				APP.api.video.scheme = 2;
			},
			save: function () {},
			cancel: function () {},
			apply: function () {}
		},
		audio: root.audio || {
			effectsVolume: 0.7,
			musicVolume: 0.7,
			hasEAX: false,
			eax: false,
			hasZenithBoard: false,
			provider: 'hardware',
			quality: 'High',
			needRestart: false,
			inCriticalState : false,
			save: function () {},
			cancel: function () {},
			canApply: function () {
				return true;
			},
			reset: function () {
				APP.api.audio.effectsVolume = 0.7;
				APP.api.audio.musicVolume = 0.7;
				APP.api.audio.quality = 'High';
				APP.api.audio.provider = 'hardware';
			},
			apply: function () {}
		},
		controls: root.controls || {
			mouseSensitivity: 3,
			mouseSensitivityMultiplier: 1,
			mouseSmoothing: 0,
			mouseYawFactor: 1,
			mousePitchFactor: 1,
			invertMouse: false,
			keyboardSensitivity: 0.1,
			getMappedString: function (mapName, index, secondary, invert) {
				return mapName.replace('PlayerInputControlMap', '');
			},
			getKeyMapping: function (mapName) {},
			mapInput: function () {
				return APP.randomInt(0, 3);
			},
			reset: function () {},
			save: function () {},
			cancel: function () {},
			apply: function () {},
			lastDuplicateInput: 'WEST_FE_COM_Controls_Weapon_WeaponKey0'
		},
		localization: root.localization || {
			get: function (tag) {
				return tag;
			},
			lang: 'en'
		}
	};
	
	
	/**
	 * Module support
	 */
	if (typeof module !== 'undefined' && module.exports) {
		module.exports = APP;
		
	} else {
		
		/**
		 * Disbale tabbing
		 */
		APP.$(win).bind('keydown', function (e) {
			if (e.keyCode === 9) {
				e.preventDefault();
			}
		});
		
		// TODO: Starting the APP should be done else where or possibly at another time
		$(function () {
			APP.$splash = $('#preloader');
			APP.$main = $('#frontend');
			
			// If we have a persona? Start application!
			if (APP.ns('config').persona) {
				
				if (root.EASY_DEBUG) {
					$(win).error(function (e) {
						APP.log.error(e.originalEvent);
						APP.trigger('error', e.originalEvent.message);
					});
				}
				
				// Start
				APP.start();
			
			} else {
				APP.$splash.hide();
				APP.$main.show();
			}
		});
	}
}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 */
(function (root) {
	"use strict";
	
	
	// Node support
	if (typeof require !== 'undefined') {
		if (!root.EASY) {
			root.EASY = require('./../../../../common/js/components/easy/easy');
		}
		if (!root.EASY.Model) {
			root.EASY.Model = require('./../../../../common/js/components/easy/easy.model');
		}
		if (!root.APP) {
			root.APP = require('./../common/app');
		}
	}
	
	var APP = root.APP,
		EASY = root.EASY;


	/**
	 * Base
	 *
	 * @class Model
	 * @extends EASY.Model
	 * @namespace GAME.APP
	 */
	APP.Model = EASY.Model.extend({});
	
	
	/**
	 * Module support
	 */
	if (typeof module !== 'undefined' && module.exports) {
		module.exports = APP.Model;
	}
}(this));

/*jshint smarttabs:true white:true */
/**
 * @module GAME
 */
(function (root) {
	"use strict";
	
	
	// Node support
	if (typeof require !== 'undefined') {
		if (!root.EASY) {
			root.EASY = require('./../../../../common/js/components/easy/easy');
		}
		if (!root.EASY.Collection) {
			root.EASY.Collection = require('./../../../../common/js/components/easy/easy.collection');
		}
		if (!root.APP) {
			root.APP = require('./app');
		}
		if (!root.APP.Model) {
			root.APP.Model = require('./model');
		}
	}
	
	var APP = root.APP,
		EASY = root.EASY;
	
	
	/**
	 * Base 
	 * 
	 * @class Collection
	 * @extends EASY.Collection
	 * @namespace GAME.APP
	 */
	APP.Collection = EASY.Collection.extend({
		model: APP.Model
	});
	
	
	/**
	 * Module support
	 */
	if (typeof module !== 'undefined' && module.exports) {
		module.exports = APP.Collection;
	}
}(this));


/*jshint smarttabs:true white:true */
/**
 * @module GAME
 */
(function (root) {
	"use strict";
	
	
	var EASY = root.EASY,
		APP = root.APP,
		win = APP.win,
		$ = APP.$,
		_ = APP._,
		parent = APP.Backbone.View.prototype,
		HTMLElement = win.HTMLElement;
	
	
	/**
	 * @constructor
	 * @class View
	 * @extends EASY.View
	 * @namespace GAME.APP
	 */
	APP.View = EASY.View.extend({
		/**
		 * Since Backbone is using this.$el.find(selector) 
		 * and instead of $(selector, this.el) we need to fix that.
		 * 
		 * @method $
		 * @param {String|HTMLElement} name
		 * @return {jQueryCollection}
		 */
		$: function (selector) {
			return $(selector, this.el);
		},
		
		
		/**
		 * Play sound with the given name
		 * 
		 * @method sound
		 * @param {String} name
		 * @chainable
		 */
		sound: function soundView(name) {
			APP.ns('game').sound(name);
			return this;
		},
		
		
		/**
		 * 
		 * 
		 * @method trans
		 * @param {String} id The message id
		 * @param {Array} [parameters] An array of parameters for the message
		 * @param {String} [domain] The domain for the message
		 * @return {String} The translated string
		 */
		trans: function transView(id, parameters, domain) {
			return APP.sidis.trans(id, parameters, domain);
		},
		
		
		/**
		 * Translates the given choice message by choosing a translation according to a number.
		 *
		 * @param {String} id The message id
		 * @param {Number} number The number to use to find the indice of the message
		 * @param {Array} [parameters] An array of parameters for the message
		 * @param {String} [domain] The domain for the message
		 * @return {String} The translated string
		 */
		transChoice: function transChoiceView(id, number, parameters, domain) {
			return APP.sidis.transChoice(id, number, parameters, domain);
		}
	});
	
	
}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 */
(function (win) {
	"use strict";
	
	
	if (!win.APP && (typeof require !== 'undefined')) {
		win.APP = require('../common/app');
	}
	
	var EASY = win.EASY,
		APP = win.APP;
	
	
	/**
	 * Extend the "common" ButtonView with some sound and trans methods...
	 * 
	 * @constructor
	 * @class Button
	 * @extends EASY.View.Button
	 * @namespace GAME.APP.View
	 */
	APP.View.Button = EASY.View.Button.extend({
		/**
		 * @method sound
		 * @param {String} name Name of the sound to play
		 * @chainable
		 */
		sound: function soundButtonView(name) {
			APP.ns('game').sound(name);
			return this;
		},
		
		
		/**
		 * Translates the given message.
		 * 
		 * @method trans
		 * @param {String} id The message id
		 * @param {Array} [parameters] An array of parameters for the message
		 * @param {String} [domain] The domain for the message
		 * @return {String} The translated string
		 */
		trans: function transButtonView(id, parameters, domain) {
			return APP.sidis.trans(id, parameters, domain);
		},
		
		
		/**
		 * Translates the given choice message by choosing a translation according to a number.
		 *
		 * @param {String} id The message id
		 * @param {Number} number The number to use to find the indice of the message
		 * @param {Array} [parameters] An array of parameters for the message
		 * @param {String} [domain] The domain for the message
		 * @return {String} The translated string
		 */
		transChoice: function transChoiceButtonView(id, number, parameters, domain) {
			return APP.sidis.transChoice(id, number, parameters, domain);
		}
	});
}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 */
(function (win) {
	"use strict";
	
	
	if (!win.APP && (typeof require !== 'undefined')) {
		win.APP = require('../common/app');
	}

    var APP = win.APP,
		_ = APP._;
	
	
	/**
	 * @constructor
	 * @class SplitButton
	 * @extends APP.View
	 * @namespace GAME.APP.View
	 */
	APP.View.SplitButton = APP.View.extend({
		name: 'splitbutton-view',
		tagName: 'span',
		events: {
            
		},
        initialize: function initializeSplitButtonView() {
            this.bind('default:click', this._onDefaultClick, this);
            this.bind('expand:click', this._onExpandClick, this);
        },
		destroy: function destroySplitButtonView() {
			
		},

        _onDefaultClick: function onDefaultClickSplitButton(view) {
            this.trigger('click', this);
        },

        _onExpandClick: function onExpandClickSplitButton(view) {
            this.trigger('expand', this);
        },
        
		text: function (text, options) {
            this.$('span').text(text);
			if (options && !options.silent) {
				this.trigger('text', this, text);
			}
			return this;
		},
		disable: function disableSplitButtonView(options) {
			this.$el.addClass('disabled');
			this.$el.attr('disabled', 'disabled');
			if (options && !options.silent) {
				this.trigger('disable', this);
			}
			return this;
		},
		enable: function enableSplitButtonView(options) {
			this.$el.removeClass('disabled');
			this.$el.removeAttr('disabled');
			if (options && !options.silent) {
				this.trigger('enable', this);
			}
			return this;
		},
		render: function renderSplitButtonView() {
            
			var list;
			
            this.$el.addClass('button-group');
            
            this.createView(APP.View.Button, {
                text: this.options.text                
            }, 'default').render().attach();

            this.createView(APP.View.Button, {
                glyph: 'expand'
            }, 'expand').render().attach();
			
			
			if (this.options.options) {
				list = this.make('ul');
				_.forEach(this.options.options, function (option) {
					
					// String
					if (_.isString(option)) {
						list.appendChild(this.make('li', null, option));
					
					// Function
					} else if (_.isFunction(option)) {
						list.appendChild(this.make('li', null, option()));
						
					}
					
					
				}, this);
				this.el.appendChild(list);
			}
		}
	});
}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 */
(function (win) {
	"use strict";
	
	
	if (!win.APP && (typeof require !== 'undefined')) {
		win.APP = require('../common/app');
	}
	
	var APP = win.APP,
		$ = APP.$,
		_ = APP._,
		parent = APP.View.prototype;
	
	
	/**
	 * @constructor
	 * @class Choose
	 * @extends APP.View
	 * @namespace GAME.APP.View
	 */
	APP.View.Choose = APP.View.extend({
		/**
		 * @property name
		 * @type {String}
		 */
		name: 'choose-view',
		
		
		/**
		 * @property tagName
		 * @type {String}
		 */
		tagName: 'span',
		events: {
			/**
			 * When clicking anywhere in the view toggle the options list 
			 * 
			 * @method event.click
			 * @params {jQuery.Event} e
			 */
			'click': function (e) {
				e.preventDefault();
				clearTimeout(this._timer);
				this.toggle();
			},
			
			
			/**
			 * When entering with the mouse play a hover sound
			 * 
			 * @method event.mouseenter
			 */
			'mouseenter': function () {
				this.sound('hover');
				clearTimeout(this._timer);
			},
			
			
			/**
			 * When leaving with the mouse and 500ms later hide the options list
			 * 
			 * @method event.mouseleave
			 */
			'mouseleave': function () {
				this._timer = setTimeout(_.bind(this.close, this), 500);
			},
			
			
			/**
			 * When clicking on a options in the options list
			 * play a click sound and get the index of the clicked
			 * "option". Then choose that index.
			 * 
			 * @method event.click a
			 */
			'click a': function (e) {
				e.preventDefault();
				
				this.sound('click');
				
				var el = e.currentTarget,
					i = this.$values.index(el);
				
				this.choose(i);
			},
			
			
			/**
			 * When entering with the mouse play a hover sound
			 * 
			 * @method event.mouseenter a
			 */
			'mouseenter a': function () {
				this.sound('hover');
			},
			
			
			/**
			 * TODO: expand on this to support tabbing better
			 * 
			 * @method event.focus a
			 */
			'focus a': function () {
				this.open();
			},
			
			
			/**
			 * TODO: expand on this to support tabbing better
			 * 
			 * @method event.blur a
			 */
			'blur a': function () {
				this.close();
			}
		},
		
		/**
		 * Destroy
		 */
		destroy: function destroyChooseView() {
			
		},
		
		
		/**
		 * Play a open sound and add a open class so the 
		 * options list can be made visible
		 * 
		 * @method open
		 * @chainable
		 */
		open: function () {
			this.sound('select:open');
			this.$el.addClass('open');
			return this;
		},
		
		
		/**
		 * Play a close sound and remove the the open class so the
		 * options list can be hidden
		 *
		 * @method close
		 * @chainable
		 */
		close: function () {
			this.sound('select:close');
			this.$el.removeClass('open');
			return this;
		},
		
		
		/**
		 * Toggles between open and close
		 *
		 * @method toggle
		 * @chainable
		 */
		toggle: function () {
			if (this.$el.hasClass('open')) {
				this.close();
			} else {
				this.open();
			}
			return this;
		},
		
		
		/**
		 * Choose a value on the given index 
		 * 
		 * @method choose
		 * @param {Number} index
		 * @param {Object} [options]
		 * @chainable
		 */
		choose: function chooseChooseView(index, options) {
			
			index = index || 0;
			options = options || {};
			
			var text = this.options.values[index] || '- ' + this.trans('WEB_GAME_SELECT_CHOOSE') + ' -';
			
			this.$values.removeClass('choosen');
			if (index >= 0) {
				this.$values.eq(index).addClass('choosen');
			}
			
			this.$choosen.text(text);
			
			if (!options.silent) {
				this.trigger('choose', index, text);
			}
			
			return this;
		},
		
		
		/**
		 * Buld the view's DOM choose the value
		 *
		 * @method render
		 * @chainable
		 */
		render: function renderChooseView() {
			
			var inner = this.make('span', {
					'class': 'values'
				});
			
			// Label
			this.$choosen = this.$(this.make('span', {
				'class': 'choosen'
			})).appendTo(this.el);
			
			// Values
			this.$values = this.$(_.map(this.options.values, function (value, i) {
				var a = this.make('a', {
						href: '#choose-' + i
					}, value);
				inner.appendChild(a);
				return a;
			}, this));
			
			this.el.appendChild(inner);
			
			this.choose(this.options.value, {
				silent: true
			});
		}
	});
}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 */
(function (win) {
	"use strict";
	
	
	var APP = win.APP,
		$ = APP.$,
		_ = APP._,
		parent = APP.View.prototype;
	
	
	/**
	 * @constructor
	 * @class DnD
	 * @extends APP.View
	 * @namespace GAME.APP.View
	 */
	APP.View.DnD = APP.View.extend({
		options: _.extend({}, parent.options, {
			drag: false,
			drop: false
		}),
		dragOptions: {
			appendTo		: APP.doc.body,
			containment		: [ 0, 0, 945, 690 ],
			cursorAt		: { left: 40, top: 35 },
			revertDuration	: 200
		},
		dropOptions: {
			tolerance	: 'pointer',
			activeClass	: 'active',
			hoverClass	: "drop-hover"
		},
		
		constructor: function constructorDnDView() {
			APP.View.apply(this, arguments);
			this.bind('render', this.initializeDragAndDrop, this);
		},
		
		_configure: function _configure(options) {
			
			// Drag options
			this.dragOptions = _.extend({}, this.dragOptions, options.dragOptions);
			delete options.dragOptions;
			
			// Drop options
			this.dropOptions = _.extend({}, this.dropOptions, options.dropOptions);
			delete options.dropOptions;
			
			return parent._configure.call(this, options);
		},
		
		initializeDragAndDrop: function initializeDragAndDropDnDView() {
			// Dragging
			if (this.options.drag) {
				this.initializeDrag();
			}
			// Dropping
			if (this.options.drop) {
				this.initializeDrop();
			}
		},
		
		/**
		 * Draggable
		 */
		initializeDrag: function initializeDragDnDView() {
			
			var view = this,
				body = APP.doc.body,
				nsConfig = APP.ns('config'),
				options = _.extend({}, this.dragOptions, {
					helper: _.bind(this.dragHelper, this),
					revert: function onRevertDnDView($to) {
						
						view.trigger('drag:revert', $to, this);
						
						if (view.dragOptions.hasOwnProperty('revert')) {
							if (_.isFunction(view.dragOptions.revert)) {
								return view.dragOptions.revert.call(this, $to, this);
							}
							
							if (view.dragOptions.revert === 'invalid') {
								return !$to;
							}
							
							if (view.dragOptions.revert === 'valid') {
								return !!$to;
							}
							
							return view.dragOptions.revert;
						}
						
						return !$to;
					},
					start: function onStartDnDView(e, ui) {
						view.trigger('drag:start', view.collection.get(ui.helper.data('id')), ui, this);
					},
					drag: function onDragDnDView(e, ui) {
						body.scrollTop = 0;
						body.scrollLeft = 0;
						view.trigger('drag', view.collection.get(ui.helper.data('id')), ui, this);
					},
					stop: function onStopDnDView(e, ui) {
						view.trigger('drag:stop', view.collection.get(ui.helper.data('id')), ui, this);
					}
				}),
				$draggables = this.$(this.options.drag);
			
			if (nsConfig.isScaled && options.cursorAt) {
				options.cursorAt.left = options.cursorAt.left * nsConfig.scale;
				options.cursorAt.top = options.cursorAt.top * nsConfig.scale;
			}
			
			// Draggable
			$draggables.draggable('destroy').draggable(options);
			
			return this;
		},
		
		
		getModelFromDOM: function getModelFromDomDnDView(el) {
			throw new Error('This needs to be implemented in any subclassses');
		},
		
		
		/**
		 * Drag Helper
		 */
		dragHelper: function dragHelperDnDView(e) {
			
			var $el = $(e.currentTarget).clone();
			
			$el.appendTo(APP.doc.body);
			
			return $el;
		},
		
		
		/**
		 * Droppable
		 */
		initializeDrop: function initializeDropDnDView() {
			
			var view = this,
				collection = this.collection,
				nsConfig = APP.ns('config'),
				options = _.extend({}, this.dropOptions, {
					accept: function accept($draggable) {
						return view.accept($draggable, this);
					},
					activate: function onActivateDnDView(e, ui) {
						view.trigger('drop:activate', collection.get(ui.helper.data('id')), ui, this);
					},
					deactivate: function onDeactivateDnDView(e, ui) {
						view.trigger('drop:deactivate', collection.get(ui.helper.data('id')), ui, this);
					},
					over: function onOverDnDView(e, ui) {
						view.trigger('drop:over', collection.get(ui.helper.data('id')), ui, this);
					},
					out: function onOutDnDView(e, ui) {
						view.trigger('drop:out', collection.get(ui.helper.data('id')), ui, this);
					},
					drop: function onDropDnDView(e, ui) {
						view.trigger('drop', collection.get(ui.helper.data('id')), ui, this);
					}
				}),
				$dropables = this.$(this.options.drop);
			
			if (nsConfig.isScaled && options.cursorAt) {
				options.cursorAt.left = options.cursorAt.left * nsConfig.scale;
				options.cursorAt.top = options.cursorAt.top * nsConfig.scale;
			}
			
			// Draggable
			$dropables.droppable('destroy').droppable(options);
			
			return this;
		},
		
		/**
		 * Accept
		 * TODO: This needs to be cleaned up alot more
		 */
		accept: function acceptDnDView($draggable) {
			var itemId,
				model;
			
			if (!itemId) {
				itemId = $draggable.find('[item-id]').attr('item-id');
			}
			
			model  = this.collection.get(itemId);
			
			return (model instanceof this.collection.model);
		}
	});
}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 */
(function (win) {
	"use strict";
	
	
	if (!win.APP && (typeof require !== 'undefined')) {
		win.APP = require('../common/app');
	}
	
	var APP = win.APP,
		$ = APP.$,
		_ = APP._,
		parent = APP.View.prototype;
	
	
	/**
	 * @constructor
	 * @class Overlay
	 * @extends APP.View
	 * @namespace GAME.APP.View
	 */
	APP.View.Overlay = APP.View.extend({
		name: 'overlay-view',
		
		/**
		 * Initialize Overlay
		 */
		initialize: function initializeOverlay() {
			// TODO: This will cause some jumping
			this.bind('show', this._onShow, this);
			this.bind('hide', this._onHide, this);
		},
		
		/**
		 * Destroy Overlay
		 */
		destroy: function destroyOverlayView() {
			
		},
		
		_onShow: function _onShowOverlayView() {
			this.dim();
			this.align();
		},
		
		_onHide: function _onHideOverlayView() {
			this.undim();
		},
		
		detach: function detachOverlayView() {
			this.undim();
			return parent.detach.apply(this, arguments);
		},
		
		/**
		 * Dim Overlay Container
		 */
		dim: function dimOverlayView() {
			if (!this.el.parentNode) {
				return this;
			}
			
			var $container = this.$(this.getContainer()),
				offset = $container.offset(),
				styles = {
					width	: $container.width() || 1024,
					height	: $container.height() || 768,
					top		: offset.top,
					left	: offset.left
				};
			
			if ($container[0] === APP.doc.body) {
				styles.width = 1024;
				styles.height = 768;
			}
			
			if (!this.$cover) {
				this.$cover = $('<div />').css({
					display: 'none'
				}).addClass('overlay-view-dimmer ' + this.className);
				this.$cover.appendTo($container);
			}
			
			this.$cover.css(styles).show();
			
			return this;
		},
		
		/**
		 * Undim Overlay Container
		 */
		undim: function undimOverlayView() {
			var $cover = this.$cover;
			if ($cover) {
				$cover.animate({
					opacity: 0
				}, 200, function () {
					$cover.remove();
				});
			}
			this.$cover = null;
			return this;
		},
		
		/**
		 * Align Overlay
		 */
		align: function alignOverlayView() {
			var css = {
					left: (1024 / 2) - (this.$el.width() / 2),
					top: (768 / 2) - (this.$el.height() / 2)
				};
			
			this.$el.css(css);
			
			return this;
		},
		
		/**
		 * Show Overlay
		 */
		show: function showOverlayView() {
			this.$el.show();
			this.trigger('show', this);
			return this;
		},
		
		/**
		 * Hide Overlay
		 */
		hide: function hideOverlayView() {
			this.$el.hide();
			this.trigger('hide', this);
			return this;
		},
		
		/**
		 * Render Overlay
		 */
		render: function renderOverlayView() {
			return this;
		}
	});
}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 */
(function (win) {
	"use strict";
	
	
	if (!win.APP && (typeof require !== 'undefined')) {
		win.APP = require('../common/app');
	}
	
	var APP = win.APP,
		$ = APP.$,
		_ = APP._,
		parent = APP.View.Overlay.prototype;
	
	
	/**
	 * @constructor
	 * @class Dialog
	 * @extends APP.View.Overlay
	 * @namespace GAME.APP.View
	 */
	APP.View.Dialog = APP.View.Overlay.extend({
		/**
		 * @property name
		 */
		name: 'dialog-view',
		
		events: {
			/**
			 * @method event.click .close
			 * @param {jQuery.Event} e
			 */
			'click .close': function (e) {
				e.preventDefault();
				this.sound('close');
				this.trigger('close', this, e);
			}
		},
		
		/**
		 * Initialize Dialog
		 */
		initialize: function initializeDialogView() {
			_.bindAll(this, '_onEscapeClose');
			parent.initialize.apply(this, arguments);
			
			$(win).bind('keyup', this._onEscapeClose);
			
			// Left button
			this.bind('button-left:click', function (view, e) {
				this.sound('click:button');
				this.trigger('button', this, e);
				this.trigger('button:left', this, e);
			}, this);
			
			// Right button
			this.bind('button-right:click', function (view, e) {
				this.sound('click:button');
				this.trigger('button', this, e);
				this.trigger('button:right', this, e);
			}, this);
		},
		
		/**
		 * Destroy Dialog
		 */
		destroy: function destroyDialogView() {
			parent.destroy.apply(this, arguments);
			$(win).unbind('keyup', this._onEscapeClose);
			return this;
		},
		
		/**
		 * On Escape Close
		 */
		_onEscapeClose: function _onEscapeCloseDialogView(e) {
			if (e.keyCode === 27 && this.$el.is(':visible')) {
				this.sound('close');
				this.trigger('close');
			}
		},
		
		/**
		 * Align Dialog
		 */
		align: function alignDialogView() {
			var	height = this.$el.outerHeight(),
				css = {
					left: Math.round((1024 - this.$el.outerWidth()) / 2),
					top: 100
				};
			
			if (height > 568) {
				css.top = Math.round((768 - height) / 2);
				if (css.top < 0) {
					css.top = 0;
				}
			}
			
			this.$el.css(css);
			
			return this;
		},
		
		/**
		 * Set Render Data
		 */
		setRenderData: function setRenderDataDialogView(renderData) {
			this.options.renderData = renderData;
			return this;
		},
		
		/**
		 * Render Dialog
		 */
		render: function renderDialogView() {
			var renderData = this.options.renderData || {},
				$body = this.$('<div />').addClass('body'),
				$bodyInner = this.$('<div />').addClass('body-inner').appendTo($body),
				$buttonContainer = this.$('<div />').addClass('buttons'),
				$title =  this.$('<h1 />').addClass('title'),
				button;
			
			this.$el.addClass('border-box');
			
			// 
			if (typeof renderData === 'string') {
				$bodyInner.html(renderData).appendTo(this.el);
				$body.appendTo(this.el);
				
			// 
			} else if (typeof renderData === 'object') {
				// Close
				if (renderData.close) {
					this.el.appendChild(this.make('span', {
                        'class': 'close'
                    }));
					$(win).unbind('keyup', this._onEscapeClose);
					$(win).bind('keyup', this._onEscapeClose);
				}

				// Title
				if (renderData.title) {
					$title.html(renderData.title).appendTo(this.el);
				}

				// Body
				if (renderData.body) {
					if (_.isArray(renderData.body)) {
						_.forEach(renderData.body, function (body) {
							if (body instanceof APP.View) {
								$bodyInner.append(body.el);
							} else {
								$bodyInner.append('<p>' + body + '</p>');
							}
						});
					} else if (renderData.body instanceof APP.View) {
						$bodyInner.append(renderData.body.el);
					} else {
						$bodyInner.append(renderData.body);
					}
					$body.appendTo(this.el);
				}
				
				// Buttons
				if (renderData.buttonLeft || renderData.buttonRight) {
					// Button Left
					if (renderData.buttonLeft) {
						if (typeof renderData.buttonLeft === 'string') {
							button = {
								attrs: {},
								text: renderData.buttonLeft
							};
						} else {
							button = renderData.buttonLeft;
						}
						
						button.container = $buttonContainer;
						button.className = 'left';
						
						this.createView(APP.View.Button, button, 'button-left').render().attach();
						
						button.attrs = _.extend({
							'class': 'button left',
							'href': '#button-left'
						}, button.attrs);
						
						// $buttonContainer.append(this.make('a', button.attrs, button.text));
					}
					
					// Button Left
					if (renderData.buttonRight) {
						if (typeof renderData.buttonRight === 'string') {
							button = {
								attrs: {},
								text: renderData.buttonRight
							};
						} else {
							button = renderData.buttonRight;
						}
						
						button.container = $buttonContainer;
						button.className = 'right';
						
						this.createView(APP.View.Button, button, 'button-right').render().attach();
						
						button.attrs = _.extend({
							'class': 'button right',
							'href': '#button-right'
						}, button.attrs);
						
						// $buttonContainer.append(this.make('a', button.attrs, button.text));
					}
					$buttonContainer.appendTo(this.el);
				}
			}
		}
	});
}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 */
(function (win) {
	"use strict";
	
	
	if (!win.APP && (typeof require !== 'undefined')) {
		win.APP = require('../common/app');
	}
	
	var APP = win.APP,
		$ = APP.$,
		_ = APP._,
		parent = APP.View.prototype;
	
	
	/**
	 * @constructor
	 * @class LabelBox
	 * @extends APP.View
	 * @namespace GAME.APP.View
	 */
	APP.View.LabelBox = APP.View.extend({
		name: 'labelbox-view',
		tagName: 'div',
		
		/**
		 * Destroy
		 */
		destroy: function destroyLabelBoxView() {
		},
		
		renderContent: function renderContentLabelBoxView(content) {
			// Array
			if (_.isArray(content)) {
				_.forEach(content, this.renderContent, this);
				return this;
			}
			
			var $container = this.$('<div />');
			
			// View
			if (content instanceof APP.View) {
				content.options.container = $container;
				content.render().attach();
			
			// jQuery object
			} else if (content instanceof $) {
				content.appendTo($container);
				
			// HTML or other
			} else if (content) {
				$container.html(content);
			}
			
			$container.appendTo(this.el);
			
			return this;
		},
		
		/**
		 * Render LabelBox
		 */
		render: function renderLabelBoxView() {
			
			// Render label
			if (this.options.label) {
				this.el.appendChild(this.make('h3', null, this.options.label));
			}
			
			// Render content
			if (this.options.content) {
				this.renderContent(this.options.content);
			}
			
			return this;
		}
	});
	
	/*new APP.View.LabelBox({
		'label': 'Price from:',
		'content': [],
		'className': 'bottom'
	})*/
	
}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 */
(function (APP) {
	"use strict";


	/**
	 * @constructor
	 * @class Page
	 * @extends APP.View
	 * @namespace GAME.APP.View
	 */
	APP.View.Page = APP.View.extend({
		_internalInitialize: function () {
			APP.View.prototype._internalInitialize.apply(this, arguments);
			this.$el.addClass('page');
		}
	});
	
}(this.APP));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 */
(function (APP) {
	"use strict";
	
	
	var parent = APP.View.prototype;

	/**
	 * @constructor
	 * @class Pane
	 * @extends APP.View
	 * @namespace GAME.APP.View
	 */
	APP.View.Pane = APP.View.extend({
		_internalInitialize: function () {
			parent._internalInitialize.apply(this, arguments);
			this.$el.addClass('pane');
		}
	});
	
}(this.APP));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 */
(function (APP) {
	"use strict";
	
	
	var $ = APP.$,
		_ = APP._;
	
	
	/**
	 * @constructor
	 * @class Tooltip
	 * @extends APP.View
	 * @namespace GAME.APP.View
	 */
	APP.View.Tooltip = APP.View.extend({
		name: 'tooltip-view',
		tagName: 'div',
		options: {
			pointer: true
		},
		events: {
			'mouseenter': function () {
				this.hide();
			},
			'mouseleave': function () {
				this.hide();
			}
		},
		initialize: function initializeTooltipView() {
			// TODO: Make sure we don't rely on this "magic" binding
			_.bindAll(this);
			
			if (_.has(this.options, 'html')) {
				this.setHtml(this.options.html);
			}
		},
		destroy: function destroyTooltipView() {
			return this;
		},
		align: function alignTooltipView($el) {
			
			// For good measure
			$el = $($el);
			
			var scaleMod = APP.ns('config').scaleMod,
				pointerPad = (this.options.pointer ? 8 : 0),
				offsetPad = 10,
				offset = $el.offset(),
				width = $el.outerWidth(),
				height = $el.outerHeight(),
				left = (offset.left * scaleMod) + (width / 2),
				top = (offset.top * scaleMod) + height + pointerPad,
				outerWidth = this.$el.outerWidth(),
				halfOuterWidth = outerWidth / 2,
				outerHeight = this.$el.outerHeight(),
				maxLeft = left + halfOuterWidth,
				maxTop = top + outerHeight,
				pointerLeft = left + (outerWidth / 2),
				pointerPos = 'top';
			
			// If too far left 
			if (left < (halfOuterWidth + offsetPad)) {
				left = halfOuterWidth + offsetPad;
				
			// if too far right
			} else if (maxLeft > 1024) {
				left = 1024 - halfOuterWidth - offsetPad;
			}
			
			// If to low
			if (maxTop > 663) {
				top = (offset.top * scaleMod) - outerHeight - pointerPad;
				pointerPos = 'bottom';
			}
			
			// Pointer
			if (this.options.pointer) {
				$('<span />').addClass('tooltip-pointer').css({
					left: pointerLeft - left
				}).appendTo(this.el);
				this.$el.removeClass('pointer-top pointer-bottom').addClass('pointer-' + pointerPos);
			}
			
			this.$el.css({
				left: Math.round(left),
				top: Math.round(top)
			});
			
			return this;
		},
		show: function showTooltipView($el) {
			this.align($el);
			this.$el.show();
			this.trigger('show', this);
			return this;
		},
		hide: function hideTooltipView() {
			this.$el.hide();
			this.trigger('hide', this);
			return this;
		},
		setHtml: function (html) {
			this.html = html;
			return this;
		},
		renderHTMLAndShow: function renderHTMLAndShowTooltipView(html, el) {
			this.setHtml(html);
			return this.renderAndShow(el);
		},
		renderAndShow: function renderAndShowTooltipView(el) {
			return this.render().show(el);
		},
		render: function renderTooltipView() {
			if (this.html) {
				this.$el.html(this.html);
			}
		}
	});
	
}(this.APP));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 */
(function (win) {
	"use strict";
	
	
	var APP = win.APP,
		parent = APP.View.prototype,
		_ = APP._,
		$ = APP.$;
	
	
	/**
	 * @constructor
	 * @class Table
	 * @extends APP.View
	 * @namespace GAME.APP.View
	 */
	APP.View.Table = APP.View.extend({
		name: 'table-view',
		tagName: 'table',
		options: {
			orderByKey: null,
			orderByDirection: null,
			headers: [],
			view: APP.View.TableRow
		},
         
		events: {
            'click th.headerSort': function (e) {
				e.preventDefault();
				
				var $el = APP.$(e.currentTarget),
					key,
					keys = _.pluck(this.options.headers, 'key'),
					i,
					len = keys.length,
					direction;
					
				for (i = 0; i < len; i += 1) {
					if ($el.hasClass(keys[i])) {
						key = keys[i];
						break;
					}
				}
				
				if (key) {
					if ($el.hasClass('headerSortDesc')) {
						direction = 'asc';
					} else if ($el.hasClass('headerSortAsc')) {
						direction = 'desc';
					}
					this.orderBy(key, direction);
				}
			}
        },
		
		/**
		 * Initialize view
		 */
		initialize: function initializeTableView() {
			this.selected = null;
			this.resetCollection();            
		},
        
		destroy: function destroyTableView() {
			
		},
		
        resetCollection: function resetCollectionTableView() {
            this.currentCollection = this.collection;
            
            return this;
        },
        
        orderBy: function orderByTableView(key, direction) {
            direction = (direction || "").toLowerCase();
            
            if (key) {
                this.options.orderByKey = key;
            }
            if (direction) {
                this.options.orderByDirection = direction;
            }   
            
            this.$ths.removeClass('headerSortAsc headerSortDesc');
            
            if (this.options.orderByKey) {
                this.$ths.filter('.' + this.options.orderByKey).addClass(this.options.orderByDirection === 'asc' ? 'headerSortAsc' : 'headerSortDesc');
            }
            
            this.renderBody();
            return this;
        },
		
		sortByIterator: function sortByIteratorTableView(model) {
			var value = model.get(this.options.orderByKey);
			
			if (typeof value === 'string') {
				return value.toLowerCase();
			}
			
			return value;
		},
        
        filterBy: function filterByTableView(filter) {
            filter = filter || {};
            
            var collection = this.collection.filterBy(filter);
			
            this.renderBody(collection);
            return this;
        },
        
        renderHead: function renderHeadTableView() {
            var thead = this.make('thead'),
                tr = this.make('tr'),
                rows = _.map(this.options.headers, function (header) {
                    var label = header.label,
                        attrs = header.attrs || {},
                        key = header.key,
                        el;
                        
                    if (label) {
                        label = APP.sidis.trans(label);
                    }
                    
                    if (key) {
                        if (!attrs.hasOwnProperty('class')) {
                            attrs['class'] = '';
                        }
                        
                        attrs['class'] += ' ' + key;
                    }
                    
                    el = this.make('th', attrs, label);
                    tr.appendChild(el);
                    
                    return el;
                }, this);
            
            thead.appendChild(tr);
            this.el.appendChild(thead);
            
            this.$ths = APP.$(rows);
            
            return this;
        },
        
        select: function selectTableView(model) {
			
			model = this.currentCollection.get(model);
			
			if (model && this.selected !== model.id) {
				this.selected = model.id;
				this.trigger('select', model);		
			}
			
			if (this.selected) {
				model = this.currentCollection.get(this.selected);
				
				var i = this.currentCollection.indexOf(model);
				
				this.$trs.removeClass('selected');
				
				if (i !== -1) {
					this.$trs.eq(i).addClass('selected');
				}
			}
			
            return this;
        },
        
		renderLimitIterator: function renderLimitIteratorTableView() {
			return false;
		},
		
		/**
		 * Render Pending Row
		 */
		renderPendingRow: function renderPendingRowTableView(pending, total) {
			this.trigger('renderpending:before');
			
			var tr = this.make('tr', { 'class': 'pending-indicator' }),
				current = (total - pending),
				text = current + ' / ' +  total;
			
			if (this.options.pendingText) {
				text = this.trans(this.options.pendingText, {
					'%current%': current,
					'%total%': total
				});
			}
			
			tr.appendChild(this.make('td', { 'colspan': this.options.headers.length }, text));
			this.$tbody.append(tr);
			
			this.trigger('renderpending');
			this.trigger('renderpending:after');
			
			return this;
		},
		
		
		/**
		 * Render Body
		 */
        renderBody: function renderBodyTableView(collection) {
			
			this.destroyViews();
			
			this.$tbody.empty();
			
            if (collection) {
                this.currentCollection = collection;
            }
            
            var viewClass = _.isString(this.options.view) ? APP.View[this.options.view] : this.options.view,
				items = this.options.orderByKey ? this.currentCollection.sortBy(this.sortByIterator, this) : this.currentCollection.toJSON(),
				pending = 0,
				total = items.length,
				tr;
            
            if (this.options.orderByDirection === 'desc') {
                items.reverse();
            }
			
			// Reset
            this.currentCollection.reset(items, {
				silent: true
			});
			
			if (this.options.pending) {
				pending = this.currentCollection.filter(this.renderLimitIterator, true).length;
			}
			
			// Loop over the current collection
			this.currentCollection.any(function (model, i) {
				
				var view = this.createView(viewClass, {
						index: i,
                        container: this.$tbody,
                        model: model,
                        keys: _.pluck(this.options.headers, 'key')
					});
				
				// Render
				view.render();
				
				// Selected??
                if (this.selected && this.selected === model.id) {
                    view.$el.addClass('selected');
                }
				
				// Return TRUE to break
				if (pending !== 0) {
					return this.options.limit && this.options.limit <= (i + 1);
				}
				return false;
			}, this);
            
			// Append to DOM
            this.$trs = $(_.pluck(this._views, 'el')).appendTo(this.$tbody);
            
			// Limit
			if (pending !== 0 && total > this.options.limit) {
				this.renderPendingRow(pending, total);
			}
			
            return this;
        },
        
		/**
		 * Render the view
		 */
		render: function renderTableView() {
			// Empty
            this.renderHead();
            
            this.$tbody = $('<tbody>');
			
            this.$tbody.appendTo(this.el);
            
            this.orderBy();
		}
	});
	
}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 */
(function (APP) {
	"use strict";
	
	
	var parent = APP.View.prototype,
		_ = APP._;
	
	
	/**
	 * @constructor
	 * @class TableRow
	 * @extends APP.View
	 * @namespace GAME.APP.View
	 */
	APP.View.TableRow = APP.View.extend({
		name: 'table-row-view',
		tagName: 'tr',
        
		/**
		 * Initialize view
		 */
		initialize: function initializeTableRowView() {
			this.model.bind('change', this.render, this);
		},
        
		destroy: function destroyTableRowView() {
			this.model.unbind('change', this.render, this);
			return this;
		},
		
        renderCell: function renderCellTableRowView(key, text) {
			if (arguments.length === 1) {
				text = this.model.get(key);
			}
			
			var td = this.make('td', { 'class': key }, text);
			
            this.el.appendChild(td);
            
            return td;
        },
        
		/**
		 * Render the view
		 */
		render: function renderTableRowView() {
			// Empty
			this.$el.empty();
            
            var i,
                len = this.options.keys.length;
            
            for (i = 0; i < len; i += 1) {
                this.renderCell(this.options.keys[i]);
            }
            
			// Return this for chaining
			return this;
		}
	});
	
}(this.APP));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 */
(function (win) {
	"use strict";
	
	
	if (!win.APP && (typeof require !== 'undefined')) {
		win.APP = require('../common/app');
	}
	
	var APP = win.APP,
		$ = APP.$,
		_ = APP._,
		parent = APP.View.prototype;
	
	
	/**
	 * @constructor
	 * @class Tabs
	 * @extends APP.View
	 * @namespace GAME.APP.View
	 */
	APP.View.Tabs = APP.View.extend({
		name: 'tabs-view',
		tagName: 'div',
		events: {
			'click a': function (e) {
				e.preventDefault();
				
				var i = this.$items.index(e.currentTarget);
				
				this.sound('click');
				
				this.select(i);
			},
			'mouseenter a': function (e) {
				var index = this.$items.index(e.currentTarget),
					tab = this.options.tabs[index];
				
				this.sound('hover');
				
				this.trigger('enter', this, tab, e);
			},
			'mouseleave a': function (e) {
				var index = this.$items.index(e.currentTarget),
					tab = this.options.tabs[index];
				
				this.trigger('leave', this, tab, e);
			}
		},
		
		/**
		 * Destroy
		 */
		destroy: function destroyTabsView() {
			
		},
		/**
		 * Select
		 */
		select: function selectTabsView(tab, options) {
			options = options || {};
			
			var i = parseInt(tab, 10),
				$el;
			
			if (_.isNaN(i) && typeof tab === 'string') {
				i = _.indexOf(_.map(this.options.tabs, function mapTabs(tab) {
					if (typeof tab === 'string') {
						return tab.toLowerCase();
					} else if (tab.name) {
						return tab.name;
					}
					return tab.text.toLowerCase();
				}), tab.toLowerCase());
			
			} else if (typeof tab === 'function') {
				i = _.indexOf(_.values(this.options.tabs), _.find(this.options.tabs, tab));
			}
			
			if (!i || i === -1) {
				i = 0;
			}
			
			// TODO: Handle case when i out of bounds
			$el = this.$items.eq(i);
			
			this.$items.removeClass('active');
			
			$el.addClass('active');
			
			if (!options.silent) {
				this.trigger('select', i, this.options.tabs[i], $el);	
			}
			
			return this;
		},
		
		getSelected: function getSelectedTabsView() {
			var $el = this.$items.filter('.active'),
				i =  this.$items.index($el);
			
			return this.options.tabs[i];
		},
		
		/**
		 * Render Attached List
		 */
		render: function renderTabsView() {
			
			var items = _.map(this.options.tabs || [], function mapTabs(tab) {
					if (typeof tab === 'string') {
						tab = {
							attrs: {},
							text: tab
						};
					}
					
					if (!tab.hasOwnProperty('attrs')) {
						tab.attrs = {};
					}
					
					if (!tab.attrs.hasOwnProperty('href')) {
						tab.attrs.href = '#' + tab.name || tab.text;
					}
					
					var a = this.make('a', tab.attrs),
						span = this.make('span', null, tab.text);
					
					a.appendChild(span);
					
					return a;
				}, this);
			
			this.$items = $(items).appendTo(this.el);
			
			this.$el.disableTextSelect();
			
			return this;
		}
	});
}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 */
(function (win) {
	"use strict";
	
	
	var APP = win.APP,
		doc = APP.doc,
		bind = function bind(el, loadHandler, errorHandler) {
			if (el.addEventListener) {
				el.addEventListener('load', loadHandler, false);
				el.addEventListener('error', errorHandler, false);
			} else if (el.attachEvent) {
				el.attachEvent('onload', loadHandler);
				el.attachEvent('onerror', errorHandler);
			} else {
				el.onreadystatechange = function () {
					var state = el.readyState;
					if (state === 'loaded' || state === 'complete') {
						loadHandler();
					}
				};
			}
		},
		unbind = function unbind(el, loadHandler, errorHandler) {
			if (el.removeEventListener) {
				el.removeEventListener('load', loadHandler, false);
				el.removeEventListener('error', errorHandler, false);
			} else if (el.detachEvent) {
				el.detachEvent('onload', loadHandler);
				el.detachEvent('onerror', errorHandler);
			} else {
				el.onreadystatechange = null;
			}
		},
		
		/**
		 * Create Load Handler
		 */
		createLoadHandler = function createLoadHandler(fn, type) {
			return function preloadLoadHandler() {
				if (fn) {
					fn.apply(this, arguments);
				}
			};
		},
		
		/**
		 * Create Error Handler
		 */
		createErrorHandler = function createErrorHandler(fn, type) {
			return function preloadErrorHandler() {
				if (fn) {
					fn.apply(this, arguments);
				}
			};
		},
		
		loopAndCall = function loopAndCall(loader, urls, fn) {
			
			var len = urls.length,
				i,
				errors = [],
				done = function done(err, url) {
					done.i += 1;
					if (err) {
						done.i = len + 1;
						fn(err, urls);
					} else if (done.i === len) {
						fn(null, urls);
					}
				};
			
			done.i = 0;
			
			for (i = 0; i < len; i += 1) {
				loader(urls[i], done);
			}
		},
		
		// Timeout time in ms
		timeout = 10 * 60 * 1000;
	
	
	
	/**
	 * Create Loadable
	 */
	APP.createLoadable = function createLoadable(tagName, fn, url) {
		var el = doc.createElement(tagName),
			loadHandler,
			errorHandler;
		
		loadHandler = createLoadHandler(function loadHandler() {
			// Unbind event handlers
			unbind(el, loadHandler, errorHandler);
			
			// Remove from the DOM
			el.parentNode.removeChild(el);
			el = null;
			
			fn(null, url);
		}, 'onload');
		
		errorHandler = createErrorHandler(function errorHandler() {
			// Unbind event handlers
			unbind(el, loadHandler, errorHandler);
			
			// Remove from the DOM
			if (el.parentNode) {
				el.parentNode.removeChild(el);
				el = null;
			}
			
			fn(new Error('Error loading: ' + url), url);
		}, 'onerror');
		
		// Bind event handlers
		bind(el, loadHandler, errorHandler);
		
		return el;
	};
	
	/**
	 * Preloader
	 */
	APP.preload = function preload(url, fn, ms) {
		// Multiple
		if (url instanceof Array) {
			return loopAndCall(APP.preload, url, fn, ms);
		}
	   
		var timer,
			el = APP.createLoadable('object', function (err) {
				clearTimeout(timer);
				fn(err, url);
			}, url);
		
		// Timeout in ms
		ms = ms || timeout;
		
		el.data = url;
		el.type = "text/plain"; // Needed for IE
		el.width = 1; // Needed for IE
		el.height = 1; // Needed for IE
		
		// Styles
		el.style.visibility = "hidden";
		el.style.position = 'absolute';
		el.style.top = '-1000px';
		el.style.left = '-1000px';
		
		// On Timeout
		timer = setTimeout(createErrorHandler(function onTimeout() {
			clearTimeout(timer);
			if (el && el.parentNode) {
				el.parentNode.removeChild(el);
				el = null;
			}
			fn(new Error('Timeout (' + timeout + 'ms) loading object: ' + url), url);
		}, 'timeout'), ms);
		
		// Append To DOM
		doc.body.appendChild(el);
	};
	
	/**
	 * Preload Image
	 */
	APP.preload.image = function preloadImage(src, fn, ms) {
		// Multiple
		if (src instanceof Array) {
			return loopAndCall(APP.preload.image, src, fn, ms);
		}
		
		var img = new Image(),
			timer;
		
		// Timeout in ms
		ms = ms || timeout;
		
		img.src = src;
		
		// Is loaded
		if (img.complete) {
			setTimeout(createLoadHandler(function onTimeout() {
				fn(null, src, {
					width: img.width,
					height: img.height
				});
				img = null;
			}, 'complete'), 0);
		
		// Need to be loaded listen to events
		} else {
			
			// On Load
			img.onload = createLoadHandler(function onLoad() {
				clearTimeout(timer);
				if (img) {
					if (img.parentNode) {
						img.parentNode.removeChild(img);
					}
					fn(null, src, {
						width: img.width,
						height: img.height
					});
				}
				img = null;
			}, 'onload');
			
			// On Error
			img.onerror = createErrorHandler(createErrorHandler(function onError() {
				clearTimeout(timer);
				if (img && img.parentNode) {
					img.parentNode.removeChild(img);
				}
				fn(new Error('Error loading image: ' + src), src);
				img = null;
			}, 'onerror'));
			
			// On Timeout
			timer = setTimeout(createErrorHandler(function onTimeout() {
				clearTimeout(timer);
				if (img && img.parentNode) {
					img.parentNode.removeChild(img);
				}
				fn(new Error('Timeout (' + timeout + 'ms) image: ' + src), src);
				img = null;
			}, 'timeout'), ms);
		}
	};
	
}(this));
/*jshint smarttabs:true white:true browser:true */
/**
 * @module GAME
 */
(function (root) {
	"use strict";
	
	/**
	 * 
	 * @class progressCircle
	 * @param {String} src
	 * @param {Number} progress
	 * @param {Object|Number} options
	 * @return {HTMLCanvasElement}
	 */
	var progressCircle = function progressCircle(src, progress, options) {
		
		options = options || {};
		
		if (typeof options === 'number') {
			options = {
				lineWidth: options,
				ms: 0
			};
		}
		
		progress = parseFloat(progress);
		progress = Math.round(progress * 100) || 1;
		
		var canvas = document.createElement('canvas'),
			ctx = canvas.getContext("2d"),
			centerX,
			centerY,
			radius,
			rewind,
			max,
			img = new Image(),
			step = 0,
			totalTicks,
			stepsPerTick = 1,
			msPerTick = 0,
			fps = 30,
			
			/**
			 * Draw
			 */
			draw = function (value) {
				
				var // Need a new fresh separate canvas for masking since old chrome, version 5?, can't do it on the same one
					maskCanvas = document.createElement('canvas'),
					maskCtx = maskCanvas.getContext("2d"),
					endingAngle,
					imageData,
					maskPixels,
					pixels,
					alpha,
					len,
					i;
				
				// Clear
				maskCanvas.width = canvas.width;
				maskCanvas.height = canvas.height;
				maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
				
				endingAngle = (max * (value / 100)) + rewind;
				
				// Draw the reference line
				maskCtx.arc(centerX, centerY, radius, rewind, endingAngle, false);
				maskCtx.lineWidth = options.lineWidth || 10;
				maskCtx.strokeStyle = 'black';
				maskCtx.stroke();
				
				// Get reference line image data
				maskPixels = maskCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height).data;
				
				// Clear canvas, we should not need to do this?
				ctx.clearRect(0, 0, canvas.width, canvas.height);
				
				// Draw the image
				ctx.drawImage(img, Math.floor((canvas.width - img.width) / 2), Math.floor((canvas.height - img.height) / 2));
				
				// Get image data
				imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
				pixels = imageData.data;
				
				// Loop image data and set alpha chanel to that of the reference line
				for (i = 0, len = pixels.length; i < len; i += 4) {
					pixels[i + 3] = maskPixels[i + 3];
				}
				
				// Update canvas with the image data
				ctx.putImageData(imageData, 0, 0);
			},
			
			/**
			 * Animate Draw
			 */
			animateDraw = function () {
				step = Math.floor(step + stepsPerTick);
				
				if (step < progress) {
					draw(step);
					setTimeout(animateDraw, msPerTick);
				} else {
					draw(progress);
					if (options.fn) {
						options.fn(null, canvas);
					}
				}
			},
			
			/**
			 * Image Ready
			 */
			imageReady = function () {
				canvas.width = (options.width || img.width);
				canvas.height = (options.height || img.height);
				
				centerX = options.centerX || options.center || (canvas.width / 2);
				centerY = options.centerY || options.center || (canvas.height / 2);
				radius = options.radius || (centerX - (options.lineWidth / 2));
				rewind = options.rewind || -(Math.PI / 2);
				max = (Math.PI * 2);
				
				animateDraw();
			};
			
		img.src = src;
		
		if (options.duration === 0) {
			stepsPerTick = progress;
		} else {
			totalTicks = fps / (1000 / options.duration);
			stepsPerTick = progress / totalTicks;
			if (stepsPerTick < 1) {
				stepsPerTick = 1;
			}
			msPerTick = Math.round(options.duration / totalTicks);
		}
		
		img.onload = imageReady;
		img.onerror = function () {
			if (options.fn) {
				options.fn(new Error('Unable to load image: ' + src), canvas);
			}
		};
		
		return canvas;
	};
	
	
	/**
	 * Module support
	 */
	if (typeof module !== 'undefined' && module.exports) {
		module.exports = progressCircle;
	} else {
		root.progressCircle = progressCircle;
	}
}(this));

/*jshint smarttabs:true white:true browser:true */
/**
 * @module GAME
 */
(function (root) {
	"use strict";
	
	
	var APP = root.APP,
		doc = APP.doc,
		
		defer = function () {
			var args = Array.prototype.slice.call(arguments, 0),
				fn = args.shift();
			
			setTimeout(function () {
				fn.apply(this, args);
			}, 0);
		},
		
		
		/**
		 * Any pixel with alpha level abow this will be considred "invisible"
		 * 
		 * @static
		 * @property ALPHA_LEVEL
		 * @type {Number}
		 */
		ALPHA_LEVEL = 220,
		
		
		/**
		 * The number of milliseconds that we will wait for a image to load
		 * 
		 * @static
		 * @property MS_TIMEOUT
		 * @type {Number}
		 */
		MS_TIMEOUT = 2000,
		
		
		/**
		 * Silhouette Rough Pass
		 *
		 * @private
		 * @method _silhouetteRoughPass
		 * @param {Array} pixels
		 * @param {Number} fill
		 * @param {Function} fn
		 */
		_silhouetteRoughPass = function (pixels, fill, fn) {
			var len = pixels.length,
				i;
			
			for (i = 0; i < len; i += 4) {
				if (pixels[i + 3] > ALPHA_LEVEL || (pixels[i] !== pixels[i + 1] && pixels[i + 1] !== pixels[i + 2])) {
					pixels[i] = pixels[i + 1] = pixels[i + 2] = fill;
				} else {
					pixels[i + 3] = 0;
				}
			}
			
			// Done!
			fn();
		},
		
		
		/**
		 * Silhouette Anti Aliasing Pass
		 *
		 * @private
		 * @method _silhouetteAntiAliasingPass
		 * @param {Array} pixels
		 * @param {Array} originalPixels
		 * @param {Number} rowLength
		 * @param {Number} fill
		 * @param {Function} fn
		 */
		_silhouetteAntiAliasingPass = function (pixels, originalPixels, rowLength, fill, fn) {
			var check = function check(index) {
					var alpha = originalPixels[index + 3];
					if (alpha < ALPHA_LEVEL) {
						pixels[index] = pixels[index + 1] = pixels[index + 2] = fill;
						pixels[index + 3] = Math.round(alpha * 0.65);
					}
				},
				max = pixels.length,
				start,
				end,
				next,
				prev,
				top,
				bottom,
				alpha,
				len,
				i;
			
			for (i = 0, len = pixels.length; i < len; i += 4) {
				start	= Math.floor(i / rowLength) * rowLength;
				end		= start + rowLength;
				next	= i + 4;
				prev	= i - 4;
				top		= i - rowLength;
				bottom	= i + rowLength;
				alpha	= originalPixels[i + 3];
		
				if (alpha > 220) {
					// Next
					if (next <= end) {
						check(next);
					}
					// Prev
					if (prev >= start) {
						check(prev);
					}
					// Top
					if (top >= 0) {
						check(top);
					}
					// Bottom
					if (bottom < max) {
						check(bottom);
					}
				}
			}
			
			// Done!
			fn();
		};
	
	
	/**
	 * Image Compose
	 *
	 * @static
	 * @class imageCompose
	 * @namespace GAME.APP
	 */
	APP.imageCompose = function imageCompose(images, width, height, fn) {
		var canvas = doc.createElement('canvas'),
			context = canvas.getContext('2d'),
			count = 0,
			len = images.length,
			done = function done() {
				var i, x, y, img;
				count += 1;
				if (count === len) {
					images.reverse();
					for (i = 0; i < len; i += 1) {
						x = images[i][1];
						y = images[i][2];
						img = images[i][3];
						context.drawImage(img, images[i][1], images[i][2], img.width, img.height);
					}
					fn(null, canvas, context);
				}
			},
			loadImage = function loadImage(src, x, y) {
				var img = new Image(),
					timer;
				
				// img.crossOrigin = true;
				
				img.src = src;
				
				if (img.complete) {
					defer(done);
				} else {
					
					// Load
					img.onload = function onLoadHandler() {
						clearTimeout(timer);
						img.onload = img.onerror = null;
						done();
					};
					
					// Error
					img.onerror = function onErrorHandler() {
						clearTimeout(timer);
						img.onload = img.onerror = null;
						fn(new Error('Error loading image: ' + src));
					};
					
					// Timeout
					timer = setTimeout(function onTimeoutHandler() {
						img.onload = img.onerror = null;
						fn(new Error('Timeout loading image: ' + src));
					}, MS_TIMEOUT);
				}
				
				return img;
			},
			i;
		
		canvas.width = width;
		canvas.height = height;
		
		if (len === 0) {
			fn(null, canvas, context);
		} else {
			for (i = 0; i < len; i += 1) {
				images[i].push(loadImage(images[i][0]));
			}
		}
	};
	
	
	/**
	 * Create a silhouette from a given canvas and context
	 * 
	 * @method silhouette
	 * @param {HTMLCanvasElement} canvas
	 * @param {Number} fill
	 * @param {Function} fn
	 */
	APP.imageCompose.silhouette = function (canvas, fill, fn) {
		fill = fill || 25;
		
		var context = canvas.getContext('2d'),
			imageData = context.getImageData(0, 0, canvas.width, canvas.height),
			pixels = imageData.data,
			orgPixels = Array.prototype.slice.call(pixels, 0);
		
		// Silhouette Rough Pass
		defer(_silhouetteRoughPass, pixels, fill, function () {
			// Silhouette Anti Aliasing Pass
			defer(_silhouetteAntiAliasingPass, pixels, orgPixels, (canvas.width * 4), fill, function () {
				context.putImageData(imageData, 0, 0);
				fn(canvas);
			});
		});
	};
}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule abilities
 */
(function createAbilityModel(win) {
	"use strict";
	
	
	if (!win.APP && (typeof require !== 'undefined')) {
		win.APP = require('../common/app');
	}
	
	var APP = win.APP,
		parent = APP.Model.prototype,
		_ = APP._;
	
	
	/**
	 * Ability model
	 * 
	 * @class Ability
	 * @extends FE.APP.Model
	 * @namespace GAME.APP.Model
	 */
	APP.Model.Ability = APP.Model.extend({
		defaults: {
			'kit'		: null,
			'level'		: 0,
			'maxlevel'	: 0,
			'name'		: null,
			'state'		: null,
			'tier'		: 0,
			'dependency': null,
			'available' : null,
			'progress'	: 0,
			'passive'	: true
		},
		schema: {
			'passive'	: 'boolean',
			
			'level'		: 'number',
			'maxlevel'	: 'number',
			'tier'		: 'number'
		},
		initialize: function initializeAbilityModel() {
			if (this.has('dependency')) {
				setTimeout(_.bind(function () {
					if (this.collection) {
						var dependency = this.get('dependency'),
							collection = this.collection.by('name', dependency);
						
						if (collection.length === 1) {
							this.set({
								dependencyId: collection.at(0).id
							}, { silent: true });
						}
					}
				}, this), 0);
			}
			this._setProgress();
			this.bind('change:level', this._setProgress, this);
		},
		
		_setProgress: function _setProgress() {
			this.set({
				progress: this.get('level') / this.get('maxlevel')
			});
		} 
	});
	
	
	
	/**
	 * Module support
	 */
	if (typeof module !== 'undefined' && module.exports) {
		module.exports = APP.Model.Ability;
	}
}(this));

/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule abilities
 */
(function (win) {
	"use strict";
	
	
	if (!win.APP && (typeof require !== 'undefined')) {
		win.APP = require('../common/app');
	}
	
	if (!win.APP.Model && (typeof require !== 'undefined')) {
		win.APP.Collection = require('../common/collection');
	}
	
	if (!win.APP.Model.Ability && (typeof require !== 'undefined')) {
		win.APP.Model.Ability = require('./model.ability');
	}
	
	var APP = win.APP,
		_ = APP._,
		$ = APP.$;
	
	
	/**
	 * Abilities Collection Class
	 * 
	 * @class Abilities
	 * @extends FE.APP.Collection
	 * @namespace GAME.APP.Collection
	 */
	APP.Collection.Abilities = APP.Collection.extend({
		model: APP.Model.Ability,
		comparator: function comparatorAbilitiesCollection(model) {
			var rank = model.get('tier');
			
			if (model.get('type') === 'combat') {
				rank += 10;
			}
			
			return rank;
		},
		getByName: function getByNameAbilitiesCollection(name) {
			name = name.toLowerCase();
			
			return this.get(function (model) {
				return model.get('name').toLowerCase() === name;
			});
		},
		
		getByType: function getByTypeAbilitiesCollection(type, options) {
			options = options || {};
			
			var filter = {
					type: type
				},
				models;
			
			if (options.level) {
				filter.level = function (level) {
					return level >= options.level;
				};
			}
			
			return this.filterBy(filter).orderBy('tier');
		}
    });
	
	/**
	 * Module support
	 */
	if (typeof module !== 'undefined' && module.exports) {
		module.exports = APP.Collection.Abilities;
	}
}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule abilities
 */
/**
 * @class GAME.Task.abilities
 */
APP.domTask('abilities', function initAbilities(done) {
	"use strict";
	
	
	var $ = APP.$,
		_ = APP._,
	
		/**
		 * Get Abilties namespace
		 */
		nsAbilities = APP.namespace('abilities'),
		
		// Main page element
		$main = nsAbilities.$el = $('div.main.main_abilities'),
		
		/**
		 * Create Abilities Collection
		 */
		collection = nsAbilities.collection = new APP.Collection.Abilities(),
		
		/**
		 * Populate Abilities
		 */
		populateAbilities = function populateAbilities() {		
			var abilities = [],
				types = [ 'equipment', 'combat' ],
				$blocks = $main.find('div.content'),
				$passive = $('div.passive_abilities div'),
				newAbilities = [],
				abilityIterator = function abilityIterator() {
					
					var $this = $(this),
						$tier = $this.parents('div.tier'),
						type = types[$blocks.index($this.parents('div.content'))],
						id = $this.attr('abilityid'),
						data = {
							'id'			: id,
							'type'			: type,
							'name'			: $this.attr('name'),
							'level'			: $this.attr('level'),
							'maxlevel'		: $this.attr('maxlevel'),
							'tier'			: ($tier.attr('class').match(/tier([0-9])/) || []).pop(),
							'description'	: $this.attr('description'),
							'available'		: $this.attr('available'),
							'dependency'	: $this.attr('dependency'),
							'passive'		: false,
							'usecount'		: 0
						},
						model = collection.get(data.id);
					
					if (nsAbilities.passiveAbilities[id]) {
						data.passive = true;
						data.usecount = nsAbilities.passiveAbilities[id];
					}
					
					if (model) {
						model.set(data);
					} else {
						newAbilities.push(data);
					}
				},
				$abilities = $main.find('span.item-ability');
			
			$abilities.each(abilityIterator);
			
			if (newAbilities.length !== 0) {
				collection.add(newAbilities);
			}
		};
	
	
	/**
	 * Listen to refresh events on the collection
	 */
	collection.bind('refresh', populateAbilities);
	
	
	/**
	 * Populate Abilities
	 */
	populateAbilities();
	
	
	/**
	 * Done
	 */
	done();
});
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule abilities
 */
/**
 * @class GAME.Task.abilities.routes
 * @uses GAME.Task.abilities
 */
APP.task('abilities.routes', [ 'abilities' ], function taskAbilitiesRoutes(done) {
	"use strict";
	
	
	var win = APP.win,
		$ = APP.$,
		_ = APP._;
	
	
	/**
	 * Abilities Page
	 */
	APP.bind('page:abilities', function onPageAbilities(from, data) {
		if (from !== 'abilities') {
			win.dontUpdateDoll = true;
			win.hideDoll();
		}
		
		if (data && data.id) {
			_.defer(function () {
				var $ability = $('div.main_abilities a.ability.abilityid_' + data.id);
				
				$ability.one('webkitAnimationEnd', function () {
					$ability.removeClass('focus');
				});
				
				$ability.addClass('focus');
			});
		}
	});
	
	
	/**
	 * Abilities page
	 */
	APP.route('abilities', 'abilities', function onAbilitiesRoute() {
		APP.page('abilities');
	});
	
	/**
	 * Booster item
	 */
	APP.route(/^abilities\/([\d]+)$/, 'abilities-id', function onAbilitiesItemRoute(id) {
		// Go to page
		APP.page('abilities', {
			id: id	
		});
	});
	
	
	/**
	 * Task done!
	 */
	done();
});
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule appearance
 */
(function (root) {
	"use strict";
	
	
	var APP = root.APP,
		_ = APP._,
		$ = APP.$,
		nsAppearance = APP.ns('appearance'),
		nsConfig = APP.ns('config'),
		parent = APP.View.DnD.prototype;
	
	
	APP.View.Appearance = APP.View.DnD.extend({
		name: 'appearance-view filter-all',
		events: {
			'click a.reset-position': function (e) {
				e.preventDefault();
				e.stopImmediatePropagation();
				
				this.sound('click');
				
				this.$el.removeClass('store inventory');
			},
			'click div.separator': function (e) {
				e.preventDefault();
				
				this.sound('click');
				
				if (this.$el.hasClass('inventory')) {
					this.openStore();
				} else {
					this.openInventory();               
				}
			}
		},
        initialize: function initializeAppearanceView() {
            this.options.viewOptions = this.options.viewOptions || {
				size: 'med',
				equipped: this.options.equipped
			};

			this._storeFilter = _.extend({
				buyable: true
			}, this.options.filter || {});
			
			this._inventoryFilter = _.extend({
				owned: true
			}, this.options.filter || {});
			
			var categories = this._categories = _.compact(_.unique(this.collection.filterBy(this.options.filter).pluck('category').concat(['all'])));

			this.collection = this.collection.filterBy({
				category: function (category) {
					return _.indexOf(categories, category) !== -1;
				}
			});
			
            this.bind('store:item:buy inventory:item:buy', this._onItemBuy, this);
            
            this.bind('store:item:click inventory:item:click', this._onItemClick, this);
            
            this.bind('store:item:render inventory:item:render', this._onItemRender, this);
            
            this.bind('store:item:buy:enter inventory:item:buy:enter', this._onItemBuyEnter, this);
            this.bind('store:item:buy:leave inventory:item:buy:leave', this._onItemBuyLeave, this);
            
            this.bind('store:item:exclaim:enter inventory:item:exclaim:enter', this._onItemExclaimEnter, this);
            this.bind('store:item:exclaim:leave inventory:item:exclaim:leave', this._onItemExclaimLeave, this);
            
            this.bind('store:item:enter inventory:item:enter', this._onItemEnter, this);
            this.bind('store:item:leave inventory:item:leave', this._onItemLeave, this);
            
            this.bind('store:drag:start inventory:drag:start', this._onItemDragStart, this);
            this.bind('store:drag:stop inventory:drag:stop', this._onItemDragStop, this);
            this.bind('store:drag:revert inventory:drag:revert', this._onItemDragRevert, this);
            
            this.bind('store:render inventory:render', this._onListRender, this);
            
            this.bind('store:remove inventory:remove store:append inventory:append', this._checkEmpty, this);
            
            this.bind('store:item:click:req inventory:item:click:req', this._onReqClick, this);
        },
        
        _onItemBuy: function (view, model) {
            this.trigger('buy', this, model);
        },
        
        _onItemClick: function (view, model, e) {
            this.trigger('item:click', this, model, e.currentTarget);
        },
        
        _onReqClick: function (view, model, e) {
            this.trigger('item:click:req', this, model, e.currentTarget);
        },
        
        _onItemDragStart: function (model, ui) {
            
            this._$dragHelper = ui.helper;
            
            this._$dragHelper.addClass('start');
            
            this._currentHighlight = model;
            
            this.trigger('list:drag:start', this, model, ui);
        },
        
        _onItemDragStop: function (model, ui) {
            this._$dragHelper = null;
            this.trigger('list:drag:stop', this, model, ui);
        },
        
        _onItemDragRevert: function (model, ui) {
            if (this._$dragHelper) {
                this._$dragHelper.removeClass('start');
            }
            this.trigger('list:drag:revert', this);
        },
        
        _onItemRender: function (view) {
            this.trigger('item:render', this, view);
        },
        
        _onItemEnter: function (view, model, e) {
            this.trigger('item:enter', this, model, e);
        },
        _onItemLeave: function (view, model, e) {
            this.trigger('item:leave', this, model, e);
        },
        _onItemBuyEnter: function (view, model, e) {
            this.trigger('item:buy:enter', this, model, e);
            
        },
        _onItemBuyLeave: function (view, model, e) {
            this.trigger('item:buy:leave', this, model, e);
        },
        _onItemExclaimEnter: function (view, model, e) {
            this.trigger('item:exclaim:enter', this, model, e);
            
        },
        _onItemExclaimLeave: function (view, model, e) {
            this.trigger('item:exclaim:leave', this, model, e);
        },
        
        _onListRender: function (listView) {
            this.trigger('list:render', this, listView);
        },
        
        _checkEmpty: function () {
            var storeFilter = _.clone(this._storeFilter),
				inventoryFilter = _.clone(this._inventoryFilter);
            
            if (this._currentFilter && this._currentFilter.category) {
				storeFilter.category = inventoryFilter.category = this._currentFilter.category;
            }
			
            // Empty store
			if (this._store && this.collection.filterBy(storeFilter).length === 0) {
				this._store.$el.addClass('empty');
			} else if (this._store) {
				this._store.$el.removeClass('empty');
			}
			
			// Empty inventory
			if (this._inventory && this.collection.filterBy(inventoryFilter).length === 0) {
				this._inventory.$el.addClass('empty');
			} else if (this._inventory) {
				this._inventory.$el.removeClass('empty');
			}
        },
        
        openStore: function () {
            this._currentState = 'store';
            
            this.$el.addClass('store');
            this.$el.removeClass('inventory');
            
            return this;
        },
        
        openInventory: function () {
            this._currentState = 'inventory';
            this.$el.addClass('inventory');
            this.$el.removeClass('store');
            
            return this;
        },
        
        highlight: function (model, options) {
            
            // Remove old highlight
            if (this._currentHighlight !== model) {
                if (this._currentHighlight) {
                    this.$el.removeClass(this._currentHighlight.get('category'));
                }
                
                // Add new highlight category
                if (model) {
                    this.$el.addClass(model.get('category'));
                }
            }
            
            this._currentHighlight = model;
            
            if (!options || !options.silent) {
                this.trigger('highlight', this, this._currentHighlight);
            }
            
            return this;
        },
        
        filter: function (filter, options) {
			if (_.isEqual(this._currentFilter, filter) && (!options || !options.force)) {
                return this;
            }
            
            this._currentFilter = filter;
            
            var filterText,
                filterClassName;
            
            if (this._currentFilter && this._currentFilter.category) {
                filterClassName = 'filter-' + this._currentFilter.category;
                filterText = this.trans('WEB_GAME_APPAREL_SEPARATOR_MY_' + this._currentFilter.category.toUpperCase());
            } else {
                filterClassName = 'filter-all';
                filterText = this.trans('WEB_GAME_APPAREL_SEPARATOR_MY_ALL');
            }
            
            this.el.className =  this.el.className.replace(/filter\-[^\s]+/, filterClassName);
            
            this._separatorText.innerHTML = filterText;
            
			this._checkEmpty();
			
            // Trigger events
            if (!options || !options.silent) {
                this.trigger('filter', this, this._currentFilter);
            }
            
            return this;
        },
        
        getGridSize: function (size) {
            return this.options.viewOptions.size;
        },
        
        setGridSize: function (size) {
            this.options.viewOptions.size = size;
            
            return this;
        },
        
        scrollTo: function ($el) {
            
            if (this._currentState === 'store') {
                this._store.scrollTo($el);
            } else if (this._currentState === 'inventory') {
                this._inventory.scrollTo($el);                
            }
        },
        
		getItems: function () {
			var $items = $([]).add(this._store.$items).add(this._inventory.$items);
			return $items;
		},

		getViewsByModel: function (model) {
			var views = [];
					
			_.forEach(this._store._views, function (view) {
				if (view.model === model) {
					views.push(view);
				}
			});

			_.forEach(this._inventory._views, function (view) {
				if (view.model === model) {
					views.push(view);
				}
			});
			
			return views;
		},
		
		getItemsByModel: function (model) {
			var $items = $([]),
				$storeEl = this._store.getElementByModel(model),
				$inventoryEl = this._inventory.getElementByModel(model);
			
			if ($storeEl) {
				$items = $items.add($storeEl);
			}
			if ($inventoryEl) {
				$items = $items.add($inventoryEl);
			}
			
			return $items;
		},
		
        render: function renderAppearanceView() {
			
            var separatorText = this.make('div', {
                    'class': 'text'
                }),
                separatorInventory = this._separatorText = this.make('span', {
                    'class': 'text-inventory'
                }),
                separatorStore = this.make('span', {
                    'class': 'text-store'
                }, this.trans('WEB_GAME_APPAREL_SEPARATOR_STORE')),
                separatorDrag = this.make('span', {
                    'class': 'drag'
                }),
				gridSize = this.getGridSize(),
                note;
            
            this.$bar = $(this.make('div', {
				'class': 'separator'
			}));
            
            separatorText.appendChild(separatorStore);
            separatorText.appendChild(separatorInventory);
            this.$bar.append(separatorText);
            
			this.$bar.append(this.make('a', {
				'href'	: '#reset-position',
				'class'	: 'reset-position'
			}));
			
			// Filter
            this.filter(this._currentFilter, {
				force: true
			});
			
            // TODO: This has horrible performance right now
            //this.$bar.append(separatorDrag);
            
            this.$el.addClass('grid-' + gridSize);

			
            // Add feature notification
			note = this.make('div', {
				'class': 'feature-help'
			});
            note.appendChild(this.make('span', {
				'class': 'label'
			}, this.trans('WEB_STORE_COMMON_NEW')));
            note.appendChild(this.make('span', {
				'class': 'text'
			}, this.trans('WEB_GAME_FEATURE_HELP_INSERTS')));
            note.appendChild(this.make('a', {
				'target': '_blank',
				'href': nsConfig.insertsForumUrl
			}, this.trans('WEB_GAME_FEATURE_HELP_INSERTS_LINK')));
			
			// Append to view
            this.el.appendChild(note);

			
			/**
			 * Store
			 */
            this._store = this.createView(APP.View.ItemList, {
                collection	: this.collection,
                viewClass	: this.options.viewClass,
                className	: 'selectable-list store',
                viewOptions	: this.options.viewOptions,
                dragOptions	: {
                    cursorAt: this.options.cursorAt[gridSize],
                    containment: this.options.containment[gridSize],
					cancel: 'li.locked'
                },
                filter: this._storeFilter,
                drag: 'li.' + APP.View.ItemList.ITEM_CLASS_NAME + ':not(.empty-msg)'
            }, 'store').render().attach();
            
			
			this.$el.append(this.$bar);
			
			
			/**
			 * Inventory
			 */
            this._inventory = this.createView(APP.View.ItemList, {
                collection	: this.collection,
                viewClass	: this.options.viewClass,
                className	: 'selectable-list inventory',
                viewOptions	: this.options.viewOptions,
                dragOptions	: {
                    cursorAt: this.options.cursorAt[gridSize],
                    containment: this.options.containment[gridSize]
                },
                filter: this._inventoryFilter,
                drag: 'li.' + APP.View.ItemList.ITEM_CLASS_NAME + ':not(.empty-msg)'
            }, 'inventory').render().attach();


			/**
			 * Insert empty messages
			 */
            _.forEach(this._categories, function (category) {
				if (!category) {
					category = 'other';
				}
				this._store.el.appendChild(this.make('li', {
					'class': 'empty-msg ' + category
				}, this.trans('WEB_GAME_EMPTY_MESSAGE_STORE_' + category.toUpperCase())));
				this._inventory.el.appendChild(this.make('li', {
					'class': 'empty-msg ' + category
				}, this.trans('WEB_GAME_EMPTY_MESSAGE_INVENTORY_' + category.toUpperCase())));
            }, this);
        }
        
    });
    
}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule appearance
 */
(function (root) {
	"use strict";
	
	
	var APP = root.APP,
		$ = APP.$,
		_ = APP._,
		win = APP.win,
		nsConfig = APP.namespace('config'),
		nsAppearance = APP.namespace('appearance'),
		parent = APP.View.prototype;
	
	/**
	 * Appearance Item View
	 */
	APP.View.AppearanceItem = APP.View.extend({
		name: 'appearance-item-view',
		options: {
			size: 'med',
			showName: true,
			showIcons: true,
			showAdditional: true,
			showLock: true,
			live: true
		},
		
		events: {
			'mouseenter span.exclaim': function (e) {
				this.sound('hover');
				this.trigger('exclaim:enter', this, this.model, e);
			},
			'mouseleave span.exclaim': function (e) {
				this.trigger('exclaim:leave', this, this.model, e);
			},
			'mouseenter a.buy, a.lock, a.unlock': function (e) {
				this.sound('hover');
				this.trigger('buy:enter', this, this.model, e);
			},
			'mouseleave a.buy, a.lock, a.unlock': function (e) {
				this.trigger('buy:leave', this, this.model, e);
			},
			
			'mouseenter': function (e) {
				this.sound('hover');
				this.trigger('enter', this, this.model, e);
			},
			'mouseleave': function (e) {
				this.trigger('leave', this, this.model, e);
			},
			
			'click a.buy, a.unlock':  function (e) {
				e.preventDefault();
				e.stopImmediatePropagation();
				this.trigger('buy', this, this.model, e);
			},
			'mousedown a.buy, a.unlock': function (e) {
				e.stopImmediatePropagation();
			},
			'click': function (e) {
				e.preventDefault();
				this.sound('click');
				this.trigger('click', this, this.model, e);
			}
		},
		
		
		/**
		 * Initialize
		 */
		initialize: function () {
			
			this.model.bind('change', this._onChange, this);
			this.model.bind('change:upgrades', this._onChangeUpgrades, this);
			
			var category = this.model.get('category');
			
			this.collection = this.model.collection;
			
            
			this.pocketModel = this.collection.get(function (model) {
				return (model.isItemType('pocket') && model.get('category') === category);
			});
			
			this.collection.bind('purchase:start', this._onPurchaseStart, this);
			this.collection.bind('purchase:end', this._onPurchaseEnd, this);
			
			this._bindInvalidDependency(this.model.get('upgrades'));
		},
		
		
		/**
		 * Destroy
		 */
		destroy: function () {
			this.model.unbind('change', this.render, this);
			this.model.unbind('change:upgrades', this._onChangeUpgrades, this);
			this.collection.unbind('purchase:start', this._onPurchaseStart, this);
			this.collection.unbind('purchase:end', this._onPurchaseEnd, this);
			this._unbindInvalidDependency(this.model.get('upgrades'));
		},
		
		_onPurchaseStart: function _onPurchaseStartAppearanceItemView(model) {
			model = this.collection.get(model);
			if (model && (model.id === this.model.id || _.indexOf(_.values(this.model.get('upgrades') || {}), model.id) !== -1)) {
				this.$el.addClass('loading');
			}
		},
		_onPurchaseEnd: function _onPurchaseEndAppearanceItemView(model) {
			model = this.collection.get(model);
			if (model && (model.id === this.model.id || _.indexOf(_.values(this.model.get('upgrades') || {}), model.id) !== -1)) {
				this.render();
			}
		},
		_onChange: function _onChangeAppearanceItemView() {
			
			var reRenderOnAttrs = [
					'upgrades',
					'expired',
					'owned',
					'isLocked'
				],
				reRender = _.some(reRenderOnAttrs, function (attr) {
					return this.model.hasChanged(attr);
				}, this),
				equippedChange = this.model.hasChanged('equippedSlot');
			
			if (this.model.hasChanged('equippedSlot')) {
				equippedChange = (!_.isNumber(this.model.previous('equippedSlot')) || !this.model.isEquipped());
			}
			
			// Only re-render if it's worth it :D
			if (reRender || equippedChange) {
				this.render();
			}
		},
		
		_unbindInvalidDependency: function _unbindInvalidDependencyPocketsView(upgrades) {
			_.forEach(upgrades || {}, function (upgrade) {
				upgrade = this.collection.get(upgrade);
				if (upgrade) {
					upgrade.unbind('change:invalidDependency', this.render, this);
				}
			}, this);
		},
		_bindInvalidDependency: function _bindInvalidDependencyPocketsView(upgrades) {
			_.forEach(upgrades || {}, function (upgrade) {
				upgrade = this.collection.get(upgrade);
				if (upgrade) {
					upgrade.bind('change:invalidDependency', this.render, this);
				}
			}, this);
		},
		_onChangeUpgrades: function () {
			// Unbind all old just good measure
			this._unbindInvalidDependency(this.model.previous('upgrades'));
			// Bind all old just good measure
			this._bindInvalidDependency(this.model.get('upgrades'));
		},
		
		
		/**
		 * Drag helper: should return a jQuery wrapped DOM element
		 */
		dragHelper: function (e) {
			
			if ((!this.model.isOwned() && this.model.isLocked()) || this.model.hasInvalidDependencies()) {
				return $(this.make('span'));
			}
			
			var item,
				size = this.options.size,
				el = this.make('div', {'class': 'appearance-draghelper size-' + size});
				
				
			item = this.make('span', {
				'class': 'item item-drag game-item item-min item-min-' + this.model.id
			});	
				
			el.appendChild(item);
			
			return $(el);
		},
		
		/**
		 * Render Lock
		 */
		renderLock: function renderLockItemView() {
			
			var nsConfig = APP.ns('config'),
				type = this.model.get('lockType'),
				criteria = this.model.get('lockCriteria'),
				lock = this.make('div', {
					'class': 'lock ' + type
				}),
				progressImage = nsConfig.imageFolder + 'game/item-lock-progress.png',
				progress = this.model.get('lockProgress'),
				canvas;
			
			lock.appendChild(this.make('span', {
				'class': 'key'
			}, criteria));
			
			if (this.options.size === 'med') {
				canvas = win.progressCircle(progressImage, progress, {
					width: 56,
					height: 56,
					lineWidth: 8,
					duration: 500
				});
				
			} else if (this.options.size === 'min') {
				canvas = win.progressCircle(progressImage, progress, {
					width: 32,
					height: 32,
					lineWidth: 5,
					duration: 500
				});
			}
			
			
			lock.appendChild(canvas);
			
			this.el.appendChild(lock);
			
			return this;
		},
				
		/**
		 * Render
		 */
		render: function renderAppearanceItemView() {
			
			var $bar = this.$('<div class="bar" />'),
				usecount = this.model.get('usecount');
			
			// Model id
			this.$el.attr('item-id', this.model.id);
			
			// Add Default Classes
			this.$el.addClass(this.model.get('category') + ' ' + this.model.get('validationGroup'));
			
			// Equipped
			if (this.model.isEquipped()) {
				this.$el.addClass('equipped');
			}
			
			/**
			 * Show Additional
			 */
			if (this.options.showIcons) {
				// Rented
				if (this.model.isRented()) {
					this.$el.addClass('rented');
					$bar.append('<span class="exclaim timer">?</span>');
				
                // Has invalid customizations
				} else if (this.model.hasInvalidCustomizations()) {
					this.$el.addClass('invalid');
					$bar.append('<span class="exclaim">!</span>');
				}
				
				// Locked
				if (this.model.isLocked()) {
					if (!this.model.isOwned()) {
						this.$el.addClass('locked');
						if (this.options.showLock) {
							this.renderLock();
						}
					}
					
					if (this.model.get('offers').hasUnlockOffers()) {
						this.$el.append('<a href="#unlock" class="icon unlock" />');
					} else {
						this.$el.append('<a href="#lock" class="icon lock" />');
					}
					
				
				// Buyable
				} else if (this.model.isBuyable()) {
					this.$el.append('<a href="#buy" class="icon buy" />');
				
				// Boostable
				} else if (this.model.isTrainable()) {
					this.$el.append('<a href="#train" class="icon train" />');
				} 
			}
			
			
			// Show Name?
			if (this.options.showName) {
				if (this.options.size !== 'min') {
					$bar.append('<span class="name">' + this.model.get('name') + '</span>');
					$bar.append('<span class="category">' + this.model.get('categoryname') + '</span>');
				}
				$bar.appendTo(this.el);
			}
			
            // Show image or sprite
			if (this.options.size === 'med') {			
				this.image = this.el.appendChild(this.make('img', {
					'src': this.model.getImage('med'),
					'width': 285,
					'height': 128,
					'class': 'item-med item-med-' + this.model.id,
					'item-id': this.model.id
				}));
				
				if (this.model.isLocked()) {
					this.image.ondragstart = function () {
						return false;
					};
				}
			} else if (this.options.size === 'min') {
				this.el.appendChild(this.make('span', {
					'class': 'item-min item-min-' + this.model.id,
					'item-id': this.model.id
				}));
			}
			
			this.createView(APP.View.AppearanceSlots, {
				model: this.model
			}).render().attach();
		}
	});
}(this));

/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule appearance
 */
(function (win) {
	"use strict";
	
	
	var APP = win.APP,
		$ = APP.$,
		_ = APP._,
		nsConfig = APP.namespace('config'),
		parent = APP.View.prototype;
	
	/**
	 * Appearance Slots View
	 */
	APP.View.AppearanceSlots = APP.View.extend({
		name: 'appearance-slots-view',
		initialize: function initializeAppearancenSlotsView() {
			if (!this.collection && this.model.collection) {
				this.collection = this.model.collection;
			}
			var category = this.model.get('category');
			this.pocketModel = this.collection.get(function (model) {
				return (model.isItemType('pocket') && model.get('category') === category);
			});
		},
		destroy: function destroyAppearancenSlotsView() {
			
		},
		render: function renderAppearancenSlotsView() {


            // Don't display pockets
            return this;
            /*
			var maxSlots = this.model.get('maxNumPockets'),
				numberOfPockets,
				upgrades,
				unlockLevels,
				pocketOffers,
				personaLevel;



            // Owned permanently
            if (this.model.isOwnedPermanent()) {
                this.$el.addClass('permanent');
            }
            
			if (maxSlots > 0) {
				upgrades = this.model.getUpgrades();
				numberOfPockets = this.model.get('numberOfPockets');
				unlockLevels = (this.pocketModel && this.pocketModel.get('unlockLevels')) || {};
				pocketOffers = (this.pocketModel && this.pocketModel.get('pocketOffers')) || {};
				personaLevel = (this.pocketModel && this.pocketModel.get('personaLevel')) || 0;
				
				// Pockets
				_.forEach(upgrades, function (upgrade, pocket) {
					var available = numberOfPockets > pocket,
						classNames,
						isLocked = personaLevel < unlockLevels[pocket],
						offers = pocketOffers[pocket];
					
					// Owned pocket
					if (available) {
						
						// Upgrade	
						if (upgrade) {					
							if (upgrade.isAllowedInGame()) {
								classNames = 'filled';						
							} else {
								classNames = 'invalid';
							}				
						} else {
							classNames = 'empty';
						}					
						
					// Not Owned
					} else if (isLocked) {
						if (offers && offers.hasUnlockOffers()) {
							classNames = 'unlockable';
						} else {
							classNames = 'locked';
						}
						
					// Buyable
					} else if (offers && offers.length !== 0) {
						classNames = 'buyable';
					}
					
					this.el.appendChild(this.make('span', {
						'class': classNames
					}));
				}, this);
			}
			*/
		}
	});
}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule appearance
 */
(function (root) {
	"use strict";
	
	
	var APP = root.APP,
		$ = APP.$,
		_ = APP._,
		win = APP.win,
		doc = APP.doc,
		nsBoosters = APP.namespace('boosters'),
		nsConfig = APP.namespace('config'),
		nsAppearance = APP.namespace('appearance');
	
	/**
	 * Upgrade Item View
	 */
	APP.View.UpgradeItem = APP.View.extend({
		name: 'upgrade-item-view',
		options: {
			size: 'med',
			showName: true,
			showIcons: true,
			showAdditional: true,
			showLock: true,
			live: true
		},
		
		events: {
			'mouseenter span.exclaim': function (e) {
				this.sound('hover');
				this.trigger('exclaim:enter', this, this.model, e);
			},
			'mouseleave span.exclaim': function (e) {
				this.trigger('exclaim:leave', this, this.model, e);
			},
			'mouseenter a.buy, a.lock, a.unlock': function (e) {
				this.sound('hover');
				this.trigger('buy:enter', this, this.model, e);
			},
			'mouseleave a.buy, a.lock, a.unlock': function (e) {
				this.trigger('buy:leave', this, this.model, e);
			},
			'mouseenter': function (e) {
				this.sound('hover');
				this.trigger('enter', this, this.model, e);
			},
			'mouseleave': function (e) {
				this.trigger('leave', this, this.model, e);
			},
			'click a.buy, a.unlock': function (e) {
				e.preventDefault();
				e.stopImmediatePropagation();
				if (!this._disabled) {
					this.sound('click');
					this.trigger('buy', this, this.model, e);
				}
			},
			'click div.req > div, div.req p': function (e) {
				e.preventDefault();
				this.trigger('click:req', this, this.model, e);
			},
			'mousedown a.buy, a.unlock': function (e) {
				e.stopImmediatePropagation();
			},
			'click div.item-info' : function () {
				this.toggleStatsDescription();
			}
		},
		
		initialize: function () {
			
			this.model.bind('change', this._onChange, this);

			this.equipped = this.options.equipped;

			this.equipped.bind('add', this._onEquippedAddRemove, this);
			this.equipped.bind('remove', this._onEquippedAddRemove, this);
			
			this.collection = this.model.collection;
			this.collection.bind('purchase:start', this._onPurchaseStart, this);
			this.collection.bind('purchase:end', this._onPurchaseEnd, this);
		},
		
		destroy: function () {

			this.model.unbind('change', this.render, this);
			
			this.equipped.unbind('add', this._onEquippedAddRemove, this);
			this.equipped.unbind('remove', this._onEquippedAddRemove, this);
			
			this.collection.unbind('purchase:start', this._onPurchaseStart, this);
			this.collection.unbind('purchase:end', this._onPurchaseEnd, this);
		},
		
		_onPurchaseStart: function _onPurchaseStartUpgradeItemView(model) {
			model = this.collection.get(model);
			if (model && (model.id === this.model.id || _.indexOf(_.values(this.model.get('upgrades') || {}), model.id) !== -1)) {
				this.$el.addClass('loading');
			}
		},
		_onPurchaseEnd: function _onPurchaseEndUpgradeItemView(model) {
			model = this.collection.get(model);
			if (model && (model.id === this.model.id || _.indexOf(_.values(this.model.get('upgrades') || {}), model.id) !== -1)) {
				
				// Remove blankstate
				nsAppearance.currentList._inventory.$el.removeClass('empty');
				
				this.render();
			}
		},
		_onChange: function _onChangeUpgradeItemView() {
			
			var reRenderOnAttrs = [
					'expired',
					'owned',
					'equippedSlot'
				],
				reRender = _.some(reRenderOnAttrs, function (attr) {
					return this.model.hasChanged(attr);
				}, this),
				equippedChange = this.model.hasChanged('equippedSlot');
			
			if (this.model.hasChanged('equippedSlot')) {
				equippedChange = (!_.isNumber(this.model.previous('equippedSlot')) || !this.model.isEquipped());
			}
			
			// Only re-render if it's worth it :D
			if (reRender || equippedChange) {
				this.render();
			}
		},
		
		_onEquippedAddRemove: function _onEquippedAddRemoveUpgradeItemView(model) {
			if (model.get('category') === this.model.get('category')) {
				this.render();
			}
		},
		
		toggleStatsDescription: function () {
			if (this.$info.hasClass('description')) {
				this.showStats();
			} else {
				this.showDescription();
			}
			return this;
		},
		showStats: function () {
			this._statsDescription = 'stats';
			this.$info.removeClass('description');
			return this;
		},
		showDescription: function () {
			this._statsDescription = 'desc';
			this.$info.addClass('description');
			return this;
		},
		
		
		/**
		 * Drag helper: should return a jQuery wrapped DOM element
		 */
		dragHelper: function (e) {
			if ((!this.model.isOwned() && this.model.isLocked()) || this.model.hasInvalidDependencies()) {
				return $(this.make('span'));
			}
			
			var item = this.make('span', {
					'class': 'item item-drag game-item item-upgrade-min item-upgrade-min-' + this.model.id
				}),
				el = this.make('div', {
					'class': 'upgrade-draghelper size-' + this.options.size
				});
				
			el.appendChild(item);
			
			return $(el);
		},
		
		/**
		 * Render Lock
		 */
		renderLock: function renderLockUpgradeItemView(container) {
			
			var type = this.model.get('lockType'),
				criteria = this.model.get('lockCriteria'),
				lock = this.make('div', {
					'class': 'lock ' + type
				}),
				progressImage = nsConfig.imageFolder + 'game/item-lock-progress.png',
				progress = this.model.get('lockProgress'),
				canvas = win.progressCircle(progressImage, progress, {
					width: 32,
					height: 32,
					lineWidth: 5,
					duration: 500
				});
			
			lock.appendChild(this.make('span', {
				'class': 'key'
			}, criteria));
			
			lock.appendChild(canvas);
			
			if (container) {				
				container.appendChild(lock);
				
				return this;
			} else {
				this.el.appendChild(lock);					
			}
				
			
			return this;
		},
		
		/**
		 * Render
		 */
		render: function renderUpgradeItemView() {
			
			var $bar = this.$('<div class="bar" />'),
				upgradeContainer = this.make('div', {'class': 'upgrade-container'}),
				info = this.make('div', {'class': 'item-info'}),
				purchaseOptions = doc.createDocumentFragment(),
				lowestOffers = this.model.get('offers').getLowestOffers(),
				prices = this.make('div', {
					'class': 'prices'
				}),
				invalidDependencies = this.model.hasInvalidDependencies(),
				reqWrapper,
				reqGear,
				reqAbility,
				reqAbilityIcon,
				hasUnlockOffers = this.model.get('offers').hasUnlockOffers(),
				dependency,
				category = this.model.get('category'),
				isCategoryEquipped = _.indexOf(this.equipped.filterBy({
					isOwnedPermanent: true
				}).pluck('category'), category) !== -1;

			
			
			// Model id
			this.$el.attr('item-id', this.model.id);
			
			// Add Default Classes
			this.$el.addClass(this.model.get('category') + ' ' + this.model.get('validationGroup'));

			// Equipped
			if (this.model.isEquipped()) {
				this.$el.addClass('equipped');
			}
			
			/**
			 * Show Additional
			 */
			if (this.options.showIcons) {
				// Rented
				if (this.model.isRented()) {
					this.$el.addClass('rented');
					$bar.append('<span class="exclaim timer">?</span>');
				}
				
				// Owned permanently
				if (this.model.isOwnedPermanent()) {
					this.$el.addClass('owned');					
				}
				
				if (!invalidDependencies || this.options.size === 'med') {
					
					// Locked
					if (this.model.isLocked()) {
						if (!this.model.isOwned()) {
							this.$el.addClass('locked');
							if (this.options.showLock) {
								this.renderLock(upgradeContainer);
							}
						}
						
						if (this.options.size === 'med') {
							if (hasUnlockOffers) {
								this.$el.append('<a href="#unlock" class="icon unlock' + (invalidDependencies ? ' disabled' : '') + '" />');
							} else {
								this.$el.append('<a href="#lock" class="icon lock' + (invalidDependencies ? ' disabled' : '') + '" />');
							}
						}
						
					
					// Buyable
					} else if (this.model.isBuyable()) {
						this.$el.append('<a href="#buy" class="icon buy' + (invalidDependencies ? ' disabled' : '') + '" />');
						
					// Boostable
					} else if (this.model.isTrainable()) {
						this.$el.append('<a href="#train" class="icon train" />');
					}
				}
			}
			
			// Show Name?
			if (this.options.showName) {
				if (this.options.size !== 'min') {
					$bar.append('<span class="name">' + this.model.get('name') + '</span>');
					$bar.append('<span class="category">' + this.model.get('categoryname') + '</span>');
				}
				$bar.appendTo(this.el);				
			}
			
			// In big grid, show description & starting prices
			if (this.options.size !== 'min') {
				this.createView(APP.View.StatsList, {
					container	: info,
					model		: this.model
				}).render().attach();
				
				
				info.appendChild(this.make('p', {
					'class': 'description'
				}, this.model.get('description')));
				
				this.$info = this.$(info);
				
				this.el.appendChild(info);
				
				// Only display on items with available offers
				if ((!this.model.isLocked() || hasUnlockOffers) && !this.model.isOwnedPermanent()) {
					
					// Lowest offers
					if (lowestOffers.credits) {
						prices.appendChild(this.make('span', {
							'class': 'currency credits'
						}, lowestOffers.credits.get('price')));
					}
					if (lowestOffers.funds) {
						prices.appendChild(this.make('span', {
							'class': 'currency funds'
						}, lowestOffers.funds.get('price')));
					}
					purchaseOptions.appendChild(prices);
					
					this.createView(APP.View.LabelBox, {
						'label': this.trans('WEB_GAME_WEAPONS_INFO_PRICE_FROM'),
						'content': purchaseOptions,
						'className': 'purchase',
						'container': this.el
					}).render().attach();
					
				}
			}
			
			// Has a unresolved dependency
			if (invalidDependencies || !isCategoryEquipped) {
				reqWrapper = this.make('div', {
					'class': 'req'
				});
				
				dependency = this.model.getDependencies();
				
				// Has corresponding active booster
				if (dependency.gear && dependency.gear.isOwned()) {
					reqGear = this.make('div', {
						'class': 'gear'
					});
					
					reqGear.appendChild(this.make('img', {
						'src': nsBoosters.list.collection.get(dependency.gear.id).getImage('min'),
						'width': 80,
						'height': 60,
						'class': 'game-item item-min item-min-' + dependency.gear.id,
						'item-id': dependency.gear.id
					}));
					
					if (this.options.size !== 'min') {
						reqGear.appendChild(this.make('h3', null, this.trans('WEB_GAME_UPGRADES_REQ_BOOSTER_INTERFERENCE')));
						reqGear.appendChild(this.make('span', {
							'class': 'name'
						}, dependency.gear.get('name')));
						reqGear.appendChild(this.make('span', {
							'class': 'expires'
						}, dependency.gear.getExpireText()));
					}
					// Prevent image dragging
					reqGear.getElementsByTagName('img')[0].ondragstart = function () {
						return false;
					};
					
					reqWrapper.appendChild(reqGear);
					
				// Depends on untrained ability
				} else if (dependency.ability && dependency.ability.get('level') === 0) {
					reqAbility = this.make('div', {
						'class': 'ability'
					});
					reqAbilityIcon = this.make('a', {
						'class': 'ability'
					});
					
					reqAbilityIcon.appendChild(this.make('span', {
						'class': 'item-ability item-ability-' + dependency.ability.id
					}));
					reqAbility.appendChild(reqAbilityIcon);
					
					if (this.options.size !== 'min') {
						reqAbility.appendChild(this.make('h3', null, this.trans('WEB_GAME_UPGRADES_REQ_TRAINING_REQUIRED')));
						reqAbility.appendChild(this.make('span', {
							'class': 'name'
						}, dependency.ability.get('name')));
					}
					
					reqWrapper.appendChild(reqAbility);
					
				// Needs a appearance item of this category equipped
				} else if (!isCategoryEquipped) {
					reqWrapper.appendChild(this.make('div', {
						'class': 'equipped-category'
					}, 'Equip an <span>' + category + '</span> apparel item to use'));
				}
				
				this.el.className += ' disabled';
				this.el.appendChild(reqWrapper);
			} 
			
			
			upgradeContainer.appendChild(this.el.appendChild(this.make('span', {
				'class': 'item-upgrade-med item-upgrade-med-' + this.model.id,
				'item-id': this.model.id
			})));			
			this.el.appendChild(upgradeContainer);
			
		}
	});
}(this));

/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule appearance
 */
(function (root) {
    "use strict";
	
	var APP = root.APP,
        _ = APP._,
        $ = APP.$,
        parent =  APP.View.DnD.prototype;
    
	/**
	 * Pocket View
	 */
	APP.View.Pockets = APP.View.DnD.extend({
		name: 'pockets-view',
		options: _.extend({}, parent.options, {
			drag: 'li',
			drop: 'li'
		}),
		dragOptions: {
			revert: false,
			cursorAt: { left: 20, top: 20 }
		},
		dropOptions: _.extend({}, parent.dropOptions, {
			greedy: true
		}),
		
		events: {
			'mouseenter ul': function (e) {
				this.trigger('enter', this, this.model, e);
			},
			'mouseleave ul': function (e) {
				this.trigger('leave', this, this.model, e);
			},
			'mouseenter li': function (e) {
				var pocket = this.$pockets.index(e.currentTarget),
					upgrades = this.model.getCustomizations(),
					model = upgrades[pocket];
				
				this.sound('hover');
				
				this.trigger('pocket:enter', this, model, e, pocket);
			},
			'mouseleave li': function (e) {
				var pocket = this.$pockets.index(e.currentTarget),
					upgrades = this.model.getCustomizations(),
					model = upgrades[pocket];
				
				this.trigger('pocket:leave', this, model, e, pocket);
			},
			'mouseenter a.icon': function (e) {
				if (this.model.isOwnedPermanent()) {
					this.sound('hover');
				}
			},
			'click a.icon.buy': function (e) {
				e.preventDefault();
				e.stopImmediatePropagation();
				
				if (this.model.isOwnedPermanent()) {
					var pocket = this.$pockets.index(e.currentTarget.parentNode),
						offers =  this.pocketModel.get('offers').filterBy({
							pocket: pocket
						});
					
					this.sound('click');
					
					this.trigger('pocket:buy', this, pocket, offers);
				}
			},
			'click a.icon.unlock': function (e) {
				e.preventDefault();
				e.stopImmediatePropagation();
				
				if (this.model.isOwnedPermanent()) {
					var pocket = this.$pockets.index(e.currentTarget.parentNode),
						offers =  this.pocketModel.get('offers').filterBy({
							pocket: pocket
						});
					
					this.sound('click');
					
					this.trigger('pocket:unlock', this, pocket, offers);
				}
			},
			'click a.icon.redeem': function (e) {
				e.preventDefault();
				e.stopImmediatePropagation();
				
				if (this.model.isOwnedPermanent()) {
					var pocket = this.$pockets.index(e.currentTarget.parentNode);
					
					this.sound('click');
					
					this.trigger('pocket:redeem', this, pocket);
				}
			},
			'mousedown': function (e) {
				e.stopImmediatePropagation();
			},
			'click li': function (e) {
				this.trigger('pocket:click', this, this.model, e);
			},
			'click li, h3': function (e) {
				e.stopImmediatePropagation();
			}
		},
		
		initialize: function initializePocketsView() {
			
			var category = this.model.get('category');
			
			this.collection = this.model.collection;
			
			this.pocketModel = this.options.pocketModel;
			
			// On Drag Start
			this.bind('drag:start', this._onDragStart, this);
			
			// On Drag Stop
			this.bind('drag:stop', this._onDragStop, this);
			
			// On Drop
			this.bind('drop', this._onDrop, this);
			
			this.model.bind('change', this._onChange, this);
			this.model.bind('change:upgrades', this._onChangeUpgrades, this);
			this.model.bind('attach:start', this._onAttachStart, this);
			this.model.bind('attach:end', this._onAttachEnd, this);
			this.collection.bind('purchase:start', this._onPurchaseStart, this);
			this.collection.bind('purchase:end', this._onPurchaseEnd, this);
			
			this._bindInvalidDependency(this.model.get('upgrades'));
		},
		
		destroy: function destroyPocketsView() {
			this.model.unbind('change', this._onChange, this);
			this.model.unbind('change:upgrades', this._onChangeUpgrades, this);
			this.model.unbind('attach:start', this._onAttachStart, this);
			this.model.unbind('attach:end', this._onAttachEnd, this);
			this.collection.unbind('purchase:start', this._onPurchaseStart, this);
			this.collection.unbind('purchase:end', this._onPurchaseEnd, this);
			
			this._unbindInvalidDependency(this.model.get('upgrades'));
		},
		
		
		_onDragStart: function _onDragStartPocketsView(model, ui, pocket) {
			if (model) {
				$(pocket).addClass('dragging');
				this.sound('equip');
			}
		},
		
		_onDragStop: function _onDragStopPocketsView(model, ui, pocket) {
			if (model) {
			
				$(pocket).removeClass('dragging');
				
				var $pocket = this.$(pocket),
					pocketOffset = $pocket.offset(),
					offset = ui.helper.offset(),
					top = offset.top + (ui.helper.height() / 2),
					left = offset.left + (ui.helper.width() / 2),
					droppedOutside = top < pocketOffset.top ||
						top > (pocketOffset.top + $pocket.height()) ||
						left < pocketOffset.left ||
						left > (pocketOffset.left + $pocket.width()),
					upgrades;
				
				if (droppedOutside) {
					upgrades = _.clone(this.model.get('upgrades'));
					_.forEach(upgrades, function (upgrade, i) {
						if (model.id === upgrade) {
							upgrades[i] = null;
						}
					});
					this.model.set('upgrades', upgrades);
				}
				
				this.sound('unequip');
			}
		},
		
		_onDrop: function _onDropPocketsView(model, ui, pocket) {
			
			var pocketIndex = this.$('li').index(pocket),
				upgrades = _.clone(this.model.get('upgrades')),
				prev;
			
			if (_.has(upgrades, pocketIndex)) {
				
				prev = _.indexOf(_.values(upgrades), model.id);
				
				if (prev !== -1) {
					upgrades[prev] = upgrades[pocketIndex] || null;
				}
				
				upgrades[pocketIndex] = model.id;
				
				_.defer(function (view) {
					view.model.set('upgrades', upgrades);
					view.trigger('pocket:enter', view, model, {
						currentTarget: view.$('li').get(pocketIndex)
					}, pocketIndex);
				}, this);
				
				this.sound('unequip');
			}
		},
		
		_onChange: function _onChangeUpgradesPocketsView() {
			this.render();
		},
		
		_unbindInvalidDependency: function _unbindInvalidDependencyPocketsView(upgrades) {
			_.forEach(upgrades || {}, function (upgrade) {
				upgrade = this.collection.get(upgrade);
				if (upgrade) {
					upgrade.unbind('change:invalidDependency', this.render, this);
				}
			}, this);
		},
		_bindInvalidDependency: function _bindInvalidDependencyPocketsView(upgrades) {
			_.forEach(upgrades || {}, function (upgrade) {
				upgrade = this.collection.get(upgrade);
				if (upgrade) {
					upgrade.bind('change:invalidDependency', this.render, this);
				}
			}, this);
		},
		_onChangeUpgrades: function () {
			// Unbind all old just good measure
			this._unbindInvalidDependency(this.model.previous('upgrades'));
			// Bind all old just good measure
			this._bindInvalidDependency(this.model.get('upgrades'));
		},
		
		_onAttachStart: function _onAttachStartPocketsView() {
			this.$el.addClass('loading');
		},
		_onAttachEnd: function _onAttachEndPocketsView() {
			this.$el.removeClass('loading');
		},
		
		_onPurchaseStart: function _onPurchaseStartPocketsView(model) {
			model = this.collection.get(model);
			if (model && (model.id === this.model.id || _.indexOf(_.values(this.model.get('upgrades') || []), model.id) !== -1)) {
				this.$el.addClass('loading');
			}
		},
		_onPurchaseEnd: function _onPurchaseEndPocketsView(model) {
			model = this.collection.get(model);
			if (model && (model.id === this.model.id || _.indexOf(_.values(this.model.get('upgrades') || []), model.id) !== -1)) {
				this.render();
			}
		},
		
		/**
		 * Render Pockets
		 */
		_renderPockets: function renderPocketsPocketsView() {
			
			var ul = this.make('ul', {
					'class': 'pockets'
				}),
				numberOfPockets = this.model.get('numberOfPockets'),
				maxNumPockets = this.model.get('maxNumPockets'),
				upgrades = this.model.getCustomizations(),
				unlockLevels = (this.pocketModel && this.pocketModel.get('unlockLevels')) || {},
				pocketOffers = (this.pocketModel && this.pocketModel.get('pocketOffers')) || 0,
				personaLevel = (this.pocketModel && this.pocketModel.get('personaLevel')) || {},
				usecount = (this.pocketModel && this.pocketModel.get('usecount')) || 0;
			
			// Loop over upgrades
			_.forEach(upgrades, function (upgrade, i) {
				i = parseInt(i, 10);
				
				var li = this.make('li'),
					className,
					isOwned = numberOfPockets > i,
					isLocked = personaLevel < unlockLevels[i],
					offers = pocketOffers[i],
					item;
				
				// Owned
				if (isOwned) {
					// Has upgrade
					if (upgrade) {
						li.appendChild(this.make('span', {
							'class': 'item-upgrade-min item-upgrade-min-' + upgrade.id,
							'item-id': upgrade.id
						}));
						
						if (!upgrade.isAllowedInGame()) {
							className = 'invalid';
						} else {
							className = 'full';
						}
					// Empty
					} else {
						className = 'empty';
					}
					
				// Redeemable
				} else if (usecount > 0 && i === numberOfPockets) {
					className = 'redeemable';
					
					// Redeem icon/button
					li.appendChild(this.make('a', {
						'class': 'icon redeem'
					}));
					
				// Locked
				} else if (isLocked) {
					if (offers && offers.hasUnlockOffers()) {
						className = 'unlockable';
						
						// Unlock icon/button
						li.appendChild(this.make('a', {
							'class': 'icon unlock'
						}));
						
					} else {
						className = 'locked';
					}
					
				// Buyable
				} else if (offers && offers.length !== 0) {
					className = 'buyable';
					
					// Buy icon/button
					li.appendChild(this.make('a', {
						'class': 'icon buy'
					}));
				}
				
				li.appendChild(this.make('span', {
					'class': 'inner'
				}));
				
				if (className) {
					li.className = className;
				}
				
				ul.appendChild(li);
			}, this);
			
			this.el.appendChild(ul);
		},
		
		
		
		/**
		 * Drag Helper
		 */
		dragHelper: function dragHelperPocketsView(e) {
			var $upgrade = this.$(e.currentTarget).find('span.item-upgrade-min'),
				$el;
			
			if ($upgrade.size() === 0) {
				return this.make('span');
			}
			
			$el = $upgrade.clone();
			
			$el.addClass('item-drag');
			
			$el.data('id', $upgrade.attr('item-id'));
			
			// TODO: Re-think this
			$el.appendTo(APP.doc.body);
			
			return $el;
		},
		
		
		/**
		 * Accept
		 */
		accept: function acceptPocketsView($draggable, li) {
			
			if (!this.model.isOwnedPermanent()) {
				return false;
			}
			
			var id = $draggable.attr('item-id') || $draggable.find('span.item-upgrade-min').attr('item-id') || $draggable.data('id'),
				pockedIndex = this.$('li').index(li),
				pockedOwned = this.model.get('numberOfPockets') > pockedIndex,
				upgrade = this.collection.get(id);
			
			return pockedOwned && upgrade && upgrade.isItemType('upgrade') && upgrade.get('category') === this.model.get('category');
		},
		
		
		/**
		 * Render
		 */
        render: function renderPocketsView() {
            
			var maxNumPockets = this.model.get('maxNumPockets'),
				i;
			
			this.$el.attr('item-id', this.model.id);
			
			if (this.model.isOwnedPermanent()) {
				this.$el.addClass('permanent');
				
			} else if (!this.model.isOwned()) {
				this.$el.addClass('invalid');
				
			} else if (this.model.isRented()) {
				this.$el.addClass('rented');
			}
			
			
			// Title
			this.el.appendChild(this.make('h3', null, this.model.get('categoryname') + '<br />' + this.trans('WEB_GAME_HEADING_POCKETS')));
			
			// Pockets
			this._renderPockets();
			this.$pockets = this.$('li');
			
			// Lines
			this.el.appendChild(this.make('span', {
				className: 'line line-connect'
			}));
			for (i = 0; i < maxNumPockets; i += 1) {
				this.el.appendChild(this.make('span', {
					className: 'line line-' + i
				}));
			}
        }
    });    
}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule appearance
 */
(function (win) {
	"use strict";
	
	
	var APP = win.APP,
		$ = APP.$,
		_ = APP._,
		nsConfig = APP.namespace('config'),
		parent = APP.View.Tooltip.prototype;
	
	
	/**
	 * Item tooltip view
	 */
	APP.View.PocketTooltip = APP.View.Tooltip.extend({
		className: 'pocket-tooltip',
		renderModelAndShow: function renderModelAndShowPocketTooltipView(model, el, options) {
			return this.renderModel(model, options).show(el);
		},
		renderModel: function renderModelStatsPocketTooltipView(model, options) {
			this.model = model;
			return this.render(options);
		},
		render: function renderStatsPocketTooltipView(options) {
			
			var category = this.model.get('category'),
				pocketModel = this.model.collection.get(function (model) {
					return (model.isItemType('pocket') && model.get('category') === category);
				}),
				numberOfPockets = this.model.get('numberOfPockets'),
				maxNumPockets = this.model.get('maxNumPockets'),
				
				pocket = options.pocket,
				
				unlockLevel = ((pocketModel && pocketModel.get('unlockLevels')) || {})[pocket],
				personaLevel = (pocketModel && pocketModel.get('personaLevel')) || 0,
				pocketOffers = (pocketModel && pocketModel.get('pocketOffers')) || {},
				usecount = (pocketModel && pocketModel.get('usecount')) || 0,
				
				isOwned = numberOfPockets > pocket,
				isLocked = personaLevel < unlockLevel,
				offers = pocketOffers[pocket],
				redeemable = usecount > 0 && pocket === numberOfPockets,
				
				lockProgress,
				html = [];
			
			// Appearance owned permananet
			if (!this.model.isOwnedPermanent()) {
				html.push('<p>' + this.trans('WEB_GAME_TOOLTIPS_POCKET_NOT_PERMANENT') + '</p>');
			
			// Pocket Owned
			} else if (isOwned) {
				html.push('<p>' + this.trans('WEB_GAME_TOOLTIPS_DROP_UPGRADE') + '</p>');
				
			// Pocked Redeemable
			} else if (redeemable) {
				html.push('<p>' + this.trans('WEB_GAME_TOOLTIPS_ATTACH_POCKET') + '</p>');
			
			// No pocket model
			} else if (!pocketModel) {
				html.push('<p>' + this.trans('WEB_GAME_POCKET_LOCKED') + '</p>');
			
			// Pocket Locked
			} else if (isLocked) {
				lockProgress = personaLevel / unlockLevel;
				
				html.push('<h3>' + this.trans('WEB_GAME_POCKET_LOCKED') + '</h3>');
				
				html.push('<div class="lock-progress">');
				html.push('<span class="bar" style="width: ' + Math.round(100 - (100 * lockProgress)) + '%;"></span>');
				html.push('<span class="text">Level ' + unlockLevel + '</span>');
				html.push('</div>');
				
				if (offers && offers.hasUnlockOffers()) {
					if (this.model.isOwnedPermanent()) {
						html.push('<h3>' + this.trans('WEB_GAME_PURCHASE_UNLOCK_OPTIONS') + '</h3>');
					}
					html.push('<dl class="prices">');
					offers.filterBy({
						'isUnlockOffer': true
					}).forEach(function (model) {
						html.push('<dt>' + model.get('limit') + '</dt>');
						html.push('<dd class="' + model.get('currency') + '">' + model.get('price') + '</dd>');
					});
					html.push('</dl>');
				}
			
			// Buyable
			} else if (offers && offers.length !== 0) {
				html.push('<h3>' + this.trans('WEB_GAME_PURCHASE_OPTIONS') + '</h3>');
				html.push('<dl class="prices">');
				offers.filterBy({
					'isUnlockOffer': false
				}).forEach(function (model) {
					html.push('<dt>' + model.get('limit') + '</dt>');
					html.push('<dd class="' + model.get('currency') + '">' + model.get('price') + '</dd>');
				});
				html.push('</dl>');
			}
			
			this.el.innerHTML = html.join('');
		}
	});
}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule appearance
 */
/**
 * 
 * 
 * @class GAME.Task.appearance
 * @uses GAME.Task.items
 * @uses GAME.Task.store
 */
APP.task('appearance', [ 'items', 'store' ], function taskAppearance(done) {
	"use strict";
	
	
	/**
	 * Store and Inventory List
	 */
	var _ = APP._,
		$ = APP.$,
		win = APP.win,
		nsAppearance = APP.namespace('appearance'),
		nsItems = APP.namespace('items'),
		nsStore = APP.namespace('store'),
		nsGame = APP.namespace('game'),
		
		// Main page element
		$main = nsAppearance.$el = $('<div>').addClass('main main_appearance page hidden loading').appendTo('#frontend'),
		$panelLeft = nsAppearance.$panelLeft = $('<div>').addClass('page-panel left').appendTo($main),
		$panelRight = nsAppearance.$panelRight = $('<div>').addClass('page-panel right').appendTo($main),
		categoryTabState = {},
		gridState = {},
		currentTabIndex,
		
		hasUpgradeItems = nsItems.collection.hasItemType('upgrade'),
		
		/**
		 * Main tabs
		 */
		mainTabs = nsAppearance.mainTabs =  [
			{
				name: 'appearance',
				text: APP.sidis.trans('WEB_GAME_APPEARANCE_TAB'),
				filter: 'appearance'
			}
		],
		
		
		$menuBar = nsAppearance.$menuBar = $('<div>').addClass('menu-bar'),
		
		categoriesSortOrder = nsAppearance.categoriesSortOrder = [
			'all',
			'head',
			'face',
			'uniform',
			'accessory1',
			'accessory2'
		],

		/**
		 * Category tabs
		 */
		appearanceCategories = _.sortBy(_.compact(_.unique(['all'].concat(nsItems.collection.byType('appearance').pluck('category')))), function (category) {
			return _.indexOf(categoriesSortOrder, category);
		}),
		appearanceTabs = nsAppearance.appearanceTabs = new APP.View.Tabs({
			container	: $menuBar,
			className	: 'category-tabs',
			tabs		: _.map(appearanceCategories, function (category) {
				return {
					name: category,
					text: APP.sidis.trans('WEB_GAME_APPEARANCE_MENU_' + category.toUpperCase()),
					filter: category
				};
			})
		}).render().select(0).attach(),

		
		/**
		 * Upgrade tabs
		 */
		upgradeCategories = _.sortBy(_.compact(_.unique(['all'].concat(nsItems.collection.byType('upgrade').pluck('category')))), function (category) {
			return _.indexOf(categoriesSortOrder, category);
		}),
		upgradeTabs = nsAppearance.upgradeTabs = new APP.View.Tabs({
			container	: $menuBar,
			className	: 'category-tabs',
			tabs		: _.map(upgradeCategories, function (category) {
				return {
					name: category,
					text: APP.sidis.trans('WEB_GAME_APPEARANCE_MENU_' + category.toUpperCase()),
					filter: category
				};
			})
		}).render().select(0),
		
		
		/**
		 *	Grid tabs
		 */
		gridTabs = nsAppearance.gridTabs = new APP.View.Tabs({
			container	: $menuBar,
			className	: 'grid-toggle',
			tabs		: [
				{ name: 'min', text: 'Min', size: 'min' },
				{ name: 'med', text: 'Med', size: 'med' }
			]
		}).attach().render(),
		
		
		/**
		 * Equip model
		 */
		equipModel = nsAppearance.equipModel = function equipModel(model) {
			if (!model || model.get('itemType') !== 'appearance') {
				return;
			}
			
			// Get category
			var category = model.get('category'),
				slot = _.indexOf([ 'head', 'face', 'uniform', 'accessory1', 'accessory2' ], category);
			
			// Equip item
			model.set({
				equippedSlot: slot
			});
		},
		categories = [ 'head', 'face', 'uniform', 'accessory1', 'accessory1' ],
		defaultsAppearance = nsItems.collection.getDefaults('appearance');

			
	/**
	 *  Create main tabs
	 */
	if (hasUpgradeItems) {
		mainTabs.push({
			name: 'upgrades',
			text: APP.sidis.trans('WEB_GAME_UPGRADES_TAB'),
			filter: 'upgrades'
		});
	}
	mainTabs = nsAppearance.mainTabs = new APP.View.Tabs({
		container	: $panelRight,
		className	: 'main-tabs',
		tabs		: mainTabs
	}).attach().render();

	$menuBar.appendTo($panelRight);
	
	
	
	/**
	 * When ching upgrades save them to blaze
	 */
	nsItems.collection.bind('change:upgrades', function onChangeUpgrades(model) {
		// Give items
		nsGame.giveItems();
		
		// Save Customizations Config
		nsGame.saveCustomizations(model);
	});
	
	
	
	/**
	 * Drop on Doll
	 */
	nsAppearance.doll = $('#soldierModel').droppable({
		accept: function ($draggable) {
			var itemId = $draggable.attr('item-id') || $draggable.data('id') || $draggable.find('div.icon').data('id'),
				model = nsItems.collection.get(itemId);
			
			return model && model.isItemType('appearance');
		},
		drop: function onDropOnDoll(e, ui) {
			var model = nsItems.collection.get(ui.helper.data('id'));
			if (model && model.isItemType('appearance')) {
				equipModel(model);
			}
		}
	});
	
	
	/**
	 *
	 */
	/*$(win).cheat('konami', function onKonami() {
		var getRandomItem = function getRandomItem(items) {
				var i = Math.floor(Math.random() * (items.length - 1));
				return items.at(i);
			},
			collection = nsItems.collection.filterBy({
				itemType: 'appearance'
			}),
			categories = [ 'head', 'face', 'uniform', 'accessory1', 'accessory2' ];
		
		_.forEach(categories, function (category, slot) {
			var items = collection.filterBy({
					'category': category
				}),
				model = getRandomItem(items);
			
			// Equip item
			model.set({
				equippedSlot: slot
			});
		});
		
		APP.navigate('/appearance', true);
	});*/
	
	
	mainTabs.bind('select', function (i) {
		APP.navigate('appearance/' + ((i === 0) ? 'apparel' :  'upgrades'));
		currentTabIndex = i;
		
		var gridIndex = gridState.hasOwnProperty(currentTabIndex) ? gridState[currentTabIndex] : 1;
		
		if (currentTabIndex === 0) {
			upgradeTabs.detach();
			appearanceTabs.attach();
		} else if (currentTabIndex === 1) {
			appearanceTabs.detach();
			upgradeTabs.attach();
		}
		
		_.defer(function () {
			gridTabs.select(gridIndex);
		});
    });
	
	appearanceTabs.bind('select', function (i) {
		APP.navigate('appearance/apparel/' + categoriesSortOrder[i]);
    });
	upgradeTabs.bind('select', function (i) {
		APP.navigate('appearance/upgrades/' + categoriesSortOrder[i]);
	});
	
	gridTabs.bind('select', function (i) {
		gridState[currentTabIndex] = i;
	});
	
	
	
	/**
	 * Default Appearnace
	 */
	nsItems.bind('unequip:appearance', function onUnequipAppearance(model, equippedSlot) {
		var category = model.get('category');
		if (_.has(defaultsAppearance, category)) {
			_.defer(function () {
				var model = nsItems.collection.bySlot('appearance', equippedSlot);
				if (!model) {
					equipModel(defaultsAppearance[category]);
				}
			});
		} else {
			_.defer(win.dressDoll);
		}
	});
	
	// Ensure that we have at least the deaults equipped
	_.forEach(defaultsAppearance, function (defaultModel, category) {
		var equippedSlot = _.indexOf(categories, category),
			model;
		
		if (!defaultModel.isEquipped()) {
			model = nsItems.collection.bySlot('appearance', equippedSlot);
			if (!model) {
				equipModel(defaultsAppearance[category]);
			}
		}
	});
	
	nsItems.bind('equip:appearance', function onUnequipAppearance(model, equippedSlot) {
		_.defer(win.dressDoll);
	});
	
	/**
	 * Initialize
	 */
	nsAppearance.setup(function initializeAppearance(ready) {
		ready();
	});
	nsAppearance.ready(function onInitializedAppearance() {
		nsAppearance.$el.removeClass('loading');
	});
	
	
	// Select first tab
	mainTabs.select(0);
	
	
	/**
	 * Task Done!
	 */
	return done();
});

/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule appearance
 */
/**
 * @class GAME.Taskappearance.list
 * @uses GAME.Taskappearance
 * @uses GAME.Taskabilities
 */
APP.task('appearance.list', [ 'appearance', 'abilities' ], function taskAppearanceList(done) {
	"use strict";
	
	
	var $ = APP.$,
		_ = APP._,
		nsAppearance = APP.ns('appearance'),
		nsAbilities = APP.ns('abilities'),
        nsItems = APP.ns('items'),
		nsStore = APP.ns('store'),
		
		cursorAt = {
			appearance: {
				min: { left: 50, top: 40 },
				med: { left: 103, top: 84 }
			},
			upgrade: {
				min: { left: 68, top: 65 },
				med: { left: 70, top: 110 }
			}
		},
		
		containment = {
			appearance: {
				min: [-5, -10, 937, 695],
				med: [-60, -50, 882, 650]
			},
			upgrade: {
				min: [-46, -43, 935, 681],
				med: [-51, -87, 930, 637]
			}
		},


		equipped = nsAppearance.equipped = nsItems.collection.getEquipped('appearance'),
		
		/**
		 * Create view
		 */
		createView = function (itemType, viewClass) {
			var view = new APP.View.Appearance({
					container: nsAppearance.$panelRight,
					collection: nsItems.collection,
					equipped: equipped,
					viewClass: viewClass,
					cursorAt: cursorAt[itemType],
					containment: containment[itemType],
					filter: {
						itemType: itemType
					}
				}),
				onLeaveItem = function () {
					nsItems.tooltip.hide();
				};
			
						
			
			// Handle item click
			if (itemType === 'appearance') {
				view.bind('item:click', function (view, model) {
					if ((model.isOwned() || !model.isLocked())) {
						nsAppearance.equipModel(model);
					}
				});
			} else if (itemType === 'upgrade') {
				view.bind('item:click:req', function onClickReq(view, model) {
					var dependencies = model.getDependencies();
					
					//
					if (dependencies.gear && dependencies.gear.isOwned()) {						
						APP.navigate('boosters/' + dependencies.gear.id, true);
					
					//
					} else if (dependencies.ability  && dependencies.ability.get('level') === 0) {
						APP.navigate('abilities/' + dependencies.ability.id, true);
						
					// 
					} else {
						APP.navigate('appearance/apparel/' + _.indexOf(nsAppearance.categoriesSortOrder, model.get('category')), true);
					}
				});
			}
			
			view.bind('buy', function onItemBuy(view, model) {
				nsStore.trigger('buy', model);
			});
			
			view.bind('list:drag:start', function (view, model) {
				nsItems.tooltip.hide();
				view.unbind('item:leave', onLeaveItem);
			});
			view.bind('list:drag:stop', function () {
				view.bind('item:leave', onLeaveItem);
			});
			
			// Show offers tooltip
			view.bind('item:buy:enter', function (view, model, e) {
				if (model && view.options.viewOptions.size === 'med') {
					/**
						name		: false
						description	: false
						dependencies: false
						stats		: false
						slots		: false
						offers		: false
						uses		: false
						time		: false
						invalid		: false
					**/
					nsItems.tooltip.renderModelAndShow(model, e.currentTarget, {
						offers		: true
					});
				}
			});
			view.bind('item:buy:leave', function (view) {
				if (view.options.viewOptions.size === 'med') {
					nsItems.tooltip.hide();
				}
			});
			
			
			// Show time tooltip
			view.bind('item:exclaim:enter', function (view, model, e) {
				if (model && view.options.viewOptions.size === 'med') {
					/**
						name		: false
						description	: false
						dependencies: false
						stats		: false
						slots		: false
						offers		: false
						uses		: false
						time		: false
						invalid		: false
					**/
					nsItems.tooltip.renderModelAndShow(model, e.currentTarget, {
						time		: true,
						invalid		: true
					});
				}
			});
			view.bind('item:exclaim:leave', function (view) {
				if (view.options.viewOptions.size === 'med') {
					nsItems.tooltip.hide();
				}
			});
			
			
			// Item tooltip
			view.bind('item:enter', function (view, model, e) {
				var options = {
						name		: true,
						stats		: true,
						offers		: true,
						time		: true,
						invalid		: true
					};
				if (model && view.options.viewOptions.size === 'min') {
					if (itemType === 'upgrade') {
						options = {
							name		: true,
							description	: true,
							dependencies: true,
							stats		: true
						};
					}
					nsItems.tooltip.renderModelAndShow(model, e.currentTarget, options);
				}
			});
			view.bind('item:leave', onLeaveItem);
			
			return view;
		},
		
		
        apparelView = nsAppearance.apparelView = createView('appearance', APP.View.AppearanceItem).render(),
        upgradeView = nsAppearance.upgradeView = createView('upgrade', APP.View.UpgradeItem).render(),
		// Default
        currentList = nsAppearance.currentList = apparelView.attach();
	
	/**
	 * Upgrade equipped state hack
	 */
	nsItems.bind('unequip:appearance', function (model) {
		equipped.remove(model);
	});
	nsItems.bind('equip:appearance', function (model) {
		equipped.add(model);
	});
	
	
	/**
	 * Listen to main tab selects
	 */
    nsAppearance.mainTabs.bind('select', function (i) {
        if (i === 1) {
            apparelView.$el.hide();
            currentList = nsAppearance.currentList = upgradeView;
        } else if (i === 0) {
            upgradeView.$el.hide();
            currentList = nsAppearance.currentList = apparelView;
        }
		currentList.attach().$el.show();
    });
    
	
	/**
	 * Listen category tab selects
	 */
    nsAppearance.appearanceTabs.bind('select', function (i, tab) {
        var filter = {};
        if (tab && tab.filter !== 'all') {
			filter.category = tab.filter;
		}
		apparelView.filter(filter);
    });
    nsAppearance.upgradeTabs.bind('select', function (i, tab) {
	    var filter = {};
        if (tab && tab.filter !== 'all') {
			filter.category = tab.filter;
		}
		upgradeView.filter(filter);
    });
	
	
	/**
	 * Listen to grid tab selects
	 */
	nsAppearance.gridTabs.bind('select', function (i, tab) {
		if (currentList.getGridSize() !== tab.size) {
			currentList.setGridSize(tab.size).render();
		}
	});
	
	
	/**
	 * Task done
	 */
    return done(); 
});
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule appearance
 */
/**
 * @class GAME.Taskappearance.pockets
 * @uses GAME.Taskappearance
 * @uses GAME.Taskappearance.list
 */
APP.task('appearance.pockets', [ 'appearance', 'appearance.list' ], function taskAppearancePockets(done) {
	"use strict";
	
	
	var _ = APP._,
		$ = APP.$,
		nsItems = APP.ns('items'),
		nsAppearance = APP.ns('appearance'),
		nsStore = APP.ns('store'),
		nsConfig = APP.ns('config'),
		
		
		/**
		 * Redeem pocket
		 */
		redeemPocket = function (model, pocketIndex, fn) {
			model.trigger('attach:start');
			
			$.ajax({
				url: nsConfig.pockets.attachUrl.replace('ITEM_ID', model.id).replace('POCKET', pocketIndex),
				type: 'post',
				cache: false,
				dataType: 'json',
				success: function (res) {
					if (res && res.status === 'success') {
						
						model.trigger('attach:success');
						
						
					} else {
						model.trigger('attach:error');
					}
				},
				error: function () {
					model.trigger('attach:error');
				},
				complete: function () {
					model.trigger('attach:end');
				}
			});
		},
		
		
		/**
		 * Pocket tooltip
		 */
		pocketTooltip = nsAppearance.pocketTooltip = new APP.View.PocketTooltip().attach(),
		
		
		/**
		 * Pockets
		 */
		pocketViews = nsAppearance.pocketViews = {},
		$container = $('#soldierModel'),
		availableUpgradeCategories = _.unique(nsItems.collection.byType('upgrade').pluck('category')),
		onEquipAppearance = function onEquipAppearance(model) {
			
            
            // Don't display pockets
            return;
            
            /*
            if (!model || !model.isItemType('appearance') || !model.isCustomizable()) {
				return;
			}
			
			var category = model.get('category'),
				pocketModel = nsItems.collection.get(function (model) {
					return (model.isItemType('pocket') && model.get('category') === category);
				}),
				pocketView = pocketViews[category],
				clearHighlight = function () {
					nsAppearance.trigger('highlight', null, 'pockets');
				};
			
			if (pocketView) {
				pocketView.destroy();
				pocketView = pocketViews[category] = null;
			}
			
			if (_.isNumber(model.get('equippedSlot'))) {
				
				
				// Create view
				pocketView = pocketViews[category] = new APP.View.Pockets({
					container	: $container,
					className	: category,
					model		: model,
					pocketModel	: pocketModel
				}).render();
				
				// Attach if we on the correct page
				if (APP.currentPage() === 'appearance') {
					pocketView.attach();
				}				
				
				// Pocket - Buy
				pocketView.bind('pocket:buy', function onPocketBuy(view, pocket, offers) {
					nsStore.trigger('buy', pocketModel, {
						offers: offers,
						pocket: pocket,
						purchaseOptions: {
							model: model
						}
					});
				});
				
				
				// Pocket - Unlock
				pocketView.bind('pocket:unlock', function onPocketUnlock(view, pocket, offers) {
					nsStore.trigger('buy', pocketModel, {
						offers: offers,
						pocket: pocket,
						purchaseOptions: {
							model: model
						}
					});
				});
				
				
				// Pocket - Redeem
				pocketView.bind('pocket:redeem', function onPocketRedeem(view, i) {
					redeemPocket(model, i);
				});
				
				// Click on empty
				pocketView.bind('pocket:click', function onClickEmpty(view, i) {
					var category = model.get('category') || 'all';
					
					APP.page('appearance', {
						tab		: 'inserts',
						state	: function (tab) {
							return tab.filter === category;
						}
					});
				});
				
				
				// Highlight logic
				pocketView.bind('drag:start', function onDradStart() {
					nsAppearance.trigger('highlight', model ? model.get('category') : null);
					pocketView.unbind('leave', clearHighlight);
				});
				pocketView.bind('drag:stop', function onDragStop() {
					clearHighlight();
					pocketView.bind('leave', clearHighlight);
				});
				pocketView.bind('enter', function onEnter(view, model) {
					nsAppearance.trigger('highlight', model ? model.get('category') : null);
				});
				pocketView.bind('leave', clearHighlight);
				
				
				// Tooltip
				pocketView.bind('pocket:enter', function onPocketEnter(view, upgradeModel, e, i) {
					if (upgradeModel) {
						pocketTooltip.hide();
						/ **
							name		: false
							description	: false
							dependencies: false
							stats		: false
							slots		: false
							offers		: false
							uses		: false
							time		: false
							invalid		: false
						** /
						nsItems.tooltip.renderModelAndShow(upgradeModel, e.currentTarget, {
							name		: true,
							description	: true,
							dependencies: true,
							stats		: true,
							offers		: true,
							time		: true,
							invalid		: true
						});
					
					} else {
						nsItems.tooltip.hide();
						pocketTooltip.renderModelAndShow(view.model, e.currentTarget, {
							pocket: i
						});
					}
				});
				pocketView.bind('pocket:leave', function onPocketLeave() {
					nsItems.tooltip.hide();
					pocketTooltip.hide();
				});
			}
			*/
            
		},
		tabFilter = 'all',
		setHighlight = function (category) {
			var el = $container.get(0);
			el.className = el.className.replace(/(highlight-[a-z0-9]+)/, 'highlight-' + category);
		};
		
	
	
	/**
	 * list to items change equippedSlot events
	 */
	nsItems.collection.bind('change:equippedSlot', onEquipAppearance);


	/**
	 * Highlighing
	 */
	nsAppearance.upgradeView.bind('list:drag:start', function (view, model) {
		if (tabFilter === 'all') {
			setHighlight(model.get('category'));
		}
	});
	nsAppearance.upgradeView.bind('list:drag:stop', function (view, model) {
		if (tabFilter === 'all') {
			setHighlight(tabFilter);
		}
	});
	nsAppearance.upgradeTabs.bind('select', function (i, tab) {
		tabFilter = tab && tab.filter;
		setHighlight(tabFilter);
	});
	$container.addClass('highlight-' + tabFilter);
	
	/**
	 * Check euipped appearance the first time go to this page
	 */
	APP.once('page:appearance', function oncePageAppearance(to, from) {
		nsItems.collection.getEquipped('appearance').forEach(onEquipAppearance);
	});
	
	
	
	/**
	 * Since we are putting the pocket views in to same container as the doll
	 * we need to detach them when leaving the appearance page
	 */
	APP.bind('page', function onPage(to, from) {
		if (to === 'appearance') {			
			if (to !== from) {
				_.forEach(pocketViews, function (pocketView) {
					if (pocketView) {
						pocketView.attach();
					}
				});
			}
		} else {
			_.forEach(pocketViews, function (pocketView) {
				if (pocketView) {
					pocketView.detach();
				}
			});
		}
	});
	
	
	
	/**
	 * Task done
	 */
	done();
});



/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule appearance
 */
/**
 * @class GAME.Task.appearance.routes
 * @uses GAME.Task.appearance
 */
APP.task('appearance.routes', [ 'appearance' ], function taskAppearanceRoutes(done) {
	"use strict";
	
	
	var win = APP.win,
		$ = APP.$,
		_ = APP._,
		nsItems = APP.namespace('items'),
		nsAppearance = APP.ns('appearance');
	
	
	/**
	 * Appearance page
	 */
	APP.bind('page:appearance', function onPageAppearance(from, data) {
		if (from !== 'appearance') {
			APP.ns('dock').change('appearance');
			win.dontUpdateDoll = false;
			win.showDoll();
			if (win.bundleOnDoll) {
				win.dressDoll();
			}
		}
		
		// Start
		nsAppearance.start(function () {
			var model;
			
			if (data.id) {
				model = nsItems.collection.get(data.id);
				
				// Choose correct section and All category
				if (model.isItemType('appearance')) {
					nsAppearance.mainTabs.select(0);
					nsAppearance.appearanceTabs.select(0);
					
				} else {
					nsAppearance.mainTabs.select(1);
					nsAppearance.upgradeTabs.select(0);
				}
				
				// Open store/inventory
				_.defer(function () {
					if (model.isOwned()) {					
						nsAppearance.currentList.openInventory();	
					} else {
						nsAppearance.currentList.openStore();
					}
					
					nsAppearance.currentList.scrollTo(model);
				});
				
			} else if (data.tab) {
				
				nsAppearance.mainTabs.select(data.tab);
				
				if (data.state) {
					// Open store/inventory
					_.defer(function () {
						
						// Open Inventory
						if (data.state === 'inventory') {
							nsAppearance.currentList.openInventory();
						
						// Open store
						} else if (data.state === 'store') {
							nsAppearance.currentList.openStore();
						
						// Select appearance tab
						} else if (nsAppearance.currentList === nsAppearance.apparelView) {
							nsAppearance.appearanceTabs.select(data.state);
						
						// Select upgrade tab
						} else if (nsAppearance.currentList === nsAppearance.upgradeView) {
							nsAppearance.upgradeTabs.select(data.state);					
						}						
					});
				}
			}
		});
	});
	
	
	/**
	 * Appearance page
	 */
	APP.route('appearance', 'appearance', function onRotueAppearance() {
		APP.page('appearance');
	});
	
	
	/**
	 * Appearance filter tab
	 */
	APP.route('appearance/:tab', 'appearance-tab', function onRotueAppearanceTab(tab) {
		APP.page('appearance', {
			tab: tab
		});
	});
	
	/**
	 * Appearance filter tab & state
	 */
	APP.route('appearance/:tab/:state', 'appearance-tab', function onRouteAppearanceTabAndState(tab, state) {
		APP.page('appearance', {
			tab: tab,
			state: state
		});
	});
	
	/**
	 * Appearance item
	 */
	APP.route(/^appearance\/([\d]+)$/, 'appearance-item', function onAppearanceItemRoute(id) {
		var model = nsItems.collection.get(id),
			url;
		
		if (model) {
			url = '/appearance/' + model.id  + '/' + model.get('name').toLowerCase().replace(/([\s])+/g, '-');
			
			APP.navigate(url);
			
			if (model.isType('appearance') || model.isType('upgrade')) {				
				APP.page('appearance', {
					id: id
				});
			}
		}
	});
	
	
	/**
	 * Task done!
	 */
	done();
});
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule boosters
 */
(function (global) {
	
	var APP = global.APP,
		$ = APP.$,
		_ = APP._,
		doc = APP.doc,
		parent = APP.View.prototype;
	
	APP.View.Booster = APP.View.extend({
		name: 'booster-view booster item',
		initialize: function initializeBoosterView() {
			this.model.bind('change', this.render, this);
			this.model.bind('purchase:start', this._onPurchaseStart, this);
			this.model.bind('purchase:end', this._onPurchaseEnd, this);
			
			this.abilityModel = this.options.abilities.get(this.model.get('dependency'));
			if (this.abilityModel) {
				this.abilityModel.bind('change', this.render, this);
			}
			
			this.bind('buy:click', this._onBuyClick, this);
		},
		
		destroy: function destroyBoosterView() {
			this.model.unbind('change', this.render, this);
			this.model.unbind('purchase:start', this._onPurchaseStart, this);
			this.model.unbind('purchase:end', this._onPurchaseEnd, this);
			if (this.abilityModel) {
				this.abilityModel.unbind('change', this.render, this);
			}
		},
		
		_onPurchaseStart: function _onPurchaseStartBoosterView() {
			this.$el.addClass('loading');
		},
		
		_onPurchaseEnd: function _onPurchaseEndBoosterView() {
			this.$el.removeClass('loading');
		},
		
        _onBuyClick: function _onBuyClickBoosterView(view, e) {
			var ability = this.model.get('dependency');
			
			if (!ability || this.hasTrainedAbility(ability)) {				
				// Trigger event
				this.trigger('click:buy', this, this.model, e);
			}
		},
		
		
		hasTrainedAbility: function hasTrainedAbilityBoosterView() {			
			var level = this.abilityModel && this.abilityModel.get('level');
			return level > 0;
		},
		
		render: function renderBoosterView() {
			
			this.$el.addClass(this.name + ' ' + this.className);
			this.$el.attr({'item-id': this.model.id});
			
			
			var abilityWrapper = this.make('a', {'class': 'ability'}),
				allowed = true,
				active = this.model.isAllowedInGame(),
				icon = this.make('div', {'class': 'icon'}),
				info = this.make('div', {'class': 'item-info'}),
				pre = this.make('div', {'class': 'prereq-info'}),
				preText = this.make('div'),
				status = this.make('p', {'class': 'status'}),
				statusText,
				purchaseOptions,
				offers = this.model.get('offers'),
				lowestOffers,
				prices = this.make('div', {
					'class': 'prices'
				}),
				hasTrainedAbility = this.hasTrainedAbility(),
				button;
			
			// Check dependencies
			if (this.abilityModel && !hasTrainedAbility) {
				allowed = false;
				abilityWrapper.appendChild(this.make('span', {
					'class': 'item-ability item-ability-' + this.abilityModel.id
				}));
				
				pre.appendChild(abilityWrapper);
				preText.appendChild(this.make('p', {'class': 'prereq'}, this.trans('WEB_GAME_BOOSTERS_REQUIREMENT')));
				preText.appendChild(this.make('h4', null, this.abilityModel.get('name')));
				pre.appendChild(preText);
				pre.appendChild(this.make('span', {
					'class': 'mini-link'
				}, this.trans('WEB_GAME_BOOSTERS_GO_TO_TRAINING')));
				this.el.appendChild(pre);
				
				this.$el.addClass('border-box-dark');
			} else {
				this.$el.addClass('border-box');
			}
			
			// Set active state if owned not expired
			if (active) {
				this.$el.addClass('active');
			}
			statusText = active ? this.trans('WEB_GAME_BOOSTERS_ACTIVE') : this.trans('WEB_GAME_BOOSTERS_INACTIVE');
			
			icon.appendChild(this.make('img', {
				'class': 'game-item',
				'src': this.model.getImage('med'),
				'item-id': this.model.id
			}));
			this.el.appendChild(icon);
			
			status.appendChild(this.make('span', {
				'class': 'booster_status'
			}, statusText));
			
			// Add expire text
			if (this.model.get('expireTS')) {
				status.appendChild(this.make('span', {
					'class': 'expires'
				}, this.model.getExpireText()));
			}
			info.appendChild(this.make('h2', null, this.model.get('name')));
			info.appendChild(status);
			info.appendChild(this.make('p', {
				'class': 'booster_description'
			}, this.model.get('description')));
			
			if (offers && offers.length !== 0) {
				lowestOffers = offers.getLowestOffers();
				purchaseOptions = doc.createDocumentFragment();
			
				if (lowestOffers.credits) {
					prices.appendChild(this.make('span', {
						'class': 'currency credits'
					}, lowestOffers.credits.get('price') + '<i class="glyphs glyphs-credits20"></i>'));
				}
				if (lowestOffers.funds) {
					prices.appendChild(this.make('span', {
						'class': 'currency funds'
					}, lowestOffers.funds.get('price') + '<i class="glyphs glyphs-funds20"></i>'));
				}
				purchaseOptions.appendChild(prices);
				
				button = this.createView(APP.View.Button, {
					container: purchaseOptions,
					primary: true,
					glyph: 'buy',
					className: 'buy' + (allowed ? '' : ' disabled'),
					text: this.trans('WEB_STORE_COMMON_BUY_BTN'),
					sound: true
				}, 'buy').render().attach();

				if (this.abilityModel && !hasTrainedAbility) {
					button.disable();
				}
				
				this.createView(APP.View.LabelBox, {
					'label': this.trans('WEB_GAME_WEAPONS_INFO_PRICE_FROM'),
					'content': purchaseOptions,
					'className': 'purchase',
					'container': info
				}).render().attach();
			
			}
			
			
			this.$('img').disableTextSelect();
			this.$el.disableTextSelect();
			
			this.el.appendChild(info);
		}
	});
}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule boosters
 */
/**
 * @class GAME.Task.boosters
 * @uses GAME.Task.items
 * @uses GAME.Task.abilities
 * @uses GAME.Task.store
 */
APP.task('boosters', ['items', 'abilities', 'store'], function initBoosters(done) {
	"use strict";
	
	
	/**
	 * Store and Inventory List
	 */
	var $ = APP.$,
		_ = APP._,
		nsBoosters = APP.namespace('boosters'),
		nsAbilities = APP.namespace('abilities'),
		nsItems = APP.namespace('items'),
		nsStore = APP.namespace('store'),
		
		// Main page element
		$main = nsBoosters.$el = $('<div>').addClass('main main_boosters page hidden loading'),
		
		/**
		 * Store
		 */
		boosterListView = nsBoosters.store = nsBoosters.list = new APP.View.ItemList({
			container: $main,
			className: 'buy_list items boosters',
			collection: nsItems.collection,
			filter: {
				'itemType': 'booster'
			},
			viewClass: 'Booster',
			viewOptions: {
				'abilities': nsAbilities.collection
			},
			drag: null
		}).attach(),
		
		
		/**
		 * Get images
		 */
		images = nsItems.collection.filterBy({
			'itemType': 'booster'
		}).invoke('getImage', 'max');
	
	
	// Handle item click
	boosterListView.bind('item:click:buy', function onClickBuy(view, model) {
		nsStore.trigger('buy', model);
	});
	
	
	/**
	 * We need to re-render the booster list after every ability reset
	 */
	nsAbilities.collection.bind('reset', function onAbilitiesReset() {
		boosterListView.render();
	});
	
	
	/**
	 *	Add boosters view to frontend
	 */
	$main.appendTo('#frontend');
	
	
	// Go to training
    $main.delegate('div.prereq-info', 'click', function (e) {
		e.preventDefault();
		APP.navigate('/abilities', true);
    });
	
	
	/**
	 * Preload each image
	 */
	APP.preload.image(images, function () { });
	
	
	/**
	 * Initialize
	 */
	nsBoosters.setup(function initializeBoosters(ready) {
		// Ready once the booster list has been rendered
		boosterListView.once('render', ready);
		
		// Render view
		boosterListView.render();
	});
	nsBoosters.ready(function onreadyBoosters() {
		nsBoosters.$el.removeClass('loading');
	});
	
	
	/**
	 * Task done
	 */
	done();
});
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule boosters
 */
/**
 * @class GAME.Task.boosters.routes
 * @uses GAME.Task.boosters
 */
APP.task('boosters.routes', [ 'boosters' ], function taskBoostersRoutes(done) {
	"use strict";
	
	
	var win = APP.win,
		$ = APP.$,
		_ = APP._,
		nsBoosters = APP.namespace('boosters'),
		boosterId;
	
	/**
	 * Boosters Page
	 */
	APP.bind('page:boosters', function onPageBoosters(from, data) {
		if (from !== 'boosters') {
			win.dontUpdateDoll = true;
			win.hideDoll();
		}
		
		// Start
		nsBoosters.start(function () {
			if (data.id) {
				nsBoosters.list.scrollTo(nsBoosters.list.getElementByModel(data.id));
			}
		});
	});
	
	
	/**
	 * Boosters page
	 */
	APP.route('boosters', 'boosters', function onBoostersRoute() {
		APP.page('boosters');
	});
	
	/**
	 * Booster item
	 */
	APP.route(/^boosters\/([\d]+)$/, 'boosters-id', function onBoostersItemRoute(id) {
		// Go to page
		APP.page('boosters', {
			id: id
		});
	});
	
	
	/**
	 * Task done!
	 */
	done();
});
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule bundles
 */
(function (root) {
	"use strict";
	
	
	var APP = root.APP,
		win = APP.win,
		$ = APP.$,
		_ = APP._,
		parent = APP.View.prototype,
		nsConfig = APP.namespace('config');
	
	APP.View.BundleItem = APP.View.extend({
		name: 'bundle-item-view',
		events: {
			'click a.buy'			: '_onClickBuy',
			'click a.tryon'			: '_onClickTryOn',
			'click'					: '_onClick',
			'mouseenter': function () {
				this.sound('hover');
				this.trigger('enter', this, this.model);
			},
			'mouseleave': function () {
				this.trigger('leave', this, this.model);
			},
			
			'mouseenter a.tryon': function (e) {
				this.sound('hover');
				this.trigger('tryon:enter', this, this.model, e);
			},
			'mouseleave a.tryon': function (e) {
				this.trigger('tryon:leave', this, this.model, e);
			},
			
			'mouseenter a.icon.buy, a.icon.lock, a.icon.unlock': function (e) {
				this.sound('hover');
				this.trigger('buy:enter', this, this.model, e);
			},
			'mouseleave a.icon.buy, a.icon.lock, a.icon.unlock': function (e) {
				this.trigger('buy:leave', this, this.model, e);
			}
		},
		initialize: function initializeBundleItemView() {
			// TODO: Make sure we don't rely on this "magic" binding
			_.bindAll(this);
			this.model.bind('change', this.render);
			this.model.bind('purchase:start', this._onPurchaseStart);
			this.model.bind('purchase:end', this._onPurchaseEnd);
		},
		destroy: function destroyBundleItemView() {
			this.model.unbind('purchase:start', this._onPurchaseStart);
			this.model.unbind('purchase:end', this._onPurchaseEnd);
		},
		
		_onPurchaseStart: function _onPurchaseStartBundleItemView() {
			this.$el.addClass('loading');
		},
		_onPurchaseEnd: function _onPurchaseEndBundleItemView() {
			this.$el.removeClass('loading');
		},
		
		_onClickBuy: function _onClickBuyBundleItemView(e) {
			e.preventDefault();
			e.stopImmediatePropagation();
			this.sound('click');
			this.trigger('buy', this.model, e.currentTarget);
		},
		_onClickTryOn: function _onClickTryOnBundleItemView(e) {
			e.preventDefault();
			e.stopImmediatePropagation();
			this.sound('click');
			this.trigger('try', this.model, e.currentTarget);
		},
		_onClick: function _onClickBundleItemView(e) {
			e.preventDefault();
			this.sound('click');
			this.trigger('click', this.model);
		},
		
		/**
		 * Render Lock
		 */
		renderLock: function renderLockWeaponBundleItemView() {
			
			var nsConfig = APP.ns('config'),
				type = this.trans('WEB_GAME_LOCK_TYPE_' + this.model.get('lockType').toUpperCase()),
				criteria = this.model.get('lockCriteria'),
				lock = this.make('div', {
					'class': 'lock ' + type
				}),
				progressImage = nsConfig.imageFolder + 'game/item-lock-progress.png',
				progress = this.model.get('lockProgress'),
				canvas = win.progressCircle(progressImage, progress, {
					width: 56,
					height: 56,
					lineWidth: 8,
					duration: 500
				});
			
			lock.appendChild(this.make('span', {
				'class': 'type'
			}, type));
			
			lock.appendChild(this.make('span', {
				'class': 'key'
			}, criteria));
			
			lock.appendChild(canvas);
			this.el.appendChild(lock);
			
			return this;
		},
		
		/**
		 * Render
		 */
		render: function renderBundleItemView() {
			
			this.$el.addClass('loading');
			
			// Model id
			this.$el.attr('item-id', this.model.id);
			
			var offer = this.model.get('offers').at(0),
				bar = this.make('div', {
					'class': 'bar'
				}),
				img = this.make('img', {
					'class'	: 'item',
					'width'	: 290,
					'height': 156,
					'src'	: nsConfig.imageFolder + '/game/1x1-transparent.png'
				});
			
			// Bar
			if (offer.isDiscounted()) {
				bar.appendChild(this.make('span', {
					'class': 'original'
				}, offer.get('originalPrice')));
			}
			bar.appendChild(this.make('span', null, this.trans('WEB_GAME_DEALS_PRICE_NOW')));
			bar.appendChild(this.make('span', {
				'class':  offer.get('currency')
			}, offer.get('price')));
			this.el.appendChild(bar);
			
			// Image
			this.el.appendChild(img);
			APP.preload.image(this.model.getImage(), _.bind(function (err, src) {
				if (err) {
					APP.log.warn(err);
					src = nsConfig.imageFolder + 'game/tmp_bundle.jpg';
				}
				img.src = src;
				this.$el.removeClass('loading');
			}, this));
			img.ondragstart = function () { return false; };
			
			// Locked
			if (this.model.isLocked()) {
				this.$el.addClass('locked');
				
				this.renderLock();
				
				if (offer && offer.isUnlock()) {
					this.$el.append('<a href="#unlock" class="icon unlock" />');
				} else {
					this.$el.append('<a href="#lock" class="icon lock" />');
				}
			
			// Buyable
			} else if (this.model.isBuyable()) {
				this.el.appendChild(this.make('a', {
					'class': 'icon buy',
					'href': '#buy'
				}));
			}
			
			// Try on
			if (this.model.get('containsAppearanceItems') && !this.model.get('isRandomContent')) {
				this.el.appendChild(this.make('a', {
					'class': 'icon tryon',
					'href': '#tryon'
				}));
			}
			
			
			// Promoted
			if (this.model.isPromoted()) {
				this.el.appendChild(this.make('span', {
					'class': 'promotion ' + this.model.get('promotionType')
				}, this.model.get('promotionLabel')));
			}
			
			this.$el.disableTextSelect();
		}
	});
}(this));

/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule bundles
 */
(function (root) {
	"use strict";
	
	
	var APP = root.APP,
		win = APP.win,
		$ = APP.$,
		_ = APP._,
		doc = APP.doc,
		parent = APP.View.prototype;
	
	APP.View.BundleInfo = APP.View.extend({
		name: 'bundle-info-view',
		className: 'info-view',
		events: {
			'click a.close': function (e) {
				e.preventDefault();
				this.sound('close');
				this.trigger('close', this, this.model, e);
			}
        },
		initialize: function initializeBundleInfoView() {
			// TODO: Make sure we don't rely on this "magic" binding
			_.bindAll(this);
			this.model.bind('change', this.render);
			this.model.bind('purchase:start', this._onPurchaseStart);
			this.model.bind('purchase:end', this._onPurchaseEnd);
			
			this.bind('try:click', this._onClickTry, this);
			this.bind('buy:click', this._onClickBuy, this);
		},
		
		destroy: function destroyBundleInfoView() {
			this.model.unbind('change', this.render);
			this.model.unbind('purchase:start', this._onPurchaseStart);
			this.model.unbind('purchase:end', this._onPurchaseEnd);
		},
		
		_onPurchaseStart: function _onPurchaseStartBundleInfoView(model) {
			this.$el.addClass('loading');
		},
		_onPurchaseEnd: function _onPurchaseEndBundleInfoView(model) {
			this.$el.removeClass('loading');
		},

		_onClickTry: function (view, e) {
			this.trigger('try', this, this.model, e);
		},
		
		_onClickBuy: function _onClickBuyBundleInfoView(view, e) {
			this.trigger('buy', this, this.model, e);
		},
		
		show: function showBundleInfoView() {
			if (!this.isVisible()) {
				this.$el.css({ 
					'opacity': 0
				}).show();
				
				this.$el.animate({
					'opacity': 1
				}, 200);
			}
			return this;
		},
		
		hide: function hideBundleInfoView() {
			if (this.isVisible()) {
				this.$el.animate({
					'opacity': 1
				}, 200, _.bind(this.$el.hide, this.$el));
			}
			return this;
		},
		
		isVisible: function isVisibleBundleInfoView() {
			// Not in DOM
			if (!this.el.parentNode) {
				return false;
			}
			
			// Display "none"
			if (this.el.style.display === 'none') {
				return false;
			}
			
			// Opacity
			if (parseInt(this.$el.css('opacity'), 10) === 0) {
				return false;
			}
			
			return true;
		},
		
		/**
		 * Render Lock
		 */
		renderLock: function renderLockWeaponItemView() {
			
			var nsConfig = APP.ns('config'),
				type = this.trans('WEB_GAME_LOCK_TYPE_' + this.model.get('lockType').toUpperCase()),
				criteria = this.model.get('lockCriteria'),
				lock = this.make('div', {
					'class': 'lock ' + type
				}),
				progressImage = nsConfig.imageFolder + 'game/item-lock-progress.png',
				progress = this.model.get('lockProgress'),
				canvas = win.progressCircle(progressImage, progress, {
					width: 116,
					height: 116,
					lineWidth: 20,
					duration: 500
				});
			
			lock.appendChild(this.make('span', {
				'class': 'type'
			}, type));
			
			lock.appendChild(this.make('span', {
				'class': 'key'
			}, criteria));
			
			lock.appendChild(canvas);
			this.el.appendChild(lock);
			
			return this;
		},
		
		render: function renderBundleInfoView() {
			
			this.$el.addClass('border-box');
			
			var offer = this.model.get('offers').at(0),
				priceContent = doc.createDocumentFragment(),
				title,
				prices,
				items;
			
			// Close
			this.el.appendChild(this.make('a', {
				'class': 'close'
			}));
			
			// Title
			title = this.make('h2');
			title.appendChild(this.make('span', null, this.model.get('name')));
			this.el.appendChild(title);
			
			// Description
			this.el.appendChild(this.make('div', {
				'class': 'description'
			}, this.model.get('description')));
			
			// Replace items with "mystery item" if bundle is a supply drop
			if (this.model.get('isRandomContent')) {
				
				// Create a dummy item
				items = [{
					'name': this.trans('WEB_GAME_SUPPLYDROPS_UNKNOWN_ITEM'),
					'buyable': false,
					'id': 'mystery-item'
				}];
			} else {
				items = this.model.get('items');
			}
			
			// Items
			this.createView(APP.View.LabelBox, {
				'label': this.trans('WEB_GAME_DEALS_ITEMS_LABEL'),
				'className': 'bundled-items',
				'content': this.createView(APP.View.ItemList, {
					collection: new APP.Collection.Items(items),
					className: 'bundles-item-list-view',
					drag: false,
					drop: false,
					viewOptions: {
						showName: false,
						live: false,
						showIcons: false
					}
				}, 'list')
			}).render().attach();
			
			
			// Is Locked
			if (this.model.isLocked()) {
				
				this.$el.addClass('locked');
				
				this.renderLock();
				
			} else {
				
				// Try on
				if (this.model.get('containsAppearanceItems') && !this.model.get('isRandomContent')) {
					this.createView(APP.View.Button, {
						glyph: 'tryon',
						large: true,
						text: this.trans('WEB_STORE_COMMON_TRY_ON_BTN'),
						className: 'try'
					}, 'try').render().attach();
				}
				
				// Discount
				prices = this.make('div', { 'class': 'prices' });
				if (offer.isDiscounted()) {
					prices.appendChild(this.make('span', {
						'class': 'original'
					}, offer.get('originalPrice')));
				}
				// Price
				prices.appendChild(this.make('span', {
					'class': 'currency ' + offer.get('currency')
				}, offer.get('price') + '<i class="glyphs glyphs-' + offer.get('currency') + '20"></i>'));
				priceContent.appendChild(prices);
				
				this.createView(APP.View.Button, {
					container: priceContent,
					className: 'buy',
					primary: true,
					glyph: 'buy',
					text: this.trans('WEB_STORE_COMMON_BUY_BTN'),
					sound: true
				}, 'buy').render().attach();
				
				
				this.createView(APP.View.LabelBox, {
					'className': 'purchase bottom',
					'label': this.trans('WEB_GAME_DEALS_PRICE_LABEL'),
					'content': priceContent
				}).render().attach();
			}
			
			// Disable selects
			this.$el.disableTextSelect();
		}
	});
}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule bundles
 */
/**
 * @class GAME.Task.bundles
 * @uses GAME.Task.items
 * @uses GAME.Task.store
 */
APP.task('bundles', ['items', 'store'], function initBundles(done) {
	"use strict";
	
	/**
	 * Bundles
	 */
	var win = APP.win,
		$ = APP.$,
		_ = APP._,
		dressDoll = win.dressDoll,
		nsItems = APP.namespace('items'),
		nsBundles = APP.namespace('bundles'),
		nsConfig = APP.namespace('config'),
		nsStore = APP.namespace('store'),
        collection = nsBundles.collection = nsItems.collection.byType('bundle'),
        
		// Main page element
		$main = nsBundles.$el = $('<div>').addClass('main main_bundles page hidden loading').appendTo('#frontend'),
		$panelLeft = nsBundles.$panelLeft = $('<div>').addClass('page-panel left').appendTo($main),
		$panelRight = nsBundles.$panelRight = $('<div>').addClass('page-panel right').appendTo($main),
		
		/**
		 * Equip Bundle
		 */
		equipBundle = function equipBundle(bundle, onlyApparanceItems) {
			
			var bundledItems = nsItems.collection.getBundledItems(bundle),
				appearanceItems = bundledItems.byType('appearance'),
				weaponItems = bundledItems.byType('weapon'),
				equippedWeapons,
				availableSlots,
				emptySlots,
				equipByValidationGroup = function equipByValidationGroup(validationGroup, emptyFirst) {
					
					var items = weaponItems.by('validationGroup', validationGroup),
						availableSlots;
					
					if (items.length !== 0) {
						availableSlots = equippedWeapons.by('validationGroup', validationGroup).pluck('equippedSlot');
						items.forEach(function eachPrimary(model, i) {
							var slot;
							
							if (emptyFirst) {
								slot = emptySlots.shift();
								if (!_.isNumber(slot) && availableSlots.length !== 0) {
									slot = (i < availableSlots.length) ? availableSlots[i] : availableSlots[0];
								}
							} else if (availableSlots.length !== 0) {
								slot = (i < availableSlots.length) ? availableSlots[i] : availableSlots[0];
							} else {
								slot = emptySlots.shift();
							}
							
							if (_.isNumber(slot) && !model.isEquipped()) {
								model.set({
									equippedSlot: slot
								});
							}
						});
					}
				};
				
			/**
			 * Appearance items
			 */
			if (appearanceItems.length !== 0) {
				availableSlots = [ 'head', 'face', 'uniform', 'accessory1', 'accessory2' ];
				appearanceItems.forEach(function eachAppearance(model) {
					var slot = _.indexOf(availableSlots, model.get('validationGroup'));
					if (slot !== -1 && !model.isEquipped()) {
						model.set({
							equippedSlot: slot
						});
					}
				});
			}
			
			/**
			 * Weapon Items
			 */
			if (weaponItems.length !== 0 && !onlyApparanceItems) {
				equippedWeapons = nsItems.collection.getEquipped('weapon');
				emptySlots = _.without.apply(_, [_.range(10)].concat(equippedWeapons.pluck('equippedSlot')));
				
				// Primary
				equipByValidationGroup('primary');
				// Secondary
				equipByValidationGroup('secondary');
				// Melee
				equipByValidationGroup('melee');
				// Gadget
				equipByValidationGroup('gadget', true);
			}
			
		};
	
	/**
	 * Purchase successful
	 */
    collection.bind('purchase:success', function onPurchaseSuccessBundle(model, offer, status, result) {
		
		var renderData = {
				title: APP.sidis.trans('WEB_GAME_TOOLTIPS_HEADER_EQUIPMENT_REMINDER'),
				body: APP.sidis.trans('WEB_GAME_TOOLTIPS_MESSAGE_EQUIPMENT_REMINDER'),
				close: true,
				buttonRight: APP.sidis.trans('WEB_GAME_TOOLTIPS_EQUIP_BTN')
			},
			dialogView = new APP.View.Dialog({
				'renderData': renderData
			}),
			close = function () {
				dialogView.sound('close');
				dialogView.destroy();
				dialogView = null;
			},
			randomItem,
			$itemContainer,
			droppedData;
		
		dialogView.bind('close', close);
		
		/**
		 * The bundle is a supply drop, let's show what you've got
		 */
		if (model.get('isRandomContent')) {
			
			// Get droppped data
			droppedData = result.data || {};
			droppedData.items = droppedData.items ? _.keys(droppedData.items) : [];
			droppedData.offers = droppedData.offers || {};
			
			// TODO: This is hack fix!
			droppedData.offerObjects = droppedData.offerObjects || {};
			
			$itemContainer = $('<ul>').addClass('item-list');
			
			// Loop through supply drop content
			_.forEach(droppedData.items, function (itemId) {
				
				var item = nsItems.get(itemId),
					// TODO: This how it should work
					//offer = item.get('offers').get(droppedData.offers[item.id]),
					offer = droppedData.offerObjects[item.id] ? new APP.Model.Offer(droppedData.offerObjects[item.id]) : null,
					$item = $('<li>'),
					$itemTitleCat = $('<span>'),
					$itemTitle = $('<h3>').text(item.get('name')).append($itemTitleCat),
					$itemImg = $('<img>').attr({
						'src': item.getImage('med'),
						'width'	: nsConfig.imageSize.med.width,
						'height': nsConfig.imageSize.med.height					
					}),
					$itemLimit = $('<p>').text(offer ? offer.get('limit') : '');
				
                if (item.get('itemType') === 'booster') {
                    $itemTitleCat.text(APP.sidis.trans('WEB_GAME_ITEM_CATEGORY_BOOSTER'));
                } else {
                    $itemTitleCat.text(item.get('categoryname'));
                }
				
				$itemTitle.appendTo($item);
				$itemImg.appendTo($item);
				$itemLimit.appendTo($item);
				$item.appendTo($itemContainer);
				
				// Show item in inventory
				$item.bind('click', function () {
					var itemType = item.get('itemType'),
						itemTypeUrls = {
							weapon		: '/weapons/' + item.id,
							appearance	: '/appearance/' + item.id,
							booster		: '/boosters/' + item.id
						},
						url = itemTypeUrls[itemType];
					
					if (url) {
						dialogView.sound('click');
						APP.navigate(url, true);
					}
					
					// Close dialog when navigating away
					close();					
				});
			});
			
			dialogView.className = "supplydrop-dialog";
			renderData.body = $itemContainer;
			renderData.buttonRight = APP.sidis.trans('WEB_GAME_TOOLTIPS_BUY_AGAIN_BTN');
			
			dialogView.bind('button:right', function () {				
				close();
				nsStore.trigger('buy', model);
			});
			
		/**
		 *
		 */
		} else {
			dialogView.bind('button:right', function () {
				equipBundle(model);
				close();
			});
		}
		
		dialogView.render();
		
		dialogView.attach();
		dialogView.show();
    });
    
	
	
	/**
	 * Initialize
	 */
	nsBundles.ready(function onReadyBundles() {
		nsBundles.$el.removeClass('loading');
	});
	
	
	/**
	 * Task Done!
	 */
    done();
});
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule bundles
 */
/**
 * @class GAME.Task.bundles.list
 * @uses GAME.Task.bundles
 */
APP.task('bundles.list', ['bundles'], function initBundlesList(done) {
	"use strict";
	
	
	var	win = APP.win,
		$ = APP.$,
		_ = APP._,
		nsBundles = APP.ns('bundles'),
		nsItems = APP.ns('items'),
		nsStore = APP.ns('store'),
		
		$menuBar = $('<div>').addClass('menu-bar').appendTo(nsBundles.$panelRight),
		
		/**
		 * Category tabs
		 */
		categoryTabs = nsBundles.categoryTabs = new APP.View.Tabs({
			container: $menuBar,
			className: 'category-tabs',
			tabs: [
				{ name: 'drops', text: APP.sidis.trans('WEB_GAME_ITEM_CATEGORY_SUPPLY_DROPS'), filter: 'drops' },
				{ name: 'hot', text: APP.sidis.trans('WEB_GAME_ITEM_CATEGORY_HOT_DEALS'), filter: 'hot' },
				{ name: 'latest', text: APP.sidis.trans('WEB_GAME_ITEM_CATEGORY_LATEST'), filter: 'latest' }
			]
		}).attach().render(),
	
		/**
		 * Bundles list
		 */
		list = nsBundles.list = new APP.View.ItemList({
			container: nsBundles.$panelRight,
			className: 'selectable-list',
			collection: nsItems.collection,
			viewClass: 'BundleItem',
			selectedClassName: 'selected',
			drag: false,
			drop: false
		}).attach(),
		
		
		/**
		 * Try on tooltip
		 */
		tryonTooltip = new APP.View.Tooltip({
			className: 'tryon-tooltip',
			html: '<p>' + APP.sidis.trans('WEB_GAME_CLICK_TO_TRYON') + '</p>'
		}).render().attach();
	
	
	/**
	 * Categroy Tabs
	 */
	categoryTabs.bind('select', function (i, tab) {
		
		var filter = {
				itemType: 'bundle'
			};
		
		
		if (tab.filter === 'drops') {
			filter.isRandomContent = true;
			
		} else if (tab.filter === 'hot') {
			filter.special = true;
			list.options.orderBy = 'sortOrder';
			list.options.orderDesc = false;
			
		} else {
			list.options.orderBy = 'lastModifiedTimestamp';
			list.options.orderDesc = true;
		}
				
		// Filter list view
		list.filterCollection(filter).render();
	});
	
	/**
	 * Scroll into view
	 */
	list.bind('select', function onSelectInList(model, $el) {
		list.scrollTo($el);
	});
	
	/**
	 * Select item on click
	 */
	list.bind('item:click', function onItemClickTaskBundlesList(model) {
		nsBundles.trigger('select', model);
	});
	
	/**
	 * Buy
	 */
	list.bind('item:buy', function onItemBuy(model) {
		nsStore.trigger('buy', model);
	});
	
	/**
	 * Customize
	 */
	list.bind('item:try', function onItemTry(model) {
		nsBundles.trigger('try', model);
	});
	
	
	/**
	 * Purchase Tooltip
	 */
	list.bind('item:buy:enter', function onBuyEnter(view, model, e) {
		/**
			name		: false
			description	: false
			dependencies: false
			stats		: false
			slots		: false
			offers		: false
			uses		: false
			time		: false
			invalid		: false
		**/
		nsItems.tooltip.renderModelAndShow(model, e.currentTarget, {
			offers		: true
		});
	});
	list.bind('item:buy:leave', function onBuyLeave() {
		nsItems.tooltip.hide();
	});
	
	
	/**
	 * Tryon Tooltip
	 */
	list.bind('item:tryon:enter', function onTryonEnter(view, model, e) {
		tryonTooltip.show(e.currentTarget);
	});
	list.bind('item:tryon:leave', function onTryonLeave() {
		tryonTooltip.hide();
	});
	
	
	/**
	 * Listen for weapon select events
	 */
	nsBundles.bind('select', function onSelectBundles(model) {
		list.select(model);
	});
	
	
	/**
	 * Initialize
	 */
	nsBundles.setup(function initializeBundlesList(ready) {
		// Ready once the bundles list has been rendered
		list.once('render', ready);
		
		// select first tab
		categoryTabs.select(0);
	});
	
	
	/**
	 * Task Done!
	 */
	done();
});
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule bundles
 */
/**
 * @class GAME.Task.bundles.info
 * @uses GAME.Task.bundles
 */
APP.task('bundles.info', ['bundles'], function initBundlesList(done) {
	"use strict";
	
	
	var	win = APP.win,
		doc = APP.doc,
		$ = APP.$,
		_ = APP._,
		nsBundles = APP.ns('bundles'),
		nsItems = APP.ns('items'),
		nsStore = APP.ns('store'),
		
		bundleInfoView,
		bundleInfoTooltip,
		
		/**
		 * Try on
		 */
		tryBundle = function tryBundle(model) {
			model = nsBundles.collection.get(model);
			
			win.dressDoll(model);
			
			if (bundleInfoView) {
				bundleInfoView.hide();
				_.delay(win.showDoll, 200);
			} else {
				win.showDoll();
			}
		};
	
	
	/**
	 * Trigger
	 */
	APP.bind('doll:undress', function onDollUndress(model) {
		if (model instanceof APP.Model.Item && bundleInfoView && bundleInfoView.model.id === model.id) {
			win.hideDoll();
			bundleInfoView.show();
		}
	});
	
		
	/**
	 * Try bundle
	 */
	nsBundles.bind('try', function onTryBundle(model) {
		tryBundle(model);
	});
	
	
	/**
	 * Listen for weapon select events
	 */
	nsBundles.bind('select', function onSelect(model) {
		
		// Ensure model
		model = nsItems.collection.get(model);
		
		if (bundleInfoView && bundleInfoView.model.id !== model.id) {
			bundleInfoView.destroy();
			bundleInfoView = nsBundles.info = null;
		}
		
		// Set some ungly globals
		win.dontUpdateDoll = true;
		win.hideDoll();
		
		// Show bundle info
		if (bundleInfoView) {
			bundleInfoView.show();
		
		// Create bundle info
		} else {
			
			bundleInfoView = nsBundles.info = new APP.View.BundleInfo({
				model: model,
				container: nsBundles.$panelLeft
			}).attach();
			
			
			/**
			 * Close
			 */
			bundleInfoView.bind('close', function onCloseBundleInfo() {
				bundleInfoView.hide();
				
				nsBundles.list.deselect();
				
				_.delay(function () {
					win.dressDoll();
					win.showDoll();
					win.dontUpdateDoll = false;
				}, 200);
			});
			
			
			/**
			 * Mouse enter
			 */
			bundleInfoView.bind('list:item:enter', function onMouseEnter(view, model, e) {
				if (model) {
					/**
						name		: false
						description	: false
						dependencies: false
						stats		: false
						slots		: false
						offers		: false
						uses		: false
						time		: false
						invalid		: false
					**/
					
					var options = {
							name	: true,
							stats	: true,
							slots	: true
						},
						offers = model.get('offers');
					
					if (offers.length !== 0) {
						options.customText = model.get('offers').at(0).get('limit');
					}
					
					nsItems.tooltip.renderModelAndShow(model, e.currentTarget, options);
				}
			});
			
			
			/**
			 * Mouse leave
			 */
			bundleInfoView.bind('list:item:leave', function () {
				nsItems.tooltip.hide();
			});
			
			
			/**
			 * Buy
			 */
			bundleInfoView.bind('buy', function onBuyBundle(view, model) {
				nsStore.trigger('buy', model);
			});
			
			
			/**
			 * Try on
			 */
			bundleInfoView.bind('try', function onTryBundle(view, model) {
				nsBundles.trigger('try', model);
			});
			
			bundleInfoView.render();
			bundleInfoView.show();
		}
	});
	
	
	/**
	 * Task Done!
	 */
	done();
});
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule bundles
 */
/**
 * @class GAME.Task.bundles.routes
 * @uses GAME.Task.items
 * @uses GAME.Task.bundles
 * @uses GAME.Task.bundles.list
 */
APP.task('bundles.routes', [ 'items', 'bundles', 'bundles.list' ], function taskAppearanceRoutes(done) {
	"use strict";
	
	
	var win = APP.win,
		$ = APP.$,
		_ = APP._,
		nsBundles = APP.ns('bundles'),
		nsItems = APP.ns('items');
	
	
	/**
	 * Bundles page
	 */
	APP.bind('page:bundles', function onPageBundle(from, data) {
		if (from !== 'bundles') {
			if (nsBundles.info && nsBundles.info.isVisible()) {
				win.dontUpdateDoll = true;
				win.hideDoll();
			} else {
				win.dontUpdateDoll = false;
				win.showDoll();
			}
		}
		
		// Start
		nsBundles.start(function () {
			var model;
			
			// Tab
			if (data.tab) {
				if (data.tab === 'drops') {
					nsBundles.categoryTabs.select(0);
				} else {
					nsBundles.categoryTabs.select(data.tab);
				}
			
			// Item
			} else if (data.id) {
				model = nsItems.collection.get(data.id);
				nsBundles.categoryTabs.select(2);
				nsBundles.trigger('select', model);
			}
		});
	});
	
	
	/**
	 * Bundles page
	 */
	APP.route('bundles', 'bundles', function onBundlesRoute() {
		APP.page('bundles');
	});
	
	
	/**
	 * Bundles filter tab
	 */
	APP.route('bundles/:tab', 'bundles-tab', function onBundlesTabRoute(tab) {
		APP.page('bundles', {
			tab: tab
		});
	});
	
	
	/**
	 * Bundle item
	 */
	APP.route(/^bundles\/([\d]+)$/, 'bundles-id', function onBundleIdRoute(id) {
		var model = nsItems.collection.get(id),
			url;
		
		// Check if model exists and is of type weapon
		if (model && model.isType('bundle')) {
			url = '/bundles/' + model.id  + '/' + model.get('name').toLowerCase().replace(/([\s])+/g, '-');
			
			APP.navigate(url);
			
			APP.page('bundles', {
				id: id
			});
		}
	});
	
	
	/**
	 * Task done!
	 */
	done();
});
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule config
 */
/**
 * @class GAME.Task.config
 */
APP.task('config', function taskConfig(done) {
	"use strict";
	
	var win = APP.win,
		doc = APP.doc,
		$ = APP.$,
		_ = APP._,
		nsConfig = APP.ns('config'),
		model = nsConfig.model = new APP.Model({
			id: 'config:' + nsConfig.uid
		}),
		isScaled = false,
		_generatePosition = $.ui.draggable.prototype._generatePosition;
	
	
	/**
	 * Images sizes
	 */
	nsConfig.imageSize = {
		min: { width: 80, height: 60 },
		med: { width: 285, height: 128 },
		max: { width: 927, height: 416 } // Used for weapon texture attachments aswell
	};
	
	/**
	 * Attachment image sizes
	 */
	nsConfig.attachmentSize = {
		min: { width: 40, height: 18 },
		med: { width: 125, height: 56 },
		max: { width: 400, height: 180 }
	};
	
	
	/**
	 * Default Customization
	 */
	_.forEach(nsConfig.defaultCustomization, function (team, teamId) {
		if (typeof team === 'object') {
			_.forEach(team, function (types, kit) {
				_.forEach(types, function (items, type) {
					types[type] = _.values(items);
				});
			});
		}
	});
    
	
	// Do we have the game dependency?
	isScaled = parseInt(JSON.parse(APP.api.general.getWindowSize()).width, 10) === 800;
	
	nsConfig.isScaled = isScaled;
	nsConfig.maxWidth = APP.$main.width();
	nsConfig.maxHeight = APP.$main.height();
	
	
	if (isScaled) {
		nsConfig.scale = 0.78125;
		nsConfig.scaleMod = 1.28;
		
		/**
		 * Need to overwrite jQuery UI draggable to adjust for the scale position
		 */
		$.ui.draggable.prototype._generatePosition = function () {
			var pos = _generatePosition.apply(this, arguments);
			pos.top = pos.top * nsConfig.scaleMod;
			pos.left = pos.left * nsConfig.scaleMod;
			return pos;
		};
		
		
		$.ui.intersect = function (draggable, droppable, toleranceMode) {
			if (!droppable.offset) {
				return false;
			}
			
			var x1 = (draggable.positionAbs || draggable.position.absolute).left,
				x2 = x1 + draggable.helperProportions.width,
				y1 = (draggable.positionAbs || draggable.position.absolute).top,
				y2 = y1 + draggable.helperProportions.height,
				l = (droppable.offset.left * nsConfig.scaleMod) - (droppable.proportions.height / 2),
				r = l + droppable.proportions.width,
				t = (droppable.offset.top * nsConfig.scaleMod) - (droppable.proportions.height / 2),
				b = t + droppable.proportions.height,
				draggableLeft = ((draggable.positionAbs || draggable.position.absolute).left + ((draggable.clickOffset || draggable.offset.click).left)),
				draggableTop = ((draggable.positionAbs || draggable.position.absolute).top + ((draggable.clickOffset || draggable.offset.click).top)),
				isOver = $.ui.isOver(draggableTop, draggableLeft, t, l, droppable.proportions.height, droppable.proportions.width);
			return isOver;
		};
		
		
		
	} else {
		nsConfig.scale = 1;
		nsConfig.scaleMod = 1;
	}
	
	
	
	
	/**
	 * Task Done!
	 */
	done();
});
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule dock
 */
(function (global) {
	"use strict";
	
	
	var APP = global.APP,
		$ = APP.$,
		_ = APP._,
		doc = APP.doc,
		parent = APP.View.DnD.prototype,
		nsConfig = APP.namespace('config');
		
	
	/**
	 * Dock View
	 */
	APP.View.Dock = APP.View.DnD.extend({
		name: 'dock-view',
		tagName: 'div',
		
		options: _.extend(_.clone(parent.options), {
			type: null,
			drag: 'div.dock_item',
			drop: 'div.dock_item',
			limit: {},
			showKey: false,
			viewClass: 'Item',
			foo: 'dock'
		}),
		
		dragOptions: _.extend({}, parent.dragOptions, {
			revert: false
		}),
		
		events: {
			'mouseenter div.dock_item': function (e) {
				var index = this.$slots.index(e.currentTarget);
				this.trigger('enter', this, this.getModelFromDOM(index), e, index);
			},
			'mouseleave div.dock_item': function (e) {
				var index = this.$slots.index(e.currentTarget);
				this.trigger('leave', this, this.getModelFromDOM(index), e, index);
			}
		},
		
		/**
		 * Initialize View
		 */
		initialize: function initializeDockView() {
			// TODO: Make sure we don't rely on this "magic" binding
			_.bindAll(this);
			
			this._highlighted = [];
			
			// On Drag Start
			this.bind('drag:start', this.onDragStart, this);
			
			// On Drag Stop
			this.bind('drag:stop', this.onDragStop, this);
			
			// On Drop
			this.bind('drop', this.onDrop, this);
			
			this.collection.bind('change:equippedSlot', this.onEquippedSlot, this);
			this.collection.bind('reset', this.onCollectionReset, this);
			this.collection.bind('remove', this.onCollectionRemove, this);
		},
		
		
		
		destroy: function destroyDockView() {
			this.collection.unbind('change:equippedSlot', this.onEquippedSlot, this);
			this.collection.unbind('reset', this.onCollectionReset, this);
			this.collection.unbind('remove', this.onCollectionRemove, this);
		},
		
		onCollectionReset: function onCollectionResetDockView() {
			this.render();
		},
		
		onCollectionRemove: function onCollectionRemoveDockView(model) {
			// Removed model is of the correct dock type and is/was equipped. Unequip it!
			if (model && model.isType(this.options.type) && model.isEquipped()) {
				this.unequip(model);
			}
		},
		
		/**
		 * Handle click on the item
		 */
		onClickItem: function onClickItem(e) {
			e.preventDefault();
			
			// Get model
			var model = this.getModelFromDOM(e.currentTarget);
			
			// Trigger event
			this.trigger('click:item', model, e);
		},
		
		/**
		 * Handle click on the buy button
		 */
		onClickBuy: function onClickBuy(e) {
			e.preventDefault();
			
			// Get model
			var $node = this.$(e.currentTarget).parents('div.dock_item'),
				model = this.getModelFromDOM($node);
			
			// Trigger event
			this.trigger('click:buy', model, e);
		},
		
		
		onDragStart: function onDragStart() {
			this.sound('equip');
		},
		
		/**
		 * Handle drag stop
		 */
		onDragStop: function onDragStop(model, ui) {
			
			var $container = this.$(this.getContainer()),
				top = $container.offset().top,
				bottom = top + $container.height(),
				helperTop = ui.helper.offset().top,
				helperPos = helperTop + (ui.helper.height() / 2);
			
			if (helperPos < top || helperPos > bottom) {
				this.unequip(model);
			}
			
			// TODO: Play drop sound
			this.sound('unequip');
			
			this.highlight();
			
			return this;
		},
		
		/**
		 * Handle change of model Equipped slot
		 */
		onEquippedSlot: function onEquippedSlotDockView(model) {
			
			// Make sure we are using the correct type
			if (model.get('itemType') !== this.options.type) {
				return this;
			}
			
			var $slot,
				previousEquippedSlot = model.previous('equippedSlot'),
				equippedSlot = model.get('equippedSlot'),
				viewClass = _.isString(this.options.viewClass) ? APP.View[this.options.viewClass] : this.options.viewClass,
				itemView,
				filter = {
					itemType: this.options.type,
					equippedSlot: previousEquippedSlot
				},
				wasEquipped = _.isNumber(previousEquippedSlot),
				onThisSlot = wasEquipped ? this.collection.filterBy(filter) : [];
			
			/**
			 * Is Equipped
			 */
			if (model.isEquipped()) {
				
				this.emptySlot(equippedSlot);
				
				$slot = this.$slots.eq(equippedSlot);
				
				// Create item view
				itemView = this.createView(viewClass, {
					model: model,
					container: $slot,
					showName: false,
					className: 'icon',
					showAdditional: false,
					showLock: false,
					size: 'min'
				}, 'item');
				
				// Check after render
				// TODO: This is need why??
				itemView.bind('render', function onRenderAfter() {
					// Invalid
					if (!model.isOwned() || model.get('expired')) {
						itemView.$el.addClass('invalid');
					}
				});
				
				// Render
				itemView.render();
				
				// Remove old icon
				$slot.find('div.item-view').remove();
				
				// Attach new icon
				itemView.attach();
				
				// Update Description
				$slot.find('span.description').html(model.get('categoryname'));
				
				if (wasEquipped && onThisSlot.length === 0) {
					this.emptySlot(previousEquippedSlot);
				}
				
				// Trigger APP event
				this.trigger('equip', model);
				//APP.trigger('equip:' + model.get('itemType'), model);
				//APP.trigger('equip', model);
				
			/**
			 * Removed
			 */
			} else {
				if (wasEquipped) {
					this.emptySlot(previousEquippedSlot);
				}
				this.trigger('unequip', model);
				//APP.trigger('unequip:' + model.get('itemType'), model);
				//APP.trigger('unequip', model);
			}
			
			return this;
		},
		
		/** 
		 * Drag Helper 
		 */ 
		dragHelper: function dragHelperItemList(e) { 
			
			var view = this.getViewByElement(e.currentTarget.getElementsByTagName('div')[0]),
				$el;
			
			if (view && view.dragHelper) {
				$el = view.dragHelper(e);
				$el.data('id', view.model.id);
				$el.appendTo(doc.body);
				return $el;
			}
			
			return this.make('span');
		},
		
		/**
		 * Empty Slot
		 */
		emptySlot: function emptySlotDockView(slot) {
			
			var $slot = this.$slots.eq(slot),
				$itemView = $slot.find('div.icon'),
				itemView = this.getView($itemView),
				onCompleteAnimate = _.bind(function onCompleteAnimate() {
					if (itemView) {
						this.destroyView(itemView);
					} else {
						$itemView.remove();
					}
				}, this);
			
			$itemView.css({
				position: 'absolute',
				top: 0
			}).animate({
				top: '-100',
				opacity: 0
			}, 200, onCompleteAnimate);
			
			$slot.find('span.description').empty();
			
			return this;
		},
		
		/**
		 * Highlight
		 */
		highlight: function highlightDockView(slot) {
			if (arguments.length !== 0) {
				if (!_.isArray(slot)) {
					slot = [ slot ];
				}
				this._highlighted = slot;
			}
			
			var len = this._highlighted.length,
				i;
			
			this.$slots.removeClass('active drop-hover');
			
			for (i = 0; i < len; i += 1) {
				this.$slots.eq(this._highlighted[i]).addClass('active');
			}
			
			return this;
		},
		
		/**
		 * Handle change of mapped slot key
		 */
		// TODO: Hack this thing into options...
		onKeyChange: function onKeyChange(model) {
			
		},
		
		/**
		 * Unequip
		 */
		unequip: function unequipDockView(model) {
			if (model instanceof APP.Model) {
				model.unset('equippedSlot');
			}
			return this;
		},
		
		/**
		 * Handle on drop
		 */
		onDrop: function onDropDockView(model, ui, $slot) {
			
			var slot = this.$slots.index($slot);
			
			// Set slot
			model.set({
				equippedSlot: slot
			});
			
			this.highlight();
		},
		
		/**
		 * Get Model From DOM
		 */
		getModelFromDOM: function getModelFromDOMDockView(el) {
			
			var i = _.isNumber(el) ? el : this.$slots.index(el),
				model = this.collection.getBy({
					itemType: this.options.type,
					equippedSlot: i
				});
			
			return model;
		},
		
		/**
		 * Get Mapped key for this slot
		 */
		// TODO: Actually implement this function
		getMappedKeyBySlot: function getMappedKeyBySlotDockView(slot) {
			var key = slot + 1;
			
			if (key === 10) {
				key = 0;
			}
			
			return key + String();
		},
		
		/**
		 * Render Slot
		 */
		renderSlot: function renderSlotDockView(i) {
			var slot = this.make('div', {
					'class': 'dock_item'
				});
			
			// Show Key
			if (this.options.showKey) {
				slot.appendChild(this.make('span', {
					'class': 'key'
				}, this.getMappedKeyBySlot(i)));
			}
			
			// Description
			slot.appendChild(this.make('span', {
				'class': 'description'
			}));
			
			
			return slot;
		},
		
		/**
		 * Render
		 */
		render: function renderDockView() {
			this.destroyViews();
			
			this.$el.empty();
			
			var i,
				len = this.options.slotCount,
				slots = [],
				slot;
			
			for (i = 0; i < len; i += 1) {
				slot = this.renderSlot(i);
				slots.push(slot);
				this.el.appendChild(slot);
			}
			
			// Get all the items for future reference
			this.$slots = this.$(slots);
			
			// Add items
			this.collection.getEquipped(this.options.type).forEach(this.onEquippedSlot, this);
			
			return this;
		}
	});

}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule dock
 */
(function (global) {
	"use strict";
	
	
	var APP = global.APP,
		$ = APP.$,
		_ = APP._,
		slotKeys = {
			0: 'head',
			1: 'face',
			2: 'uniform',
			3: 'accessory1',
			4: 'accessory2'
		},
		parent = APP.View.Dock.prototype;
	
	/**
	 * Dock View
	 */
	APP.View.DockAppearance = APP.View.Dock.extend({
		name: 'dock-view',
		tagName: 'div',
		className: 'appearance',
		options: _.extend(_.clone(parent.options), {
			type: 'appearance',
			slotCount: 5,
			limit: {
				head: 1,
				face: 1,
				uniform: 1,
				accessory1: 1,
				accessory2: 1
			},
			viewClass: 'AppearanceItem'
		}),
		
		_highlighted: [ 0, 1, 2, 3, 4 ],
		
		/**
		 * Initialize
		 */
		initialize: function initialize() {
			parent.initialize.apply(this, arguments);
			
			/**
			 * Handle Drop Active
			 */
			this.bind('drop:activate', function onDropActivate(model) {				
				// Clear Class
				this.$slots.removeClass('active');
				
				// Make active
				this.$slots.filter('.' + model.get('validationGroup')).addClass('active');
			}, this);
			
			/**
			 * Handle Drop Deactivate
			 */
			this.bind('drop:deactivate', function onDropDeactivate(model) {
				this.highlight();
			}, this);
			
			/**
			 * Handle Drag Start
			 */
			this.bind('drag:start', function onDragStart(model) {
				if (model) {
					// Clear Class
					this.$slots.removeClass('active');
					
					// Make active
					this.$slots.filter('.' + model.get('validationGroup')).addClass('active');
				}
			}, this);
			
			/**
			 * Handle Drag Stop
			 */
			this.bind('drag:stop', function onDragStop() {
				this.highlight();
			}, this);
			
			/**
			 * Handle Empty
			 */
			this.bind('empty', function onEmpty($slot, i) {
				$slot.find('span.description').text(this.trans('WEB_GAME_APPEARANCE_MENU_' + slotKeys[i].toUpperCase()));
			}, this);
		},
		
		/**
		 * Accept
		 */
		accept: function acceptDockAppearanceView($draggable, slot) {
			
			var itemId = $draggable.attr('item-id') || $draggable.data('id') || $draggable.find('div.icon').data('id'),
				model = this.collection.get(itemId);
			
			return model && model.get('itemType') === 'appearance' && $(slot).hasClass(model.get('category'));
		},
		
		/**
		 * Empty Slot
		 */
		emptySlot: function emptySlotDockAppearanceView(i) {
			
			parent.emptySlot.apply(this, arguments);
			
			var $slot = this.$slots.eq(i),
				description = this.trans('WEB_GAME_APPEARANCE_MENU_' + slotKeys[i].toUpperCase());
			
			$slot.find('span.description').text(description);
			
			return this;
		},
		
		/**
		 * Render Slot
		 */
		renderSlot: function renderSlot(i) {
			
			var slot = parent.renderSlot.call(this, i),
				$slot = $(slot),
				slotClasses = {
					0: 'head',
					1: 'face',
					2: 'uniform',
					3: 'accessory1',
					4: 'accessory2'
				},
				description = this.trans('WEB_GAME_APPEARANCE_MENU_' + slotKeys[i].toUpperCase()),
				$description = $slot.find('span.description');
			
			$slot.addClass(slotClasses[i]);
			
			$description.text(description);
			
			return slot;
		}
	});
	
}(this));
(function (global) {
	
	var APP = global.APP,
		win = APP.win,
		$ = APP.$,
		_ = APP._,
		parent = APP.View.Dock.prototype;
	
	/**
	 * Dock View
	 */
	APP.View.DockWeapons = APP.View.Dock.extend({
		name: 'dock-view',
		tagName: 'div',
		className: 'weapons',
		options: _.extend(_.clone(parent.options), {
			type: 'weapon',
			slotCount: 10,
			showKey: true,
			foo: 'weapons',
			viewClass: 'WeaponItem'
		}),
		
		dragOptions: _.extend({}, parent.dragOptions, {
			containment: [ -158, 0, 882, 704 ],
			cursorAt: { left: 158, top: 67 }
		}),
		
		initialize: function initializeDockWeaponsView() {
			parent.initialize.apply(this, arguments);
			
			// On Drag Start
			this.bind('drag:start', function onDragStart(model) {
				this.collection.setSelected('weapon', model);
			}, this);
			
			this.options.keys.bind('change', this.render, this);
		},
		
		destroy: function destroyDockWeaponsView() {
			parent.destroy.apply(this, arguments);
			this.options.keys.unbind('change', this.render, this);
		},
		
		/**
		 * Get Mapped key for this slot
		 */
		// TODO: Actually implement this function... ...and do a better job of it!
		getMappedKeyBySlot: function getMappedKeyBySlotDockWeaponsView(slot) {
			return this.options.keys.at(slot).get('keyName');
		},
		
		/**
		 * Accept
		 */
		accept: function acceptDockWeaponsView($draggable, slot) {
			var itemId = $draggable.attr('item-id') || $draggable.find('div').attr('item-id') || $draggable.data('id'),
				model = this.collection.get(itemId);
			
			return (model && model.get('itemType') === 'weapon');
		}
	});

}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule dock
 */
/**
 * @class GAME.Task.dock
 * @uses GAME.Task.items
 * @uses GAME.Task.sidis
 * @uses GAME.Task.appearance
 * @uses GAME.Task.store
 * @uses GAME.Task.options.data
 */
APP.task('dock', [ 'items', 'sidis', 'appearance', 'store', 'options.data' ], function taskDock(done) {
	"use strict";
	
	
	var $ = APP.$,
		_ = APP._,
		
		nsDock = APP.namespace('dock'),
		nsItems = APP.namespace('items'),
		nsStore = APP.namespace('store'),
		nsGame = APP.namespace('game'),
		nsOptions = APP.namespace('options'),
		nsAppearance = APP.namespace('appearance'),
		
		$footer = nsDock.$el = $('<div>')
			.addClass('footer weapons')
			.append('<a href="#toggle-dock" class="toggle"><span></span></a>')
			.appendTo('#frontend'),
		
		
		
		/**
		 * Weapons Dock
		 */
		$weapons = nsDock.$weapons = $('<div>')
			.addClass('dock weapons_dock')
			.append('<div class="dock_title"><a href="#weapons">' + APP.sidis.trans('WEB_GAME_DOCK_WEAPONS') + '</a></div>')
			.appendTo($footer),
		weaponDock = nsDock.weapons = new APP.View.DockWeapons({
			collection: nsItems.collection,
			container: $weapons,
			keys: nsOptions.collection.filterBy({
				group: 'equipment'
			})
		}).render(),
		
		
		
		/**
		 * Appearance Dock
		 */
		$appearance = nsDock.$appearance = $('<div>')
			.addClass('dock appearance_dock')
			.append('<div class="dock_title"><a href="#appearance">' + APP.sidis.trans('WEB_GAME_DOCK_APPERANCE') + '</a></div>')
			.appendTo($footer),
		appearanceDock = nsDock.appearance = new APP.View.DockAppearance({
			collection: nsItems.collection,
			container: $appearance
		}).render(),
		
		/**
		 * Change Dock
		 */
		change = nsDock.change = function dockChange(dock) {
			$footer[0].className = 'footer ' + dock || '';
			return nsDock;
		},
		
		/**
		 * Open Dock
		 */
		open = nsDock.open  = function dockOpen(fn) {
			if (!$footer.hasClass('open')) {
				$footer.css('height', '');
				if (_.isFunction(fn)) {
					$footer.one('webkitTransitionEnd', fn);
				}
				$footer.addClass('open');
			} else if (_.isFunction(fn)) {
				_.defer(fn);
			}
			
			return nsDock;
		},
		
		/**
		 * Close Dock
		 */
		close = nsDock.close = function dockClose(fn) {
			if ($footer.hasClass('open')) {
				if (_.isFunction(fn)) {
					$footer.one('webkitTransitionEnd', fn);
				}
				$footer.removeClass('open');
			} else if (_.isFunction(fn)) {
				_.defer(fn);
			}
			return nsDock;
		},
		
		/**
		 * Hide Dock
		 */
		hide = nsDock.hide = function dockHide(fn) {
			var height = $footer.height();
			if (height > 0) {
				$footer.css('height', 0);
				if (_.isFunction(fn)) {
					$footer.one('webkitTransitionEnd', fn);
				}
				$footer.removeClass('open');
			} else if (_.isFunction(fn)) {
				_.defer(fn);
			}
			return nsDock;
		},
		
		/**
		 * Show Dock
		 */
		show = nsDock.show = function dockShow(fn) {
			var height = $footer.height();
			if (height === 0) {
				if (_.isFunction(fn)) {
					$footer.one('webkitTransitionEnd', fn);
				}
				$footer.css('height', '');
			} else if (_.isFunction(fn)) {
				_.defer(fn);
			}
			return nsDock;
		},
		
		
		/**
		 * Setup helper function
		 */
		setup = function setupDock(view, $el) {
			var tooltip;
			
			$el.remove();
			view.attach();
			
			// Handle click on item
			view.bind('item:click', function onViewClickItem(view, model) {
				if (model && model.isItemType('weapon')) {
					APP.navigate('/weapons/' + model.id, true);
				} else if (model && model.isItemType('appearance')) {
					APP.navigate('/appearance', true);
				}
			});
			
			// Handle click on item
			view.bind('item:buy', function onClickBuyDockView(view, model) {
				nsStore.trigger('buy', model);
			});
			
			
			// Tooltip
			view.bind('enter', function onEnter(view, model, e) {
				if (model) {
					/**
						name		: false
						description	: false
						dependencies: false
						stats		: false
						slots		: false
						offers		: false
						uses		: false
						time		: false
						invalid		: false
					**/
					nsItems.tooltip.renderModelAndShow(model, e.currentTarget, {
						name		: true,
						slots		: true,
						offers		: true,
						uses		: true,
						time		: true,
						invalid		: true
					});
				}
			});
			view.bind('leave', function () {
				nsItems.tooltip.hide();
			});
		},
		
		/**
		 * Dock Errors
		 *
		 * TODO: Migrate this into something moree robust
		 */
		dualWeaponBooster = nsItems.get(7000),
		extraWeaponUpgrade = nsItems.get(7109),
		$dockErrors = $('<div>').addClass('dock_errors').css('display', 'none').appendTo('#frontend'),
		validateEquippedWeapons = _.debounce(function validateEquippedWeapons() {
			var errors = {
					5017: APP.sidis.trans('WEB_GAME_DOCK_ERROR_5017'), // You need to have a Primary Weapon equipped.
					5018: APP.sidis.trans('WEB_GAME_DOCK_ERROR_5018'), // You have too many Primary Weapons equipped.
					5019: APP.sidis.trans('WEB_GAME_DOCK_ERROR_5019'), // You need to have a Secondary Weapon equipped.
					5020: APP.sidis.trans('WEB_GAME_DOCK_ERROR_5020'), // You have too many Secondary Weapons equipped.
                    5024: APP.sidis.trans('WEB_GAME_DOCK_ERROR_5024'), // You need to have a Melee Weapon equipped.
                    5025: APP.sidis.trans('WEB_GAME_DOCK_ERROR_5025') // You have too many Melee Weapons equipped.
				},
				equippedPrimary = nsItems.collection.getEquipped('weapon').by('validationGroup', 'primary'),
				primaryLimit = dualWeaponBooster && dualWeaponBooster.isOwned() ? 2 : 1;
			
			if (primaryLimit === 1 && extraWeaponUpgrade && extraWeaponUpgrade.isEquipped() && extraWeaponUpgrade.isOwned()) {
				primaryLimit = 2;
			}
			
			weaponDock.$slots.removeClass('invalid');
			
			// No primary weapons equipped
			if (equippedPrimary.length === 0) {
				$dockErrors.html(errors[5017]).show().animate({
					bottom: $('#frontend .footer').height()
				}, 200);
			
			// To many Primary Weapons Equipped
			} else if (equippedPrimary.length > primaryLimit) {
				$dockErrors.html(errors[5018]).show().animate({
					bottom: $('#frontend .footer').height()
				}, 200);
				
				// Set all as invalid
				equippedPrimary.forEach(function (model) {
					var slot = model.get('equippedSlot');
					weaponDock.$slots.eq(slot).addClass('invalid');
				});
				
			} else {
				$dockErrors.hide();
			}
		}, 100),
		
		onWeaponEquipping = function onWeaponEquipping() {
			nsGame.saveWeapons();
			validateEquippedWeapons();
		},
		
		onAppearanceEquipping = function onAppearanceEquipping() {
			nsGame.saveAppearance();
			appearanceDock.highlight();
			validateEquippedWeapons();
		};
	
	
	
	/**
	 * On Weapon Equip & Unequip
	 */
	nsItems.bind('equip:weapon', onWeaponEquipping);
	nsItems.bind('unequip:weapon', onWeaponEquipping);
	
	
	
	/**
	 * On Appearance Equip & Unequip
	 */
	nsItems.bind('equip:appearance', onAppearanceEquipping);
	nsItems.bind('unequip:appearance', onAppearanceEquipping);
	
	
	
	/**
	 * Toggle open dock
	 */
	$footer.find('a.toggle').bind('click', function onToggleClick(e) {
		e.preventDefault();
		$footer.toggleClass('open');
	});
	
	/**
	 * On Page change close the dock
	 */
	APP.bind('page', function onPageDockTask() {
		close();
	});
	
	/**
	 * Setup
	 */
	setup(weaponDock, $weapons.find('div.weapons'));
	setup(appearanceDock, $appearance.find('div.appearance'));

	
	/**
	 * TODO: Investigate and fix the issue!!!
	 */
	/*
	weaponDock.bind('drag:start', function onDockedWeaponDragStart() {
		APP.namespace('appearance').doll.droppable('disable');
	});
	weaponDock.bind('drag:stop', function onDockedWeaponDragStop() {
		APP.namespace('appearance').doll.droppable('enable');
	});*/
	
	/**
	 * Validate Equipped Weapons
	 */
	validateEquippedWeapons();
	
	/**
	 * On Filter Appearance
	 *
	 * TODO: Make this less hacky
	 */
	APP.bind('filter:appearance', function onFilterAppearance(filter) {
		
		var slots = [],
			keys = _.keys(appearanceDock.options.limit);
		
		if (_.isEmpty(filter)) {
			slots = [ 0, 1, 2, 3, 4 ];
		} else {
			slots = _.indexOf(keys, filter.category);
		}
		
		appearanceDock.highlight(slots);
	});
	
	
	/**
	 * When er change bind keys in the options we need to re-render the dock
	 */
	APP.bind('bindkey', function () {
		weaponDock.render();
	});
	if (dualWeaponBooster) {
		dualWeaponBooster.bind('change:owned', validateEquippedWeapons);
	}
	if (extraWeaponUpgrade) {
		extraWeaponUpgrade.bind('change:owned change:equippedSlot', validateEquippedWeapons);
	}

	
	// Task Done!
	done();
});
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule eor
 */
(function (win) {
	"use strict";
	
	
	if (!win.APP && (typeof require !== 'undefined')) {
		win.APP = require('../common/app');
	}
	
	var APP = win.APP,
		parent = APP.Model.prototype,
		_ = APP._,
		kitNames = [ 'recon', 'assault', 'medic', 'engineer' ];
	
	
	/**
	 * Model: EORPlayer
	 */
	APP.Model.EORPlayer = APP.Model.extend({
		defaults: {
			'kit': null,
			'kitName': null,
			'team': null,
			'teamName': null,
			'name': null,
			'score': 0,
			'kills': 0,
			'deaths': 0,
			'realKD': 0,
			'scorePerKill': 0,
			'level': 0,
			'xp': 0,
			'xpToNextLevel': 0,
			'kd': null
		},
		
		schema: {
			'kit'			: 'number',
			'team'			: 'number',
			'level'			: 'number',
			'score'			: 'number',
			'kills'			: 'number',
			'deaths'		: 'number',
			'xp'			: 'number',
			'xpToNextLevel'	: 'number'
		},
		
		idAttribute: 'name',
		
		initialize: function initializeEORPlayerModel() {
			this._setKitName();
			this.bind('change:kit', this._setKitName, this);
			
			this._setTeamName();
			this.bind('change:team', this._setTeamName, this);
			
			this._setKD();
			this.bind('change:kills', this._setKD, this);
			this.bind('change:deaths', this._setKD, this);
		},
		
		_setKitName: function _setKDEORPlayerModel() {
			this.set({
				kitName: kitNames[this.get('kit')]
			});
			return this;
		},
		
		_setTeamName: function _setKDEORPlayerModel() {
			this.set({
				teamName: this.get('team') === 1 ? 'RU' : 'US'
			});
			return this;
		},
		
		_setKD: function _setKDEORPlayerModel() {
			var kills = this.get('kills'),
				deaths = this.get('deaths'),
				score = this.get('score');
			
			this.set({
				kd: kills + '/' +  deaths,
				realKD: deaths ? (kills / deaths) || 0 : kills,
				scorePerKill: (score / kills) || 0,
				scorePerDeath: deaths ? (score / deaths) || 0 : score
			});
			
			return this;
		}
	});
	
	/**
	 * Module support
	 */
	if (typeof module !== 'undefined' && module.exports) {
		module.exports = APP.Model.EORPlayer;
	}
}(this));

/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule eor
 */
(function (win) {
	"use strict";
	
	
	if (!win.APP && (typeof require !== 'undefined')) {
		win.APP = require('../common/app');
	}
	
	if (!win.APP.Model && (typeof require !== 'undefined')) {
		win.APP.Collection = require('../common/collection');
	}
	
	if (!win.APP.Model.Player && (typeof require !== 'undefined')) {
		win.APP.Model.Player = require('./model.eorplayer');
	}
	
	var APP = win.APP,
		_ = APP._,
		$ = APP.$;
	
	APP.Collection.EORPlayers = APP.Collection.extend({
		model: APP.Model.EORPlayer,
		
		comparator: function comparatorEORPlayersCollection(model) {
			return -((model.get('team') || 0) * 100000) - model.get('score');
		},
		
		/**
		 * Get Model Rank
		 */
		getModelKitRank: function getModelKitRankEORPlayersCollection(model) {
			model = this.get(model);
			
			if (!(model instanceof APP.Model.EORPlayer)) {
				throw new Error('Model in is not a APP.Model.EORPlayer');
			}
			
			var rank = {},
				filtered = this.filterBy({
					kit: model.get('kit')
				}).orderBy('score').reverse();
			
			// Global
			rank.global = filtered.indexOf(model);
			
			// Team
			rank.team = filtered.filterBy({
				team: model.get('team')
			}).orderBy('score').reverse().indexOf(model);
			
			return rank;
		},
		
		/**
		 * Get KD Rank
		 */
		getModelKDRank: function getModelKDRankEORPlayersCollection(model) {
			model = this.get(model);
			
			if (!(model instanceof APP.Model.EORPlayer)) {
				throw new Error('Model in is not a APP.Model.EORPlayer');
			}
			
			var rank = {},
				team = model.get('team'),
				sorted = this.orderBy('realKD').reverse();
			
			// Global
			rank.global = sorted.indexOf(model);
			
			// Team
			rank.team = _.filter(sorted, function (model) {
				return model.get('team') === team;
			}).indexOf(model);
			
			return rank;
		},
		
		/**
		 * Get Kill Rank
		 */
		getModelKillRank: function getModelKillRankEORPlayersCollection(model) {
			model = this.get(model);
			
			if (!(model instanceof APP.Model.EORPlayer)) {
				throw new Error('Model in is not a APP.Model.EORPlayer');
			}
			
			var rank = {},
				team = model.get('team'),
				sorted = this.orderBy('kills').reverse();
			
			// Global
			rank.global = sorted.indexOf(model);
			
			// Team
			rank.team = _.filter(sorted, function (model) {
				return model.get('team') === team;
			}).indexOf(model);
			
			return rank;
		},
		
		/**
		 * Score per kill
		 */
		getModelScorePerKillRank: function getModelScorePerKillRankEORPlayersCollection(model) {
			model = this.get(model);
			
			if (!(model instanceof APP.Model.EORPlayer)) {
				throw new Error('Model in is not a APP.Model.EORPlayer');
			}
			
			var rank = {},
				team = model.get('team'),
				sorted = this.orderBy('scorePerKill').reverse();
			
			// Global
			rank.global = _.indexOf(sorted, model);
			
			// Team
			rank.team = _.filter(sorted, function (model) {
				return model.get('team') === team;
			}).indexOf(model);
			
			return rank;
		},
		
		/**
		 * Score per death
		 */
		getModelScorePerDeathRank: function getModelScorePerDeathRankEORPlayersCollection(model) {
			model = this.get(model);
			
			if (!(model instanceof APP.Model.EORPlayer)) {
				throw new Error('Model in is not a APP.Model.EORPlayer');
			}
			
			var rank = {},
				team = model.get('team'),
				sorted = this.orderBy('scorePerDeath').reverse();
			
			// Global
			rank.global = _.indexOf(sorted, model);
			
			// Team
			rank.team = _.filter(sorted, function (model) {
				return model.get('team') === team;
			}).indexOf(model);
			
			return rank;
		},
		
		/**
		 * Get Model Achievements
		 */
		getModelAchievements: function getModelAchievementsEORPlayersCollection(model) {
			model = this.get(model);
			
			if (!(model instanceof APP.Model.EORPlayer)) {
				throw new Error('Model in is not a APP.Model.EORPlayer');
			}
			
			var levels = [ 'platinum', 'gold', 'silver', 'bronze' ],
				kit = this.getModelKitRank(model),
				kd = this.getModelKDRank(model),
				kills = this.getModelKillRank(model),
				scorePerKill = this.getModelScorePerKillRank(model),
				scorePerDeath = this.getModelScorePerDeathRank(model),
				achievements = {};
			
			// Kit
			if (kit.global === 0) {
				achievements.kit = levels[0];
			} else if (kit.team >= 0 && kit.team < 3) {
				achievements.kit = levels[kit.team + 1];
			}
			
			// Kill / Death
			if (kd.global === 0) {
				achievements.kd = levels[0];
			} else if (kd.team >= 0 && kd.team < 3) {
				achievements.kd = levels[kd.team + 1];
			}
			
			// Kills
			if (kills.global === 0) {
				achievements.kills = levels[0];
			} else if (kills.team >= 0 && kills.team < 3) {
				achievements.kills = levels[kills.team + 1];
			}
			
			// Score Per Kill
			if (scorePerKill.global === 0) {
				achievements.scorePerKill = levels[0];
			} else if (scorePerKill.team >= 0 && scorePerKill.team < 3) {
				achievements.scorePerKill = levels[scorePerKill.team + 1];
			}
			
			// Score Per Death
			if (scorePerDeath.global === 0) {
				achievements.scorePerDeath = levels[0];
			} else if (scorePerDeath.team >= 0 && scorePerDeath.team < 3) {
				achievements.scorePerDeath = levels[scorePerDeath.team + 1];
			}
			
			// 5+ kills and never died
			if (model.get('kills') > 5 && model.get('deaths') === 0) {
				achievements.unstoppable = 'unstoppable';
			}
			
			// Most kills
			return achievements;
		}
	});
	
	/**
	 * Module support
	 */
	if (typeof module !== 'undefined' && module.exports) {
		module.exports = APP.Collection.EORPlayers;
	}
}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule eor
 */
(function (win) {
	"use strict";
	
	
	var APP = win.APP,
		_ = APP._,
		$ = APP.$,
		parent = APP.View.TableRow.prototype;
		
	APP.View.EORTableRow = APP.View.TableRow.extend({
		name: 'eor-table-row-view',
		tagName: 'tr',
		
		/**
		 * Render the view
		 */
		render: function renderEORTableRowView() {
			var index = this.options.index + 1,
				
				// Index
				pos = this.renderCell('position', index < 10 ? '0' + index : index),
				
				// Name
				name = this.renderCell('name', ''),
				
				// Kit Icon
				kit = this.make('span', {
					'class': 'kit-' + this.model.get('kit')
				}, this.model.get('name')),
				
				// K/D
				kd = this.renderCell('kd'),
				
				// Score
				score = this.renderCell('score', this.model.get('score') + String());
				
			if (this.model.isNew()) {
				this.$el.addClass('empty');
				pos.innerHTML = kit.innerHTML = kd.innerHTML = score.innerHTML = '&nbsp;';
			}
			
			name.appendChild(kit);
		}
	});
	
}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule eor
 */
(function (root) {
	"use strict";
	
	
	var APP = root.APP,
		_ = APP._,
		$ = APP.$,
		win = APP.win,
		parent = APP.View.prototype;
		
	APP.View.EOR = APP.View.extend({
		name: 'eor-view',
		tagName: 'div',
		
		initialize: function initializeEORView() {
			this.bind('ready:click', this._onReadyClick, this);
		},
		
		destroy: function destroyEORView() {
			$(win).unbind('keyup', this.onEscapeClose);
		},
		
		_onReadyClick: function _onReadyClickEORView() {
			this.hideReadyButton();
			this.$el.addClass('hide');
			this.trigger('ready');
		},
		
		createTeamTable: function createTeamTableEORView(team, rushAttackingTeam) {
			var collection = this.collection.filterBy({
					team: team
				}),
				
				stringAtt	= this.trans('WEB_GAME_EOR_ATTACKER'),
				stringDef	= this.trans('WEB_GAME_EOR_DEFENDER'),
				stringRu	= this.trans('WEB_GAME_EOR_RU_TEAM'),
				stringUs	= this.trans('WEB_GAME_EOR_US_TEAM'),
				
				
				// Set correct team labels, depending on game mode
				label = function () {
					if (rushAttackingTeam && rushAttackingTeam !== 0) {
						return team === rushAttackingTeam ? stringAtt : stringDef;
					}
					return team === 1 ? stringRu : stringUs;
				},
				
				table = this.createView(APP.View.Table, {
					view: APP.View.EORTableRow,
					collection: collection,
					headers: [
						{
							'label': label,
							'key': 'name',
							'attrs': {
								'colspan': 2
							}
						},
						{
							'label': this.trans('WEB_GAME_EOR_KILL_DEATH_RATE'),
							'key': 'kd'
						},
						{
							'label': this.trans('WEB_GAME_EOR_SCORE'),
							'key': 'score'
						}
					]
				}),
				pad = [];
			
			// Pad the collection to 16 entries
			if (collection.length < 16) {
				_.times(16 - collection.length, function () {
					pad.push(null);
				});
				collection.add(pad);
			}
			
			return table;
		},
		
		showReadyButton: function showReadyButtonEORView() {
			this.readyButton.$el.css({
				'opacity': 1,
				'right': ''
			});
			return this;
		},
		
		hideReadyButton: function showReadyButtonEORView() {
			this.readyButton.$el.css({
				'opacity': 0,
				'right': -1000
			});
			return this;
		},
		
		/**
		 * Render Player
		 */
		renderPlayer: function renderPlayerEORView() {
			
			var container = this.make('div', {
					'class': 'player'
				}),
				
				heading = this.make('h2', null, this.trans('WEB_GAME_EOR_PERSONAL_STATS')),
				
				experience = this.make('div', {
					'class': 'experience'
				}),
				
				kit = this.make('div', {
					'class': 'class kit-' + this.model.get('kit')
				}),
				
				kd = this.make('div', {
					'class': 'kd'
				}),
				
				progressBar = this.make('span', { 
					'class': 'progress'
				}),
				progress = this.make('span'),
				bottom,
				levelProgression;
			
			// Heading
			heading.appendChild(this.make('span', null, this.model.get('name')));
			container.appendChild(heading);
			
			// Experience
			bottom = this.make('div');
			
			
			// Is not max level
			if (this.model.get('xpToNextLevel') > 0) {
				
				experience.appendChild(this.make('span', null, Math.max(0, this.model.get('xpToNextLevel') - this.model.get('xp')) + ' XP'));
				experience.innerHTML += this.trans('WEB_GAME_EOR_XP_TO_NEXT_LEVEL');
				
				bottom.appendChild(this.make('span', {
					'class': 'current'
				}, this.model.get('level')));
				
				bottom.appendChild(this.make('span', {
					'class': 'next'
				}, this.model.get('level') + 1));
				
				levelProgression = Math.round((this.model.get('xp') / this.model.get('xpToNextLevel')) * 100);
				if (levelProgression > 100) {
					levelProgression = 100;
				}
				progress.style.width = levelProgression + '%';
				
				
				progressBar.appendChild(progress);
				
			// Max Level
			} else {
				experience.appendChild(this.make('span', null, this.trans('WEB_GAME_EOR_LEVEL') + ' ' + this.model.get('level')));
				experience.innerHTML += this.trans('WEB_GAME_EOR_MAX') + ' ' + this.trans('WEB_GAME_EOR_LEVEL_REACHED');
				
				progressBar.className += ' full';
			}
			bottom.appendChild(progressBar);
			experience.appendChild(bottom);
			container.appendChild(experience);
			
			// Kit / Class
			kit.appendChild(this.make('div', null, this.trans('WEB_GAME_EOR_CLASS')));
			container.appendChild(kit);
			
			// Kill death ratio
			kd.appendChild(this.make('span', null, this.model.get('kd')));
			kd.appendChild(this.make('div', null, this.trans('WEB_GAME_EOR_KILL_DEATH_RATE')));
			container.appendChild(kd);			
			
			this.el.appendChild(container);
			
			return this;
		},
		
		/**
		 * Render Score
		 */
		renderStats: function renderStatsEORView() {
			
			var container = this.make('div', {
					'class': 'stats'
				}),
			
				heading = this.make('h2', null, this.trans('WEB_GAME_EOR_SCORE')),
				
				xp = this.make('div', { 
					'class': 'xp'
				}),
				credits = this.make('div', { 
					'class': 'credits'
				}),
				
				roundXP = parseInt(this.options.stats.roundXP, 10),
				roundBonusXP =  parseInt(this.options.stats.roundBonusXP, 10),
				roundVP =  parseInt(this.options.stats.roundVP, 10),
				roundBonusVP =  parseInt(this.options.stats.roundBonusVP, 10);
			
			container.appendChild(heading);
			
			// XP
			xp.appendChild(this.make('span', null, (roundXP - roundBonusXP) + String()));
			xp.appendChild(this.make('span', {
				'class': 'bonus'
			}, '+' + roundBonusXP));
			xp.appendChild(this.make('span', {
				'class': 'total'
			}, roundXP + String()));
			xp.appendChild(this.make('div', null, this.trans('WEB_GAME_EOR_XP')));
			container.appendChild(xp);
			
			// Credits
			credits.appendChild(this.make('span', null, (roundVP - roundBonusVP) + String()));
			credits.appendChild(this.make('span', {
				'class': 'bonus'
			}, '+' + roundBonusVP));
			credits.appendChild(this.make('span', {
				'class': 'total'
			}, roundVP + String()));
			credits.appendChild(this.make('div', null, this.trans('WEB_GAME_EOR_CREDITS')));
			container.appendChild(credits);	
			
			this.el.appendChild(container);
			
			return this;
		},
		
		/**
		 * Render Scoureboard
		 */
		renderScoreboard: function renderScoreboardEORView() {
			var scoreboard = this.make('div', {
					'class': 'scoreboard'
				}),
				team = this.model.get('team'),
				gameMode = this.options.gameMode,
				rushAttackingTeam = parseInt(this.options.rushAttackingTeam, 10),
				myTeam = this.createTeamTable(team, rushAttackingTeam),
				thierTeam = this.createTeamTable(team === 1 ? 2 : 1, rushAttackingTeam);
			
			myTeam.className += ' my-team';
			myTeam.options.container =  this.make('div');
			myTeam.render().attach();
			myTeam.select(this.model);
			
			
			thierTeam.className += ' thier-team';
			thierTeam.options.container = this.make('div');
			thierTeam.render().attach();
			
			scoreboard.appendChild(myTeam.options.container);
			scoreboard.appendChild(thierTeam.options.container);
			this.el.appendChild(scoreboard);
			
			return this;
		},
		
		
		/**
		 * Render Achievements
		 */
		renderAchievements: function renderAchievementsEORView() {
			
			var container = this.make('div', {
					'class': 'achievements'
				}),
				heading = this.make('h2', {
					'class': 'heading'
				}, this.trans('WEB_GAME_EOR_ACHIEVEMENTS_COMPLETED')),
				achievements = this.collection.getModelAchievements(this.model),
				list = this.make('div');
			
			// Best in class
			if (achievements.kit === 'platinum') {
				heading.appendChild(this.make('span', null, this.trans('WEB_GAME_ACHIEVEMENT_BEST_IN_CLASS_DESCRIPTION_' + this.model.get('kitName').toUpperCase())));
				list.appendChild(this.make('span', {
					'class': 'kit-' + this.model.get('kit') + ' ' + achievements.kit
				}));
			}
			
			container.appendChild(heading);
			container.appendChild(list);
			this.el.appendChild(container);
			
			return this;
			
		},
		
		/**
		 * Render
		 */
		render: function renderEORView() {
			
			this.$el.addClass('hide');
			
			var team = this.model.get('team'),
				
				flag = this.make('div', {
					'class': 'flag big'
				}),
				readyButtonContainer = this.make('div', {
					'class': 'ready-button-container'
				});
			
			this.$el.addClass(team === this.options.winner ? 'won' : 'lost');
			this.$el.addClass(this.options.gameMode);
			this.$el.addClass(this.model.get('teamName').toLowerCase());
			
			this.el.appendChild(flag);
			
			if (this.isAttached) {
				this.once('attach', function () {
					flag.className = 'flag';
				});
			} else {
				this.once('render', function () {
					flag.className = 'flag';
				});
			}
			
			// Player Stats
			this.renderPlayer();	
			
			// Player Score
			this.renderStats();	
			
			// Scoreboard
			this.renderScoreboard();
			
			// Achievements
			this.renderAchievements();
			
			// Ready button
			this.readyButton = this.createView(APP.View.Button, {
				container: readyButtonContainer,
				className: 'play',
                large: true,
                glyph: 'arrow',
				text: this.trans('WEB_GAME_EOR_READY_BTN')
			}, 'ready').render().attach();
			this.el.appendChild(readyButtonContainer);
			
			this.hideReadyButton();
			
			setTimeout(_.bind(function () {
				this.$el.removeClass('hide');
			}, this), 100);
		}
	});
	
}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule eor
 */
(function (root) {
	"use strict";
	
	
	var APP = root.APP,
		_ = APP._,
		$ = APP.$,
		parent = APP.View.Overlay.prototype;
		
	APP.View.EORAD = APP.View.Overlay.extend({
		name: 'eorad-view',
		tagName: 'div',
		
		events: {
			'click a.close': '_onClickClose'
		},
		
		initialize: function initializeEORADView() {
			parent.initialize.apply(this, arguments);
			this.offer = this.options.offer;
		},
		
		_onClickClose: function _onClickCloseEORADView() {
			this.trigger('close');
		},
		
		/**
		 * Render the view
		 */
		render: function renderEORADView() {
			
			var nsConfig = APP.ns('config'),
				title = this.make('h1', null, this.trans('WEB_GAME_EORAD_HEAD_KIT_' + this.options.persona.kit) + ':'),
				img = this.make('img', {
					'src': nsConfig.imageFolder + '/game/1x1-transparent.png',
					'width': nsConfig.imageSize.max.width,
					'height': nsConfig.imageSize.max.height,
					'class': 'loading'
				}),
				bottom = this.make('div', {
					'class': 'bottom'
				}),
				oldPrice,
				price,
				button,
				attachedItems,
				src;
			
			// Close
			this.el.appendChild(this.make('a', {
				'class': 'close'
			}));
			
			// Title
			title.appendChild(this.make('span', null, this.model.get('name')));
			this.el.appendChild(title);
			
			// Image
			if (this.model.isCustomizable()) {
				attachedItems = this.collection.getModelAttachedItems(this.model);
				if (attachedItems.texture) {
					src = attachedItems.texture.getAttachmentImage('max');
				} else {
					src = nsConfig.imageFolder + 'attachment-icons/max/weapon_texture.png';
				}
			} else {
				src = this.model.getImage('max');
			}
			this.el.appendChild(img);
			this.$(img).disableTextSelect();
			
			// Preload Image
			APP.preload.image(src, function (err) {
				if (err) {
					src = nsConfig.imageFolder + 'attachment-icons/max/weapon_texture.png';
				}
				img.src = src;
				img.className = '';
			});
			
			
			// Discount
			if (this.offer.isDiscounted()) {
				// Discount stamp
				this.el.appendChild(this.make('span', {
					'class': 'discount-stamp'
				}, Math.floor(100 - (100 * (this.offer.get('price') / this.offer.get('originalPrice')))) + '%'));
				
				// Old price
				oldPrice = this.make('div', { 'class': 'discount' }, this.trans('WEB_GAME_EORAD_OLD_PRICE_LABEL'));
				oldPrice.appendChild(this.make('span', {
					'class': this.offer.get('currency')
				}, this.offer.get('originalPrice')));
				bottom.appendChild(oldPrice);
			} else {
				// Ugly placeholder
				bottom.appendChild(this.make('div'));
			}
			
			// Price
			price = this.make('div', { 'class': 'price' }, this.trans('WEB_GAME_EORAD_PRICE_LABEL'));
			price.appendChild(this.make('span', {
				'class': this.offer.get('currency')
			}, this.offer.get('price')));
			bottom.appendChild(price);
			
			// Buy Button
			button = this.make('div');
			this.createView(APP.View.Button, {
				container: button,
				className: 'buy',
				text: this.trans('WEB_GAME_EORAD_BUY_BUTTON'),
				attrs: {
					href: '#/eor-offer/' + this.offer.id
				}
			}, 'button').render().attach();
			bottom.appendChild(button);
			
			this.el.appendChild(bottom);
		}
	});
	
}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule eor
 */
/**
 * @class GAME.Task.eor
 * @uses GAME.Task.game
 * @uses GAME.Task.items
 * @uses GAME.Task.config
 */
APP.task('eor', [ 'game', 'items', 'config' ], function taskEOR(done) {
	"use strict";
	
	
	var $ = APP.$,
		_ = APP._,
		win = APP.win,
		
		nsEOR = APP.ns('eor'),
		nsGame = APP.ns('game'),
		nsItems = APP.ns('items'),
		nsConfig = APP.ns('config'),
		
		/**
		 * Get End Of Round Data
		 */
		getEndOfRoundData = function getEndOfRoundData(fn) {
			if (win.hasOwnProperty('eor')) {
				_.defer(function () {
					var data;
					try {
						data = JSON.parse(win.eor.data);
					} catch (err) {
						fn(err);
					}
					fn(null, data);
				});
				
			} else {
				$.ajax({
					url: 'http://battlefield.play4free.com/static/eor-data.json',
					dataType: 'json',
					cache: false,
					error: function onError(xhr, status, err) {
						fn(err);
					},
					success: function onSuccess(res) {
						fn(null, res);
					}
				});
			}
		},
		
		view,

		destroyEORView = function destroyEORView() {
			if (view) {
				view.destroy();
				view = nsEOR.view = null;
			}
		},
		
		createEORView = function createEORView() {
			destroyEORView();
			view = nsEOR.view = new APP.View.EOR();
			view.attach();
			
			// 
			nsGame.asyncPaint();
		},
		
		/**
		 * Show End Of Round
		 */
		showEOR = nsEOR.show = function show() {
			if (!view) {
				createEORView();
			}
			
			// Get Data
			getEndOfRoundData(function gotEndOFRoundData(err, data) {
				APP.log('EORTask - showEOR#gotEndOFRoundData', err, data);
				
				if (err) {
					APP.log.error(err);
					return nsGame.quit();
				}
				
				var players = data.teams[0].players.concat(data.teams[1].players);
				
				// Players
				nsEOR.players = new APP.Collection.EORPlayers(players);
				
				// Player
				nsEOR.player = nsEOR.players.get(data.localPlayer.name);
				
				if (win.soldier) {
					nsEOR.player.set({
						xp: win.soldier.xp,
						level: win.soldier.level,
						xpToNextLevel: win.soldier.xpToNextLevel
					});
				} else {
					nsEOR.player.set({
						xp: 56018,
						level: 22,
						xpToNextLevel: 50000
					});
				}
				
				// Set options and data
				view.model = view.options.model = nsEOR.player;
				view.collection = view.options.collection = nsEOR.players;
				view.options.winner = parseInt(data.winner, 10);
				view.options.stats = data.stats;
				view.options.gameMode = data.gameMode;
				view.options.rushAttackingTeam = data.rushAttackingTeam;
				
				
				// Render view
				view.render();
				
				// Ready
				view.bind('ready', function () {
					win.playSound('Ready', 'Click EOR ready button');
					if (nsGame.model.get('roundState') === 3) {
						_.delay(nsGame.startNewRound, 500);
					}
				});
				
				// Confirm Close
				view.bind('close', function onCloseEOR() {
					var dialog = new APP.View.Dialog(),
						destroyDialog = function destroyDialog() {
							dialog.destroy();
							dialog = null;
						};
					
					dialog.setRenderData({
						title: 'Confirm <span>Quit game</span>',
						body: 'Are you sure you wish quit the current game?',
						close: true,
						buttonLeft: 'No, stay and play',
						buttonRight: 'Yes, quit now'
					});
					
					dialog.bind('close', destroyDialog);
					
					dialog.bind('button:left', destroyDialog);
					
					dialog.bind('button:right', function () {
						destroyDialog();
						nsGame.quit();
					});
					
					dialog.render();
					dialog.attach();
					
					dialog.show();
				});
			});
		},
		
		/**
		 * Hide End Of Round
		 */
		hide = nsEOR.hide = function hide() {
			if (view) {
				view.$el.empty();
			}
		},
		
		/**
		 * Fetch Offer
		 */
		fetchOffer = function fetchOffer(fn) {
			if (!nsConfig.model.get('forceEORAD')) {
				if (!nsConfig.showEorAds) {
					return _.delay(fn, 0, new Error('EORAD\'s is disabled!'));
				}
				
				if (nsConfig.model.get('hasSeenEORAD')) {
					return _.delay(fn, 0, new Error('EORAD\'s has already been seen!'));
				}
				
				var i = APP.randomInt(0, nsConfig.adFrequency),
					x = APP.randomInt(0, nsConfig.adFrequency);
				
				if (i !== x) {
					return _.delay(fn, 0, new Error('Not in adFrequency'));
				}
			}
			
			// Ask backend to give us offer
			$.ajax({
				url: 'http://battlefield.play4free.com/en/ads/getEORAd',
				dataType: 'json',
				cache: false,
				data: {
					kit: nsGame.persona.get('kit'),
					personaId: nsGame.persona.id
				},
				error: function onError(xhr, status, err) {
					fn(err);
				},
				success: function onSuccess(res) {
					if (res && res.status === 'success' && !_.isEmpty(res.data)) {
						fn(null, res.data);
					} else {
						fn(new Error('No ads for you'));
					}
				}
			});
		},
		
		/**
		 * Send Tracklog
		 */
		sendTracking =  function sendTracking(data, fn) {
			$.ajax({
				url: 'http://battlefield.play4free.com/en/dc/submitData',
				type: 'post',
				data: JSON.stringify([ { "table": "adclicks", "data":  data } ]),
				dataType: 'json',
				cache: false,
				complete: fn
			});
		},
		
		
		/**
		 * Ready For next round
		 */
		readyForNextRound = function readyForNextRound() {
			fetchOffer(function onOfferFetched(err, data) {
				if (!err) {
					var model = nsItems.collection.get(data.itemId),
						offer = new APP.Model.Offer(data),
						eorad = nsEOR.eorad = new APP.View.EORAD({
							collection: nsItems.collection,
							model: model,
							offer: offer,
							persona: nsConfig.persona
						}),
						trackingData = {
							"pid": nsConfig.persona.id,
							"itemid": model.id,
							"offerid": offer.id,
							"viewstate": "viewed",
							"spot": "eor"
						};
					
					/**
					 * Send Tracking
					 */
					sendTracking(trackingData, function onViewedTrackingSent() {
						
						/**
						 * On Close
						 */
						eorad.bind('close', function onEORADClose() {
							/**
							 * Send Tracking data
							 */
							trackingData.viewstate = "dismissed";
							sendTracking(trackingData, function onDismissedTrackingSent() {
								eorad.destroy();
								eorad = null;
							});
						});
						
						/**
						 * On Buy
						 */
						eorad.bind('button:click', function onButtonClick() {
							/**
							 * Send Tracking data
							 */
							trackingData.viewstate = "clicked";
							sendTracking(trackingData, function onClickedTrackingSent() {
								APP.navigate('/eor-offer/' + offer.id);
								eorad.destroy();
								eorad = null;
								nsGame.quit();
							});
						});
						
						// Render -> Attach -> Show
						eorad.render().attach().show();
												
						// User has seen the ad
						nsConfig.model.set({
							'hasSeenEORAD': true
						});
						
						// Show ready button
						if (view) {
							view.showReadyButton();
						}
					});
					
				// Show ready button
				} else if (view) {
					view.showReadyButton();
				}
			});
		};
	
	
	
	/**
	 * On Game state change
	 */
	nsGame.model.bind('change:roundState', function onRoundStateChange() {
		if (view) {
			if (nsGame.model.get('roundState') === 3) {
				readyForNextRound();
			} else {
				view.hideReadyButton();
			}
		}
	});
	
	
	// On new round
	nsGame.bind('round:new', function () {
		APP.log('EORTask - round:new');
		createEORView();
	});
	// Screen Load
	nsGame.bind('screen:load', function () {
		APP.log('EORTask - screen:load');
		destroyEORView();
	});
	// Screen EOR
	nsGame.bind('screen:eor', function () {
		APP.log('EORTask - screen:eor');
		showEOR();
	});
	// Screen Main
	nsGame.bind('screen:main', function () {
		APP.log('EORTask - screen:main');
		destroyEORView();
	});
	
	
	/**
	 * EORAD route
	 *
	 * TODO: Move to a separate task
	 *
	 */
	APP.route('eorad/:offer', 'eorad', function (offerId) {
		nsItems.getItemByOfferId(offerId, function (err, model, offers) {
			APP.navigate('');
			
			if (err) {
				return APP.log.warn(err);
			}
			
			var offer = offers.at(0),
				eorad = nsEOR.eorad = new APP.View.EORAD({
					collection: nsItems.collection,
					model: model,
					offer: offer,
					persona: nsConfig.persona
				});
			
			/**
			 * On Close
			 */
			eorad.bind('close', function onEORADClose() {
				eorad.destroy();
				eorad = null;
			});
			
			
			/**
			 * On Buy
			 */
			eorad.bind('button:click', function onButtonClick() {
				eorad.destroy();
				eorad = null;
				if (nsGame.isPlaying()) {
					APP.navigate('/offer/' + offer.id);
					nsGame.quit();
				} else {
					APP.navigate('/offer/' + offer.id, true);
				}
			});
			
			
			// Render -> Attach -> Show
			eorad.render().attach().show();
		});
	});
	
	
	/**
	 * Give me ad
	 */
	/*$(win).cheat('give me ad', function onCheat() {
		
		var items = nsItems.collection.filterBy({
				itemType: 'weapon',
				buyable: true,
				validationGroup: 'primary'
			}),
			model = items.at(APP.randomInt(0, items.length - 1)),
			offers = model.get('offers'),
			offer = offers.at(APP.randomInt(0, offers.length - 1)),
			eorad = nsEOR.eorad = new APP.View.EORAD({
				collection: nsItems.collection,
				model: model,
				offer: offer,
				persona: nsConfig.persona
			});
		
		APP.navigate('/eorad/' + offer.id, true);
	});*/
	
	
	/**
	 * Task Done
	 */
	done();
});
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule preload
 */
/**
 * @class GAME.Task.servers.routes
 * @uses GAME.Task.config
 * @uses GAME.Task.weapons
 */
APP.task('preload', [ 'config', 'weapons' ], function taskPreload(done) {
	"use strict";
	
	var win = APP.win,
		$ = APP.$,
		_ = APP._,
		basePath = $.magma.jsVariables.imageFolder,
		images = [],
		preloadDone = _.after(2, done),
		weapons = APP.ns('items').collection.filterBy({
			itemType: 'weapon'
		}),
		compostedWeaponImages = _.after(weapons.length * 2, function () {
			APP.log.timeEnd('pre-compose weapon images: ' + weapons.length);
			preloadDone();
		});

	APP.log.time('pre-compose weapon images: ' + weapons.length);
	weapons.invoke('composeImage', 'med', compostedWeaponImages);
	weapons.invoke('composeImage', 'min', compostedWeaponImages);
	
	
	images.push(basePath + 'game/bg.jpg');
    images.push(basePath + 'game/containers/column_box.jpg');
    images.push(basePath + 'game/containers/column_box_large.jpg');
    images.push(basePath + 'game/progress_bar-dark.png');
    images.push(basePath + 'game/progress_bar-empty.png');
    images.push(basePath + 'game/soldierlist-bg.jpg');
	images.push(basePath + 'game/checkbox-icon.png');
	
    images.push(basePath + 'game/maps/karkand.jpg');
    images.push(basePath + 'game/maps/oman.jpg');
    images.push(basePath + 'game/maps/sharqi.jpg');
    images.push(basePath + 'game/maps/basra.jpg');
    images.push(basePath + 'game/maps/dragonvalley.jpg');
    images.push(basePath + 'game/maps/dalianplant.jpg');
	
    images.push(basePath + 'game/table-header.gif');
    images.push(basePath + 'game/sort-arrows.png');
    images.push(basePath + 'game/headers-selected.jpg');
    images.push(basePath + 'game/headers-selected_grey.png');
    images.push(basePath + 'game/serverbrowser-icons.png');
	
	images.push(basePath + 'game/bg-noise-620px.jpg');
	images.push(basePath + 'game/bg-noise-darker-620px.jpg');
	images.push(basePath + 'game/bg-noise-dark2-620px.jpg');
	
	images.push(basePath + 'game/attachment-label-sprite.png');
	
	images.push(basePath + 'item-icons/items-ability.png');
	images.push(basePath + 'item-icons/items-min.png');
	images.push(basePath + 'item-icons/items-upgrade-min.png');
	images.push(basePath + 'item-icons/items-upgrade-med.png');
    
    images.push(basePath + 'game/credits-25.png');
    images.push(basePath + 'game/funds-25.png');
	
	images.push(basePath + 'class-icons/engineer.png');
    images.push(basePath + 'class-icons/medic.png');
    images.push(basePath + 'class-icons/assault.png');
    images.push(basePath + 'class-icons/recon.png');
	
    images.push(basePath + 'game/abilities-bg.jpg');
    images.push(basePath + 'game/buy-mock.png');
    
	images.push(basePath + 'game/game-menu.jpg');
    images.push(basePath + 'game/menu-arrow.png');    
    images.push(basePath + 'game/play-arrow.png');
    images.push(basePath + 'game/header-arrow.png');
    images.push(basePath + 'game/icon-bg.png');    
    images.push(basePath + 'game/item-hover.jpg');
    images.push(basePath + 'game/headers.jpg');
    images.push(basePath + 'game/headers-selected.jpg');
    images.push(basePath + 'game/tiled-background-large.jpg');
    
    // EOR
	images.push(basePath + 'game/map-default.jpg');
	/*
    images.push(basePath + 'game/map-karkand-victory.jpg');
    images.push(basePath + 'game/map-karkand-defeat.jpg');
    images.push(basePath + 'game/map-oman-victory.jpg');
    images.push(basePath + 'game/map-oman-defeat.jpg');
    images.push(basePath + 'game/map-sharqi-victory.jpg');
    images.push(basePath + 'game/map-sharqi-defeat.jpg');
	*/
	images.push(basePath + 'game/store_sprites.png'); 
    images.push(basePath + 'game/store_warnings.png');
	
    images.push(basePath + 'game/customization-case.png');
    images.push(basePath + 'game/customization-icon-sprite.png');
	
	// Dialog icons
    images.push(basePath + 'game/dialog-icons/apparel-exclaim.png');
    images.push(basePath + 'game/dialog-icons/battlefunds.png');
    images.push(basePath + 'game/dialog-icons/default.png');
    images.push(basePath + 'game/dialog-icons/error.png');
    images.push(basePath + 'game/dialog-icons/keys-exclaim.png');
    images.push(basePath + 'game/dialog-icons/keys-questionmark.png');
	images.push(basePath + 'game/dialog-icons/reset.jpg');
	
	
	images.push(basePath + 'game/pockets-sprite.png');
	
	if (!win.doll) {
		images.push(basePath + 'game/bf-doll.png');
	}

	APP.log.time('Preload images');
	APP.preload.image(images, function () {
		APP.log.timeEnd('Preload images');
		preloadDone();
	});
});
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule error
 */
/**
 * @class GAME.Task.error
 * @uses GAME.Task.sidis
 */
APP.domTask('error', ['sidis'], function initializeErrors(done) {
	"use strict";
	
	var $ = APP.$,
		_ = APP._,
		win = APP.win,
		baseData = {
			title: APP.sidis.trans('WEB_COMMON_ERROR'),
			buttonRight: APP.sidis.trans('WEB_GAME_TOOLTIPS_OK_BTN')
		},
		errorDialogView,
		reload = function () {
			if (errorDialogView) {
				errorDialogView.destroy();
			}
			APP.log('APP.View.Dialog:reload');
			APP.reload();
		},
		
		onApplicationError = function onApplicationError(err) {
			if (typeof err === 'string') {
				err = { body: err };
			} else if (err instanceof Error) {
				err = { body: err.message };
			} else if (_.isArray(err)) {
				err = { body: '<p>' + err.join('</p><p>') + '</p>' };
			}
			
			if (errorDialogView) {
				errorDialogView.destroy();
				errorDialogView = null;
			}
			
			var data = _.extend({}, baseData, err);
			
			errorDialogView = new APP.View.Dialog({
				className: 'error-dialog',
				renderData: data
			});
			
			// Bind events
			errorDialogView.bind('close', reload);
			errorDialogView.bind('button:right', reload);
			
			errorDialogView.attach();
			
			errorDialogView.render();
			
			errorDialogView.show();
		};
	
	
	/**
	 * On APP errors
	 */
	APP.once('error', onApplicationError);
	
	/**
	 * Task Done
	 */
	done();
});
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule game
 */
(function (win) {
	"use strict";
	
	if (!win.APP && (typeof require !== 'undefined')) {
		win.APP = require('../common/app');
	}
	
	var APP = win.APP,
		parent = APP.Model.prototype,
		_ = APP._,
		STATE_MAP = {
			0: 'WEB_GAME_TOOLTIPS_MESSAGE_READY',
			1: 'WEB_GAME_TOOLTIPS_MESSAGE_SEARCH',
			2: 'WEB_GAME_TOOLTIPS_MESSAGE_CANCELING',
			3: 'WEB_GAME_TOOLTIPS_MESSAGE_CANCELED',
			4: 'WEB_GAME_TOOLTIPS_MESSAGE_QUEUE',
			5: 'WEB_GAME_TOOLTIPS_MESSAGE_JOINING',
			6: 'WEB_GAME_TOOLTIPS_MESSAGE_JOINED',
			7: 'WEB_GAME_TOOLTIPS_MESSAGE_LEAVING',
			8: 'WEB_GAME_TOOLTIPS_MESSAGE_LEFT',
			9: 'WEB_GAME_TOOLTIPS_MESSAGE_ERROR',
			90: 'WEB_GAME_TOOLTIPS_MESSAGE_WRONG_PASSWORD'
		},
		ERROR_MAP = {
			0: 'WEB_GAME_TOOLTIPS_MESSAGE_ERROR_0',
			1: 'WEB_GAME_TOOLTIPS_MESSAGE_ERROR_1',
			2: 'WEB_GAME_TOOLTIPS_MESSAGE_ERROR_2'
		};
    
	
	/**
	 * Model: Game
	 */
	APP.Model.Game = APP.Model.extend({
		
		STATE_READY: 0,
		STATE_SEARCHING: 1,
		STATE_CANCELING_SEARCH: 2,
		STATE_CANCELED_SEARCH: 3,
		STATE_IN_QUEUE: 4,
		STATE_JOINING: 5,
		STATE_JOINED: 6,
		STATE_LEAVING: 7,
		STATE_LEFT: 8,
		STATE_ERROR: 9,
		STATE_INVALID_PASSWORD: 90,
		
		ERROR_FAILED: 1,
		ERROR_TIME_OUT: 2,
		
		defaults: {
			'version': 0,
			'state': 0,
			'roundState': 0
		},
		schema: {
			state: 'number',
			roundState: 'number',
			queuePosition: 'number',
			queueSize: 'number'
		},
		
		initialize: function initializeGameModel() {
			
			// State
			this.bind('change:state', this._processState, this);
			this._processState();
		},
		
		isStateCancelable: function () {
			var state = this.get('state');
			return (state === this.STATE_READY || state === this.STATE_SEARCHING || state === this.STATE_IN_QUEUE);
		},
		
		_processState: function _processStateGameModel() {
			
			var state = this.get('state'),
				attrs = {
					stateName	: STATE_MAP[state],
					error		: (win.matchmaking && win.matchmaking.lastError) || 0
				};
						
			attrs.errorName = ERROR_MAP[attrs.error] || 'unknown';
			
			this.set(attrs);
		}
	});
	
	
	
	/**
	 * Module support
	 */
	if (typeof module !== 'undefined' && module.exports) {
		module.exports = APP.Model.Game;
	}
}(this));

/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule game
 */
(function (root) {
	"use strict";
	
	if (!root.APP && (typeof require !== 'undefined')) {
		root.APP = require('../common/app');
	}
	
	var APP = root.APP,
		parent = APP.Model.prototype,
		_ = APP._;
    
	
	/**
	 *  Model: Persona
	 */
	APP.Model.Persona = APP.Model.extend({
		defaults: {
			name: '',
			isMaxLevel: false,
			level: 0,
			nextLevel: 0,
			xp: 0,
			xpForNextLevel: 0,
			xpToNextLevel: 0,
			levelUpProgression: 0,
			levelDescription: ''
		},
		schema: {
			'level'				: 'number',
			'nextLevel'			: 'number',
			'xp'				: 'number',
			'xpForNextLevel'	: 'number',
			'xpToNextLevel'		: 'number',
			'levelUpProgression': 'number',
			
			'isMaxLevel': 'boolean'
		},
		initialize: function initializePersonaModel() {
			this._setNextLevel();
			this.bind('change:level', this._setNextLevel, this);
			
			this._setXpToNextLevel();
			this.bind('change:xpForNextLevel', function () {
				this._setXpToNextLevel();
				this._setLevelUpProgression();
			}, this);
			this.bind('change:xp', function () {
				this._setXpToNextLevel();
				this._setLevelUpProgression();
			}, this);
		},
		_setNextLevel: function _setNextLevelPersonaModel() {
			this.set({
				nextLevel: this.get('level') + 1
			});
		},
		_setXpToNextLevel: function _setXpToNextLevelPersonaModel() {
			this.set({
				xpToNextLevel: Math.max(0, this.get('xpForNextLevel') - this.get('xp'))
			});
		},
		_setLevelUpProgression: function _setLevelUpProgressionPersonaModel() {
			this.set({
				levelUpProgression: Math.floor((this.get('xp') / this.get('xpForNextLevel')) * 100)
			});
		}
	});
	
	
	/**
	 * Module support
	 */
	if (typeof module !== 'undefined' && module.exports) {
		module.exports = APP.Model.Persona;
	}
}(this));

/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule game
 */
(function (root) {
	"use strict";
	
	if (!root.APP && (typeof require !== 'undefined')) {
		root.APP = require('../common/app');
	}
	
	if (!root.APP.Model && (typeof require !== 'undefined')) {
		root.APP.Collection = require('../common/collection');
	}
	
	if (!root.APP.Model.Persona && (typeof require !== 'undefined')) {
		root.APP.Model.Persona = require('./model.persona');
	}
	
	var APP = root.APP,
		win = APP.win,
		nsConfig = APP.ns('config'),
		_ = APP._,
		$ = APP.$;
	
	
	/**
	 *  Personas Collection
	 */
	APP.Collection.Personas = APP.Collection.extend({
		model: APP.Model.Persona,
		url: function () {
			return nsConfig.personasUrl;
		},
		parse: function (response) {
			return response && response.data && response.data.personas;
		}
	});
	
	
	/**
	 * Module support
	 */
	if (typeof module !== 'undefined' && module.exports) {
		module.exports = APP.Collection.Personas;
	}
}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule game
 */
(function (root) {
	"use strict";
	
	
	var APP = root.APP,
		win = APP.win,
		$ = APP.$,
		_ = APP._,
		parent = APP.View.Dialog.prototype;



	/**
	 * Invalid
	 */
	APP.View.InvalidDialog = APP.View.Dialog.extend({
		name: parent.name + ' invalid-dialog-view',
		
		events: _.extend({}, parent.events, {
			'mouseenter li div > i.glyphs': function (e) {
				var id = this.$(e.currentTarget).closest('li').attr('item-id'),
					model = this.collection.get(id);
				
				if (model) {
					this.trigger('glyph:enter', this, model, e);
				}
			},
			'mouseleave li div > i.glyphs': function (e) {
				var id = this.$(e.currentTarget).closest('li').attr('item-id'),
					model = this.collection.get(id);
					
				if (model) {
					this.trigger('glyph:leave', this, model, e);
				}
			}
		}),

		/**
		 * Initialize
		 */
		initialize: function initializeInvalidDialogView() {
			parent.initialize.apply(this, arguments);
			
			this._modelState = {};
			
			this._unboughtItems = this.collection.filterBy({
				owned: false,
				expired: false
			});
			
			this._expiredItems = this.collection.filterBy({
				expireTS: function (ts) {
					return !!ts;
				},
				expired: true
			});
			
			this._soonItems = this.collection.getExpiringSoon(this.options.soonTS);
			
			this._lowItems = this.collection.getLowUseCount(this.options.lowLimit);
						
			this._invalidItems = this._unboughtItems.models.concat(this._expiredItems.models);
			
			
			this.collection.bind('purchase:start', this._onPurchaseStart, this);
			this.collection.bind('purchase:end', this._onPurchaseEnd, this);
			
			
			this.bind('unequip:click', this._onUnequipClick, this);
			
			this.bind('buy:click', this._onBuyClick, this);
		},
		

		destroy: function destroyInvalidDialogView() {
			parent.destroy.apply(this, arguments);
			this.collection.unbind('purchase:start', this._onPurchaseStart, this);
			this.collection.unbind('purchase:end', this._onPurchaseEnd, this);
		},


		/**
		 * Get Model State
		 * @param {Model} model
		 * @return {Object}
		 * @private
		 */
		_getModelState: function (model) {
			if (!this._modelState[model.id]) {
				this._modelState[model.id] = {};
			}
			return this._modelState[model.id];
		},
		/**
		 * Clear Model State
		 * @param {Model} model
		 * @return {this} for chaining 
		 * @private
		 */
		_clearModelState: function (model) {
			this._modelState[model.id] = {};
			return this;
		},
		
		
		_onPurchaseStart: function _onPurchaseStartInvalidDialogView(model) {
			this._getModelState(model).loading = true;
			this.render();
		},
		_onPurchaseEnd: function _onPurchaseEndStartInvalidDialogView(model) {
			var modelState = this._getModelState(model);
			
			modelState.loading = false;
			
			if (model.isConsumable()) {
				modelState.valid = (model.get('usecount') > this.options.lowLimit);
				
			} else if (model.isOwned()) {
				modelState.valid = true;
				modelState.purchased = true;
			}
			
			this.render();
		},

		/**
		 * Unequip
		 * @param view
		 * @private
		 */
		_onUnequipClick: function _onUnequipClick(view) {
			var model = view.model;
			if (model) {
				this.trigger('unequip', this, model);
				this._getModelState(model).valid = true;
				this._getModelState(model).unequipped = true;
				this.render();
			}
		},


		/**
		 * Unequip
		 * @param view
		 * @private
		 */
		_onBuyClick: function _onBuyClick(view) {
			var model = view.model;
			if (model) {
				this.trigger('buy', this, model);
			}
		},
		
		
		_checkValid: function _checkValid() {
			var isInvalid = _.some(this._invalidItems, function (model) {
					var valid = !!this._getModelState(model).valid;
					return valid === false;
				}, this);
			
			this._isValid = !isInvalid;
		},

		/**
		 * Render List
		 * @param {APP.Collection} collection
		 * @param {string} type
		 * @return {HTMLUListElement}
		 * @private
		 */
		_renderList: function (collection, type) {
			var list = this.make('ul', {
					'class': 'list'
				}),
				glyphMap = {
					expired: 'exclaim-expired',
					expiring: 'exclaim-rented',
					unbought: 'exclaim-error',
					low: 'exclaim-info'
				};
			
			collection.forEach(function (model) {
				var li = this.make('li', {
						'item-id': model.id,
						'class': 'border-box type-' + type
					}),
					inner = this.make('div'),
					modelState = this._getModelState(model);
				
				inner.appendChild(this.make('i', {
					'class': 'glyphs glyphs-' + (modelState.valid ? 'exclaim-check' : glyphMap[type])
				}));
				

				inner.appendChild(this.make('span', {
					'class': 'name'
				}, model.get('name')));

				inner.appendChild(this.make('span', {
					'class': 'category'
				}, model.get('categoryname')));

				li.appendChild(inner);
				
				// Unequipped
				if (modelState.unequipped) {
					inner.appendChild(this.make('span', {
						'class': 'label-unequipped'
					}, this.trans('WEB_GAME_ITEM_ACTION_UNEQUIPPED')));
				
				// Purchased
				} else if (modelState.purchased) {
					inner.appendChild(this.make('span', {
						'class': 'label-purchased'
					}, this.trans('WEB_GAME_ITEM_ACTION_PURCHASED')));
				
				// Actions
				} else {
					// Unequip 
					if ((type === 'unbought' || type === 'expired')) {
						this.createView(APP.View.Button, {
							container	: li,
							model		: model,
							text		: this.trans('WEB_GAME_COMMON_BTN_UNEQUIP')
						}, 'unequip').render().attach();
					}

					// Buyable?
					if (model.isBuyable()) {
						this.createView(APP.View.Button, {
							container	: li,
							primary		: true,
							glyph		: 'buy',
							model		: model,
							text		: this.trans('WEB_GAME_TOOLTIPS_BUY_BTN')
						}, 'buy').render().attach();
					}
				}
				
				// State Loading
				if (modelState.loading) {
					li.className += ' loading';
				}
				
				list.appendChild(li);
			}, this);
			
			return list;
		},
		
		/**
		 * Render
		 */
		render: function renderInvalidDialogView() {

			this._checkValid();
			
			this.$el.addClass('border-box');
			
			var body = this.make('div', {
					'class': 'body'
				}),
				scrollContainer = this.make('div', {
					'class': 'scroll-container'
				}),
				bottom = this.make('div', {
					'class': 'bottom'
				}),
				playButton;
			
			this.el.appendChild(this.make('h1', {
				'class': 'title'
			}, this.trans('WEB_INVALID_EQUIPMENT_HEADER')));

			this.el.appendChild(this.make('a', {
				'class': 'close',
				'href': '#close'
			}));

			body.appendChild(this.make('h2', null, this.trans('WEB_INVALID_EQUIPMENT_SUBHEADER')));
			
			// Unbought
			if (this._unboughtItems.length !== 0) {
				scrollContainer.appendChild(this.make('h3', null, this.trans('WEB_GAME_TOOLTIPS_HEADER_UNBOUGHT_ITEMS')));
				scrollContainer.appendChild(this._renderList(this._unboughtItems, 'unbought'));
			}

			// Expired
			if (this._expiredItems.length !== 0) {
				scrollContainer.appendChild(this.make('h3', null, this.trans('WEB_GAME_HEAD_EXPIRED_ITEMS')));
				scrollContainer.appendChild(this._renderList(this._expiredItems, 'expired'));
			}

			// Expiring soon
			if (this._soonItems.length !== 0) {
				scrollContainer.appendChild(this.make('h3', null, this.trans('WEB_GAME_HEAD_EXPIRING_ITEMS')));
				scrollContainer.appendChild(this._renderList(this._soonItems, 'expiring'));
			}

			// Low use count
			if (this._lowItems.length !== 0) {
				scrollContainer.appendChild(this.make('h3', null, this.trans('WEB_GAME_HEAD_LOWCOUNT_ITEMS')));
				scrollContainer.appendChild(this._renderList(this._lowItems, 'low'));
			}
			
			body.appendChild(this.make('div', {
				'class': 'scroll-well'
			}));
			body.appendChild(scrollContainer);
			this.el.appendChild(body);
			
			
			playButton = this.createView(APP.View.Button, {
				container	: bottom,
				large		: true,
				glyph		: 'arrow',
				text		: this.trans('WEB_GAME_TOOLTIPS_PLAY_BTN')
			}, 'play').render().attach();
			
			if (!this._isValid) {
				playButton.disable();
			}
			
			this.el.appendChild(bottom);
		}
	});
}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule game
 */
(function (root) {
	"use strict";
	
	
	var APP = root.APP,
		win = APP.win,
		$ = APP.$,
		_ = APP._;

	
	
	/**
	 * Join View
	 */
	APP.View.Join = APP.View.extend({
		name: 'join-view',
		
		events: {
			'keydown div.server-password input': function onPasswordInput(e) {
				clearTimeout(this._keytimer);
				this._keytimer = setTimeout(_.bind(this._checkPasswordLength, this), 0);
			},
			'keypress div.server-password input': function onPasswordKeyPress(e) {
				if (e.keyCode === 13) {
					var length = ($('div.server-password input').val() || '').length;
					if (length !== 0) {
						this._onClickJoin();
					}
				}
			}
		},
		
		initialize: function initializeJoinView() {
			
			this._waiting = false;

			this.server = this.options.server;
			
			this.model.bind('change:state', this._onChangedState, this);

			this.model.bind('change:queue', this._onQueueChange, this);
			
			// Do we need to fetch the server
			/*
			if (this.server && this.model.get('state') !== this.model.STATE_ERROR) {
				// Do we need to fetch the server
				if (this.server.get('players') !== this.server.get('gameRoster').length) {
					this._waiting = true;
					this.server.fetch({
						success: _.bind(function () {
							this._waiting = false;
							this.render();
						}, this)
					});
				}
			}
			*/
	
			// Clicking
			this.bind('join:click', this._onClickJoin, this);
			
			this.bind('cancel:click', this._onClickCancel, this);
		},
		
		destroy: function destroyJoinView() {
			this.model.unbind('change:state', this._onChangedState, this);

			this.model.unbind('change:queue', this._onQueueChange, this);
		},

		_onChangedState: function _onChangedStateJoinView(model, state) {
			APP.log('_onChangedStateJoinView', state, this.model.get('error'));
			
			// Ready or error
			if (state === this.model.STATE_READY || state === this.model.STATE_ERROR) {
				this._password = null;
				this._isReady = false;
				
				// 
				if (state === this.model.STATE_ERROR && (!this.server || this.model.get('error') === this.model.ERROR_TIME_OUT)) {
					this.model.unbind('change:state', this._onChangedState, this);
					this.model.unbind('change:queue', this._onQueueChange, this);
				}
				
				this.render();
				
			// Invalid Password
			} else if (state === this.model.STATE_INVALID_PASSWORD) {
				this._invalidPassword = true;
				
			// 
			} else {
				this.render();
			}

		},

		_onQueueChange: function _onQueueChangeJoinView() {
			this.render();
		},
		
		_onClickJoin: function _onClickJoinJoinView() {
			this.$('div.border-box').addClass('loading');
			
			this._password = this.$('input').val();
			
			this._checkReady();
		},

		_onClickCancel: function _onClickCancelJoinView() {
			this.trigger('close', this);
		},
		
		_checkPasswordLength: function () {
			var length = ($('div.server-password input').val() || '').length;
			
			
			if (length !== 0) {
				this._joinButton.enable();
			} else {
				this._joinButton.disable();
			}
		},
		
		/**
		 * Render server password
		 * @private
		 */
		_renderServerPassword: function _renderServerPasswordJoinView() {
			var borderBox = this.make('div', {
					'class': 'border-box server-password'
				}),
				btnContainer = this.make('div', {
					'class': 'button-container'
				}),
				title = this.make('h2'),
				input = this.make('input', {
					'type': 'password'
				});
			
			title.appendChild(this.make('div', null, this.trans('WEB_GAME_SERVERBROWSER_COL_SERVER_NAME')));
			title.appendChild(this.make('span', null, this.server.get('name')));
			borderBox.appendChild(title);
			
			if (this._invalidPassword) {
				borderBox.appendChild(this.make('p', {
					'class': 'error'
				}, this.trans('WEB_GAME_TOOLTIPS_MESSAGE_WRONG_PASSWORD')));
				this.value = this._password || '';
			} else {
				borderBox.appendChild(this.make('p', null, this.trans('WEB_GAME_TOOLTIPS_MESSAGE_NEED_PASSWORD')));
			}
			
			borderBox.appendChild(input);
			
			this._joinButton = this.createView(APP.View.Button, {
				container: btnContainer,
				className: 'btn-join',
				text: this.trans('WEB_GAME_TOOLTIPS_JOIN_PASSWORD_BTN')
			}, 'join').render().attach();

			this._cancelButton = this.createView(APP.View.Button, {
				container: btnContainer,
				className: 'btn-cancel',
				text: this.trans('WEB_COMMON_CANCEL_BUTTON')
			}, 'cancel').render().attach();

			borderBox.appendChild(btnContainer);

			this._checkPasswordLength();
			
			return borderBox;
		},
		
		
		/**
		 * Render server info
		 * @private
		 */
		_renderServerInfo: function _renderServerInfoJoinView() {
			var borderBox = this.make('div', {
					'class': 'border-box server-info'
				}),
				info = this.make('div', {
					'class': 'info'
				}),
				title = this.make('h2'),
				friendsOnServer = _.filter(this.model.get('gameRoster'), function (player) {
					return player.isFriend;
				}),
				friends;

			title.appendChild(this.make('div', null, this.trans('WEB_GAME_SERVERBROWSER_COL_SERVER_NAME')));
			title.appendChild(this.make('span', null, this.model.get('name')));
			borderBox.appendChild(title);
			
			info.appendChild(this.make('div', {
				'class': 'map map-' + this.model.get('currentMap')
			}));

			info.appendChild(this.make('h3', null, this.model.get('currentMapName')));

			info.appendChild(this.make('h4', null, this.trans('WEB_GAME_SERVERBROWSER_COL_PLAYERS')));
			info.appendChild(this.make('p', null, this.model.get('players') + '/' + this.model.get('capacity')));
			borderBox.appendChild(info);
			
			// Friends on server
			if (friendsOnServer.length !== 0) {
				friends = this.make('ul', {
					'class': 'friends'
				});
				_.forEach(friendsOnServer, function (friend) {
					var li = this.make('li');
					
					// Glyph
					li.appendChild(this.make('i', {
						'class': 'glyphs glyphs-kit-' + friend.kit
					}));
					
					// Name
					li.appendChild(this.make('span', {
						'class': 'name'
					}, friend.name));
					
					// Rank
					li.appendChild(this.make('span', {
						'class': 'rank'
					}, this.trans('WEB_GAME_HOME_SOLDIERLIST_LEVEL') + ' ' + friend.level));
					
					friends.appendChild(li);
				}, this);

				borderBox.appendChild(this.make('h4', {
					'class': 'friend-label'
				}, this.trans('WEB_GAME_HOME_FRIENDS_HEADER')));
				borderBox.appendChild(friends);
			}
			
			
			return borderBox;
		},
		

		/**
		 * Render Error
		 * @private
		 */
		_renderError: function () {
			var container = this.make('div', {
					'class': 'state'
				}),
				stateName = this.model.get('stateName'),
				errorName = this.model.get('errorName');
			
			
			if (errorName === 'unknown') {
				container.appendChild(this.make('span', null, this.trans(stateName)));
			} else {
				container.appendChild(this.make('span', null, this.trans(errorName)));
			}
			
			this.createView(APP.View.Button, {
				container: container,
				className: 'btn-cancel',
				text: this.trans('WEB_GAME_TOOLTIPS_CLOSE_BTN')
			}, 'cancel').render().attach();
			
			return container;
		},

		/**
		 * Render state
		 * @private
		 */
		_renderState: function () {
				
			var state = this.model.get('state'),
				container = this.make('div', {
					'class': 'state'
				});
			
			// 4 = StateInQueue
			if (state === this.model.STATE_IN_QUEUE) {
				container.appendChild(this.make('span', null, this.trans(this.model.get('stateName'))));
				container.appendChild(this.make('span', {
					'class': 'position'
				}, this.model.get('queuePosition')));


				this.createView(APP.View.Button, {
					container: container,
					text: this.trans('WEB_GAME_TOOLTIPS_LEAVE_QUEUE_BTN')
				}, 'cancel').render().attach();
								
			} else {
				container.appendChild(this.make('span', null, this.trans(this.model.get('stateName'))));
				
				if (this.model.isStateCancelable()) {
					this.createView(APP.View.Button, {
						container: container,
						className: 'state-cancel',
						text: this.trans('WEB_COMMON_CANCEL_BUTTON')
					}, 'cancel').render().attach();
				}
			}
			
			return container;
		},

		/**
		 * Check ready
		 * @private
		 */
		_checkReady: function () {
			if (!this._isReady && (!this.server || !this.server.get('hasPassword') || this._password)) {
				this._isReady = true;
				_.delay(_.bind(function () {
					this.trigger('ready', this, {
						password: this._password
					});
				}, this), 500);
			}
		},
		
		/**
		 * Render
		 */
		render: function renderJoinView() {
			
			var state = this.model.get('state');
			
			// Is for what ever reason waiting on something
			if (this._waiting) {
				this.$el.addClass('loading');
			
			} else {
				
				// Error
				if (state === this.model.STATE_ERROR) {
					this.$el.addClass('error');
					
					this.el.appendChild(this.make('h1', null, this.trans('WEB_COMMON_ERROR')));
					
					this.el.appendChild(this._renderError());
				
				// Password
				} else if (this.server && this.server.get('hasPassword') && (state === this.model.STATE_READY || state === this.model.STATE_INVALID_PASSWORD)) {
					this.$el.addClass('server-password');
	
					this.el.appendChild(this.make('h1', null, this.trans('WEB_GAME_TOOLTIPS_HEADER_NEED_PASSWORD')));
	
					this.el.appendChild(this._renderServerPassword());
				
				} else {
					this.$el.addClass('play-now');
					
					this.el.appendChild(this.make('h1', null, this.trans('WEB_GAME_TOOLTIPS_MESSAGE_JOINING')));
					
					this.el.appendChild(this._renderState());
				}

				this._checkReady();
			}
		}
	});
}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule game
 */
(function (root) {
	"use strict";
	
	
	var APP = root.APP,
		win = APP.win,
		$ = APP.$,
		_ = APP._;



	/**
	 * Leave View
	 */
	APP.View.Leave = APP.View.extend({
		name: 'leave-view',

		events: {
			
		},
				
		initialize: function initializeLeaveView() {
		
		},
		
		
		destroy: function destroyLeaveView() {
			
		},

		setStateMessage: function (stateMessage) {
			this._stateMessage = stateMessage;
			this.render();
			return this;
		},

		setErrorMessage: function (errorMessage) {
			this._errorMessage = errorMessage;
			this.render();
			return this;
		},
		
		/**
		 * Render
		 */
		render: function renderJoinView() {
					
			if (this._errorMessage || this._stateMessage) {
				this.el.appendChild(this.make('h1', null, this.trans('WEB_GAME_TOOLTIPS_MESSAGE_LEAVING')));

				this.el.appendChild(this.make('div', {
					'class': 'state' + (this._errorMessage ? ' error' : '')
				}, this._errorMessage || this._stateMessage));
				
				
				if (this._errorMessage) {
					this.createView(APP.View.Button, {
						className: 'btn-cancel',
						text: this.trans('WEB_GAME_TOOLTIPS_OK_BTN')
					}, 'cancel').render().attach();
				}
			}
		}
	});
}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule game
 */
(function (root) {
	"use strict";
	
	
	var APP = root.APP,
		win = APP.win,
		doc = APP.doc,
		$ = APP.$,
		_ = APP._,
		parent = APP.View.Dialog.prototype;
	
	APP.View.RosterDialog = APP.View.Dialog.extend({
		className: 'roster-dialog',
		
		events: _.extend({}, parent.events, {
			'mouseenter li:not(.current)': function () {
				this.sound('hover');
			},
			'click li:not(.current)': function (e) {
				e.preventDefault();
				
				this.sound('click:button');
				
				var row = e.currentTarget,
					i = this.$rows.index(row),
					model;
					
				if (i !== -1) {
					this.$rows.removeClass('current');
					this.$rows.eq(i).addClass('current');
					model = this.collection.at(i);
					this.trigger('choose', this, model, e);
				}
			}
		}),
		
		/**
		 * Render Body
		 */
		renderBody: function renderBodyRosterDialogView() {
			var list = this.make('ul', {
					'class': 'persona-list'
				}),
				rows = [];
			
			this.rows = [];
			
			this.collection.forEach(function renderPersona(model) {
				var li = this.make('li'),
					level = this.make('div', { 'class': 'level' }),
					progress,
					bar;
				
				// Name
				li.appendChild(this.make('h3', null, model.get('name')));
				
				// Kit
				li.appendChild(this.make('span', {
					'class': 'kit-' + model.get('kit')
				}));
				
				li.appendChild(level);
				
				// Progress
				if (model.get('isMaxLevel')) {
					level.appendChild(this.make('div', null, this.trans('WEB_SOLDIER_LEVEL') + ' ' + model.get('level')));
					level.appendChild(this.make('span', null, this.trans('WEB_SOLDIER_MAX_LEVEL_REACHED')));
				} else {
					level.appendChild(this.make('div', null, model.get('xpToNextLevel') + 'XP'));
					level.appendChild(this.make('span', null, this.trans('WEB_GAME_EOR_XP_TO_NEXT_LEVEL')));
					
					
					progress = this.make('div', { 'class': 'progress' });
					
					bar = this.make('div', { 'class': 'bar' });
					bar.appendChild(this.make('div', { 'style': 'width: ' + model.get('levelUpProgression') + '%;' }));
					progress.appendChild(bar);
					
					progress.appendChild(this.make('span', { 'class': 'current' }, model.get('level')));
					progress.appendChild(this.make('span', { 'class': 'next' }, model.get('nextLevel')));
					
					li.appendChild(progress);
				}
				
				
				li.appendChild(this.make('p', null, model.get('levelDescription')));
				
				// Current
				if (model.get('isCurrent')) {
					li.className = 'current';
				}
				
				rows.push(li);
				
				list.appendChild(li);
				
			}, this);
			
			this.$rows = this.$(rows);
			
			return list;
		},
		
		
		/**
		 * Render
		 */
		render: function renderRosterDialogView() {
			
			// Render Data
			this.options.renderData = {
				close: true,
				title: '<span>' + this.trans('WEB_GAME_SOLDIER_CHOOSE_YOUR_SOLDIER') + '</span>',
				body: this.renderBody()
			};
			
			// Render parent
			parent.render.apply(this, arguments);
		}
	});
}(this));

/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule game
 */
/**
 * @class GAME.Task.game
 * @uses GAME.Task.config
 */
APP.task('game', [ 'config' ], function taskGame(done) {
	"use strict";
	
	var win = APP.win,
		$ = APP.$,
		_ = APP._,
		doc = APP.doc,
		nsGame = APP.ns('game'),
		nsConfig = APP.ns('config'),
		gameModel = nsGame.model = new APP.Model.Game(),
		personaModel = nsGame.persona = new APP.Model(nsConfig.persona),
		game = null,
		_gameEventListeners = win._gameEventListeners = {},
		currentScreen = 1;
	
	
	if (win.hasOwnProperty('game')) {
		game = win.game;
	}
		
	// Set game version
	$('#game-version span.game').html(nsConfig.gameVersion);
	if (win.EASY_DEBUG) {
		$('#game-version').show();
	} else {
		$('#game-version').hide();
	}
	
	
	
	/**
	 * Game wants us to go to a specific screen, send the event
	 */
	win.frontend_setScreen = function frontend_setScreen(id) {
		APP.log('frontend_setScreen', id);
		
		var screenStates = {
				0: 'NullScreen',
				1: 'MainScreen',
				2: 'LoadingScreen',
				3: 'EndOfRoundScreen'
			},
			activeScreen = screenStates[id];
		
		nsGame.gotoScreen(id);
	};
	
	/**
	 * Is Playing
	 */
	nsGame.isPlaying = function isPlaying() {
		return (game && game.mapName !== '$noCurrentGame');
	};
	
	/**
	 * Quit
	 */
	nsGame.quit = function quitGame() {
		if (nsGame.isPlaying()) {
			game.quitGame();
		} else {
			nsGame.gotoScreen(1);
		}
		return nsGame;
	};
	
	/**
	 * Start new Round
	 */
	nsGame.startNewRound = function startNewRound() {
		if (game) {
			game.startNewRound();
		}
		nsGame.trigger('round:new');
		return nsGame;
	};
	
	
	/**
	 * Go to screen
	 */
	nsGame.gotoScreen = function gotoScreen(id) {
		APP.log('gotoScreen', id);
		
		var	states = [ 'empty', 'main', 'load', 'eor' ],
			state = states[id],
			elMain = APP.$main.get(0);
		
		
		currentScreen = id;
		
		// Trigger Game Events
		nsGame.trigger('screen', id, state);
		nsGame.trigger('screen:' + state, id, state);
		
		if (id === 1) {
			if (!elMain.parentNode) {
				doc.body.appendChild(elMain);
			}
		} else if (elMain.parentNode) {
			elMain.parentNode.removeChild(elMain);
		}
		
		// Async paint
		nsGame.asyncPaint();
		
		return nsGame;
	};
	
	
	/**
	 * Async paint
	 */
	nsGame.asyncPaint = function asyncPaint() {
		if (win.frontendCoreLoop && win.frontendCoreLoop.asyncPaint) {
			win.frontendCoreLoop.asyncPaint();
		}
		
		return nsGame;
	};
	
	
	// If "is playing" that means that we are reloading the
	// frontend while still in a game so we need to quit
	// the game
	if (nsGame.isPlaying()) {
		APP.log('Reloading frontend while in game!: ' + game.mapName);
		nsGame.quit();
		
	// Listeners to game events
	} else {
		nsGame.hasEnteredGame = false;
		nsGame.isAborted = false;
		
		/**
		* Raised when a map load is initiated
		*/
		_gameEventListeners.onLoadingStart = function onLoadingStart() {
			APP.log('load:start');
			nsGame.isAborted = false;
			nsGame.trigger('load:start');
		};
	   
		/**
		 * Raised while loading a level, every time the load progress changes.
		 * The value progress ranges from 0 to 1.
		 */
		_gameEventListeners.onLoadingProgressUpdated = function onLoadingProgressUpdated(progress) {
			APP.log('load:update', progress);
			if (progress === 100 && !nsGame.isAborted) {
				nsGame.hasEnteredGame = true;
			}
			nsGame.trigger('load:update', progress);
		};
		
		/**
		 * Raised when the user hits escape key while loading a level
		 */
		_gameEventListeners.onLoadingAborted = function onLoadingAborted() {
			APP.log('load:abort', nsGame.hasEnteredGame);

			nsGame.isAborted = true;
						
			nsGame.trigger('load:abort');
		};
		
		/**
		 * Raised when the map loading is finished
		 */
		_gameEventListeners.onLoadingComplete = function onLoadingComplete() {
			APP.log('load:complete', nsGame.hasEnteredGame);
			if (!nsGame.isAborted) {
				nsGame.hasEnteredGame = true;
			}
			nsGame.trigger('load:complete');
		};
	   
		/**
		 * Raised when begin round state changes. The value ranges from 0 to 4.
		 * 0 - BRSNotPlaying = Before game has started
		 * 1 - BRSWaitingForPlayers = Waiting for enough players to join. Spawning allowed, but no ticketloss.
		 * 2 - BRSCommanderElection = Waiting <startDelay> time for commander voting. No spawning allowed.
		 * 3 - BRSPlaying = Normal play
		 * 4 - BRSMigrating = Restoring game state through host migration
		 */
		_gameEventListeners.onBeginRoundStateChanged = function onBeginRoundStateChanged(state) {
			APP.log('changed:roundState', state);
			gameModel.set({
				roundState: state
			});
		};
		gameModel.bind('change:roundState', function () {
			nsGame.trigger('roundState', gameModel);
		});
		
		
		/**
		 * 
		 */
		_gameEventListeners.onGameStarted = function onGameStarted(gameId) {
			nsConfig.model.set({
				'check-eor-reported': gameId
			});
		};



		/**
		 * Raised when the matchmaking state changes. See the state property for the enum values.
		 *
		 * @param int oldState
		 * @param int newState
		 */
		_gameEventListeners.onStateChanged = function onStateChanged(oldState, newState, errorCode) {
			// Check if the reason for leaving was an invalid password
			if (newState === nsGame.model.STATE_LEAVING && (errorCode === 11 || errorCode === 12)) {
				newState = 90;
			}
			
			// When canceling search we need to call matchmaking.finalizeCancelSearch() :S
			if (newState === nsGame.model.STATE_CANCELED_SEARCH) {
				win.matchmaking.finalizeCancelSearch();
			}
			
			// Update model
			nsGame.model.set('state', newState);
		};

		
		/**
		 * Raised when the user's position in the join queue has changed
		 */
		_gameEventListeners.onQueueUpdated = function onQueueUpdated() {
			nsGame.model.set({
				queuePosition: win.matchmaking.queuePosition,
				queueSize:  win.matchmaking.queueSize
			});
		};
		
		
		/**
		 * Set up some event listeners
		 */
		if (game) {
			game.addEventHandler('onLoadingStart', '_gameEventListeners.onLoadingStart');
			game.addEventHandler('onLoadingProgressUpdated', '_gameEventListeners.onLoadingProgressUpdated');
			game.addEventHandler('onLoadingAborted', '_gameEventListeners.onLoadingAborted');
			game.addEventHandler('onLoadingComplete', '_gameEventListeners.onLoadingComplete');
			game.addEventHandler('onBeginRoundStateChanged', '_gameEventListeners.onBeginRoundStateChanged');
			
			win.matchmaking.addEventHandler('onGameStarted', '_gameEventListeners.onGameStarted');
			win.matchmaking.addEventHandler('onStateChanged', '_gameEventListeners.onStateChanged');
			win.matchmaking.addEventHandler('onQueueUpdated', '_gameEventListeners.onQueueUpdated');
			
			gameModel.set({
				version: game.version,
				loadingProgress: game.loadingProgress,
				state: win.matchmaking.state,
				mapName: game.mapName,
				firstTimePlaying: game.firstTimePlaying,
				timeToNextStateChange: game.timeToNextStateChange
			});
		}
	}
	
	
	/**
	 * Task done!
	 */
	done();
});
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule game
 */
/**
 * @class GAME.Task.game.frontend
 * @uses GAME.Task.game
 */
APP.task('game.frontend', [ 'game' ], function taskGame(done) {
	"use strict";

	var win = APP.win,
		setTimeout = win.setTimeout,
		clearTimeout = win.clearTimeout,
		$ = APP.$,
		_ = APP._,
		nsGame = APP.ns('game'),
		nsConfig = APP.ns('config'),
		nsStore = APP.ns('store'),
		nsItems = APP.ns('items'),
		nsWelcome = APP.ns('welcome'),

		reasonMap = {
			'0': 'Undefined',
			'1': 'You have been kicked from the server.',
			'2': 'You are banned from this server.',
			'3': 'Connection to server lost.',
			'4': 'KeyInUse',
			'5': 'KeyNotValid',
			'6': 'Invalid Game Data',
			'7': 'InvalidExe',
			'8': 'You are running an older version of the game.',
			'9': 'You are running an newer version of the game.',
			'10': 'Reset',
			'11': 'InvalidPassword',
			'12': 'InvalidReserverPassword',
			'13': 'Server is full.',
			'14': 'PunkBusterNotEnabled',
			'15': 'Failed to connect.',
			'16': 'Deleted1',
			'17': 'Deleted2',
			'18': 'Deleted3',
			'19': 'Deleted4',
			'20': 'RestartMenu',
			'21': 'Map not found',
			'22': 'Kicked by PunkBuster.',
			'23': 'Corrupt Data Critical.',
			'24': 'KickedReservedSlots',
			'25': 'KeyDisabled',
			'26': 'KeyXPack1NotInstalled',
			'27': 'KeyXPack2NotInstalled',
			'28': 'KeyXPack1NotAuthorized',
			'29': 'KeyXPack2NotAuthorized',
			'30': 'ModNotFound',
			'31': 'AboveMaxRank',
			'32': 'PlayerLeft' // Normal leaving  game
		},

		frontend = win.frontend || {},


		/**
		 * @param {Function} fn
		 */
		refresh = nsGame.refresh = function (fn) {
			APP.log('nsGame::refresh');

			var done = _.after(4, function () {
				if (fn) {
					fn();
				}
			});


			// Personas
			nsGame.personas.fetch({
				updateOrRemove: true,
				success: done,
				error: done
			});

			// Wallet
			nsStore.wallet.fetch({
				success: done,
				error: done
			});

			// Use count for consumables and expired
			nsItems.refreshItems(done);

			// VIP
			nsGame.getVIPChanges(done);
			
			APP.ns('abilities').updatePage();
		},


		/**
		 * Check if round has been reported
		 *
		 */
		checkEORReported = function checkEORReported(gameId, fn) {
			var checkResponse = function checkResponse(response) {
				if (response && (response.data === 'END_OF_ROUND_REPORTED' || response.message === 'END_OF_ROUND_REPORTED')) {
					checkEORReported.count = 0;
					fn();
				} else {
					checkEORReported.count += 1;
					_.delay(checkEORReported, 1500, gameId, fn);
				}
			};

			if (checkEORReported.count === 5) {
				checkEORReported.count = 0;
				fn();
			} else {
				if (!checkEORReported.hasOwnProperty('count')) {
					checkEORReported.count = 0;
				}
				$.ajax({
					url: nsConfig.eorUrl + gameId,
					dataType: 'json',
					cache: false,
					success: checkResponse,
					error: checkResponse
				});
			}
		},

		leaveView,
		createLeaveView = function () {
			if (!leaveView) {
				leaveView = new APP.View.Leave();
				leaveView.render();
				leaveView.attach();
			}
		},
		destroyLeaveView = function () {
			if (leaveView) {
				leaveView.destroy();
				leaveView = null;
			}
		};


	/**
	 * Enable Frontend
	 */
	nsGame.enableFrontend = function enableFrontend(activationReason, activationDetails) {
		if (nsGame.isFrontendEnabled) {
			return nsGame;
		}
		
		nsGame.isFrontendEnabled = true;
		
		APP.log('screenMain::activationReason', activationReason);
		APP.log('screenMain::activationDetails', activationDetails);

		if ((win.location.hash.indexOf('eor-offer') !== -1)) {
			activationReason = 32;
		}

		var timer,
			refreshAndWelcomeBack = function () {
				refresh(function () {
					nsWelcome.checkMessages(function (err, view) {
						destroyLeaveView();
						
						if (err) {
							APP.log.warn(err);
						} else if (view) {
							view.render();
							view.attach();
						}
						
						win.showDoll.force = true;
						if (APP.doll.visible) {
							win.showDoll();
						}
					});
				});
			};

		createLeaveView();
		
		// Left game unwillingly
		if (activationReason && activationReason !== 32) {
			leaveView.setStateMessage(APP.sidis.trans('WEB_GAME_TOOLTIPS_MESSAGE_DISCONNECTED_' + activationReason));

			// Left game willingly
		} else {
			leaveView.setStateMessage(APP.sidis.trans('WEB_GAME_TOOLTIPS_MESSAGE_LEAVING'));
		}

		// Show new message after 1 second
		timer = setTimeout(function () {
			if (leaveView) {
				leaveView.setStateMessage(APP.sidis.trans('WEB_GAME_TOOLTIPS_MESSAGE_REFRESHING_STATS'));
			}
		}, 1000);


		// Need to check the if end of round was reported
		if (nsConfig.model.has('check-eor-reported')) {
			checkEORReported(nsConfig.model.get('check-eor-reported'), function (err) {
				if (err) {
					// Clear timer so that we display that message
					clearTimeout(timer);

					// When clicking on cancel to error message
					// refresh and check welcome message
					leaveView.bind('cancel:click', function (view) {
						view.destroy();
						refreshAndWelcomeBack();
					});

					leaveView.setErrorMessage(APP.sidis.trans('WEB_GAME_TOOLTIPS_MESSAGE_STATS_FAILED'));

				} else {

					// Refresh and check welcome message
					refreshAndWelcomeBack();
				}
			});
			nsConfig.model.unset('check-eor-reported');

		} else {
			refreshAndWelcomeBack();
		}
		
		nsGame.asyncPaint();

		return nsGame;
	};
	nsGame.isFrontendEnabled = true;

	/**
	 * Disable Frontend
	 */
	nsGame.disableFrontend = function disableFrontend() {
		nsGame.isFrontendEnabled = false;
		
		createLeaveView();
		
		return nsGame;
	};
	
	// 
	nsGame.bind('screen:main', function () {
		var activationReason = win.frontend && win.frontend.activationReason,
			activationDetails = win.frontend && win.frontend.activationDetails;
		nsGame.enableFrontend(activationReason, activationDetails);
	});
	nsGame.bind('screen:load', nsGame.disableFrontend);
	

	/**
	 * If we got game
	 */
	if (win.game) {
		win.onEnabledFrontend = function onEnabledFrontend() {
			APP.log(' onEnabledFrontend::activationReason', win.frontend.activationReason);
			APP.log('onEnabledFrontend::activationDetails', win.frontend.activationDetails);
			//nsGame.enableFrontend(win.frontend.activationReason, win.frontend.activationDetails);

		};
		win.onDisabledFrontend = function onDisabledFrontend() {
			APP.log(' onDisabledFrontend::activationReason', win.frontend.activationReason);
			APP.log('onDisabledFrontend::activationDetails', win.frontend.activationDetails);
			//nsGame.disableFrontend(win.frontend.activationReason, win.frontend.activationDetails);
		};

		win.frontend.addEventHandler('onEnabled', 'onEnabledFrontend');
		win.frontend.addEventHandler('onDisabled', 'onDisabledFrontend');
	}


	/**
	 * Task Done!
	 */
	done();
});
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule game
 */
/**
 * @class GAME.Task.game-items
 * @uses GAME.Task.items
 * @uses GAME.Task.abilities
 */
APP.task('game-items', [ 'items', 'abilities' ], function taskGameItems(done) {
	"use strict";
	
	
	var $ = APP.$,
		_ = APP._,
		win = APP.win,
		
		nsGame = APP.namespace('game'),
		nsItems = APP.namespace('items'),
		nsConfig = APP.namespace('config'),
		nsAbilities = APP.namespace('abilities'),
		
		/**
		 * Give Items
		 */
		prevItems = null,
		giveItemsBarCodes = {
			0: "Unknown bar",
			1: "Clothing Bar",
			2: "Equipment Bar",
			3: "Emote Bar",
			4: "Mission Bar",
			5: "Passive Inventory"
		},
		giveItemsErrorCodes = {
			0	: "ErrNone",
			5003: "ErrAssetInvalid",
			5009: "ErrAssetLevel",
			5013: "ErrAssetMissingDependencies",
			5017: "ErrTooFewPrimaryWeapons",
			5018: "ErrTooManyPrimaryWeapons",
			5019: "ErrTooFewSecondaryWeapons",
			5020: "ErrTooManySecondaryWeapons",
			5021: "ErrInvalidAssetForTeam",
			5022: "ErrInvalidAssetForKit",
			5023: "ErrInvalidAttachmentParent",
            5024: "ErrTooFewMeleeWeapons",
            5025: "ErrTooManyMeleeWeapons"
		},


		/**
		 *  Give Items
		 *  @param {Function} fn
		 *  @param {Boolean} force
		 */
		giveItems = nsGame.giveItems = function giveItems(fn, force) {
			
			var items = {
					EquipmentBar: [],
					MissionBar: [],
					VisualItems: [],
					PassiveItems: [],
					AttachmentItems: []
				},
				itemsJSON;
			
			// Set weapons
			nsItems.collection.getEquipped('weapon').forEach(function eachWeapon(model) {
				items.EquipmentBar.push({
					id: model.id,
					count: model.get('usecount'),
					position: model.get('equippedSlot')
				});
				
				// Is customizable?
				if (model.isCustomizable()) {
					_.forEach(model.collection.getModelAttachedItems(model, true), function (attachmentModel) {
						items.AttachmentItems.push({ 
							id: attachmentModel.id, 
							parentid: model.id
						});
					});
				}
			});
			
			// Set Appearance
			nsItems.collection.getEquipped('appearance').forEach(function eachWeapon(model) {
				
				if (!model.isDefault()) {
					items.VisualItems.push({
						id: model.id,
						position: model.get('equippedSlot')
					});
				}
				
				if (model.isCustomized()) {
					_.forEach(model.get('upgrades'), function (upgrade) {
						if (upgrade) {
							items.PassiveItems.push({
								id: upgrade
							});
						}
					});
				}
			});
			
			// Add Passive Items
			nsAbilities.collection.filterBy({
				passive	: true
			}).forEach(function (model) {
				items.PassiveItems.push({
					id		: model.id,
					count	: model.get('usecount')
				});
			});
			
			// Set Boosters
			nsItems.collection.byType('booster').forEach(function eachBooster(model) {
				// Send active 
				if (model.isAllowedInGame()) {
					items.PassiveItems.push({
						id: model.id
					});
				}
			});
			
			// Create JSON
			itemsJSON = JSON.stringify(items);
			
			// Do we have a game/soldier to send this to?
			if (win.soldier && (force || itemsJSON !== prevItems)) {
				
				APP.log('giveItems:itemsJSON', itemsJSON);
				
				prevItems = itemsJSON;
				
				_.defer(function () {
					var results = win.soldier.giveItems(itemsJSON),
						resultsJSON = JSON.parse(results),
						errors = _.map(resultsJSON, function (res) {
							
							var err = new Error(giveItemsErrorCodes[res.ErrCode] || 'Error Unknown');

							err.itemId = res.ItemId;
							err.code = res.ErrCode;
							err.bar = res.CustBar;
							err.type = giveItemsBarCodes[res.CustBar] || 'Error Type';
							
							return err;
						});
					
					if (errors.length !== 0) {
						prevItems = null;
						APP.log('giveItems:errors: ', errors);
					}
					
					if (fn) {
						fn(errors.length !== 0 ? errors : null);
					}
				});
				
			} else if (fn) {
				fn();
			}
			
			return nsGame;
		},
		
		/**
		 * Save
		 */
		saveCache = {},
		save = _.debounce(function save(url, data, fn, force) {
			
			var cacheValue = JSON.stringify(data);
			
			if (force || saveCache[url] !== cacheValue) {
				saveCache[url] = cacheValue;
				$.ajax({
					type: 'POST',
					url: url,
					data: data,
					success: function onSuccessSave(res) {
						if (res && res.status === 'success') {
							fn();
						} else {
							saveCache[url] = null;
							fn(new Error('Save request failed to return a success response!'));
						}
					},
					error: function onErrorSave() {
						saveCache[url] = null;
						fn(new Error('Save request return an error!'));
					}
				});
			} else {
				_.defer(fn);
			}
		}, 100),
		
		/**
		 * Save Weapons
		 */
		saveWeapons = nsGame.saveWeapons = function saveWeapons(fn) {
			
			var url = nsConfig.saveEquipmentUrl,
				data = {
					equipment: JSON.stringify(nsItems.collection.getLoadout('weapon'))
				};
			
			save(url, data, function onSaveWeapons(err) {
				giveItems();
				if (fn) {
					fn(err);
				} else if (err) {
					throw err;
				}
			});
			
			return nsGame;
		},
		
		/**
		 * Save Appearance
		 */
		saveAppearance = nsGame.saveAppearance = function saveAppearance(fn) {
			
			var url = nsConfig.saveAppearanceUrl,
				data = {
					appearance: JSON.stringify(nsItems.collection.getLoadout('appearance'))
				};
			
			save(url, data, function onSaveAppearance(err) {
				giveItems();
				if (fn) {
					fn(err);
				} else if (err) {
					throw err;
				}
			});
			
			return nsGame;
		},
		
		/**
		 * Save Customization
		 */
		saveCustomizations = nsGame.saveCustomizations = function saveCustomization(model, fn) {
			model = nsItems.collection.get(model);
			
			if (!(model instanceof APP.Model.Item)) {
				if (fn) {
					return fn(new Error('Invalid Model "' + model + '"'));
				} else {
					throw new Error('Invalid Model "' + model + '"');
				}
			}
			
			var url = nsConfig.saveCustomizationUrl + '#' + model.id,
				customizations = {},
				data = {
					itemId: model.id
				};
			
			_.forEach(model.getCustomizations(), function (model, i) {
				customizations[i] = (model && model.id) || null;
			});
			
			data.customization = JSON.stringify(customizations);
			
			// Talk to server
			save(url, data, function onSaveCustomization(err) {
				giveItems();
				if (fn) {
					fn(err);
				} else if (err) {
					throw err;
				}
			});
			
			return nsGame;
		},
		
		
		/**
		 * Save All
		 */
		saveAll = nsGame.saveAll = function saveAll() {
			// Weapons
			saveWeapons();
			
			// Appearance
			saveAppearance();
			
			// Attachments
			nsItems.collection.filterBy({
				'isCustomizable': true,
				'owned': true
			}).forEach(saveCustomizations);
			
			return nsGame;
		};
	
	nsGame.bind('save:weapons', saveWeapons);
	nsGame.bind('save:weapon', saveWeapons);
	nsGame.bind('save:appearance', saveAppearance);
	nsGame.bind('save:appearances', saveAppearance);
	nsGame.bind('save:customization', saveCustomizations);
	nsGame.bind('save:customizations', saveCustomizations);
	nsGame.bind('save', saveAll);
	nsGame.bind('giveitems', giveItems);
	
	
	
	/**
	 * We Need to "warm" the cache to reduce the number of blaze request
	 */
	// Weapons
	saveCache[nsConfig.saveEquipmentUrl] = JSON.stringify({
		equipment: JSON.stringify(nsItems.collection.getLoadout('weapon'))
	});
	// Appearance
	saveCache[nsConfig.saveAppearanceUrl] = JSON.stringify({
		appearance: JSON.stringify(nsItems.collection.getLoadout('appearance'))
	});
	// Customized Weapons
	nsItems.collection.filterBy({
		owned: true,
		isCustomizable: true
	}).forEach(function (model) {
		saveCache[nsConfig.saveCustomizationUrl + '#' + model.id] = JSON.stringify({
			itemId: model.id,
			customization: JSON.stringify(model.get('attachments'))
		});
	});
	
	
	/**
	 * When application is ready give items
	 */
	APP.ready(function () {
		prevItems = null;
		giveItems();
	});
	
	
	
	/**
	 * Validate
	 */
	nsGame.validate = function validate() {
		
		var equipped = nsItems.collection.filterBy({
				itemType: function (itemType) {
					return itemType === 'weapon' || itemType === 'appearance';
				},
				isEquipped: true
			}),
			equippedInvalid = equipped.filterBy({
				isAllowedInGame: false
			}),
			equippedPrimaryWeapons,
			maxNumPrimaryWeapons = 1,
			extraWeaponBooster,
			extraWeaponUpgrade,
			err = new Error();
		
		// All valid equipped
		if (equippedInvalid.length === 0) {
			
			// Extra weapon slot BOOSTER
			extraWeaponBooster = nsItems.collection.get(7000);
			if (extraWeaponBooster && extraWeaponBooster.isOwned()) {
				maxNumPrimaryWeapons = 2;
				
			// Extra weapon slot UPGRADE
			} else {
				extraWeaponUpgrade = nsItems.collection.getEquippedCustomizations().get(7109);
				if (extraWeaponUpgrade && extraWeaponUpgrade.isEquipped() && extraWeaponUpgrade.isOwned()) {
					maxNumPrimaryWeapons = 2;
				}
			}
			
			// Requipped primary weapons
			equippedPrimaryWeapons = equipped.filterBy({
				itemType: 'weapon',
				isEquipped: true,
				validationGroup: 'primary'
			});
			
			// Check number of primary weapons equipped
			if (equippedPrimaryWeapons.length > maxNumPrimaryWeapons && equippedPrimaryWeapons === 0) {
				err.type = 'NumPrimaryWeapons';
				err.items = equippedPrimaryWeapons;
				return err;
			}
			
		// Invalid
		} else {
			err.type = 'Invalid';
			err.items = equippedInvalid;
			return err;
		}
		
		
		return true;
	}; 
	
	
	/**
	 * Task Done!
	 */
	done();
});
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule game
 */
/**
 * @class GAME.Task.game-vip
 * @uses GAME.Task.servers
 */
APP.domTask('game-vip', [ 'servers' ], function taskGameVIP(done) {
	"use strict";
	
	
	var $ = APP.$,
		_ = APP._,
		win = APP.win,
		
		nsGame = APP.ns('game'),
		nsConfig = APP.ns('config'),
		
		
		getVIPChanges = nsGame.getVIPChanges = function (fn) {
			nsGame.vipStatusChanged = {};
			$.ajax({
				url: nsConfig.vipUrl,
				//url: '/static/vip.json',
				cache: false,
				dataType: 'json',
				success: function (res) {
					if (res && res.status === 'success') {
						nsGame.vipStatusChanged = res.data.vip;
						if (fn) {
							fn(null, nsGame.vipStatusChanged);
						}
					} else if (fn) {
						fn(new Error('Unable to get VIP changes'));
					}
				},
				error: function (err) {
					if (fn) {
						fn(err);
					}
				}
			});
		};

	getVIPChanges(done);
});
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule game
 */
/**
 * @class GAME.Task.game.events
 * @uses GAME.Task.config
 */
APP.task('game.events', [ 'config' ], function taskGameEvents(done) {
	"use strict";
	
	
	var win = APP.win,
		_ = APP._,
		$ = APP.$,
		JSON = win.JSON,
		nsGame = APP.ns('game'),
		nsConfig = APP.ns('config');
	
	
	/**
	 * Get game events
	 */
	nsGame.getGameEvents = function getGameEvents(fn) {
		$.ajax({
			url: nsConfig.gameEventsUrl,
			// url: '/static/game-events.json',
			data: {
				personaId: nsGame.personas.current.id
			},
			dataType: 'json',
			cache: false,
			success: function (response) {
				if (response && response.status === 'success') {
					fn(null, response.data.unlockInfo);
				} else {
					fn(new Error('Unable to get game events!'));
				}
			},
			error: function () {
				fn(new Error('Unable to get game events!'));
			}
		});
		
		
		return nsGame;
	};

    /**
	 * Task done!
	 */
	done();
});
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule game
 */
/**
 * @class GAME.Task.game-sound
 * @uses GAME.Task.config
 */
APP.task('game-sound', 'config', function taskGame(done) {
	"use strict";
	
	
	var win = APP.win,
		_ = APP._,
		doc = APP.doc,
		nsGame = APP.ns('game'),
		nsConfig = APP.ns('config'),
		game = win.game,
		
		mapping = {
			// Next
			'next': 'beep_click02.wav',
			// Prev
			'prev': 'beep_click01.wav',
			
			// Invalid Drop
			'revert': 'general_movement02.wav',
			
			// General Click
			'click': 'general_click.wav',
			// Click Button
			'click:button': 'general_stat04.wav',
			// Click buy button in purchase dialog
			'click:buybutton': 'buy.wav',
			// Click open on non-button
			'click:open': 'menu_click.wav',
			// Click disabled
			'click:disabled': 'general_movement05.wav',
			
			// General Hover
			'hover': 'general_mouseover.wav',
			
			// Open select box
			'select:open': 'menu_slide_up.wav',
			// Close Select Box
			'select:close': 'menu_slide_down.wav',
			
			// Equip
			'equip': 'menu_drop.wav',
			// Unequip
			'unequip': 'general_movement04.wav',
			
			// Open Error Dialog
			'error': 'general_stat03.wav',
			
			// Close
			'close': 'menu_quit.wav'
			/*
			'!!!!general_stat01': 'general_stat01.wav',
			'!!!!general_stat02': 'general_stat02.wav',
			'!!!!mouseover_weapon': 'mouseover_weapon.wav',
			'!!!!general_movement03': 'general_movement03.wav'
			*/
		},
		
		oldMapping = {
			// Next
			'next': 'Select',
			// Prev
			'prev': 'Select',
			
			// Invalid Drop
			'revert': 'Reset',
			
			// General Click
			'click': 'Click',
			// Click Button
			'click:button': 'Click',
			// Click buy button in purchase dialog
			'click:buybutton': 'ClickBuy',
			// Click open on non-button
			'click:open': 'Click',
			
			// General Hover
			'hover': 'Select',
			
			// Open select box
			'select:open': 'BarSlideUp',
			// Close Select Box
			'select:close': 'BarSlideDown',
			
			// Equip
			'equip': 'Pickup',
			// Unequip
			'unequip': 'Drop',
			
			// Open Error Dialog
			'error': 'Error',
			
			// Close
			'close': 'Click'
		},
		
		sound = nsGame.sound = function sound(name) {
			// Play using game
			if (game) {
				if (oldMapping.hasOwnProperty(name)) {
					game.playSound(oldMapping[name]);
				} else {
					game.playSound(name);
				}
				
			// Missing sound
			} else if (!mapping.hasOwnProperty(name)) {
				APP.log.warn(new Error('Unable to play sound, no sound named "' + name + '"'));
				
			// Play in browser
			} else if (sound.audio[name]) {
				sound.audio[name].play();
			}
		},
		
		doneFn;
	
	sound.audio = {};
	
	/**
	 * Show Dialog to test sounds
	 */
	sound.test = function soundTest() {
		var soundDialog = new APP.View.Dialog({
				className: 'sound-test-dialog'
			});
		
		soundDialog.once('close', function () {
			soundDialog.destroy();
			soundDialog = null;
		});
		
		soundDialog.setRenderData({
			close: true,
			title: 'Test <span>Sounds</span>',
			body: _.map(mapping, function (file, name) {
				return '<a href="#sound-' + name + '"><strong>' + name + '</strong> (' + file + ')</a>';
			})
		});
		
		soundDialog.$el.delegate('div.body a', 'click', function (e) {
			e.preventDefault();
			var name = e.currentTarget.href.split('-').pop();
			
			sound(name);
		});
		
		
		soundDialog.render();
		
		soundDialog.attach();
        
		soundDialog.show();
	};
	
	// Preload sounds for non game env
	if (!game) {
		_.forEach(mapping, function (file, name) {
			var audio = sound.audio[name] = new win.Audio('audio');
			audio.src = nsConfig.soundFolder + 'game/' + file;
			audio.load();
		});
	}
	
	/**
	 * Task done!
	 */
	done();
});
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule game
 */
/**
 * @class GAME.Task.game-persona
 * @uses GAME.Task.game
 */
APP.task('game-persona', [ 'game' ], function taskGamePersona(done) {
	"use strict";
	
	
	var win = APP.win,
		$ = APP.$,
		_ = APP._,
		nsGame = APP.ns('game'),
		nsConfig = APP.ns('config'),
		
		
		/**
		 * Personas collection
		 */
		personas = nsGame.personas,
		
		/**
		 * Switch Persona
		 */
		switchPersona = nsGame.switchPersona = function switchPersona(model) {
			model = personas.get(model);
			if (model instanceof APP.Model.Persona) {
				var url = nsConfig.personaUrl + model.id;
				APP.showSplash();
				if (win.login) {
					_.defer(function () {
						var picked = win.login.pickSoldier(model.get('name'));
						if (picked) {
							win.location.href = url;
						} else {
							APP.log.error('Unable to switch persona');
						}
					});
				} else {
					win.location.href = url;
				}
			}
		},
		
		
		rosterView,
		showRoster = function showRoster() {
			
			if (rosterView) {
				rosterView.destroy();
				rosterView = null;
			}
			
			rosterView = new APP.View.RosterDialog({
				collection: personas
			});
            
			rosterView.bind('close', function onCloseRosterView() {
				rosterView.destroy();
				rosterView = null;
			});
			
			rosterView.bind('choose', function (view, model) {
				nsGame.trigger('switch:persona', model);
			});
			
			rosterView.render().attach().show();
		};
	
	
	personas.get(nsGame.persona.id).set({
		'isCurrent': true
	});
	
	
	/**
	 * Roster
	 */
	nsGame.bind('roster', function () {
		showRoster();
	});
	
	
	/**
	 * Switch persona
	 */
	nsGame.bind('switch:persona', switchPersona);
	
	
	/**
	 * Task Done!
	 */
	done();
});
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule game
 */
/**
 * @class GAME.Task.game-routes
 * @uses GAME.Task.game-persona
 */
APP.task('game-routes', [ 'game-persona' ], function taskGameRoutes(done) {
	"use strict";
	
	
	var win = APP.$,
		$ = APP.$,
		_ = APP._,
		nsGame = APP.ns('game');
	
	
	/**
	 * Roster route
	 */
	APP.route('roster', 'roster', function routeRoster() {
		APP.navigate('');
		nsGame.trigger('roster');
	});
		
	
	/**
	 * Task done!
	 */
	done();
});

	
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule game
 */
/**
 * @class GAME.Task.game-matchmaking
 * @uses GAME.Task.game
 * @uses GAME.Task.servers
 * @uses GAME.Task.items
 */
APP.task('game-matchmaking', [ 'game', 'servers', 'items' ], function taskGameMatchmaking(done) {
	"use strict";
	
	
	var $ = APP.$,
		_ = APP._,
		win = APP.win,
		
		nsGame = APP.namespace('game'),
		nsConfig = APP.namespace('config'),
		nsServers = APP.namespace('servers'),
		nsItems = APP.namespace('items'),
		nsStore = APP.namespace('store'),


		/**
		 * Validate equipment
		 * @param {Function} done
		 * @param {Boolean}
		 */
		validate = function validate(done) {
			
			var err = nsItems.collection.validateLoadout(),
				equippedItems,
				invalidDialogView,
				destroyInvalidDialogView = function () {
					if (invalidDialogView) {
						invalidDialogView.destroy();
						invalidDialogView = null;
					}
				};
			
			// No errors then give items to soldier
			if (!err) {
				APP.log('validate::valid');
				
				// Give items to soldier
				nsGame.giveItems(function (err) {
					APP.log('validate::onGiveItems', err);

					var dialog;

					// Give items returned an error
					if (err) {
						dialog = new APP.View.Dialog({
							className: 'error-dialog',
							renderData: {
								close: true,
								title: APP.sidis.trans('WEB_GAME_ERROR_GIVE_ITEMS'),
								body: '<ul class="give-items-errors">' + _.map(err, function (error) {
									var html = '';

									html += '<li>';
									html += '<h4>' + error.message + '</h4>';
									html += '<div>Item: ' + error.itemId + '</div>';
									html += '<div>Type: ' + error.type + '</div>';
									html += '</li>';
									
									return html;
								}).join('') + '</ul>',
								buttonRight: APP.sidis.trans('WEB_GAME_TOOLTIPS_OK_BTN')
							}
						}).render().attach().show();

						dialog.bind('close', function () {
							dialog.destroy();
							dialog = null;
						});
						
						dialog.bind('button:right', function () {
							dialog.destroy();
							dialog = null;
						});

					} else {
						done();
					}
				});
				
				return true;
			}

			// Validate returned an error
			if (err.name === 'PrimaryError') {
				invalidDialogView = new APP.View.Dialog({
					className: 'error-dialog',
					renderData: {
						close: true,
						title: APP.sidis.trans('WEB_GAME_TOOLTIPS_HEADER_INVALID_PRIMARY'),
						body: APP.sidis.trans(err.message),
						buttonRight: APP.sidis.trans('WEB_GAME_TOOLTIPS_CHANGE_WEAPON_BTN')
					}
				});

				invalidDialogView.bind('button:right', function () {
					destroyInvalidDialogView();
					APP.navigate('weapons/inventory/primary', {
						trigger: true
					});
				});
				
			// Unbought or expired
			} else {
				
				equippedItems = nsItems.collection.getEquippedItems();
				
				// Instantiate the InvalidDialog view
				invalidDialogView = new APP.View.InvalidDialog({
					soonTS				: nsConfig.timeNow + (5 * 60),
					lowLimit			: 10,
					collection			: equippedItems
				});
				
				// Play click
				invalidDialogView.bind('play:click', function () {
					destroyInvalidDialogView();
					validate(done);
				});
				
				// Unequip
				invalidDialogView.bind('unequip', function (view, model) {
					model.unequip();
				});

				// Buy
				invalidDialogView.bind('buy', function (view, model) {
					nsStore.trigger('buy', model);
				});
				
				// Glyph enter
				invalidDialogView.bind('glyph:enter', function (view, model, e) {
					/**
					 name			: false
					 description	: false
					 dependencies	: false
					 stats			: false
					 slots			: false
					 offers			: false
					 uses			: false
					 time			: false
					 invalid		: false
					 **/
					
					var config = {
							time	: true,
							uses	: true,
							invalid	: true
						};
					
					if (!model.isOwned() && !model.isExpired()) {
						config.customText = APP.sidis.trans('WEB_GAME_ERROR_NOT_OWNED_ITEM');
					}
					
					
					nsItems.tooltip.renderModelAndShow(model, e.currentTarget, config);
				});
				// Glyph Leave
				invalidDialogView.bind('glyph:leave', function () {
					nsItems.tooltip.hide();
				});
			}
	
			// Close dialog
			invalidDialogView.bind('close', destroyInvalidDialogView);

			// Render InvalidDialog view
			invalidDialogView.render();

			// Attach it to the DOM
			invalidDialogView.attach();

			// 
			invalidDialogView.show();

			
			return false;
		},
		
				
		
		
		/**
		 * Destroy Join View
		 */
		destroyJoinView = function destroyJoinView() {
			if (nsGame.joinView) {
				nsGame.joinView.destroy();
				nsGame.joinView = null;
			}
		},
		
		
		/**
		 * Create Join View
		 * @param {Object} options
		 * @param {Function} readyFn
		 * @returns {View.Join}
		 */
		createJoinView = function createJoinView(options, readyFn) {
			APP.log('createJoinView', options);

			// Event handler to 
			var onKeyUp = function onKeyUp(e) {
					APP.log('onKeyUp::isStateCancelable', nsGame.model.isStateCancelable());
					if (e.keyCode === 27 && nsGame.model.isStateCancelable()) {
						destroyJoinView();
					}
				};

			
			// Ensure that we don't already have a join view
			destroyJoinView();
			
			
			nsGame.joinView = new APP.View.Join(options);

			/**
			 * When attaching the to the DOM do this
			 */
			nsGame.joinView.bind('attach', function (view) {
				
				var focusInput = function () {
						view.$('input[type=password]').focus();
					};

				nsGame.joinView.bind('render', function () {
					focusInput();
				});

				focusInput();
			});
			
			
			/**
			 * When the view is closed
			 */
			nsGame.joinView.bind('close', function () {
				destroyJoinView();
			});

			
			/**
			 * When the view is destroyed
			 */
			nsGame.joinView.bind('destroy', function () {
				$(win).unbind('keyup', onKeyUp);
				
				var state = nsGame.model.get('state');
				
				if (win.matchmaking) {
					if (state === nsGame.model.STATE_IN_QUEUE) {
						win.matchmaking.leaveQueue();
					}
					if (state === nsGame.model.STATE_SEARCHING) {
						win.matchmaking.cancelSearch();
					}
				}
			});
			
			$(win).bind('keyup', onKeyUp);

			
			nsGame.joinView.once('ready', readyFn);
			
			
			return nsGame.joinView;
		},
		
		
		/**
		 * Play Now
		 * @returns {nsGame}
		 */
		playNow = nsGame.playNow = function playNow() {
			validate(function () {
				var view = createJoinView({
					model: nsGame.model
				}, function () {
					APP.log('nsGame.playNow::onReady');
					
					var err;
					
					// Matchmaking module enabled, starting Matchmaking
					if (win.matchmaking && win.matchmaking.isEnabled === true) {
						// Join a game via automatic matchmaking.
						// Returns a backend::ErrorCode.
						err = win.matchmaking.joinByMatchmaking();

					// Matchmaking module disabled, starting game directly
					} else if ((!win.matchmaking || !win.matchmaking.isEnabled)) {
						// Join a game via automatic matchmaking.
						// Returns a backend::ErrorCode.
						err = win.game.playNow();
						
					} else {
						APP.log.warn('This client seems to be unplayable!');
					}
					
					if (err) {
						view.destroy();
					}
				});

				view.render();

				view.attach();
			});
			
			return nsGame;
		},


		/**
		 * The Join Helper helps by checking stuff like if the server if ranked, offline, etc.
		 * 
		 * @param {Model.Server} server
		 * @param {Function} fn
		 * @returns {nsGame}
		 */
		joinHelper = function (server, fn) {
			
			var dialog,
				destroyDialog = function () {
					if (dialog) {
						dialog.destroy();
						dialog = null;
					}
				},

				// This function is called when we have passed
				// validation and give items to the soldier 
				// without any errors
				onValidate = function () {
					APP.log('nsGame.joinPlayer::onValidate');

					// Create Join View
					var	view = createJoinView({
						server: server,
						model: nsGame.model
					}, fn);

					view.render();

					view.attach();
				};
			
			// Server online
			if (!server.collection || server.get('online')) {

				// Server is ranked
				if (server.get('ranked')) {
					// Validate Equipment
					validate(onValidate, true);

				// Server is not ranked
				} else {

					// Create a dialog that will tell the user that
					// playing on this server will got get any XP
					dialog = new APP.View.Dialog({
						className: 'error-dialog',
						renderData: {
							close: true,
							title: APP.sidis.trans('WEB_GAME_TOOLTIPS_HEADER_JOINING_UNRANKED_SERVER'),
							body: APP.sidis.trans('WEB_GAME_TOOLTIPS_MESSAGE_JOINING_UNRANKED_SERVER'),
							buttonLeft: APP.sidis.trans('WEB_GAME_TOOLTIPS_CANCEL_BTN'),
							buttonRight: APP.sidis.trans('WEB_GAME_TOOLTIPS_PLAY_BTN')
						}
					}).render().attach().show();
					
					// Destroy dialog when closing it
					dialog.bind('close', destroyDialog);
					
					// Destroy dialog when click on the "Cancel" button
					dialog.bind('button:left', destroyDialog);

					// Continue on to validating the equipment 
					// when clicking on the "Play" button
					dialog.bind('button:right', function () {
						destroyDialog();
						// Validate Equipment
						validate(onValidate, true);
					});
				}

			// Server offline
			} else {

				// Create a dialog that will tell the user that
				// this server is offline :(
				dialog = new APP.View.Dialog({
					className: 'error-dialog',
					renderData: {
						close: true,
						title: APP.sidis.trans('WEB_GAME_TOOLTIPS_HEADER_JOINING_OFFLINE'),
						body: APP.sidis.trans('WEB_GAME_TOOLTIPS_MESSAGE_JOINING_OFFLINE'),
						buttonRight: APP.sidis.trans('WEB_GAME_TOOLTIPS_OK_BTN')
					}
				}).render().attach().show();

				// Destroy dialog when closing it
				dialog.bind('close', destroyDialog);

				// Destroy dialog when click on the "Ok" button
				dialog.bind('button:right', destroyDialog);
			}

			return nsGame;
		},
		
		
		/**
		 * Join Player
		 * @param {String} playerName
		 * @param {String|Server} serverId
		 * @returns {nsGame}
		 */
		joinPlayer = nsGame.joinPlayer = function joinPlayer(playerName, serverId) {
			// Get this server if we got it
			var server;

			if (serverId instanceof APP.Model.Server) {
				server =  serverId;
			} else {
				server = nsServers.collection.get(serverId);
				if (!server) {
					if (_.isString(serverId)) {
						server = {
							persistentId: serverId
						};
					}
					server = new APP.Model.Server(server);
				}
			}
			
			// Call the join helper
			joinHelper(server, function (view, info) {
				APP.log('nsGame.joinPlayer::onReady');

				var err;
				
				// Can we match make?
				if (win.matchmaking) {
					try {
						err = win.matchmaking.joinByPlayerName(playerName, info.password || '');
					} catch (e) {
						err = e;
					}

					APP.log('joinByBookmark::err', err);
				}
			});

			return nsGame;
		},


		/**
		 * Join Server
		 * @param {String|Server} serverId
		 * @returns {nsGame}
		 */
		joinServer = nsGame.joinServer = function joinServer(serverId) {
			// Get this server if we got it
			var server;

			if (serverId instanceof APP.Model.Server) {
				server =  serverId;
			} else {
				server = nsServers.collection.get(serverId);
				if (!server) {
					if (_.isString(serverId)) {
						server = {
							persistentId: serverId
						};
					}
					server = new APP.Model.Server(server);
				}
			}
			// Call the join helper
			joinHelper(server, function (view, info) {
				APP.log('nsGame.joinServer::onReady');

				var err;

				// Can we match make?
				if (win.matchmaking) {
					try {
						err = win.matchmaking.joinByBookmark(server.id, info.password || '');
					} catch (e) {
						err = e;
					}

					APP.log('joinServer::err', err);
				}
			});
						
			return nsGame;
		};


	/**
	 * Destroy join view
	 */
	nsGame.bind('screen', destroyJoinView);
	nsGame.bind('onDisabled', destroyJoinView);
	
	/**
	 * Task Done!
	 */
	done();
});
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule sidis
 */
/**
 * @class GAME.Task.sidis
 */
APP.domTask('sidis', function initializeSidis(done) {
	"use strict";
	
	
	var nsLang = APP.ns('lang');
	
	APP.sidis = new Sidis(nsLang.locale, nsLang.messages);
	
	// Task done
	done();
});
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule store
 */
(function (root) {
	"use strict";
	
	
	// Node support
	if (typeof require !== 'undefined') {
		if (!root.APP) {
			root.APP = require('./../common/app');
		}
		
		if (!root.APP.Model) {
			root.APP.Model = require('./../common/model');
		}
	}
	
	var APP = root.APP,
		_ = APP._,
		parent = APP.Model.prototype;
    
	
	/**
	 * Model: Offer
	 */
	APP.Model.Offer = APP.Model.extend({
		normalizeKeys: {
			'offer'		: 'id',
			'offerId'	: 'id',
			'cost'		: 'price',
			'costSave'	: 'discount'
		},
		defaults: {
			'currency'		: null,
			'limit'			: null,
			'price'			: 0,
			'formatedPrice'	: 0,
			'discount'		: 0,
			'isPermanent'	: false,
			'isUnlimited'	: false,
			'isUnlockOffer'	: false,
			'label'			: null
		},
		schema: {
			'isPermanent'	: 'bool',
			'isUnlimited'	: 'bool',
			'isUnlockOffer'	: 'bool',
			
			'price'			: 'number',
			'originalPrice'	: 'number',
			'discount'		: 'number',
			
			// Currency
			'currency': function castCurrencyOfferModel(value) {
				value = (value || '').toLowerCase();
				if (value === '_ac' || value === 'credits') {
					return 'credits';
				} else if (value === '_db' || value === '_pf' || value === 'funds') {
					return 'funds';
				}
				// Return invalid
				return new Error('Invalid currency');
			}
		},
		
		initialize: function initializeOfferModel() {
			
			var err;
			
			// Price
			if (!this.has('price')) {
				err = new Error('Offer.Model requires a "price" attribute');
				this.trigger('error', this, err);
			}
			
			// Currency
			if (!this.has('currency')) {
				err = new Error('Offer.Model requires a "currency" attribute');
				//this.trigger('error', this, err);
			}
			
			// Discount
			if (!this.isDiscounted() && this.get('originalPrice')) {
				this._setDiscount();
			}
			
			// OriginalPrice
			if (this.isDiscounted() && !this.has('originalPrice')) {
				this._setOriginalPrice();
			}
			
			this._setFormatPrice();
			this._setLabel();
		},
		
		_setLabel: function _setLabelOfferModel() {
			var limit = this.get('limit'),
				label;
			
			if (limit) {
				label = limit;
			} else if (this.isDiscounted()) {
				label = APP.sidis.trans('WEB_GAME_DEALS_SAVE_LABEL') + ' ' + Math.abs(this.get('discount'));
			} else {
				label = 'Offer';
			}
			
			this.set({'label': label});
		},
		
		_setDiscount: function _setDiscountOfferModel() {
			var originalPrice = this.get('originalPrice');
			
			if (originalPrice) {
				this.set({
					discount: originalPrice - this.get('price')
				});
			}
		},
		
		_setFormatPrice: function _setFormatPriceOfferModel() {
			this.set({
				formatedPrice: this.format(this.get('price'))
			});
		},
		
		_setOriginalPrice: function _setOriginalPriceOfferModel() {
			var discount = this.get('discount');
			if (discount) {
				this.set({
					originalPrice: this.get('price') + discount
				});
			}
		},
		
		format: function (num) {
			if (num > 999) {
				// TODO: Fix this
				return num.toString().split('').reverse().join('').split(/^[0-9]{3}/).reverse().join(' 000');
			}
			return num.toString();
		},
		
		isDiscounted: function isDiscountedOfferModel() {
			return (this.get('discount') > 0);
		},
		
		isPermanent:  function isPermanentOfferModel() {
			return !!this.get('isPermanent');
		},
		
		isUnlimited:  function isUnlimitedOfferModel() {
			return !!this.get('isUnlimited');
		},
		
		isUnlock: function isUnlockOfferModel() {
			return !!this.get('isUnlockOffer');
		}
	});
	
	/**
	 * Module support
	 */
	if (typeof module !== 'undefined' && module.exports) {
		module.exports = APP.Model.Offer;
	}
}(this));

/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule store
 */
(function (root) {
	"use strict";
	
	if (!root.APP && (typeof require !== 'undefined')) {
		root.APP = require('./../common/app');
	}
	
	var APP = root.APP,
		parent = APP.Model.prototype,
		_ = APP._;
    
	
	/**
	 * Model: Wallet
	 */ 
	APP.Model.Wallet = APP.Model.extend({
		normalizeKeys: {
			_AC: 'credits',
			_PF: 'funds'
		},
		defaults: {
			'credits': 0,
			'funds': 0
		},
		schema: {
			'credits'	: 'number',
			'funds'		: 'number'
		},
		url: function () {
			return APP.ns('config').walletUrl;
		},
		parse: function (response) {
			return response && response.data;
		}
	});
	
	
	/**
	 * Module support
	 */
	if (typeof module !== 'undefined' && module.exports) {
		module.exports = APP.Model.Wallet;
	}
}(this));

/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule store
 */
(function (root) {
	"use strict";
	
	
	// Node support
	if (typeof require !== 'undefined') {
		if (!root.APP) {
			root.APP = require('./../common/app');
		}
		
		if (!root.APP.Collection) {
			root.APP.Collection = require('./../common/collection');
		}
		
		if (!root.APP.Model.Offer) {
			root.APP.Model.Offer = require('./model.offer');
		}
	}
	
	
	var APP = root.APP,
		_ = APP._,
		$ = APP.$,
		parent = APP.Collection.prototype;
	
	
	/**
	 * Collection: Offers
	 */
	APP.Collection.Offers = APP.Collection.extend({
		
		model: APP.Model.Offer,
		
		comparator: function comparatorOffersCollection(model) {
			// We already got this no need re-calculate it
			if (model.hasOwnProperty('sortWeight')) {
				return model.sortWeight;
			}
			
			var base = model.get('currency') === 'credits' ? 1000000 : 2000000;
			
			return (model.sortWeight = base + model.get('price'));
		},
		
		
		/**
		 * Get limited offers
		 */
		getLimitedOffers: function getLimitedPricesOffersCollection(filter) {
			filter = _.extend(filter || {}, {
				isUnlimited: false
			});
			return this.filterBy(filter);
		},
		
		
		/**
		 * Get unlimited offers
		 */
		getUnlimitedOffers: function getUnlimitedOffersCollection(filter) {
			filter = _.extend(filter || {}, {
				isUnlimited: true
			});
			return this.filterBy(filter);
		},
		
		
		/**
		 * Get Credit offers
		 */
		getCreditOffers: function getCreditOffersCollection(filter) {
			filter = _.extend(filter || {}, {
				currency: 'credits'
			});
			return this.filterBy(filter);
		},
		
		
		/**
		 * Get fund offers
		 */
		getFundOffers: function getFundPricesOffersCollection(filter) {
			filter = _.extend(filter || {}, {
				currency: 'funds'
			});
			return this.filterBy(filter);
		},
		
		/**
		 * Get lowest offers
		 */
		getLowestOffers: function getLowestOffersCollection() {
			var credits = this.getCreditOffers(),
				funds = this.getFundOffers(),
				getPriceFromModel = function (model) {
					return model.get('price');
				},
				lowest = {
					credits: credits.min(getPriceFromModel) || null,
					funds: funds.min(getPriceFromModel) || null
				};
			
			return lowest;
		},
		
		/**
		 * Get Unlocks
		 */
		getUnlockOffers: function getUnlocksOffersCollection(filter) {
			filter = _.extend(filter || {}, {
				isUnlock: true
			});
			return this.filterBy(filter);
		},
		
		/**
		 * Has Unlock offer
		 */
		hasUnlockOffers: function hasUnlock() {
			return this.some(function findUnlockOffer(model) {
				return model.isUnlock();
			});
		},
		
		/**
		 * Get lowest
		 */
		getLowest: function getLowestOffersCollection() {
			APP.log.warn('Use OffersCollection::getLowestOffers instead of OffersCollection::getLowest');
			return this.getLowestOffers.apply(this, arguments);
		},
		
		/**
		 * Get Unlocks
		 */
		getUnlocks: function getUnlocksOffersCollection() {
			APP.log.warn('Use OffersCollection::getUnlockOffers instead of OffersCollection::getUnlocks');
			return this.getUnlockOffers.apply(this, arguments);
		},
		
		/**
		 * Has Unlock offer
		 */
		hasUnlock: function hasUnlock() {
			APP.log.warn('Use OffersCollection::hasUnlockOffers instead of OffersCollection::hasUnlock');
			return this.hasUnlockOffers.apply(this, arguments);
		}
	});
	
	
	/**
	 * Module support
	 */
	if (typeof module !== 'undefined' && module.exports) {
		module.exports = APP.Collection.Offers;
	}
}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule store
 */
(function (global) {
	"use strict";
	
	
	var APP = global.APP,
		parent = APP.View.prototype,
		_ = APP._;
	
	/**
	 * Wallet View
	 */
	APP.View.Wallet = APP.View.extend({
		name: 'wallet-view',
        
		/**
		 * Initialize
		 */
		initialize: function initializeWalletView() {
			this.model.bind('change', this.render, this);
		},
		
		/**
		 * Destroy
		 */
		destroy: function destroyWalletView() {
			this.model.unbind('change', this.render, this);
		},
		
		/**
		 * Render
		 */
        render: function renderWalletView() {
			// Funds
            this.el.appendChild(this.make('span', {
				'class': 'funds'
			}, this.model.get('funds').toString()));
			
			// Credits
            this.el.appendChild(this.make('span', {
				'class': 'credits'
			}, this.model.get('credits').toString()));
			 
			// Disable Text Select
			this.$('span').disableTextSelect();
        }
	});
	
}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule store
 */
(function (root) {
	"use strict";
	
	
	var APP = root.APP,
		parent = APP.View.Dialog.prototype,
		win = APP.win,
		doc = APP.doc,
		$ = APP.$,
		_ = APP._,
		nsConfig = APP.namespace('config');
	
	APP.View.PurchaseDialog = APP.View.Dialog.extend({
		className: 'purchase-dialog',
		
		events: _.extend({}, parent.events, {
			'change input[type=radio]': function (e) {
				this.select(e.currentTarget.value);
			},
			'click a.get-more-funds': function (e) {
				if (e.currentTarget.className.indexOf('loading') === -1) {
					this.trigger('getfunds', this, this.lockboxUrl, e);
				} else {
					e.preventDefault();
				}
			}
		}),
		
		lockboxUrl: '#get-more-funds',
		
		/**
		 * Initialize
		 */
		initialize: function initializePurchaseDialogView() {
			parent.initialize.apply(this, arguments);
			
			if (!this.options.groupPrices && this.model.isCustomizable()) {
				this.options.groupPrices = 'both';
			}
			
			if (this.options.wallet) {
				this.options.wallet.bind('change', this.render, this);
			}
			
			this.offers = this.options.offers || this.model.get('offers');
			
			this.bind('insufficientfunds', this._onInsufficientFunds, this);
			
			this.bind('buy:click', this._onClickBuy, this);
		},
		
		/**
		 * Destroy
		 */
		destroy: function destroyPurchaseDialogView() {
			if (this.options.wallet) {
				this.options.wallet.unbind('change', this.render, this);
			}
			parent.destroy.apply(this, arguments);
		},
		
		/**
		 * Trigger buy Event
		 */
		_onClickBuy: function _onClickBuyPurchaseDialogView(view, e) {
			if (this._canClickBuy && this.selectedOffer) {
				this._canClickBuy = false;
				
				var currency = this.selectedOffer.get('currency'),
					price = this.selectedOffer.get('price'),
					balance = this.options.wallet.get(currency) - price;
				
				if (balance < 0) {
					this.trigger('insufficientfunds');
				} else {
					this.trigger('buy', this, this.model, e, this.selectedOffer, this.options.purchaseOptions);
				}
			}
		},
		
		_onInsufficientFunds: function _onInsufficientFundsPurchaseDialogView() {
			this._showInsufficientDialog();
		},
		
		
		_showInsufficientDialog: function () {
			this._hideInsufficientDialog();
			
			this.insufficientFundsDialog = this.createView(APP.View.Dialog, {
				container: doc.body,
				className: 'insufficient-funds-dialog',
				renderData: {
					close: true,
					title: this.trans('WEB_GAME_INSUFFICIENT_FUNDS_DIALOG_TITLE'),
					body: this.trans('WEB_GAME_INSUFFICIENT_FUNDS_DIALOG_BODY'),
					buttonRight: {
						attrs: {
							href: this.lockboxUrl,
							target: '_blank'
						},
						text: this.trans('WEB_GAME_INSUFFICIENT_FUNDS_DIALOG_BUTTON')
					}
				}
			}, 'insufficientfunds');
			
			this.insufficientFundsDialog.bind('close', this._hideInsufficientDialog, this);
			
			this.insufficientFundsDialog.bind('button:right', function () {
				this._hideInsufficientDialog();
				this.trigger('getfunds');
			}, this);
			
			this.insufficientFundsDialog.attach();
			this.insufficientFundsDialog.render();
			this.insufficientFundsDialog.show();
		},
		
		
		_hideInsufficientDialog: function () {
			if (this.insufficientFundsDialog) {
				this.destroyView(this.insufficientFundsDialog);
			}
			this.insufficientFundsDialog = null;
			this._canClickBuy = true;
		},
		
		
		/**
		 * Select
		 */
		select: function selectPurchaseDialogView(offer) {
			
			if (offer) {
				this.selectedOffer = this.offers.get(offer); 
			}
			
			if (!this.selectedOffer) {
				if (this.options.offer) {
					this.selectedOffer = this.options.offer;
				} else {
					this.selectedOffer = this.offers.at(0); 
				}
			}
			
			offer = this.selectedOffer;
			
			var currency = this.selectedOffer.get('currency'),
				price = this.selectedOffer.get('price'),
				balance = this.options.wallet.get(currency) - price,
				i;
			
			this.viewWallet.$('span.error').removeClass('error');
			
			this._canClickBuy = true;
			
			// Insufficient funds/credits
			if (balance < 0) {
				this.$checkoutMessage.text(this.trans('WEB_GAME_TOOLTIPS_INSUFFICIENT_' + currency.toUpperCase()));
				
				if (currency === 'funds') {
					this.$checkoutContainer.removeClass('error');
					this.$checkoutMessage.append(this.make('a', {
						'href': this.lockboxUrl,
						'target': '_blank',
						'class': 'get-more-funds'
					}, this.trans('WEB_GAME_TOOLTIPS_GET_MORE_BATTLEFUNDS')));
				} else {
					this._canClickBuy = false;
					this.$checkoutContainer.addClass('error');
					this.viewWallet.$('span.' + currency).addClass('error');
				}
				
				this.$checkoutMessage.show();
			} else {
				this.$checkoutContainer.removeClass('error');
				this.$checkoutMessage.empty().hide();
			}
			
			
			if (this._canClickBuy) {
				this.buyButton.enable();
			} else {
				this.buyButton.disable();
			}
			
			
			// Clear and set some classes
			this.$cost.html(price + '<i class="glyphs glyphs-' + currency + '20"></i>');
			
			this.$prices.removeClass('checked');
			this.$prices.find('input').filter(function () {
				return (this.value === offer.id);
			}).parent().addClass('checked');
			
			this.trigger('select', this.selectedOffer);
			
			return this;
		},
		
		
		/**
		 * Get Lookbox URL
		 */
		getLookboxUrl: function getLookboxUrl(fn) {
			var url = nsConfig.lockboxUrl,
				onError = function onError() {
					APP.log.error('Couldn\'t connect to the store, please try again later.');
				},
				$el = this.$('a.get-more-funds');
			
			$el.addClass('loading');
			
			$.ajax({
				url: url,
				context: this,
				success: function onSuccess(response) {
					if (response && response.status === 'success') {
						this.lockboxUrl = response.message;
						$el.attr('href', this.lockboxUrl);
						$el.removeClass('loading');
					} else {
						onError();
					}
				},
				error: onError
			});
			
			return this;
		},
		
		/**
		 * Render Group
		 */
		renderGroup: function renderGroupPurchaseDialogView(offers, options) {
			
			if (offers instanceof APP.Collection) {
				offers = offers.models;
			} else if (!_.isArray(offers)) {
				offers = [ offers ];
			}
			
			options = options || {};
			
			var content = _.map(offers, this.renderOffer, this);
			
			if (options.content && !_.isArray(options.content)) {
				options.content = [ options.content ];
			}
			
			options.content = (options.content || []).concat(content);
			
			return this.createView(APP.View.LabelBox, options);
		},
		
		/**
		 * Render Offer
		 */
		renderOffer: function renderOfferPurchaseDialogView(offer) {
			var text = offer.get('label'),
				label = this.make('label', null, text),
				currency = offer.get('currency'),
				price = offer.get('price'),
				attrs = {
					type: 'radio',
					name: 'price',
					value: offer.id
				},
				isLocked;
			
			if (this.model.isItemType('pocket')) {
				isLocked = this.model.isLocked(this.options.pocket);
			} else {
				isLocked = this.model.isLocked();
			}
			
			if (currency !== 'funds' && price > this.options.wallet.get(currency)) {
				label.className = 'error';
			}
			
			if (isLocked && !offer.isUnlock()) {
				attrs.disabled = 'disabled';
			}
			
			// Radio
			label.appendChild(this.make('input', attrs));
			
			// Label
			label.appendChild(this.make('span', {
				'class'	: currency
			}, price));
			
			return label;
		},
		
		/**
		 * Render Prices
		 */
		renderOffers: function renderOffersPurchaseDialogView() {
			
			var container = doc.createElement('div'),
				offers = this.offers,
				unlimitedOffers,
				limitedOffers,
				className = 'offers',
				condition,
				description,
				itemType = this.model.get('itemType'),
				permanentText,// = 'WEB_GAME_TOOLTIPS_CUSTOMIZE_UNLIMITED',
				unlockLevels,
				isLocked,
				lockType,
				lockCriteria;
			
			// Pocket item
			if (this.model.isItemType('pocket')) {
				unlockLevels = this.model.get('unlockLevels');
				lockType = 'level';
				lockCriteria = unlockLevels[offers.at(0).get('pocket')];
				isLocked = this.model.isLocked(this.options.pocket);
			
			// Other items
			} else {
				lockType = this.model.get('lockType');
				lockCriteria = this.model.get('lockCriteria');
				isLocked = this.model.isLocked();
			}
			
			// If model is locked ensure that are only using unlock
			if (isLocked && !this.options.offer) {
				condition = this.trans('WEB_GAME_LOCK_TYPE_' + lockType.toUpperCase()) + ' ' + lockCriteria;
				description = 'WEB_GAME_TOOLTIPS_DESCRIPTION_UNLOCK_' + lockType.toUpperCase();
				
				this.renderGroup(offers.getUnlockOffers(), {
					container: container,
					className: className,
					label:  this.trans('WEB_GAME_TOOLTIPS_PRICE_GROUP_UNLOCK') + ':',
					content: '<p>' + this.trans(description, { '%condition%': condition }) + '</p>'
				}).render().attach();
				
				offers = offers.filterBy({
					isUnlockOffer: false
				});
				className += ' locked';
			}
			
			// Specific offer
			if (this.options.offer) {
				this.renderGroup(this.options.offer, {
					container: container,
					className: 'offers' + (isLocked && !this.options.offer.isUnlock() ? ' locked' : '')
				}).render().attach();
				
			// Group Prices
			} else if (this.options.groupPrices) {
				
				// Unlimited
				if (this.options.groupPrices === 'unlimited' || this.options.groupPrices === 'both') {
					unlimitedOffers = offers.getUnlimitedOffers({
						isUnlockOffer: false
					});
					
					if (unlimitedOffers.length !== 0) {
						
						/* 
						TODO: Uncomment this when we do functional clothing again
						if (itemType === 'appearance') {
							permanentText = 'WEB_GAME_TOOLTIPS_CUSTOMIZE_APPAREL_ITEM_UNLIMITED';
						} else
						*/
						if (itemType === 'weapon') {
							permanentText = 'WEB_GAME_TOOLTIPS_CUSTOMIZE_WEAPON_UNLIMITED';
						}
						
						
						this.renderGroup(unlimitedOffers, {
							container: container,
							className: className,
							label: this.trans('WEB_GAME_TOOLTIPS_PRICE_GROUP_UNLIMITED') + ':',
							content: permanentText ? '<p>' + this.trans(permanentText) + '</p>' : null
						}).render().attach();
					}
				}
				
				// Limited
				if (this.options.groupPrices === 'limited' || this.options.groupPrices === 'both') {
					limitedOffers = offers.getLimitedOffers({
						isUnlockOffer: false
					});
					
					if (limitedOffers.length !== 0) {
						this.renderGroup(limitedOffers, {
							container: container,
							className: className,
							label: this.trans('WEB_GAME_TOOLTIPS_PRICE_GROUP_LIMITED') + ':'
						}).render().attach();
					}
				}
			
			// All in one group
			} else if (offers.length !== 0) {
				this.renderGroup(offers.filterBy({
					isUnlockOffer: false
				}), {
					container: container,
					className: className,
					label: this.trans('WEB_GAME_TOOLTIPS_PRICE_GROUP_BOTH') + ':'
				}).render().attach();
			}
			
			return container;
		},
		
		/**
		 * Render Checkout
		 */
		renderCheckout: function renderCheckoutPurchaseDialogView() {
			var checkoutWrapper = doc.createDocumentFragment(),
				checkoutContainer = doc.createDocumentFragment(),
				costContainer = this.make('div', {
					'class': 'prices'
				});
			
			// Cost
			this.$cost = this.$('<span />').addClass('currency').appendTo(costContainer);
			
			// Checkout Message
			this.$checkoutMessage = this.$('<span />').addClass('checkout-message').appendTo(checkoutWrapper);
			
			checkoutContainer.appendChild(costContainer);
			
			// Buy button
			this.buyButton = this.createView(APP.View.Button, {
				container: checkoutContainer,
				className: 'buy',
				primary: true,
				glyph: 'buy',
				text: this.trans('WEB_GAME_TOOLTIPS_BUY_BTN'),
				sound: true
			}, 'buy').render().attach();
			
			// Label box
			this.createView(APP.View.LabelBox, {
				className: 'purchase',
				container: checkoutWrapper,
				label: this.trans('WEB_GAME_TOOLTIPS_CREDITS_TOTAL'),
				content: checkoutContainer
			}).render().attach();
			
			
			this.$checkoutContainer = this.$(checkoutContainer);
			
			return checkoutWrapper;
		},
		
		/**
		 * Render Wallet
		 */
		renderAccount: function renderAccountPurchaseDialogView() {
			var accountContainer = this.make('div', {
					'class'	: 'account-container'
				});
			
			accountContainer.appendChild(this.make('h4', null, this.trans('WEB_GAME_TOOLTIPS_ACCOUNT_BALANCE')));
			
			// Wallet View
			this.viewWallet = this.createView(APP.View.Wallet, {
				container: accountContainer,
				model: this.options.wallet
			}, 'wallet');
			
			this.viewWallet.render();
			
			this.viewWallet.attach();
			
			accountContainer.appendChild(this.make('a', {
				'href': this.lockboxUrl,
				'target': '_blank',
				'class': 'get-more-funds loading'
			}, this.trans('WEB_GAME_TOOLTIPS_GET_MORE_BATTLEFUNDS')));
			
			return accountContainer;
		},
		
		/**
		 * Render Body
		 */
		renderBody: function renderBodyPurchaseDialogView() {
			
			var docFrag = APP.doc.createDocumentFragment(),
				img = this.make('img', {
					'src'	: nsConfig.imageFolder + 'game/1x1-transparent.png',
					'class'	: 'item loading',
					'width'	: nsConfig.imageSize.med.width,
					'height': nsConfig.imageSize.med.height
				}),
				description = this.model.get('description'),
				shortDescription = this.model.get('shortDescription'),
				mainContainer = this.make('div', {
					'class'	: 'main-container'
				}),
				offers = this.renderOffers(),
				checkout = this.renderCheckout(),
				account = this.renderAccount(),
				count;
			
			// Load image
			APP.preload.image(this.model.getImage('med'), _.bind(function (err, src, size) {
				// TODO: Log this error
				if (err) {
					APP.log.warn(err);
					src = nsConfig.imageFolder + 'game/tmp_bundle.jpg';
					size = { width: img.width, height: img.height };
				}
				img.src = src;
				img.width = size.width;
				img.height = size.height;
				img.className = 'item ' + this.model.get('itemType');
			}, this));
			
			// Description text
			// Weapons and attachments
			if ((this.model.isType('weapon') || this.model.isType('attachment')) && description && description.length < 60) {
				mainContainer.appendChild(this.make('p', {
					'class' : 'description'
				}, description));
				
			// Training point
			} else if (this.model.isType('trainingpoint')) {
				count = this.model.get('extraPointsMax') - this.model.get('extraPointsPurchased');
				mainContainer.appendChild(this.make('p', {
					'class' : 'description'
				}, this.transChoice('WEB_STORE_ABILITIES_BUY_POINTS_TEXT', count, { '%count%': count })));
				
			// Supply drop
			} else if (this.model.isType('bundle') && this.model.get('isRandomContent')) {
				mainContainer.appendChild(this.make('p', {
					'class' : 'description'
				}, shortDescription));
			}
			
			
			mainContainer.appendChild(offers);
			mainContainer.appendChild(checkout);
			
			docFrag.appendChild(img);
			docFrag.appendChild(mainContainer);
			docFrag.appendChild(account);
			
			return docFrag;
		},
		
		
		/**
		 * Render
		 */
		render: function renderPurchaseDialogView() {
			
			// Render Data
			this.options.renderData = {
				close: true,
				title: this.trans('WEB_GAME_TOOLTIPS_CONFIRM_PURCHASE') + ' <span>' + this.model.get('name') + '</span>',
				body: this.renderBody()
			};
			
			
			// Render parent
			parent.render.apply(this, arguments);
			
			// Add item-type class
			this.$el.addClass(this.model.get('itemType'));
			
			// Identify supply drops
			if (this.model.isType('bundle') && this.model.get('isRandomContent')) {				
				this.$el.addClass('supply-drop');
			}
			
			
			// Get prices
			this.$prices = this.$('label');
			
			// Get first not disabled prices input 
			var $first = this.$prices.find('input:not([disabled])');
			
			// Select price
			if (this.selectedOffer) {
				this.select();
			} else if ($first.size() !== 0) {
				this.select($first.val());
			}
			
			// Update lookbox
			this.getLookboxUrl();
			
			// Disable Text Select
			this.$('img, h3, p, a.get-more-funds, div.checkout-container').disableTextSelect();
		}
	});
}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule store
 */
(function (win) {
	"use strict";
	
	
	var APP = win.APP,
		$ = APP.$,
		_ = APP._,
		nsConfig = APP.namespace('config'),
		parent = APP.View.Tooltip.prototype;
	
	/**
	 * Purchase View
	 */
	APP.View.PurchaseTooltip = APP.View.Tooltip.extend({
		className: 'purchase-tooltip',
		renderModelAndShow: function renderModelAndShow(model, el) {
			return this.renderModel(model).show(el);
		},
		renderModel: function renderModelPurchaseTooltipView(model) {
			this.model = model;
			return this.render();
		},
		render: function renderPurchaseTooltipView() {
			
			var html = [];
			
			// Is Locked
			if (this.model.isLocked()) {
				this.$el.addClass('locked');
				
				html.push('<h3>' + this.trans('WEB_GAME_PURCHASE_ITEM_LOCKED') + '</h3>');
				
				html.push('<div class="lock-progress">');
				html.push('<span class="bar" style="width: ' + Math.round(100 - (100 * this.model.get('lockProgress'))) + '%;"></span>');
				html.push('<span class="text">' + this.trans('WEB_GAME_LOCK_TYPE_' + this.model.get('lockType').toUpperCase()) + ' ' + this.model.get('lockCriteria') + '</span>');
				html.push('</div>');
				
				if (this.model.get('offers').hasUnlockOffers()) {
					html.push('<h3>' + this.trans('WEB_GAME_PURCHASE_UNLOCK_OPTIONS') + '</h3>');
					html.push('<dl class="prices">');
					this.model.get('offers').filterBy({
						'isUnlockOffer': true
					}).forEach(function (model) {
						html.push('<dt>' + model.get('limit') + '</dt>');
						html.push('<dd class="' + model.get('currency') + '">' + model.get('price') + '</dd>');
					});
					html.push('</dl>');
				}
				
			// Show prices
			} else if (this.model.isBuyable()) {
				html.push('<h3>' + this.trans('WEB_GAME_PURCHASE_OPTIONS') + '</h3>');
				html.push('<dl class="prices">');
				this.model.get('offers').filterBy({
					'isUnlockOffer': false
				}).forEach(function (model) {
					html.push('<dt>' + model.get('limit') + '</dt>');
					html.push('<dd class="' + model.get('currency') + '">' + model.get('price') + '</dd>');
				});
				html.push('</dl>');
			}
			
			this.$el.html(html.join(''));
		}
	});
}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule store
 */
/**
 * @class GAME.Task.store.purchase
 * @uses GAME.Task.store.wallet
 * @uses GAME.Task.items
 */
APP.task('store.purchase', [ 'store.wallet', 'items' ], function taskStoreBuy(done) {
	"use strict";
	
	
	var $ = APP.$,
		_ = APP._,
		nsConfig = APP.namespace('config'),
		nsStore = APP.namespace('store'),
		nsItems = APP.namespace('items'),
		nsBundles = APP.namespace('bundles'),
		
		/**
		 * Get Wallet
		 */
		wallet = nsStore.wallet,
		
		/**
		 * Purchase
		 */
		purchase = nsStore.purchase  = function purchase(model, offer, options) {
			options = options || {};
			model = nsItems.collection.get(model);
			
			// Is a model?
			if (!(model instanceof APP.Model.Item)) {
				nsStore.trigger('purchase:error', model, offer, new Error('Invalid model!'));
				return nsStore;
			}
			
			// AJAX Options
			var ajaxOptions = {
					type: 'POST',
					cache: false,
					
					/**
					 * On Success
					 */
					success: function onSuccessPurchase(response) {
						if (response && response.status === 'success') {
							var data = response.data || {},
								newWalletBalance = {};
							
							// New credits balance
							if (data.hasOwnProperty('credits')) {
								newWalletBalance.credits = data.credits;
							}
							// New battlefunds balance
							if (data.hasOwnProperty('battlefunds')) {
								newWalletBalance.funds = data.battlefunds;
							}
							// New funds balance
							if (data.hasOwnProperty('funds')) {
								newWalletBalance.funds = data.funds;
							}
							// Update Wallet
							if (!_.isEmpty(newWalletBalance)) {
								wallet.set(newWalletBalance);
							}
							
							// Update item model(s)
							_.forEach(data.items || [], function updateItemsIterator(data, modelId) {
								var model = nsItems.collection.get(modelId);
								
								// We have this item
								if (model) {
									// Remove equipped slot since it can already be set but not saved
									delete data.equippedSlot;
									model.set(data);
								
								// Add as new item
								} else {
									nsItems.collection.add([ data ]);
								}
							});
							
							// Update Training point
							if (model.isType('trainingpoint') && data.hasOwnProperty('purchasedPoints') && data.hasOwnProperty('trainingPoints')) {
								// TODO: We should NOT set anything on the namespace, we should be able
								// to fix this as soon as we fix item refresh/delta reload on ability purchase
								model.set({
									'extraPointsPurchased': (nsItems.extraPointsPurchased = parseInt(data.purchasedPoints, 10)),
									'trainingPointsCurrent': (nsItems.trainingPointsCurrent = parseInt(data.trainingPoints, 10)),
									'prices': (nsItems.trainingPointOffers = data.offers || [])
								});
							}
							
							// Trigger the SUCCESS event
							model.trigger('purchase:success', model, offer, response.status, response);
							nsStore.trigger('purchase:success', model, offer, response.status, response);
							
						} else {
							APP.log.warn('purchase:error', {
								model: model,
								offer: offer,
								response: response
							});
							
							// Trigger the ERROR event
							model.trigger('purchase:error', model, offer, new Error('Invalid status!'), response);
							nsStore.trigger('purchase:error', model, offer, new Error('Invalid status!'), response);
						}
					},
					
					/**
					 * On Error
					 */
					error: function onErrorPurchase(jqXHR, status, err) {
						APP.log.warn('purchase:error', {
							model: model,
							offer: offer
						});
						
						// Trigger the ERROR event
						model.trigger('purchase:error', model, offer, err);
						nsStore.trigger('purchase:error', model, offer, err);
					},
					
					/**
					 * On Complete
					 */
					complete: function onCompletePurchase() {
						// Trigger the END event
						model.trigger('purchase:end', model, offer);
						nsStore.trigger('purchase:end', model, offer);
					}
				};
			
			// Traningpoint purchase url
			if (model.isItemType('trainingpoint')) {
				ajaxOptions.url = nsConfig.purchaseTrainingPointUrl.replace('OFFERID', offer.id);
			
			// Upgrade purchase and attach url
			} else if (model.isItemType('pocket')) {
				ajaxOptions.url = nsConfig.pockets.purchaseAndAttachUrl.replace('ITEM_ID', options.model.id);
				ajaxOptions.url = ajaxOptions.url.replace('POCKET', offer.get('pocket'));
				ajaxOptions.url = ajaxOptions.url.replace('OFFER_ID', offer.id);
				
				// Change model
				model = options.model;
				
			// All others purchase url 
			} else {
				ajaxOptions.url = nsConfig.purchaseUrl.replace('OFFERID', offer.id);
			}
			
			
			// Is a offer?
			if (!(offer instanceof APP.Model.Offer)) {
				model.trigger('purchase:error', model, offer, new Error('Invalid Offer!'));
				nsStore.trigger('purchase:error', model, offer, new Error('Invalid Offer!'));
				return nsStore;
			}
			
			
			// Trigger the START event
			model.trigger('purchase:start', model, offer);
			nsStore.trigger('purchase:start', model, offer);
			
			// Make Request
			$.ajax(ajaxOptions);
			
			// Return namespace
			return nsStore;
		};
	
	/**
	 * Task Done!
	 */
	done();
});
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule store
 */
/**
 * @class GAME.Task.store.getfunds
 * @uses GAME.Task.store.wallet
 */
APP.task('store.getfunds', [ 'store.wallet' ], function taskStoreBuy(done) {
	"use strict";
	
	var $ = APP.$,
		_ = APP._,
		win = APP.win,
		setTimeout = win.setTimeout,
		clearTimeout = win.clearTimeout,
		nsConfig = APP.namespace('config'),
		nsStore = APP.namespace('store'),
		
		/**
		 * Get Wallet
		 */
		wallet = nsStore.wallet,
		
		getfundsDialog,
		
		renderData = {
			//title: APP.sidis.trans('WEB_MENU_GET_BATTLEFUNDS'),
			body: [
				APP.sidis.trans('WEB_GAME_TOOLTIPS_GET_MORE_BATTLEFUNDS_OPEN_WINDOW'),
				APP.sidis.trans('WEB_GAME_TOOLTIPS_GET_MORE_BATTLEFUNDS_WAITING')
			]
		},
		
		onClose = function onClose() {
			if (getfundsDialog) {
				getfundsDialog.destroy();
				getfundsDialog = null;
			}
		},
		
		onButton = function onButton() {
			APP.reload();
		},
		
		/**
		 * Poll for battlefunds
		 */
		checkForFunds = function checkForFunds() {
			if (!checkForFunds.count) {
				checkForFunds.count = 0;
			}
			
			clearTimeout(checkForFunds.timer);
			
			var keepLooking = function keepLooking() {
					checkForFunds.count += 1;
					
					// Have we reached the limit?
					if (checkForFunds.count >= 10 && getfundsDialog) {
						
						// Timed out we need to re-redner the dialog with a new button
						getfundsDialog.setRenderData(_.extend({}, renderData, {
							buttonRight: APP.sidis.trans('WEB_GAME_TOOLTIPS_GET_MORE_BATTLEFUNDS_TIMEOUT')
						})).render();
					}
					
					// Keep looking for changes
					checkForFunds.timer = setTimeout(checkForFunds, 2000);
				};
			
			$.ajax({
				type: "GET",
				dataType: 'json', 
				url: nsConfig.walletUrl,
				cache: false,
				success: function onSuccess(response) {
					var fundsOnServer;
					// Successful response
					if (response && response.status === 'success') {
						fundsOnServer = parseInt((response.data && response.data._PF) || 0, 10);
						
						// Funds on server is different than what we have
						if (fundsOnServer !== wallet.get('funds')) {
							// Reset counter
							checkForFunds.count = null;
							
							// Update wallet with new value
							wallet.set({
								funds: fundsOnServer
							});
							
							onClose();
							
						// Keep looking for changes
						} else {
							keepLooking();
						}
					
					// Keep looking for changes
					} else {
						keepLooking();
					}
				},
				error: keepLooking
			});
		},
		
		/**
		 * On Store Get Funds
		 */
		onGetFunds = function onGetFunds() {
			if (getfundsDialog) {
				getfundsDialog.destroy();
			}
			
			getfundsDialog = new APP.View.Dialog({
				className: 'getfunds-dialog'
			});
			
			// Listen to close events
			getfundsDialog.bind('close', onClose);
			
			// Listen to button clicks
			getfundsDialog.bind('button', onButton);
            
			// Render
			getfundsDialog.attach().setRenderData(renderData).render();
			
			// Show
			getfundsDialog.show();
			
			// Check for funds
			checkForFunds();
		};
	
	
	/**
	 * Listen to get funds events
	 */
	nsStore.bind('getfunds', onGetFunds);
	
	/**
	 * Task Done!
	 */
	done();
});
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule store
 */
/**
 * @class GAME.Task.store
 * @uses GAME.Task.store.purchase
 * @uses GAME.Task.store.wallet
 * @uses GAME.Task.store.getfunds
 */
APP.domTask('store', [ 'store.purchase', 'store.wallet', 'store.getfunds' ], function taskStore(done) {
	"use strict";
	
	var $ = APP.$,
		_ = APP._,
		nsStore = APP.namespace('store'),
		nsItems = APP.namespace('items'),
			
		/**
		 * Purchase Dialog View
		 */
		purchaseDialog,
		
		/**
		 * On Store Buy Handler
		 */
		onStoreBuy =  function onStoreBuy(model, options) {
			
			// Validate model
			model = nsItems.collection.get(model);
			if (!(model instanceof nsItems.collection.model)) {
				throw new Error('Buy: Invalid model!');
			}
			
			// if we gat a dialog Destroy it! 
			if (purchaseDialog) {
				purchaseDialog.destroy();
				purchaseDialog = null;
			}
			
			// Extend and set view options
			options = _.extend(options || {}, {
				model: model,
				wallet: nsStore.wallet
			});
			
			// Create dialog
			purchaseDialog = new APP.View.PurchaseDialog(options);
            
			// On close destroy view
			purchaseDialog.bind('close', function onClosePurchaseDialog() {
				purchaseDialog.destroy();
				purchaseDialog = null;
			});
			
			// On get funds destroy view
			purchaseDialog.bind('getfunds', function onGetFundsPurchaseDialog() {
				nsStore.trigger('getfunds');
			});
			
			// On buy purchase
			purchaseDialog.bind('buy', function onBuyPurchaseDialog(view, model, e, offer, options) {
				purchaseDialog.destroy();
				purchaseDialog = null;
				nsStore.purchase(model, offer, options);
			});
            
			// Attach
			purchaseDialog.render().attach();
			
			// Show view
			purchaseDialog.show();
		},
		
		/**
		 * Buy Offer
		 */
		buyOffer = function buyOffer(offerId) {
			var overlay = new APP.View.Overlay();
			
			overlay.render().attach().show();
			
			nsItems.getItemByOfferId(offerId, function (err, model, offers) {
				if (err) {
					APP.log.warn(err);
				} else {
					nsStore.trigger('buy', model, {
						offer: offers.at(0)
					});
				}
				overlay.destroy();
			});
		};
	
	
	/**
	 * Listen for buy events
	 */
	nsStore.bind('buy', onStoreBuy);
	
	
	/**
	 * Listen for buy offer events
	 */
	nsStore.bind('buy:offer', buyOffer);
	
	
	/**
	 * Task Done
	 */
	done();
});
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule store
 */
/**
 * @class GAME.Task.store.wallet
 */
APP.domTask('store.wallet', function taskStoreWallet(done) {
	"use strict";
	
	
	var $ = APP.$,
		_ = APP._,
		nsConfig = APP.namespace('config'),
		nsStore = APP.namespace('store'),
		
		/**
		 * Get current
		 */
		wallet = nsStore.wallet = new APP.Model.Wallet({
			credits	: nsConfig.credits,
			funds	: nsConfig.funds
		}),
		
		/**
		 * Wallet View
		 */
		$container = $('div.main.main_home div.wallet'),
		walletView = nsStore.walletView = new APP.View.Wallet({
			container	: $container,
			model		: wallet
		});
	
	$container.empty();
	
	walletView.attach().render();
	
	/**
	 * Task Done
	 */
	done();
});
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule store
 */
/**
 * @class GAME.Task.store.routes
 * @uses GAME.Task.store
 */
APP.task('store.routes', [ 'store' ], function taskStoreRoutes(done) {
	"use strict";
	
	
	var win = APP.$,
		$ = APP.$,
		_ = APP._,
		nsStore = APP.ns('store');
	
	
	/**
	 * End of round offer
	 */
	APP.route('eor-offer/:offer', 'eor-offer', function (offerId) {
		nsStore.trigger('buy:offer', offerId);
		APP.navigate('/weapons', true);
	});
	
	
	/**
	 * Buy offer
	 */
	APP.route('offer/:offer', 'buy-offer', function (offerId) {
		nsStore.trigger('buy:offer', offerId);
		APP.navigate('/');
	});
	
	
	/**
	 * Buy
	 */
	APP.route('buy/:model', 'buy-model', function (modelId) {
		nsStore.trigger('buy', modelId);
		APP.navigate('/');
	});
	
	
	/**
	 * Task done!
	 */
	done();
});

	
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule login
 */
/**
 * @class GAME.Task.login
 * @uses GAME.Task.items
 * @uses GAME.Task.preload
 */
APP.task('login', ['items', 'preload'], function initLogin(done) {
	"use strict";
	
	
	var win = APP.win,
		$ = APP.$,
		nsConfig = APP.ns('config');
	
	
	// On login success
	APP.once('login:success', function onLoginSuccess() {
		// Initialize the doll
		win.initDoll();
		
		// Task done
		done();
	});
	
	// On login error
	APP.once('login:error', function onLoginError(data) {
		done(new Error(data.message));
	});
	
	/**
	 * Login error
	 */
	win.onLoginError = function onLoginError() {
			
		var errorMessages = {
				1000: 'ErrConnectionFailed',
				1001: 'ErrConnectionLost',
				1002: 'ErrAccountLogin',
				1003: 'ErrSoldierLogin',
				1004: 'ErrInvalidAccount',
				1005: 'ErrInvalidPassword',
				1006: 'ErrInvalidSoldier',
				1007: 'ErrNotEntitled',
				1008: 'ErrPortInUse',
				1009: 'ErrSoldierLoginDataFailed',
				1010: 'ErrNoEncryptedLogin',
				1011: 'ErrNoAccountName',
				1012: 'ErrNoAccountPassword',
				1013: 'ErrInvalidConnectionState',
				1014: 'ErrInvalidService',
				1015: 'ErrSoldiersListDataFailed',
				1017: 'ErrNotEntitledToPlay'
				
			},
			errorCode = win.login ? win.login.error : 1003,
			errorMessage;
		
		if (errorMessages.hasOwnProperty(errorCode)) {
			errorMessage = errorCode + ': ' + errorMessages[errorCode];
		} else {
			errorMessage = errorCode + ': Unknown error';
		}
		
		// Trigger APP event
		APP.trigger('login:error', {
			code: errorCode,
			message: errorMessage
		});
	};
	
	/**
	 * Login State Chagne
	 */
	win.onLoginStateChange = function onLoginStateChange(oldState, state) {
		
		var msg = '',
			eventData = {
				state: state,
				prevState: oldState,
				message: msg
			};
		
		// Initializing
		if (state === 1) {
			msg = 'Initializing...';
		
		// Connecting
		} else if (state === 2) {
			msg = 'Connecting...';
		
		// 'Logging in account
		} else if (state === 3) {
			msg = 'Logging in account...';
		
		// Retrieving soldiers list
		} else if (state === 4) {
			msg = 'Retrieving soldiers list...';
		
		// Downloading soldiers data
		} else if (state === 5) {
			msg = 'Downloading soldiers data...';
		
		// Waiting for soldiers data
		} else if (state === 6) {
			msg = 'Waiting for soldiers data...';
		
		// Logging in soldier
		} else if (state === 7) {
			msg = 'Logging in soldier...';
		
		// Picking soldier
		} else if (state === 8) {
			APP.log('Login state  8: Picked soldier ' + nsConfig.personaName);
			
			win.login.pickSoldier(nsConfig.personaName);
			
			msg = 'Picking soldier...';
			
		// Logging out
		} else if (state === 9) {
			msg = 'Logging out...';
			
		// Login complete
		} else if (state === 100) {
			msg = 'Login complete!';
			
			// Trigger APP event
			APP.trigger('login:success', eventData);
		}
		
		APP.log('Login state ' + state + ': ' + msg);
	};
	
	/**
	 * In game login?
	 */
	if (win.login) {
		
		// Listen to events
		win.login.addEventHandler('onError', 'onLoginError');
		win.login.addEventHandler('onStateChanged', 'onLoginStateChange');
		
		// Begin login
		if (win.login.state === 0) {
			win.login.start();
			
		// Logged in!
		} else if (win.login.state === 100) {
			// Trigger APP event
			APP.trigger('login:success');
			
		// THIS IS BAD
		} else if (win.login.state === 2) {
			
			APP.log('THIS IS BAD');
			
			
		} else if (win.login.error !== 0) {
			win.onLoginError();
		}
	
	/**
	 * In regular browser, fake login
	 */
	} else {
		APP.trigger('login:success');
	}
});
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule menu
 */
/**
 * @class GAME.Task.menu
 * @uses GAME.Task.game
 * @uses GAME.Task.items
 */
APP.task('menu', [ 'game', 'items' ], function taskMenu(done) {
	"use strict";
	
	var win = APP.win,
		setTimeout = win.setTimeout,
		clearTimeout = win.clearTimeout,
		$ = APP.$,
		_ = APP._,
		nsMenu = APP.ns('menu'),
		nsGame = APP.ns('game'),
		nsItems = APP.ns('items'),

		view = nsMenu.view = new APP.View.Menu({
			container	: APP.$main,
			personas	: nsGame.personas,
			tp			: nsItems.get('tp')
		}),

		setFriendsCount = nsMenu.setFriendsCount = function setFriendsCount(count) {
			count = count || 0;

			view.setFriendsCount(count);
		},

		menuTooltip = new APP.View.Tooltip({
			className: 'main-menu-tooltip'
		}),

		menuTextMap = {
			home		: APP.sidis.trans('WEB_GAME_MENU_HOME'),
			weapons		: APP.sidis.trans('WEB_GAME_MENU_WEAPONS'),
			appearance	: APP.sidis.trans('WEB_GAME_MENU_APPERANCE'),
			boosters	: APP.sidis.trans('WEB_GAME_MENU_BOOSTERS'),
			bundles		: APP.sidis.trans('WEB_GAME_MENU_BUNDLES'),
			abilities	: APP.sidis.trans('WEB_GAME_MENU_ABILITIES'),
			options		: APP.sidis.trans('WEB_GAME_OPTIONS_HEADER_SETTINGS'),
			browser		: APP.sidis.trans('WEB_GAME_MENU_SERVERS'),
			friends		: APP.sidis.trans('WEB_GAME_MENU_JOINFRIENDS')
		},
		timer;

	menuTooltip.attach();

	view.bind('enter:nav', function (view, e) {
		var name = $(e.currentTarget).data('name'),
			menuText = menuTextMap[name];

		clearTimeout(timer);

		timer = setTimeout(function () {
			menuTooltip.renderHTMLAndShow(menuText, e.currentTarget);
		}, 500);
	});
	view.bind('leave:nav', function () {
		clearTimeout(timer);
		menuTooltip.hide();
	});
    
	view.bind('show:personas', function () {
		clearTimeout(timer);
		menuTooltip.hide();
	});


	view.render();

	view.attach();

	setFriendsCount($('.main_home .friends_list li.friend').size());
	
	/**
	 * Task Done!
	 */
	done();
});
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule menu
 */
/**
 * @class GAME.Task.menu.routes
 * @uses GAME.Task.menu
 */
APP.task('menu.routes', [ 'menu' ], function taskMenuRoutes(done) {
	"use strict";
	
	var nsGame = APP.ns('game'),
		nsMenu = APP.ns('menu');
	
	
	// Switch persona
	APP.route('switch/:id', 'switch-persona', function (id) {
		var persona = nsGame.personas.get(id);
		if (persona) {
			nsGame.switchPersona(persona);
		}
	});
	
	
	// Play Now
	APP.route('play-now', 'play-now', function (id) {
		APP.navigate('');
		nsGame.playNow();
	});
	
	
	// Page chagne
	APP.bind('page', function onPageTaskMenu(page, from) {
		nsMenu.view.setActive(page);
	});

	
	/**
	 *  Task done!s
	 */
	done();	
});
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule menu
 */
(function (root) {
	"use strict";
	
	
	var APP = root.APP,
		win = APP.win,
		$ = APP.$,
		_ = APP._;

	/**
	 * Menu View
	 */
	APP.View.Menu = APP.View.extend({
		name: 'menu-view',
		tagName: 'div',
		
		options: {
			items: [
				'home',
				'weapons',
				'appearance',
				'boosters',
				'bundles',
				'abilities',
				'options'
			]
		},
		
		events: {
			'mouseenter a.play-now': function (e) {
				this.sound('hover');
			},
			'mouseenter .nav': function (e) {
				this.sound('hover');
				this.trigger('enter:nav', this, e);
			},
			'mouseleave .nav': function (e) {
				this.trigger('leave:nav', this, e);
			},
			'mouseenter li.home': function () {
				this.sound('hover');
				this.showPersonas();
			},
			'mouseleave li.home': function () {
				this.hidePersonas();
			},
			'mouseenter ul.persona-list': function () {
				this.sound('hover');
				this.showPersonas();
			},
			'mouseleave ul.persona-list': function () {
				this.hidePersonas();
			},
			/*'mousedown ul.persona-list a, ul.persona-list a span': function () {
				return false;
			}, 
			'mousedown ul.items a, ul.items a span': function () {
				return false;
			},
			'mousedown a.play-now, a.browser, a.friends': function () {
				return false;
			},*/

			/**
			 *  Handle click on items
			 */
			'click a': function onClickItem() {
				this.sound('click');
			}
		},

		initialize: function initializeMenuView() {
			
			this.personas = this.options.personas;
					
			this.tp = this.options.tp;

			this.tp.bind('change:trainingPointsCurrent', this._renderTrainingPoint, this);
		},

		destroy: function destroyMenuView() {
			
		},


		/**
		 * Render menu items
		 * @param name
		 * @return {*}
		 * @private
		 */
		_renderItems: function _renderItemsListMenuView(name) {
			var list = this.make('ul', {
					'class': 'items'
				});
			
			_.forEach(this.options.items, function (name) {
				var li = this.make('li', {
						'class': name + ' nav',
						'data-name': name
					}),
					link = this.make('a', {
						'href': '#' + name
					});
				
				link.appendChild(this.make('span', {
					'class': 'glyph ' + name
				}));
							
				li.appendChild(link);
				
				list.appendChild(li);
			}, this);
						
			return list;
		},


		/**
		 * Render soldier list 
		 * @return {*}
		 * @private
		 */
		_renderPersonaList: function _renderPersonaListMenuView() {
			var list = this.make('ul', {
					'class': 'dropdown persona-list'
				});


			this.personas.forEach(function (persona) {
				var li = this.make('li'),
					a;
				
				if (persona.get('isCurrent')) {
					a = this.make('span', {
						'class'	: 'persona kit-' + persona.get('kit')
					});
				} else {
					a = this.make('a', {
						'href'	: '#switch/' + persona.id,
						'class'	: 'persona kit-' + persona.get('kit')
					});
				}
				
				// Name
				a.appendChild(this.make('span', {
					'class'	: 'name'
				}, persona.get('name')));
				
				// Rank
				a.appendChild(this.make('span', {
					'class'	: 'rank'
				}, this.trans('WEB_GAME_HOME_SOLDIERLIST_LEVEL') + ' ' + persona.get('level')));


				li.appendChild(a);
				list.appendChild(li);
			}, this);
			
			return list;
		},

		_renderTrainingPoint: function () {
			var trainingPointsCurrent = this.tp.get('trainingPointsCurrent'),
				$tpCount = this.$('li.abilities span.count');
			
			if (trainingPointsCurrent === 0) {
				$tpCount.remove();
				
			} else {
				if ($tpCount.size() === 0) {
					$tpCount = $('<span class="count"></span>');
					$tpCount.appendTo(this.$('li.abilities a'));
				}

				$tpCount.text(trainingPointsCurrent);
			}
		},

		setFriendsCount: function (count) {
			
			var $count = this.$('a.friends span.count');

			if (count === 0) {
				$count.remove();

			} else {
				if ($count.size() === 0) {
					$count = $('<span class="count"></span>');
					$count.appendTo(this.$('a.friends'));
				}

				$count.text(count);
			}
		},
		
		showPersonas: function showPersonasMenuView() {
			clearTimeout(this._leaveTimer);
			var $personaList = this.$('ul.persona-list');
			$personaList.show();
			this.trigger('show:personas', this, $personaList);
		},
		hidePersonas: function hidePersonasMenuView() {
			var $personaList = this.$('ul.persona-list');
			this._leaveTimer = setTimeout(_.bind(function () {
				$personaList.hide();
				this.trigger('hide:personas', this, $personaList);
			}, this), 200);
		},
		
		/**
		 * Set active
		 * @param active
		 * @return {*}
		 */
		setActive: function setActiveMenuView(active) {
			var $items = this.$('ul.items li'),
				$browser = this.$('a.browser'),
				$friends = this.$('a.friends'),
				i = _.indexOf(this.options.items, active);

			$items.removeClass('active');
			$browser.removeClass('active');
			$friends.removeClass('active');
			
			if (i !== -1) {
				$items.eq(i).addClass('active');
				
			} else if (active === 'serverbrowser') {
				$browser.addClass('active');
				
			} else if (active === 'joinfriends') {
				$friends.addClass('active');
			}
			
			return this;
		},
		
		/**
		 * Render Item View
		 */
		render: function renderMenuView() {
			
			var items = this._renderItems(),
				personas = this._renderPersonaList();
			
			this.el.appendChild(items);
			this.el.appendChild(personas);

			
			
			// Play now
			this.el.appendChild(this.make('a', {
				'href'	: '#play-now',
				'class'	: 'play-now'
			}, this.trans('WEB_MENU_PLAY_NOW')));

			
			
			// Server browser
			this.el.appendChild(this.make('a', {
				'href'		: '#serverbrowser',
				'class'		: 'browser nav',
				'data-name'	: 'browser'
			}));


			// Friends
			this.el.appendChild(this.make('a', {
				'href'		: '#joinfriends',
				'class'		: 'friends nav',
				'data-name'	: 'friends'
			}));


			this._renderTrainingPoint();
		}
	});
}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule options
 */
(function createControlModel(win) {
	"use strict";
	
	
	if (!win.APP && (typeof require !== 'undefined')) {
		win.APP = require('../common/app');
	}
	
	var APP = win.APP,
		parent = APP.Model.prototype,
		_ = APP._,
		controlsAPI = APP.api.controls,
		localizationAPI = APP.api.localization;
    
	
	/**
	 * Model: Mouse
	 */
	APP.Model.Control = APP.Model.extend({
		defaults: {
			'name'		: null,
			'map'		: null,
			'key'		: null,
			'keyName'	: null,
			'index'		: null,
			'secondary'	: false,
			'invert'	: false,
			'commonMap' : false
		},
		schema: {
			'name'		: 'string',
			'map'		: 'string',
			'key'		: 'string',
			'keyName'	: 'string',
			
			'index'		: 'number',
			
			'secondary'	: 'bool',
			'invert'	: 'bool',
			'commonMap'	: 'bool'
		},
		initialize: function initializeControlModel() {
			this.bind('change:map', this._checkMap, this);
			this._checkMap();
			this._setKey();
		},
		
		_checkMap: function _checkMapControlModel() {
			var map = this.get('map') || '';
			if (map[0] !== '_') {
				throw new Error('"map" ("' + map + '") property needs to start with an "_" (underscore)');
			}
		},
		
		_setKey: function _setKeyControlModel() {
			var key = controlsAPI.getMappedString(this.get('map'), this.get('index'), this.get('secondary'), this.get('invert')),
				keyName;
			
			if (key.match(/^-/)) {
				keyName = '-' + localizationAPI.get(key.replace(/^-/, ''));
			} else {
				keyName = localizationAPI.get(key);
			}
			keyName = keyName.replace('CONTROLLER_None', '');
			
			if (keyName === '?' || keyName === 'null') {
				keyName = null;
			}
			
			this.set({
				key: key,
				keyName: keyName || null
			});
		},
		
		reload: function reloadControlModel() {
			this._setKey();
			return this;
		},
		
		mapInput: function mapInputControlModel(fn) {
			_.delay(_.bind(function () {
				
				var statusMap = {
						0: 'success',
						1: 'duplicate',
						2: 'timeout',
						3: 'reserved'
					},
					status,
					result,
					err = null,
					data = null;
				
				// Set active map
				controlsAPI.activeMap = this.get('map');
				
				// Calling mapInput will block everything until it times out
				result = controlsAPI.mapInput(this.get('index'), this.get('secondary'), this.get('invert'), this.get('commonMap'));
				
				// Set status
				status = statusMap[result] || 'unknown';
				
				// Success
				if (status === 'success') {
					
					// Save current control settings
					controlsAPI.apply();
					
					// Set key
					this._setKey();
					
				// Duplicate
				} else if (status === 'duplicate') {
					err = new Error('Duplicate Keybinding!');
					data = controlsAPI.lastDuplicateInput;
					
				// Timeout
				} else if (status === 'timeout') {
					err = new Error('Keybinding timed out...');
					
				// Reserved
				} else if (status === 'reserved') {
					err = new Error('Reserved Key, sorry');
					
				// Unknown
				} else {
					err = new Error('An unknown error occurred while trying to map input!');
				}
				
				if (fn) {
					fn(err, status, data);
				} else {
					this.trigger('error', this, err, status, data);
				}
			}, this), 50);
			return this;
		}
	});
	
	
	/**
	 * Module support
	 */
	if (typeof module !== 'undefined' && module.exports) {
		module.exports = APP.Model.Control;
	}
}(this));

/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule options
 */
(function createMouseModel(win) {
	"use strict";
	
	
	if (!win.APP && (typeof require !== 'undefined')) {
		win.APP = require('../common/app');
	}
	
	var APP = win.APP,
		parent = APP.Model.prototype,
		_ = APP._,
		controlsAPI = APP.api.controls;
    
	
	/**
	 * Model: Mouse
	 */
	APP.Model.Mouse = APP.Model.extend({
		defaults: {
			'map'				: null,
			'mouseSensitivity'	: 3,
			'mouseYawFactor'	: 2,
			'mousePitchFactor'	: 1,
			'invertMouse'		: false
		},
		schema: {
			'map': 'string',
			
			'mouseSensitivity'	: 'number',
			'mouseYawFactor'	: 'number',
			'mousePitchFactor'	: 'number',
			
			'invert': 'boolean'
		},
		initialize: function initializeMouseModel() {
			this.bind('change:map', this._checkMap, this);
			this._checkMap();
			this._setValues();
		},
		
		_checkMap: function _checkMapMouseModel() {
			var map = this.get('map') || '';
			if (map[0] !== '_') {
				throw new Error('"map" ("' + map + '") property needs to start with an "_" (underscore)');
			}
		},
		
		_setValues: function _setInvertMouseMouseModel() {
			controlsAPI.activeMap = this.get('map');
			
			this.set({
				mouseSensitivity: controlsAPI.mouseSensitivity,
				mouseYawFactor: controlsAPI.mouseYawFactor,
				mousePitchFactor: controlsAPI.mousePitchFactor,
				invertMouse: !!controlsAPI.invertMouse
			});
		},
		
		reload: function reloadControlModel() {
			this._setValues();
		},
		
		mapInput: function mapInputMouseModel(fn) {
			_.delay(_.bind(function () {
				var props = [ 'mouseSensitivity', 'mouseYawFactor', 'mousePitchFactor', 'invertMouse' ],
					res,
					err = null,
					status;
				
				controlsAPI.activeMap = this.get('map');
				
				_.forEach(props, function (prop) {
					controlsAPI[prop] = this.get(prop);
				}, this);
				
				// Apply settings
				res = controlsAPI.apply();
				
				if (res) {
					status = 'success';
				} else {
					status = 'unknown';
					err = new Error('An unknown error occured while trying to map input!');
				}
				
				if (fn) {
					fn(err, status);
				} else {
					this.trigger('error', this, err, status);
				}
			}, this), 50);
			return this;
		}
	});
	
	
	/**
	 * Module support
	 */
	if (typeof module !== 'undefined' && module.exports) {
		module.exports = APP.Model.Control;
	}
}(this));

/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule options
 */
(function (root) {
	"use strict";
	
	var APP = root.APP,
		win = APP.win,
		$ = APP.$,
		_ = APP._,
		doc = APP.doc,
		parent = APP.View.prototype;
	
	APP.View.Settings = APP.View.extend({
		name: 'settings-view',
		className: 'info-view',
		
		initialize: function initializeRowSettingsView() {
			this.bind('reset:click', function () {
				this.sound('revert');
			}, this);
		},
		
		destroy: function destroyRowSettingsView() {
			
		},
		
		
		/**
		 * Make row
		 */
		_makeRow: function _makeRowSettingsView(options, callback) {
			var docFrag = APP.doc.createDocumentFragment(),
				wrapper,
				inner,
				$all,
				timer,
				name,
				label1,
				label2;
			
			/**
			 * Label
			 */
			docFrag.appendChild(this.make('span', {
				'class': 'label'
			}, options.label));
			
            
			
			/**
			 * Select
			 */
			if (options.type === 'select') {
				
				this.createView(APP.View.Choose, {
					container	: docFrag,
					values		: options.values,
					value		: options.value
				}).render().attach().bind('choose', callback);
				
				
			/**
			 * Slider
			 */
			} else if (options.type === 'slider') {	
				wrapper = this.make('div', {
					'class': 'slider'
				});
				
				this.$(wrapper).slider({
					range: 'min',
					orientation: 'horizontal',
					min: 0,
					max: 100,
					value: options.value,
					start: _.bind(function (e, ui) {
						this.sound('select:open');
						callback(ui.value);
					}, this),
					stop: _.bind(function (e, ui) {
						this.sound('select:close');
						callback(ui.value);
					}, this)
				}).bind('mouseenter', _.bind(function () {
					this.sound('hover');
				}, this));
				
				docFrag.appendChild(wrapper);
				
				
			/**
			 * Radio
			 */
			} else if (options.type === 'radio') {
				
				wrapper = this.make('div', {
					'class': 'switch-view'
				});
				name = _.uniqueId(this.name + '-radio-');
				
				label1 = this.make('label', {'for': name + '-yes'}, '<span>' + options.values[0] + '</span>');
				label2 = this.make('label', {'for': name + '-no'}, '<span>' + options.values[1] + '</span>');
				
				label1.appendChild(this.make('input', {
					'type': 'radio',
					'id': name + '-yes',
					'name': name,
					'value': 1
				}));
				
				label2.appendChild(this.make('input', {
					'type': 'radio',
					'id': name + '-no',
					'name': name,
					'value': 0
				}));
				
				wrapper.appendChild(label1);
				wrapper.appendChild(label2);
				
				$all = $('input', wrapper);
				
				
				if (options.value) {
					$all.first().attr('checked', 'checked').closest('label').addClass('checked');
				} else {
					$all.last().attr('checked', 'checked').closest('label').addClass('checked');
				}
				
				/**
				 * Listen to change events
				 */
				$all.bind('change', _.bind(function () {
					var value = !!$all.get(0).checked;
					
					$all.closest('label').removeClass('checked');
					
					if (value) {
						$all.first().attr('checked', 'checked').closest('label').addClass('checked');
					} else {
						$all.last().attr('checked', 'checked').closest('label').addClass('checked');
					}
					
					if (value) {
						this.sound('select:open');
					} else {
						this.sound('select:close');
					}
					callback(value);
				}, this));
				
				$('label', wrapper).bind('mouseenter', _.bind(function () {
					this.sound('hover');
				}, this));
				
				docFrag.appendChild(wrapper);
			}
			
			return docFrag;
		},
		
		
		/**
		 * Render Video
		 */
		_renderVideo: function _renderVideoSettingsView() {
			var content = [],
				videoAPI = APP.api.video,
				selectedResolution = videoAPI.selectedResolution,
				resolutionIndex = null,
				screenResolutions = _.map(JSON.parse(videoAPI.getScreenResolutions()), function (res, i) {
					var resolution = res.resolution;
					
					if (resolution === selectedResolution) {
						resolutionIndex = i;
					}
					
					if (res.recommended === 'true') {
						resolution += '*';
					}
					
					return resolution;
				}),
				schemes = [
					this.trans('WEB_GAME_OPTIONS_QUALITY_SUPER_LOW'),
					this.trans('WEB_GAME_OPTIONS_QUALITY_LOW'),
					this.trans('WEB_GAME_OPTIONS_QUALITY_MEDIUM'),
					this.trans('WEB_GAME_OPTIONS_QUALITY_HIGH')
				],
				scheme = videoAPI.scheme || 0;
			
			// Resolution
			content.push(this._makeRow({
				type: 'select',
				label: this.trans('WEB_GAME_OPTIONS_FULLSCREEN_RESOLUTION') + '<span>* = ' + this.trans('WEB_GAME_OPTIONS_RECOMMENDED') + '</span>',
				values: screenResolutions,
				value: resolutionIndex
			}, function onChangeResolution(value) {
				var res = screenResolutions[value].split('*').shift();
				videoAPI.resolution = res;
				videoAPI.save();
			}));
			
			// Video quality
			content.push(this._makeRow({
				type: 'select',
				label: this.trans('WEB_GAME_OPTIONS_VIDEO_QUALITY'),
				values: schemes,
				value: scheme
			}, function onChangeScheme(value) {
				videoAPI.scheme = value;
				videoAPI.save();
			}));
			
			// Start In Fullscreen
			content.push(this._makeRow({
				type: 'radio',
				label: this.trans('WEB_GAME_OPTIONS_START_IN_FULLSCREEN'),
				values: [
					this.trans('WEB_COMMON_YES'),
					this.trans('WEB_COMMON_NO')
				],
				value: !!videoAPI.startInFullscreen
			}, function onChangeStartInFullscreen(value) {
				videoAPI.startInFullscreen = !!value;
				videoAPI.save();
			}));
			
			return content;
		},
		
		
		/**
		 * Render Audio
		 */
		_renderAudio: function _renderAudioSettingsView() {
			var content = [],
				audioAPI = APP.api.audio,
				qualityValues = [ "Low", "Medium", "High" ];
			
			// Effects volume
			content.push(this._makeRow({
				type: 'slider',
				label: this.trans('WEB_GAME_OPTIONS_EFFECTS_VOL'),
				value: audioAPI.effectsVolume * 100
			}, function onChangeEffectsVolume(value) {
				audioAPI.effectsVolume = value / 100;
				audioAPI.apply();
			}));
			
			// Music volume
			content.push(this._makeRow({
				type: 'slider',
				label: this.trans('WEB_GAME_OPTIONS_MUSIC_VOL'),
				value: audioAPI.musicVolume * 100
			}, function onChangeMusicVolume(value) {
				audioAPI.musicVolume = value / 100;
				audioAPI.apply();
			}));
			
			// Audio quality
			content.push(this._makeRow({
				type: 'select',
				label: this.trans('WEB_GAME_OPTIONS_AUDIO_QUALITY'),
				values:  [
					this.trans('WEB_GAME_OPTIONS_QUALITY_LOW'),
					this.trans('WEB_GAME_OPTIONS_QUALITY_MEDIUM'),
					this.trans('WEB_GAME_OPTIONS_QUALITY_HIGH')
				],
				value: _.indexOf(qualityValues, audioAPI.quality)
			}, function onChangeAudioQuality(value) {
				audioAPI.quality = qualityValues[value];
				audioAPI.apply();
			}));
			
			
			// Audio renderer
			content.push(this._makeRow({
				type: 'radio',
				label: this.trans('WEB_GAME_OPTIONS_AUDIO_RENDERER'),
				values: [
					this.trans('WEB_GAME_OPTIONS_AUDIO_RENDERER_SOFTWARE'),
					this.trans('WEB_GAME_OPTIONS_AUDIO_RENDERER_HARDWARE')
				],
				value: audioAPI.provider === 'software' ? 1 : 0
			}, function onChangeAudioQuality(value) {
				audioAPI.provider = value ? 'software' : 'hardware';
				audioAPI.apply();
			}));
			
			
			return content;
		},
		
		
		/**
		 * Render Game
		 */
		_renderGame: function _renderGameSettingsView() {
			var content = [],
				generalAPI = APP.api.general;
			
			// Auto reload
			content.push(this._makeRow({
				type: 'radio',
				label: this.trans('WEB_GAME_OPTIONS_AUTO_RELOAD'),
				values: [
					this.trans('WEB_COMMON_YES'),
					this.trans('WEB_COMMON_NO')
				],
				value: !!generalAPI.autoReload
			}, function onChangeAutoReload(value) {
				generalAPI.autoReload = value;
				generalAPI.apply();
			}));
			
			// Camera shake
			content.push(this._makeRow({
				type: 'radio',
				label: this.trans('WEB_GAME_OPTIONS_CAMERA_SHAKE'),
				values: [
					this.trans('WEB_COMMON_YES'),
					this.trans('WEB_COMMON_NO')
				],
				value: !!generalAPI.cameraShake
			}, function onChangeCameraShake(value) {
				generalAPI.cameraShake = !!value;
				generalAPI.apply();
			}));
			
			return content;
		},
		
		
		/**
		 * Render
		 */
		render: function renderSettingsView() {
			
			this.$el.addClass('border-box');
			
			// Title
			this.el.appendChild(this.make('h2', null, this.trans('WEB_GAME_OPTIONS_HEADER_SETTINGS')));
			
			var videoContent = this._renderVideo(),
				audioContent = this._renderAudio(),
				gameContent = this._renderGame();
			
			
			this.video = this.createView(APP.View.LabelBox, {
				className: 'video',
				label: this.trans('WEB_GAME_OPTIONS_VIDEO'),
				content: videoContent
			}).render().attach();
			
			
			this.audio = this.createView(APP.View.LabelBox, {
				className: 'audio',
				label: this.trans('WEB_GAME_OPTIONS_AUDIO'),
				content: audioContent
			}).render().attach();
			
			
			this.game = this.createView(APP.View.LabelBox, {
				className: 'game',
				label: this.trans('WEB_GAME_OPTIONS_GAME'),
				content: gameContent
			}).render().attach();
			
			
			this.createView(APP.View.Button, {
				text: this.trans('WEB_GAME_OPTIONS_RESET'),
				className: 'small'
			}, 'reset').render().attach();
			
			this.$el.disableTextSelect();
		}
	});
}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule options
 */
(function (root) {
	"use strict";
	
	
	var APP = root.APP,
		win = APP.win,
		$ = APP.$,
		_ = APP._,
		doc = APP.doc,
		parent = APP.View.prototype;
	
	APP.View.Controls = APP.View.extend({
		name: 'controls-view',
		
		events: {
			'click a.key': '_onClickKey',
			'mouseenter a.key': '_onMouseEnterKey'
		},
		
		categoryGroupMapping: {
			foot: {
				left: [ 'movement', 'mouse' ],
				right: [ 'weapons', 'equipment' ]
				
			},
			vehicle: {
				left: [ 'land', 'land-mouse' ],
				right: [ 'sea', 'sea-mouse' ]
			},
			aircraft: {
				left: [ 'air', 'air-mouse' ],
				right: [ 'helicopter', 'helicopter-mouse' ]
			},
			general: {
				left: [ 'general' ],
				right: [ 'positions' ]
			}
		},
		
		labelMapping: {
			'movement'	: 'WEB_GAME_OPTIONS_MOVEMENT',
			'mouse'		: 'WEB_GAME_OPTIONS_MOUSE_INFANTRY',
			'weapons'	: 'WEB_GAME_OPTIONS_WEAPONS',
			'equipment'	: 'WEB_GAME_OPTIONS_EQUIPMENT_BAR',
			
			'land'		: 'WEB_GAME_OPTIONS_LAND_VEHICLE_CONTROLS',
			'land-mouse': 'WEB_GAME_OPTIONS_LAND_VEHICLE_MOUSE',
			'sea'		: 'WEB_GAME_OPTIONS_SEA_VEHICLE_CONTROLS',
			'sea-mouse'	: 'WEB_GAME_OPTIONS_SEA_VEHICLE_MOUSE',
			
			'air': 'WEB_GAME_OPTIONS_PLANE_CONTROLS',
			'air-mouse': 'WEB_GAME_OPTIONS_PLANE_MOUSE',
			'helicopter': 'WEB_GAME_OPTIONS_HELICOPTER_CONTROLS',
			'helicopter-mouse': 'WEB_GAME_OPTIONS_HELICOPTER_MOUSE',
			
			'general': 'WEB_GAME_OPTIONS_GENERAL_CONTROLS',
			'positions': 'WEB_GAME_OPTIONS_VEHICLE/AIRCRAFT_POSITIONS'
		},
		
		initialize: function initializeControlControlsView() {
			_.bindAll(this);
			this.bind('tab:select', this._onTabSelect, this);
			this.collection.bind('change', this._onChange, this);
			this.bind('reset:click', function () {
				this.sound('revert');
			}, this);
		},
		
		
		destroy: function destroyControlControlsView() {
			this.collection.unbind('change', this._onChange, this);
		},
		
		_onClickKey: function _onClickKeyControlsView(e) {
			e.preventDefault();
			
			var cid = this.$(e.currentTarget).attr('cid'),
				model = this.collection.getByCid(cid);
			
			if (model) {
				this.sound('click');
				this.trigger('click:key', model);
			}
		},
		
		_onMouseEnterKey: function _onMouseEnterKeyControlsView() {
			this.sound('hover');
		},
		
		_onTabSelect: function _onTabSelectControlsView(i, tab) {
			this.category = tab.filter;
			this._renderBody();
		},
		
		_onChange: function _onChangeControlsView(model) {
			this._renderBody();
		},
		
		/**
		 * Render control
		 */
		_renderControl: function _renderControlControlsView(model) {
			var docFrag = APP.doc.createDocumentFragment(),
				keyName = model.get('keyName'),
				key;
			
			// Label
			docFrag.appendChild(this.make('span', {
				'class': 'label'
			}, this.trans(model.get('name'))));
			
			
			if (!keyName || keyName === 'null') {
				keyName = '?';
			}
			
			docFrag.appendChild(this.make('a', {
				'href': '#key',
				'class': 'key' + (keyName === '?' ? ' empty' : ''),
				'cid': model.cid
			}, keyName));
			
			
			return docFrag;
		},
		
		
		/**
		 * Render mouse
		 */
		_renderMouse: function _renderMouseControlsView(model) {
			
			var sliderProps = [ 'mouseSensitivity', 'mouseYawFactor', 'mousePitchFactor' ],
				labelMap = {
					mouseSensitivity: 'WEB_GAME_OPTIONS_MOUSE_SENSITIVITY',
					mouseYawFactor: 'WEB_GAME_OPTIONS_MOUSE_YAW',
					mousePitchFactor: 'WEB_GAME_OPTIONS_MOUSE_PITCH',
					invertMouse: 'WEB_GAME_OPTIONS_MOUSE_INVERTED'
				},
				docFrag = APP.doc.createDocumentFragment(),
				radioContainer = this.make('div', {
					'class': 'switch'
				}),
				radioName = 'invert-mouse-group-' + model.get('group') + '-' + model.cid,
				radioYes,
				radioNo,
				content;
				
			// Sliders
			content = _.map(sliderProps, function (prop) {
				var docFrag = APP.doc.createDocumentFragment(),
					slider = this.make('div', {
						'class': 'slider'
					});
				
				docFrag.appendChild(this.make('span', {
					'class': 'label'
				}, this.trans(labelMap[prop])));
				
				$(slider).slider({
					range: 'min',
					orientation: 'horizontal',
					min: 0,
					max: 500,
					value: model.get(prop) * 100,
					start: _.bind(function () {
						this.sound('select:open');
					}, this),
					stop:  _.bind(function onStopSlider(event, ui) {
						this.sound('select:close');
						
						var attrs = {},
							value = ui.value / 100;
						
						attrs[prop] = value;
						
						model.set(attrs, { silent: true }).mapInput();
					}, this)
				}).bind('mouseenter', _.bind(function () {
					this.sound('hover');
				}, this));
				
				docFrag.appendChild(slider);
				return docFrag;
			}, this);
			
			
			// 
			docFrag.appendChild(this.make('span', {
				'class': 'label'
			}, this.trans(labelMap.invertMouse)));
			
			radioContainer.appendChild(this.make('label', {
				'for': radioName + '-yes'
			}, this.trans('WEB_COMMON_YES')));
			radioYes = this.make('input', {
				'type': 'radio',
				'id': radioName + '-yes',
				'name': radioName,
				'value': 1
			});
			radioContainer.appendChild(radioYes);
			
			radioContainer.appendChild(this.make('label', {
				'for': radioName + '-no'
			}, this.trans('WEB_COMMON_NO')));
			radioNo = this.make('input', {
				'type': 'radio',
				'id': radioName + '-no',
				'name': radioName,
				'value': 0
			});
			radioContainer.appendChild(radioNo);
			
			if (model.get('invertMouse')) {
				radioYes.checked = true;
			} else {
				radioNo.checked = true;
			}
			
			/**
			 * Listen to change events
			 */
			$('input', radioContainer).bind('change', _.bind(function onRadioChange() {
				if (radioYes.checked) {
					this.sound('select:open');
				} else {
					this.sound('select:close');
				}
				
				model.set({
					invertMouse: !!radioYes.checked
				}, { silent: true }).mapInput();
			}, this)).customInput();
			
			$('label', radioContainer).bind('mouseenter', _.bind(function () {
				this.sound('hover');
			}, this));
			
			docFrag.appendChild(radioContainer);
			
			content.push(docFrag);
			
			return content;
		},
		
		
		/**
		 * Render body
		 */
		_renderBody: function _renderBodyControlsView() {
			if (!this.body || !this.body.parentNode) {
				this.body = this.make('div', {
					'class': 'body'
				});
				this.el.appendChild(this.body);
			}
			this.$(this.body).empty();
			
			var groupMapping = this.categoryGroupMapping[this.category],
				cols = {
					left: this.make('div', {
						'class': 'col-left'
					}),
					right: this.make('div', {
						'class': 'col-right'
					})
				};
			
			_.forEach(groupMapping, function (groups, colName) {
				var col = cols[colName];
				_.forEach(groups, function (group) {
					var	content = this.collection.filterBy({
							category: this.category,
							group: group
						}).map(function (model) {
							if (model.has('invertMouse')) {
								return this._renderMouse(model);
							}
							return this._renderControl(model);
						}, this);
					
					if (content.length === 1) {
						content = content.pop();
					}
					
					// Create view
					this.createView(APP.View.LabelBox, {
						container: col,
						label: this.trans(this.labelMapping[group]),
						content: content
					}).render().attach();
				}, this);
			}, this);
			
			
			this.body.appendChild(cols.left);
			this.body.appendChild(cols.right);
			
			this.trigger('render:body');
		},

		
		/**
		 * Render
		 */
		render: function renderControlsView() {

			this.$menuBar = $('<div>').addClass('menu-bar').appendTo(this.$el);

			this.tabs = this.createView(APP.View.Tabs, {
				container: this.$menuBar,
				className: 'category-tabs',
				tabs: [
                    { name: 'foot', text: this.trans('WEB_GAME_OPTIONS_CATEGORY_FOOT'), filter: 'foot' },
                    { name: 'vehicle', text: this.trans('WEB_GAME_OPTIONS_CATEGORY_VEHICLE'), filter: 'vehicle' },
                    { name: 'aircraft', text: this.trans('WEB_GAME_OPTIONS_CATEGORY_AIRCRAFT'), filter: 'aircraft' },
                    { name: 'general', text: this.trans('WEB_GAME_OPTIONS_CATEGORY_GENERAL'), filter: 'general' }
				]
			}, 'tab').render().attach().select(this.category || 0);
			
			this.createView(APP.View.Button, {
                text: this.trans('WEB_GAME_OPTIONS_RESET_ALL_CONTROLS'),
				className: 'small'
			}, 'reset').render().attach();
			
			this.$el.disableTextSelect();
		}
	});
}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule options
 */
/**
 * @class GAME.Task.options
 */
APP.task('options', function taskOptions(done) {
	"use strict";
	
	
	/**
	 * Bundles
	 */
	var win = APP.win,
		$ = APP.$,
		_ = APP._,
		
		// Namespace
		nsOptions = APP.ns('options'),
		
		// Main page element
		$main = nsOptions.$el = $('<div>').addClass('main main_options page hidden loading').appendTo('#frontend'),
		$panelLeft = nsOptions.$panelLeft = $('<div>').addClass('page-panel left').appendTo($main),
		$panelRight = nsOptions.$panelRight = $('<div>').addClass('page-panel right').appendTo($main);
	
	
	/**
	 * Initialize
	 */
	nsOptions.ready(function onreadyOptions() {
		nsOptions.$el.removeClass('loading');
	});
	
	
	/**
	 * Task done!
	 */
	done();
});
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule options
 */
/**
 * @class GAME.Task.options.data
 * @uses GAME.Task.options
 */
APP.task('options.data', [ 'options' ], function taskOptionsData(done) {
	"use strict";
	
	
	var win = APP.win,
		$ = APP.$,
		_ = APP._,
		
		// Namespace
		nsOptions = APP.ns('options'),
		
		/**
		 * Controls
		 */
		controls = {
			/**
			 * Foot controls
			 */
			"foot": {
				// WEB_GAME_OPTIONS_MOVEMENT
				"movement": [
					{ "name": "WEB_GAME_OPTIONS_FORWARD", "map": "_InfantryPlayerInputControlMap", "index": "3", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_BACKWARD", "map": "_InfantryPlayerInputControlMap", "index": "3", "secondary": false, "invert": true },
					{ "name": "WEB_GAME_OPTIONS_STRAFE_LEFT", "map": "_InfantryPlayerInputControlMap", "index": "0", "secondary": false, "invert": true },
					{ "name": "WEB_GAME_OPTIONS_STRAFE_RIGHT", "map": "_InfantryPlayerInputControlMap", "index": "0", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_LOOK_UP", "map": "_defaultPlayerInputControlMap", "index": "5", "secondary": false, "invert": true },
					{ "name": "WEB_GAME_OPTIONS_LOOK_DOWN", "map": "_defaultPlayerInputControlMap", "index": "5", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_TURN_LEFT", "map": "_defaultPlayerInputControlMap", "index": "4", "secondary": false, "invert": true },
					{ "name": "WEB_GAME_OPTIONS_TURN_RIGHT", "map": "_defaultPlayerInputControlMap", "index": "4", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_JUMP_PARA", "map": "_InfantryPlayerInputControlMap", "index": "9", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_SPRINT", "map": "_InfantryPlayerInputControlMap", "index": "13", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_CROUCH", "map": "_InfantryPlayerInputControlMap", "index": "40", "secondary": false, "invert": false}
				],
				// WEB_GAME_OPTIONS_MOUSE_INFANTRY
				"mouse": [
					{
						"map": "_InfantryPlayerInputControlMap",
						"mouseSensitivity": 0,
						"mouseYawFactor": 0,
						"mousePitchFactor": 0,
						"invertMouse": false
					}
				],
				// WEB_GAME_OPTIONS_WEAPONS
				"weapons": [
					{ "name": "WEB_GAME_OPTIONS_FIRE", "map": "_InfantryPlayerInputControlMap", "index": "8", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_ZOOM", "map": "_InfantryPlayerInputControlMap", "index": "33", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_RELOAD", "map": "_defaultPlayerInputControlMap", "index": "34", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_NEXT_SLOT", "map": "_defaultPlayerInputControlMap", "index": "50", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_PREVIOUS_SLOT", "map": "_defaultPlayerInputControlMap", "index": "51", "secondary": false, "invert": false}
				],
				// WEB_GAME_OPTIONS_EQUIPMENT_BAR
				"equipment": [
					{ "name": "WEB_GAME_OPTIONS_SLOT_1", "map": "_defaultPlayerInputControlMap", "index": "15", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_SLOT_2", "map": "_defaultPlayerInputControlMap", "index": "16", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_SLOT_3", "map": "_defaultPlayerInputControlMap", "index": "17", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_SLOT_4", "map": "_defaultPlayerInputControlMap", "index": "18", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_SLOT_5", "map": "_defaultPlayerInputControlMap", "index": "19", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_SLOT_6", "map": "_defaultPlayerInputControlMap", "index": "20", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_SLOT_7", "map": "_defaultPlayerInputControlMap", "index": "21", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_SLOT_8", "map": "_defaultPlayerInputControlMap", "index": "22", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_SLOT_9", "map": "_defaultPlayerInputControlMap", "index": "23", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_SLOT_10", "map": "_defaultPlayerInputControlMap", "index": "24", "secondary": false, "invert": false}
				]
			},
			/**
			 * Vehicle controls
			 */
			"vehicle": {
				// WEB_GAME_OPTIONS_LAND_VEHICLE
				"land": [
					{ "name": "WEB_GAME_OPTIONS_FIRE", "map": "_LandPlayerInputControlMap", "index": "8", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_ALT-FIRE", "map": "_LandPlayerInputControlMap", "index": "33", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_SMOKE", "map": "_LandPlayerInputControlMap", "index": "49", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_REPAIR", "map": "_LandPlayerInputControlMap", "index": "35", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_ACCELERATE", "map": "_LandPlayerInputControlMap", "index": "3", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_DECELERATE", "map": "_LandPlayerInputControlMap", "index": "3", "secondary": false, "invert": true },
					{ "name": "WEB_GAME_OPTIONS_STEER_LEFT", "map": "_LandPlayerInputControlMap", "index": "0", "secondary": false, "invert": true },
					{ "name": "WEB_GAME_OPTIONS_STEER_RIGHT", "map": "_LandPlayerInputControlMap", "index": "0", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_CROUCH", "map": "_LandPlayerInputControlMap", "index": "40", "secondary": false, "invert": false}
				],
				// WEB_GAME_OPTIONS_LAND_VEHICLE MOUSE
				"land-mouse": [
					{
						"map": "_LandPlayerInputControlMap",
						"mouseSensitivity": 0,
						"mouseYawFactor": 0,
						"mousePitchFactor": 0,
						"invertMouse": false
					}
				],
				// WEB_GAME_OPTIONS_SEA_VEHICLE CONTROLS
				"sea": [
					{ "name": "WEB_GAME_OPTIONS_FIRE", "map": "_SeaPlayerInputControlMap", "index": "8", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_ALT-FIRE", "map": "_SeaPlayerInputControlMap", "index": "33", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_REPAIR", "map": "_SeaPlayerInputControlMap", "index": "35", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_ACCELERATE", "map": "_SeaPlayerInputControlMap", "index": "3", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_DECELERATE", "map": "_SeaPlayerInputControlMap", "index": "3", "secondary": false, "invert": true },
					{ "name": "WEB_GAME_OPTIONS_STEER_LEFT", "map": "_SeaPlayerInputControlMap", "index": "0", "secondary": false, "invert": true },
					{ "name": "WEB_GAME_OPTIONS_STEER_RIGHT", "map": "_SeaPlayerInputControlMap", "index": "0", "secondary": false, "invert": false}
				],
				// WEB_GAME_OPTIONS_SEA_VEHICLE MOUSE
				"sea-mouse": [
					{
						"map": "_SeaPlayerInputControlMap",
						"mouseSensitivity": 0,
						"mouseYawFactor": 0,
						"mousePitchFactor": 0,
						"invertMouse": false
					}
				]
			},
			/**
			 * Aircraft controls
			 */
			"aircraft": {
				// WEB_GAME_OPTIONS_PLANE_CONTROLS
				"air": [
					{ "name": "WEB_GAME_OPTIONS_MISSILES", "map": "_AirPlayerInputControlMap", "index": "8", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_GUN", "map": "_AirPlayerInputControlMap", "index": "33", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_BOMBS", "map": "_AirPlayerInputControlMap", "index": "47", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_COUNTERMEASURE", "map": "_AirPlayerInputControlMap", "index": "49", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_REPAIR", "map": "_AirPlayerInputControlMap", "index": "35", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_MOUSE_LOOK", "map": "_AirPlayerInputControlMap", "index": "11", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_ACCELERATE", "map": "_AirPlayerInputControlMap", "index": "3", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_DECELERATE", "map": "_AirPlayerInputControlMap", "index": "3", "secondary": false, "invert": true },
					{ "name": "WEB_GAME_OPTIONS_STEER_LEFT", "map": "_AirPlayerInputControlMap", "index": "0", "secondary": false, "invert": true },
					{ "name": "WEB_GAME_OPTIONS_STEER_RIGHT", "map": "_AirPlayerInputControlMap", "index": "0", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_PITCH_FORWARD", "map": "_AirPlayerInputControlMap", "index": "1", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_PITCH_BACKWARD", "map": "_AirPlayerInputControlMap", "index": "1", "secondary": false, "invert": true },
					{ "name": "WEB_GAME_OPTIONS_ROLL_LEFT", "map": "_AirPlayerInputControlMap", "index": "2", "secondary": false, "invert": true },
					{ "name": "WEB_GAME_OPTIONS_ROLL_RIGHT", "map": "_AirPlayerInputControlMap", "index": "2", "secondary": false, "invert": false }
				],
				// WEB_GAME_OPTIONS_PLANE_MOUSE
				"air-mouse": [
					{
						"map": "_AirPlayerInputControlMap",
						"mouseSensitivity": 0,
						"mouseYawFactor": 0,
						"mousePitchFactor": 0,
						"invertMouse": false
					}
				],
				// WEB_GAME_OPTIONS_HELICOPTER_CONTROLS
				"helicopter": [
					{ "name": "WEB_GAME_OPTIONS_FIRE", "map": "_HelicopterPlayerInputControlMap", "index": "8", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_ALT-FIRE", "map": "_HelicopterPlayerInputControlMap", "index": "33", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_COUNTERMEASURE", "map": "_HelicopterPlayerInputControlMap", "index": "49", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_REPAIR", "map": "_HelicopterPlayerInputControlMap", "index": "35", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_MOUSE_LOOK", "map": "_HelicopterPlayerInputControlMap", "index": "11", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_ACCELERATE", "map": "_HelicopterPlayerInputControlMap", "index": "3", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_DECELERATE", "map": "_HelicopterPlayerInputControlMap", "index": "3", "secondary": false, "invert": true },
					{ "name": "WEB_GAME_OPTIONS_STEER_LEFT", "map": "_HelicopterPlayerInputControlMap", "index": "0", "secondary": false, "invert": true },
					{ "name": "WEB_GAME_OPTIONS_STEER_RIGHT", "map": "_HelicopterPlayerInputControlMap", "index": "0", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_PITCH_FORWARD", "map": "_HelicopterPlayerInputControlMap", "index": "1", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_PITCH_BACKWARD", "map": "_HelicopterPlayerInputControlMap", "index": "1", "secondary": false, "invert": true },
					{ "name": "WEB_GAME_OPTIONS_ROLL_LEFT", "map": "_HelicopterPlayerInputControlMap", "index": "2", "secondary": false, "invert": true },
					{ "name": "WEB_GAME_OPTIONS_ROLL_RIGHT", "map": "_HelicopterPlayerInputControlMap", "index": "2", "secondary": false, "invert": false }
				],
				// WEB_GAME_OPTIONS_HELICOPTER_MOUSE
				"helicopter-mouse": [
					{
						"map": "_HelicopterPlayerInputControlMap",
						"mouseSensitivity": 0,
						"mouseYawFactor": 0,
						"mousePitchFactor": 0,
						"invertMouse": false
					}
				]
			},
			
			/**
			 * General controls
			 */
			"general": {
				// WEB_GAME_OPTIONS_GENERAL_CONTROLS
				"general": [
					{ "name": "WEB_GAME_OPTIONS_ENTER/EXIT", "map": "_defaultPlayerInputControlMap", "index": "10", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_TOGGLE_CAMERA", "map": "_defaultPlayerInputControlMap", "index": "37", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_ZOOM_MAP", "map": "_defaultGameControlMap", "index": "36", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_SHOW_MAP", "map": "_defaultGameControlMap", "index": "35", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_SCOREBOARD", "map": "_defaultGameControlMap", "index": "55", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_SCREEN_SHOT", "map": "_defaultGameControlMap", "index": "18", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_CHAT", "map": "_defaultGameControlMap", "index": "29", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_SAY_ALL", "map": "_defaultGameControlMap", "index": "22", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_SAY_TEAM", "map": "_defaultGameControlMap", "index": "23", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_FACE_CAMERA", "map": "_defaultGameControlMap", "index": "56", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_EMOTES", "map": "_defaultGameControlMap", "index": "34", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_BOOKMARK_SERVER", "map": "_defaultGameControlMap", "index": "57", "secondary": false, "invert": false}
				],
				// WEB_GAME_OPTIONS_VEHICLE/AIRCRAFT_POSITIONS
				"positions": [
					{ "name": "WEB_GAME_OPTIONS_POSITION_1", "map": "_defaultPlayerInputControlMap", "index": "25", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_POSITION_2", "map": "_defaultPlayerInputControlMap", "index": "26", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_POSITION_3", "map": "_defaultPlayerInputControlMap", "index": "27", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_POSITION_4", "map": "_defaultPlayerInputControlMap", "index": "28", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_POSITION_5", "map": "_defaultPlayerInputControlMap", "index": "29", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_POSITION_6", "map": "_defaultPlayerInputControlMap", "index": "30", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_POSITION_7", "map": "_defaultPlayerInputControlMap", "index": "31", "secondary": false, "invert": false },
					{ "name": "WEB_GAME_OPTIONS_POSITION_8", "map": "_defaultPlayerInputControlMap", "index": "32", "secondary": false, "invert": false}
				]
			}
		},
		
		models = [];
	
	// Loop over the options and create models
	_.forEach(controls, function (groups, category) {
		_.forEach(groups, function (controls, group) {
			var ModelClass;
			
			if (group.indexOf('mouse') === -1) {
				ModelClass = APP.Model.Control;
			} else {
				ModelClass = APP.Model.Mouse;
			}
			
			_.forEach(controls, function (control) {
				control.category = category;
				control.group = group;
				models.push(new ModelClass(control));
			});
		});
	});
	
	// Create a collection to hold all options
	nsOptions.collection = new APP.Collection(models);
	
	// Remove these
	controls = models = null;
	

	/**
	 * Task done
	 */
	done();
});
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule options
 */
/**
 * @class GAME.Task.options.settings
 * @uses GAME.Task.options.data
 */
APP.task('options.settings', [ 'options.data' ], function taskOptionsSettings(done) {
	"use strict";
	
	
	var win = APP.win,
		$ = APP.$,
		_ = APP._,
		
		// Namespace
		nsOptions = APP.ns('options'),
		
		view = nsOptions.settings = new APP.View.Settings({
			container: nsOptions.$panelLeft
		});
	
	/**
	 * On reset click
	 */
	view.bind('reset:click', function () {
		var videoAPI = APP.api.video,
			audioAPI = APP.api.audio,
			generalAPI = APP.api.general;
		
		// Reset video
		videoAPI.startInFullscreen = false;
		videoAPI.reset();
		videoAPI.save();
		
		// Reset audio
		audioAPI.reset();
		audioAPI.quality = 'High';
		audioAPI.apply();
		
		// Reset general
		generalAPI.reset();
		generalAPI.apply();
		
		view.render();
	});
	
	
	/**
	 * Initialize
	 */
	nsOptions.setup(function initializeSettings(ready) {
		// Ready once the view has been rendered
		view.once('render', ready);
		
		// Render
		view.render();
		
		// Attach
		view.attach();
	});
	
	
	/**
	 * Task done!
	 */
	done();
});
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule options
 */
/**
 * @class GAME.Task.options.controls
 * @uses GAME.Task.options.data
 */
APP.task('options.controls', [ 'options.data' ], function taskOptionsControls(done) {
	"use strict";
	
	var win = APP.win,
		$ = APP.$,
		_ = APP._,
		
		// Namespace
		nsOptions = APP.ns('options'),
		
		view = nsOptions.controls = new APP.View.Controls({
			container: nsOptions.$panelRight,
			collection: nsOptions.collection
		});
	
	
	view.bind('click:key', function onClickKeyTaskOptionsControls(model) {
		
		var renderData = {
				title: APP.sidis.trans('WEB_GAME_TOOLTIPS_HEADER_CONTROLS_PRESSKEY'),
				body: APP.sidis.trans('WEB_GAME_TOOLTIPS_MESSAGE_CONTROLS_PRESSKEY')
			},
			dialogView = new APP.View.Dialog({
				className: 'map-input-dialog',
				renderData: renderData
			}),
			state = null,
			onMapInput = function onMapInput(err, status, data) {
				state = status;
				
				var renderData = {
						close: true
					},
					localizationAPI = APP.api.localization;
				
				if (err) {
					// Duplicate
					if (status === 'duplicate') {
						renderData.title = APP.sidis.trans('WEB_GAME_TOOLTIPS_HEADER_CONTROLS_ERROR_1');
						
						renderData.body = APP.sidis.trans('WEB_GAME_TOOLTIPS_MESSAGE_CONTROLS_ERROR_1');
						renderData.body += '<ul>';
						renderData.body += _.map(data.split(';'), function (key) {
							return '<li>' + localizationAPI.get(key) + '</li>';
						}).join('');
						renderData.body += '</ul>';
						
						renderData.buttonRight = APP.sidis.trans('WEB_GAME_TOOLTIPS_FORCE_BTN');
						
						
					// Timeout
					} else if (status === 'timeout') {
						renderData.title = APP.sidis.trans('WEB_GAME_TOOLTIPS_HEADER_CONTROLS_ERROR_2');
						
						renderData.body = APP.sidis.trans('WEB_GAME_TOOLTIPS_MESSAGE_CONTROLS_ERROR_2');
						
						renderData.buttonRight = APP.sidis.trans('WEB_GAME_TOOLTIPS_RETRY_BTN');
						
					// Reserved
					} else if (status === 'reserved') {
						renderData.title = APP.sidis.trans('WEB_GAME_TOOLTIPS_HEADER_CONTROLS_ERROR_3');
						
						renderData.body = APP.sidis.trans('WEB_GAME_TOOLTIPS_MESSAGE_CONTROLS_ERROR_3');
						
						renderData.buttonRight = APP.sidis.trans('WEB_GAME_TOOLTIPS_RETRY_BTN');
						
					// Unknown
					} else {
						renderData.title = 'Error';
						renderData.body = err.message;
					}
					
					dialogView.setRenderData(renderData).render();
					
					dialogView.$el.addClass(status);
					
				} else {
					dialogView.destroy();
					dialogView = null;
				}
			};
		
		
		// On button right
		dialogView.bind('close', function onClose() {
			dialogView.destroy();
			dialogView = null;
		});
		
		
		// On button right
		dialogView.bind('button:right', function onButtonRight() {
			var controlsAPI = APP.api.controls;
			
			if (state === 'duplicate') {
				
				controlsAPI.forceSetLastInput();
				controlsAPI.apply();
				
				// Reload all mappings
				nsOptions.collection.invoke('reload');
				
				dialogView.destroy();
				dialogView = null;
				
			} else {
				dialogView.setRenderData(renderData).render();
				// Call mapInput
				_.delay(_.bind(model.mapInput, model), 400, onMapInput);
			}
		});
		
		// Attach render & show
		dialogView.attach();
		dialogView.render();
		dialogView.show();
		
		
		// Call mapInput
		_.delay(_.bind(model.mapInput, model), 400, onMapInput);

	});
	
	
	/**
	 * On reset click
	 */
	view.bind('reset:click', function () {
		var controlsAPI = APP.api.controls;
		
		controlsAPI.reset();
		controlsAPI.apply();
		
		// Reload all mappings
		nsOptions.collection.invoke('reload');
	});
	
	
	/**
	 * Initialize
	 */
	nsOptions.setup(function initializeControls(ready) {
		// Ready once the view has been rendered
		view.once('render', ready);
		
		// Render
		view.render();
		
		// Attach
		view.attach();
	});
	
	
	/**
	 * Task done!
	 */
	done();
});
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule options
 */
/**
 * @class GAME.Task.options.routes
 * @uses GAME.Task.options.controls
 */
APP.task('options.routes', [ 'options.controls' ], function taskOptionsRoutes(done) {
	"use strict";
	
	var win = APP.win,
		$ = APP.$,
		_ = APP._,
		nsOptions = APP.ns('options');
	
	/**
	 * Options Page
	 */
	APP.bind('page:options', function onPageOptions(from, data) {
		if (from !== 'options') {
			win.dontUpdateDoll = true;
			win.hideDoll();
		}
		
		// Start
		nsOptions.start(function () {
			if (data.tab) {
				nsOptions.controls.tabs.select(data.tab);
			}
		});
	});
	
	
	/**
	 * Options route
	 */
	APP.route('options', 'options', function onOptionsRoute() {
		APP.page('options');
	});
	
	
	/**
	 * Options tab route
	 */
	APP.route('options/:tab', 'options', function onOptionsTabRoute(tab) {
		APP.page('options', {
			tab: tab
		});
	});
	
	/**
	 * Task done!
	 */
	done();
});
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule home
 */
(function (root) {
	"use strict";
	
	var APP = root.APP,
		win = APP.win,
		$ = APP.$,
		_ = APP._;
	
	
	/**
	 * Home Persona View
	 */
	APP.View.HomePersona = APP.View.extend({
		name: 'home-persona-view',
		
		template: _.template([
			'<h2 class="kit_<%= persona.kit %>">',
			'<%= persona.name %>',
			'<span class="rank"><%= persona.levelDescription %></span>',
			'</h2>',
			'<div class="soldier-content">',
			'<div class="stat levelprogress">',
			'<p class="data"><span><%= statXP %></span><%= statText %></p>',
			'<% if (!persona.isMaxLevel) { %>',
			'<div class="experience">',
			'<p class="current-level"><%= persona.level %></p>',
			'<p class="next-level"><%= persona.nextLevel %></p>',
			'<div class="progress-bar yellow-glow">',
			'<div class="progress" style="width:<%= persona.levelUpProgression %>%;"></div>',
			'</div>',
			'<% } %>',
			'</div>',
			'</div>',
			'</div>'
		].join('')),
		
		initialize: function initializeHomePersonaView() {
			this.model.bind('change', this.render, this);
		},
		
		destroy: function destroyHomePersonaView() {
			this.model.unbind('change', this.render, this);
			return this;
		},
		
		
		/**
		 * Render Item View
		 */
		render: function renderHomePersonaView() {
			var context = {
					persona: this.model.toJSON()
				};
			
			if (context.persona.isMaxLevel) {
				context.statXP = this.trans('WEB_GAME_EOR_LEVEL') + ' ' + context.persona.level;
				context.statText = this.trans('WEB_GAME_EOR_MAX') + ' ' + this.trans('WEB_GAME_EOR_LEVEL_REACHED');
				
			} else {
				context.statXP = context.persona.xpToNextLevel + ' ' + this.trans('WEB_GAME_EOR_XP');
				context.statText = this.trans('WEB_GAME_EOR_XP_TO_NEXT_LEVEL');
			}
			
			this.el.innerHTML = this.template(context);
		}
	});
}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule home
 */
/**
 * @class GAME.Task.home
 * @uses GAME.Task.home.abilities
 */
APP.task('home', [ 'abilities' ], function taskHome(done) {
	"use strict";
	
	
	var win = APP.win,
		$ = APP.$,
		_ = APP._,
		nsHome = APP.ns('home'),
		nsGame = APP.ns('game'),
		nsAbilities = APP.ns('abilities'),
		
		$main = nsHome.$el = $('div.main.main_home'),

		view = new APP.View.HomePersona({
			model: nsGame.personas.current,
			container: $main.find('div.summary-area.summary-soldier div.summary-content')
		});

	view.render();
	
	view.attach({
		prepend: true
	});
	
	/*
	nsHome.equipmentView = new APP.View.HomeAbilities({
		container: $main,
		className: 'equipment',
		type: 'equipment',
		collection: nsAbilities.collection
	}).attach();
	
	nsHome.equipmentView.render();
	
	
	nsHome.combatView = new APP.View.HomeAbilities({
		container: $main,
		className: 'combat',
		type: 'combat',
		collection: nsAbilities.collection
	}).attach();
		
	nsHome.combatView.render();
	*/

	
	
	
	$('#show-soldier-list, #show-more-soldiers').bind('click', function (e) {
		e.preventDefault();
		APP.navigate('/roster', true);
    });
	
	
	// Start the slideshow
	$.highlights.startSlideshow();
	
	
	/**
	 * Task done!
	 */
	done();
});


/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule home
 */
/**
 * @class GAME.Task.home.routes
 */
APP.task('home.routes', function taskHomeRoutes(done) {
	"use strict";
	
	
	var win = APP.win,
		$ = APP.$,
		_ = APP._;
	
	
	/**
	 * Home Page
	 */
	APP.bind('page:home', function onPageHome(from) {
		if (from !== 'home') {
			win.dontUpdateDoll = false;
			win.showDoll();
			if (win.bundleOnDoll) {
				win.dressDoll();
			}
		}
	});
	
	
	/**
	 * Home route
	 */
	APP.route('home', 'home', function onHomeRoute() {
		APP.page('home');
	});
	
	
	/**
	 * Task done!
	 */
	done();
});
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule items
 */
(function (root) {
	"use strict";

	// Node support
	if (typeof require !== 'undefined') {
		if (!root.APP) {
			root.APP = require('./../common/app');
		}
		
		if (!root.APP.Model) {
			root.APP.Model = require('./../common/model');
		}
		
		if (!root.APP.Collection) {
			root.APP.Collection = require('./../common/collection');
		}
		
		if (!root.APP.Collection.Offers) {
			root.APP.Collection.Offers = require('./../store/collection.offers');
		}
	}
	
	
	var APP = root.APP,
		_ = APP._,
		$ = APP.$,
		win = APP.win,
		typeMap = {
			'weapons'	: 'weapon',
			'gadgets'	: 'weapon',
			'abilities'	: 'weapon',
			
			'appearances'	: 'appearance',
			'head'			: 'appearance',
			'face'			: 'appearance',
			'uniform'		: 'appearance',
			'accessory1'	: 'appearance',
			'accessory2'	: 'appearance',
			
			'boosters'	: 'booster',
			'gear'		: 'booster',
			'bundles'	: 'bundle',
			
			'attachment'	: 'attachment',
			'attachments'	: 'attachment',
			
			'item_upgrades'	: 'upgrade',
			'upgrades'		: 'upgrade',
			
			'item_pockets'	: 'pocket',
			'pockets'		: 'pocket'
		},
		attachmentSlots = [ 'MUZZLE', 'SCOPE', 'BARREL', 'AMMO', 'STOCK', 'TEXTURE' ],
		validTypes = [ 'weapon', 'appearance', 'booster', 'bundle', 'attachment', 'trainingpoint', 'upgrade', 'pocket' ],
		
		parent = APP.Model.prototype,
		equipLimit = {
			primary: 1,
			secondary: 1,
            melee: 1,
			head: 1,
			face: 1,
			uniform: 1,
			accessory1: 1,
			accessory2: 1
		},
		nsAbilities = APP.namespace('abilities'),
		nsConfig = APP.namespace('config'),
		trainable = {  }, 
		boosterable = {  },
		getRandomInt = function getRandomInt(min, max) {
			return Math.floor(Math.random() * (max - min + 1)) + min;
		},
		
		
		normalizeKeys = {
			// Weapon and attachments stat keys
			'Action'			: 'action',
			'Accuracy'			: 'accuracy',
			'AccuracyLvL'		: 'accuracy',
			'Zoom'				: 'zoom',
			'Damage'			: 'damage',
			'DamageLvL'			: 'damage',
			'Rof'				: 'rof',
			'ROF'				: 'rof',
			'ROFLvL'			: 'rof',
			'Range'				: 'range',
			'RangeLvL'			: 'range',
			'Ammo'				: 'ammo',
			'MagSizeIncrease'	: 'ammo',
			'Mags'				: 'mags',
			'nrOfMAgs'			: 'mags',
			'MagIncrease'		: 'mags',
			
			// Upgrade stat keys
			'DamageTaken'		: 'damageTaken',
			'SprintSpeed'		: 'sprintSpeed',
			'NrRPGRound'		: 'numRPGRound',
			'NrHandGrenade'		: 'numHandGrenade',
			'NrClaymore'		: 'numClaymore',
			'NrC4'				: 'numC4',
			'NrMedBox'			: 'numMedBox',
			'NrPrimaryMag'		: 'nrPrimaryMag'
		},
		CACHE_IMAGE_DATA = false, //!!win.sessionStorage,
		ITEM_IMAGE_DATA_CACHE_KEY = 'ITEM_IMAGE_DATA:',

		TIME_GROUPS = {
			years: 60 * 60 * 24 * 365,
			months: 60 * 60 * 24 * 30,
			//weeks: 60 * 60 * 24 * 7,
			days: 60 * 60 * 24,
			hours: 60 * 60,
			minutes: 60,
			seconds: 1
		},
		TIME_DATE_KEY_MAP = {
			years: 'WEB_COMMON_DATE_YEARS',
			months: 'WEB_COMMON_DATE_MONTHS',
			//weeks: week: 60 * 60 * 24 * 7,
			days: 'WEB_COMMON_DATE_DAYS',
			hours: 'WEB_COMMON_DATE_HOURS',
			minutes: 'WEB_COMMON_DATE_MINUTES',
			seconds: 'WEB_COMMON_DATE_LESS_THAN_MINUTE'
		};
	
	
	/**
	 * Model: Item
	 */
	/**
	 * @class Item
	 * @extend FE.APP.Model
	 * @namespace GAME.APP.Model
	 * @type {*}
	 */
	APP.Model.Item = APP.Model.extend({
		normalizeKeys: normalizeKeys,
		
		defaults: {
			'id'			: null,
			'type'			: null,
			'name'			: null,
			'expired'		: false,
			'expiredate'	: false,
			'buyable'		: true,
			'owned'			: false,
			'equippedSlot'	: null,
			'promotionType'	: null,
			'bundles'		: [],
			'prices'		: []
		},
		
		schema: {
			'accuracy'			: 'number',
			'action'			: 'number',
			'damage'			: 'number',
			'ammo'				: 'number',
			'mags'				: 'number',
			'range'				: 'number',
			'rof'				: 'number',
			'zoom'				: 'number',
			'fitsSlot'			: 'number',
			'tier'				: 'number',
			'usecount'			: 'number',
			'minNumPockets'		: 'number',
			'maxNumPockets'		: 'number',
			'numberOfPockets'	: 'number',
			
			
			'buyable'			: 'bool',
			'expired'			: 'bool',
			'isnew'				: 'bool',
			'owned'				: 'bool',
			'ownedPermanent'	: 'bool',
			'isDefault'			: 'bool',
			'locked'			: 'bool',
			
			'promotionLabel': 'string',
			'promotionType'	: function castPromotionTypeItemModel(value) {
				if ((value || '').toString().toLowerCase() === 'default') {
					return null;
				}
				return value;
			},
			
			'equippedSlot': function castEquippedSlotItemModel(value) {
				value = APP.Model.Schema.number(value);
				if (value instanceof Error) {
					return null;
				}
				return value;
			},
			
			'bestInClass': function castBestInClassItemModel(value) {
				return _.map(value || [], function (key) {
					if (normalizeKeys.hasOwnProperty(key)) {
						return normalizeKeys[key];
					}
					return key;
				}, this);
			},
			
			'attachments': function castAttachmentsItemModel(value) {
				if (_.isEmpty(value)) {
					return null;
				}
				return value;
			},
			
			'upgrades': function castUpgradesItemModel(value) {
				if (_.isEmpty(value)) {
					return {};
				} else if (_.isArray(value)) {
					var tmp = {};
					_.forEach(value, function (val, i) {
						tmp[i] = val; 
					});
					return tmp;
				}
				return value;
			},
			
			'type': function castTypeItemModel(value, attrs) {
				attrs.itemType = typeMap.hasOwnProperty(value) ? typeMap[value] : value;
				return value;
			},
			
			'itemType': function castItemTypeItemModel(value, attrs) {
				if (value) {
					return value;
				} else if (attrs.type) {
					return typeMap.hasOwnProperty(attrs.type) ? typeMap[attrs.type] : attrs.type;
				}
				return new Error('Unable to set "itemType"');
			},
			
			'prices': function castPricesItemModel(value, attrs, schema) {
				attrs.offers = schema.cast('offers', value);
				return null;
			},
			
			'offers': function castOffersItemModel(value) {
				return new APP.Collection.Offers(value || []);
			}
		},
		
		
		/**
		 * Initialize
		 */
		initialize: function initializeItemModel() {
			
			var itemsType = this.get('itemsType');
			
			this._imageData = {};
			this._attachmentImages = {};
			
			// Set up an change event listener if this is equippable
			if (this.isEquippable()) {
				this.bind('change:equippedSlot', this._onEquippedSlotChange, this);
			}
			
			
			
			// Customizable
			if (this.isCustomizable()) {
				if (this.isItemType('weapon')) {
					this.bind('change:attachments', this._onChangeAttachments, this);
					
				} else if (this.isItemType('appearance')) {
					// Listen to upgrades change events to figure which models are equipped
					this.bind('change:upgrades', this._setEquippedUpgrades, this);
				}
			}


			// Fix "categoryname" attribute for upgrades
			if (this.isItemType('upgrade')) {
				this.set('categoryname', APP.sidis.trans('WEB_GAME_ITEM_CATEGORY_' + this.get('category').toUpperCase() + '_UPGRADE'));
				
			// Fix "categoryname" attribute for boosters
			} else if (this.isItemType('booster')) {
				this.set('categoryname', APP.sidis.trans('WEB_GAME_ITEM_CATEGORY_BOOSTER'));
			}
			
			
			// Is locked

            if(this.isLocked()) {
                this._lockProgress();
                //nsGame.personas.current.bind('change:level', this._lockProgress, this);
            }
			
			// Is Promted
			if (this.isPromoted()) {
				this._setPromotion();
			}
			this.bind('change:promotionType', this._setPromotion, this);
			
			// Offers
			this._onChangeOffers();
			this.bind('change:offers', this._onChangeOffers, this);
			
			
			// Dependency
			if (this.has('dependency')) {
				_.defer(_.bind(this._handleDependency, this));
			}
			
			// Corresponding Gear Id
			if (this.has('correspondingGearId')) {
				_.defer(_.bind(this._handleCorrespondingGearId, this));
			}
		},
		
		/**
		 * On change attachments
		 */
		_onChangeAttachments: function () {
			// When attachments change we need to invalidate the images
			this._imageData = {};
			this._processCustomizations();
			
			/**
			if (CACHE_IMAGE_DATA) {
				win.sessionStorage.removeItem(ITEM_IMAGE_DATA_CACHE_KEY + this.id + ':min');
				win.sessionStorage.removeItem(ITEM_IMAGE_DATA_CACHE_KEY + this.id + ':med');
			}
			**/
		},
		
		/**
		 * On Change Offers
		 */
		_onChangeOffers: function _onChangeOffersItemModel() {
			var offers = this.get('offers'),
				oldOffers = this.previous('offers');
			
			if (oldOffers instanceof APP.Collection.Offers && oldOffers !== offers) {
				oldOffers.unbind();
			}
			
			if (offers instanceof APP.Collection.Offers) {
				this.proxyEvents(offers, 'offer');
			}
		},
		
		_handleDependency: function _processDependencyItemModel() {
			var ability = nsAbilities.collection && nsAbilities.collection.get(this.get('dependency')),
				level = 0;
			
			if (ability) {
				level = ability.get('level');
				ability.bind('change:level', function () {
					this.set('invalidDependency', (ability.get('level') === 0));
				}, this);
			} else {
				APP.log.warn('Unable to find "dependency", defaulting to invalid!');
			}
			
			this.set('invalidDependency', (level === 0));
		},
		_handleCorrespondingGearId: function _handleCorrespondingGearIdItemModel() {
			var item = this.collection.get(this.get('correspondingGearId')),
				owned = true;
			
			if (item) {
				owned = item.isOwned();
				item.bind('change:owned', function () {
					this.set('invalidCorrespondingGearId', item.isOwned());
				}, this);
			} else {
				APP.log.warn('Unable to find "correspondingGearId", defaulting to invalid!');
			}
			
			this.set('invalidCorrespondingGearId', owned);
		},
		
		
		/**
		 * Process Attachments
		 */
		_processAttachments: function _processAttachmentsItemModel() {
			if (this.isCustomizable()) {
				var attached = this.collection.getModelAttachedItems(this),
					attachments = {};
				
				_.forEach(attached, function (model, key) {
					var slot = _.indexOf(attachmentSlots, key.toUpperCase()) + 1;
					attachments[slot] = model ? model.id : null;
				});
				
				this.set({
					attachments: attachments
				}, { silent: true });
			}
		},
		/**
		 * Process Upgrades
		 */
		_processUpgrades: function _processUpgradesItemModel() {
			
		},
		/**
		 * Process Customizations
		 */
		_processCustomizations: function _processCustomizationsItemModel() {
			if (this.has('attachments')) {
				return this._processAttachments();
			} else if (this.has('upgrades')) {
				return this._processUpgrades();
			}
			return this;
		},
		
		/**
		 * _set Promotion
		 * @ap
		 */
		_setPromotion: function _setPromotionItemModel() {
			
			var promotionType = this.get('promotionType'),
				type = (promotionType || '').toString().toLowerCase(),
				off = parseInt(type, 10),
				label,
				transKey;
			
			if (off) {
				type = 'off';
				label = APP.sidis.trans('WEB_GAME_PROMOTION_OFF', { '%off%': off });
				
			} else if (type === 'new') {
				label = APP.sidis.trans('WEB_GAME_PROMOTION_NEW');
				
			} else if (type === 'popular') {
				label = APP.sidis.trans('WEB_GAME_PROMOTION_POPULAR');
				
			} else if (type) {
				type = 'other';
				transKey = 'WEB_GAME_PROMOTION_' + type.toUpperCase();
				label = APP.sidis.trans(transKey);
				
				if (label === transKey) {
					label = promotionType;
				}
			} else {
				type = null;
			}
			
			this.set({
				promotionType: type,
				promotionLabel: label
			}, {
				silent: true
			});
		},
		
		
		/**
		 * Unlock progress
		 */
		_lockProgress: function _lockProgressItemModel() {
            var lockProgress = -1,
                type = this.get('lockType'),
                key,
            // Persona
                persona = (typeof require !== 'undefined') ? { level: 10 } : APP.ns('config').persona;


            if (type === 'level') {
                key = parseInt(this.get('lockCriteria'), 10);
                lockProgress = Math.round(100 * (persona.level / key)) / 100;
            }
            
            this.set({
                lockProgress: lockProgress
            }, {
                silent: true
            });
            
            return this;
		},
		
		
		/**
		 * On Equipped Slot Change
		 */
		_onEquippedSlotChange: function _onEquippedSlotChangeItemModel() {
			
			// Item Type
			var collection = this.collection,
			
				itemType = this.get('itemType'),
				
				//
				equippedSlot = this.get('equippedSlot'),
				
				// Get Previous Equipped Slot
				previousEquippedSlot = this.previous('equippedSlot'),
				
				squattingModels,
				
				// Get Validation Group
				validationGroup = this.get('validationGroup'),
				
				limit,
				groupModels,
				extraWeaponBooster,
				extraWeaponUpgrade;
			
			// Is the model equipped?
			if (_.isNumber(equippedSlot)) {
				
				// Get models on slot
				squattingModels = collection.filterBy({
					itemType: itemType,
					equippedSlot: equippedSlot
				}).without(this);
				
				// Occupied
				if (squattingModels.length !== 0) {
					if (_.isNumber(previousEquippedSlot)) {
						_.invoke(squattingModels, 'set', {
							equippedSlot: previousEquippedSlot
						});
					} else {
						_.invoke(squattingModels, 'unset', 'equippedSlot');
					}
				}
				
				
				// Is there a limit to how many of this group that can be equipped
				if (equipLimit.hasOwnProperty(validationGroup)) {
					// Dual primary
					if (validationGroup === 'primary') {
						extraWeaponBooster = collection.get(7000);
						limit = extraWeaponBooster && extraWeaponBooster.get('owned') ? 2 : 1;
						if (limit === 1) {
							extraWeaponUpgrade = collection.getEquippedCustomizations().get(7109);
							if (extraWeaponUpgrade && extraWeaponUpgrade.isOwned()) {
								limit = 2;
							}
						}
					} else {
						limit = equipLimit[validationGroup];
					}
					
					
					// Get model equipped in this group
					groupModels = collection.filterBy({
						itemType: itemType,
						isEquipped: true,
						validationGroup: validationGroup
					});
					
					
					// Over the limit
					if (groupModels.length > limit) {
						
						groupModels = groupModels.sortBy(function (model) {
							return model.get('equippedSlot');
						});
						
						groupModels.reverse();
						
						_.forEach(_.without(groupModels, this).slice(limit - 1), function (model) {
							model.unset('equippedSlot');
						});
					}
				}
			}

			/**
			 * Need to set equippedSlot for upgrades
			 */
			if (itemType === 'appearance') {
				this._setEquippedUpgrades();
			}
		},
		
		_setEquippedUpgrades: function _setEquippedUpgradesItemModel() {
			
			var collection = this.collection,
				equippedSlot = this.get('equippedSlot'),
				isEquipped = this.isEquipped(),
				upgrades = _.values(this.get('upgrades')),
				previous = _.values(this.previous('upgrades')),
				removed = _.difference(previous, upgrades);
			
			// Removed
			_.forEach(removed, function (upgrade) {
				upgrade = collection.get(upgrade);
				if (upgrade) {
					upgrade.unset('equippedSlot');
				}
			});
			
			// Current & Added
			_.forEach(upgrades, function (upgrade, slot) {
				upgrade = collection.get(upgrade);
				if (upgrade) {
					// Equipped
					if (isEquipped) {
						upgrade.set('equippedSlot', parseInt(slot.toString() + equippedSlot.toString(), 10));

						// Unequipped
					} else {
						upgrade.unset('equippedSlot');
					}
				}
			});
		},

		/**
		 * URL
		 */
		url: function urlItemModel() {
			return nsConfig.getItemUrl + this.id;
		},
		
		parse: function (response) {
			if (response && response.status === 'success') {
				return response.data || {};
			}
		},
		
		/**
		 * Get Image
		 */
		getImage: function getImageItemModel(size) {
			// Got set on the item
			if (this.has('image')) {
				return this.get('image');
			}
			
			var category = this.get('category'),
				hasGeneric = ['barrel', 'ammo', 'stock'];
			
			// Set generic images on barrel, ammo and stock
			if (_.indexOf(hasGeneric, category) !== -1) {
				return nsConfig.imageFolder + 'item-icons/' + size + '/' + category + '.png';
			}
			
			size = size || 'max';
			
			return nsConfig.imageFolder + 'item-icons/' + size + '/' + this.id + '.png';
		},
		
		/**
		 * Get Attachment Image
		 */
		getAttachmentImage: function getAttachmentImageItemModel(size) {
			size = size || 'max';
			
			if (this._attachmentImages.hasOwnProperty(size)) {
				return this._attachmentImages[size];
			}
			
			return nsConfig.imageFolder + 'attachment-icons/' + size + '/' + this.id + '.png';
		},
		
		/**
		 * Set Attachment Image
		 */
		setAttachmentImage: function setAttachmentImageItemModel(size, url) {
			this._attachmentImages[size] = url;
			return this;
		},
		
		/**
		 * Has Composed Image
		 */
		hasComposedImage: function hasComposedImageItemModel(size) {
			var local = !!(this._imageData[size] && this._imageData[size].image && this._imageData[size].silhouette),
				cacheKey = ITEM_IMAGE_DATA_CACHE_KEY + this.id +  ':' + size;

			if (local) {
				return true;
			}
			/**
			if (CACHE_IMAGE_DATA && win.sessionStorage.hasOwnProperty(cacheKey)) {
				this._imageData[size] = JSON.parse(win.sessionStorage.getItem(cacheKey));
				return true;
			}
			**/
			return false;
		},
		
		/**
		 * Compose Image
		 */
		composeImage: function composeImageItemModel(size, fn) {
			var	imageData,
				attachedItems,
				pos = APP.ns('weapons').getSlotPositions(this),
				images = [],
				texture = [ 0, 0 ],
				muzzle = pos.muzzle.box.slice(0),
				scope = pos.scope.box.slice(0),
				width = nsConfig.imageSize[size].width,
				height = nsConfig.imageSize[size].height,
				onImageCompose = _.bind(function onImageCompose(err, canvas) {
					// If we get an error, just re-run as image loading should be catached elsewhere
					if (err) {
						APP.log.warn(err);
						return this.composeImage(size, fn);
					}

					var cacheKey = ITEM_IMAGE_DATA_CACHE_KEY + this.id +  ':' + size;
					
					imageData.image = canvas.toDataURL();
					
					// Only med sized compositions needs a silhouette
					if (size === 'med') {
						APP.imageCompose.silhouette(canvas, 25, function onImageComposeSilhouette(canvas) {
							imageData.silhouette = canvas.toDataURL();
							
							/**
							if (CACHE_IMAGE_DATA) {
								win.sessionStorage.setItem(cacheKey, JSON.stringify(imageData));
							}
							**/
							
							fn(imageData.image, imageData.silhouette);
						});
					} else {
						imageData.silhouette = '';
						
						/**
						if (CACHE_IMAGE_DATA) {
							win.sessionStorage.setItem(cacheKey, JSON.stringify(imageData));
						}
						**/
						
						fn(imageData.image, imageData.silhouette);
					}
				}, this),
				doneFn;
			
			// TODO: Fix this in a better way
			if (size === 'min' && this.get('validationGroup') === 'primary' && this.get('category') !== 'shotgun') {
				width = 90;
				height = 40;
			}
			
			// Cached
			if (imageData) {
				root.setTimeout(_.bind(function onTimeoutComposeImageItemModel() {
					fn(imageData.image, imageData.silhouette);
				}, this), 0);
				return this;
				
			// Cached
			} else if (this.hasComposedImage(size)) {
				root.setTimeout(_.bind(function onTimeoutComposeImageItemModel() {
					fn(this._imageData[size].image, this._imageData[size].silhouette);
				}, this), 0);
				return this;
			}
			
			this._imageData[size] = imageData = {};
			
			// We need to render
			if (this.isCustomizable()) {
				attachedItems = this.collection.getModelAttachedItems(this);
				
				if (size !== 'max') {
					muzzle[0] = muzzle[0] / 3.2;
					muzzle[1] = muzzle[1] / 3.2;
					scope[0] = scope[0] / 3.2;
					scope[1] = scope[1] / 3.2;
				}
				
				if (size === 'min') {
					muzzle[0] = muzzle[0] / 3.2;
					muzzle[1] = muzzle[1] / 3.2;
					scope[0] = scope[0] / 3.2;
					scope[1] = scope[1] / 3.2;
				}
				
				// Muzzle
				if (attachedItems.muzzle) {
					muzzle.unshift(attachedItems.muzzle.getAttachmentImage(size));
					images.push(muzzle);
				}
				
				// Scope
				if (attachedItems.scope) {
					scope.unshift(attachedItems.scope.getAttachmentImage(size));
					images.push(scope);
				}
				
				// Texture
				if (attachedItems.texture) {
					texture.unshift(attachedItems.texture.getAttachmentImage(size));
					images.push(texture);
				}
				
			} else {
				images.push([ this.getImage(size), 0, 0 ]);
			}
			
			// After all is done compose image
			doneFn = _.after(images.length, function () {
				// Compose image
				APP.imageCompose(images, width, height, onImageCompose);
			});
			
			// Preload and check for errors
			_.forEach(images, function (image) {
				APP.preload.image(image[0], _.bind(function (err, src) {
					if (err) {
						var model = this.collection.get(src.match(/[0-9]+/g).pop());
						if (model) {
							if (model.isItemType('attachment')) {
								image[0] = src = nsConfig.imageFolder + 'attachment-icons/' + size + '/' + model.get('category') + '.png';
								model.setAttachmentImage(size, src);
							} else {
								image[0] = src = nsConfig.imageFolder + 'attachment-icons/' + size + '/weapon_texture.png';
							}
						}
					}
					doneFn();
				}, this), 15000);
			}, this);
			
			return this;
		},
		
		/**
		 * Is Item Type
		 */
		isItemType: function isItemTypeItemModel(type) {
			this.constructor.validateType(type);
			return (this.get('itemType') === type);
		},
		
		/**
		 * Is Type
		 */
		isType: function isTypeItemModel(type) {
			return this.isItemType(typeMap[type] || type);
		},
		
		/**
		 * Is Owned
		 */
		isOwned: function isOwnedItemModel() {
			return !!this.get('owned');
		},
		
		/**
		 * Is Equipped
		 */
		isEquipped: function isEquippedItemModel() {
			return _.isNumber(this.get('equippedSlot'));
		},

		/**
		 * Get Expire Text
		 * @return {String}
		 */
		getExpireText: function getExpireTextItemModel() {
			var nowTs = Math.round((Date.now() + nsConfig.timeDiff) / 1000),
				timeDiff = Math.abs(nowTs - this.get('expireTS')),
				units,
				group,
				text,
				textContext = {};
			
			_.find(TIME_GROUPS, function (time, timeGroup) {
				units = Math.floor(timeDiff / time);
				group = timeGroup;
				return timeDiff > time;
			});
			
			textContext['%' + group + '%'] = units;
			text = APP.sidis.trans(TIME_DATE_KEY_MAP[group], textContext);
			
			if (this.isExpired()) {
				return APP.sidis.trans('WEB_COMMON_EXPIRED', {
					'%t%': text
				});
			}
			
			return APP.sidis.trans('WEB_COMMON_WILL_EXPIRE_IN', {
				'%t%': text
			});
		},
		
		/**
		 * 
		 * @param testOnly
		 * @return {Boolean}
		 */
		autoEquip: function (testOnly) {
			var id = this.id,
				itemType = this.get('itemType'),
				category = this.get('category'),
				collection = this.collection,
				filterFn,
				parentItems,
				fitsSlot,
				items;


			/**
			 * Attachments requires that a parent item is equipped
			 */
			if (itemType === 'attachment') {
				parentItems = this.get('parentItems') || [];
				items = collection.filter(function (model) {
					return _.indexOf(parentItems, model.id) !== -1 && model.isEquipped() && model.isOwnedPermanent();
				});


				// Can we do it?
				if (items.length !== 0) {

					// Test only
					if (testOnly) {
						return true;
					}

					fitsSlot = this.get('fitsSlot');

					// Equip
					_.forEach(items, function (model) {
						var attachments = _.clone(model.get('attachments'));
						attachments[fitsSlot] = id;
						model.set('attachments', attachments);
                        // Save customization changes
                        //nsGame.saveCustomizations(model);
					});

				}
			}


			/**
			 * Upgrades requires an appearance item of the same category that has a free slot
			 */
			if (itemType === 'upgrade') {
				items = collection.filter(function (model) {
					return (
						model.isItemType('appearance') &&
						model.isOwnedPermanent() && 
						model.get('category') === category &&
						model.isEquipped() &&
						model.get('numberOfPockets') > _.compact(model.get('upgrades')).length
					);
				});

				// Can we do it?
				if (items.length !== 0) {

					// Test only
					if (testOnly) {
						return true;
					}

					// Equip
					_.forEach(items, function (model) {
						var numberOfPockets = model.get('numberOfPockets'),
							upgrades = _.clone(model.get('upgrades'));

						// Find the first falsy value and set upgrade there
						_.some(upgrades, function (value, i) {
							if (!value && i < numberOfPockets) {
								upgrades[i] = id;
								return true;
							}
						});

						model.set('upgrades', upgrades);
					});
				}
			}

			/**
			 * Pockets can not be auto equipped
			 */
			if (itemType === 'pocket') {
				return false;
			}

			/**
			 * Appearance items can always auto equipped
			 */
			if (itemType === 'appearance') {
				if (testOnly) {
					return true;
				}

				this.set('equippedSlot', _.indexOf([
					'head',
					'face',
					'uniform',
					'accessory1',
					'accessory2'
				], category));
			}

			/**
			 * Weapon items requires that there is a weapon of the category equipped
			 */
			if (itemType === 'weapon') {
				items = collection.filter(function (model) {
					return model.isItemType('weapon') && model.isEquipped() && model.get('category') === category;
				});

				// Can we do it?
				if (items.length !== 0) {

					// Test only
					if (testOnly) {
						return true;
					}

					// Get lowest slot
					fitsSlot = items.sort(function (a, b) {
						return a.get('equippedSlot') - b.get('equippedSlot');
					})[0].get('equippedSlot');

					this.set('equippedSlot', fitsSlot);
				}
			}

			return false;
		},

		/**
		 * Unequip
		 */
		unequip: function unequip() {
			var itemType = this.get('itemType'),
				slot;
			
			// Equipped in item bar
			if (itemType === 'weapon' || itemType === 'appearance') {
				this.unset('equippedSlot');

			// Equipped on a weapon
			} else if (itemType === 'attachment') {

				slot = this.get('fitsSlot');

				this.collection.forEach(function (model) {
					if (model.isEquipped() && model.has('attachments') && model.get('attachments')[slot] === this.id) {
						var attachments = _.clone(model.get('attachments'));
						attachments[slot] = null;
						model.set('attachments', attachments);
					}
				}, this);


			} else if (itemType === 'upgrade') {

				this.collection.forEach(function (model) {
					var values = (model.isEquipped() && _.values(model.get('upgrades'))) || [],
						i = _.indexOf(values, this.id),
						upgrades;
					
					if (i !== -1) {
						upgrades = _.clone(model.get('upgrades'));
						upgrades[i] = null;
						model.set('upgrades', upgrades);
					}
				}, this);
				
			}
			
			return this;
		},
		
		/**
		 * Is Equipable
		 */
		isEquippable: function isEquippableItemModel() {
			return _.indexOf(['weapon', 'appearance'], this.get('itemType')) !== -1;
		},
		
		
		/**
		 * Is Boostable
		 */
		isBoostable: function isBoostableItemMode() {
			return false;
		},
		
		/**
		 * Is Trainable
		 */
		isTrainable: function isTrainableItemModel() {
			return false;
		},
		
		/**
		 * Is Consumable
		 */
		isConsumable: function isConsumableItemModel() {
			return this.isBuyable() && this.get('type') === 'gadgets';
		},
		
		/**
		 * Is Buyable
		 */
		isBuyable: function isBuyableItemModel() {
			return !!this.get('buyable');
		},
		
		/**
		 * Is Rented
		 */
		isRented: function isRentedItemModel() {
			return !!(this.get('owned') && this.get('expireTS'));
		},
		
		/**
		 * Is Default
		 */
		isDefault: function isDefaultItemModel() {
			return !!this.get('isDefault');
		},
		
		/**
		 * Is Customizable
		 */
		isCustomizable: function isCustomizableItemModel() {
			return this.has('attachments') || this.get('maxNumPockets') > 0;
		},
		
		/**
		 * Is Customized
		 */
		isCustomized: function isCustomizedItemModel() {
			if (this.isCustomizable()) {
				if (this.isItemType('weapon')) {
					return _.filter(this.collection.getModelAttachedItems(this, true), function (model) {
						return !model.isDefault();
					}).length !== 0;
				} else if (this.has('upgrades')) {
					return _.filter(this.get('upgrades') || [], function (upgrade) {
						return !!upgrade;
					}).length !== 0;
				}
			}
			return false;
		},
		
		
		/**
		 * Is Locked
		 */
		isLocked: function isLockedItemModel(pocket) {
			if (this.isItemType('pocket') && this.has('unlockLevels')) {
				var unlockLevel = this.get('unlockLevels')[pocket] || 9999;
				return (unlockLevel > this.get('personaLevel'));
			}
            
			return !!this.get('isLocked');
		},
		
		/**
		 * Is Valid
		 */
		isValid: function isValidItemModel() {
			// Expired
			if (this.isExpired()) {
				return false;
			}
			
			if (this.isCustomizable()) {
				return false;
			}
			
			return true;
		},
		
		/**
		 * Has Expired
		 */
		isExpired: function isExpiredItemModel() {
			return !!this.get('expired');
		},
		
		
		/**
		 * Is Promoted
		 */
		isPromoted: function isPromoted() {
			return !!this.get('promotionType');
		},
		
		/**
		 * Has Expired
		 */
		hasExpired: function hasExpiredItemModel() {
			return this.isExpired();
		},
		
		
		/**
		 * Is Owned Permamnent
		 */
		isOwnedPermanent: function isOwnedPermanentItemModel() {
			return !!this.get('ownedPermanent');
		},
		
		/**
		 * Get Attachments
		 */
		getAttachments: function getAttachmentsItemModel() {
			var attachments = _.clone(this.get('attachments') || {});
			
			_.forEach(attachments, function (itemId, slot) {
				attachments[slot] = this.collection.get(itemId);
			}, this);
			
			return attachments;
		},
		/**
		 * Get Upgrades
		 */
		getUpgrades: function getUpgradesItemModel() {
			var upgrades = _.clone(this.get('upgrades') || {});
			
			_.forEach(upgrades, function (itemId, slot) {
				upgrades[slot] = this.collection.get(itemId);
			}, this);
			
			return upgrades;
		},
		/**
		 * Get Customizations
		 */
		getCustomizations: function getCustomizationsItemModel() {
			if (this.has('attachments')) {
				return this.getAttachments();
			} else if (this.has('upgrades')) {
				return this.getUpgrades();
			}
			return {};
		},
		
		
		
		/**
		 * Has Invalid Attachments
		 */
		hasInvalidAttachments: function hasInvalidAttachmentsItemModel() {
			return _.some(this.get('attachments') || [], function (itemId, slot) {
				var model = this.collection.get(itemId);
				if (model) {
					return !model.get('owned');
				}
				return false;
			}, this);
		},
		/**
		 * Has Invalid Upgrades
		 */
		hasInvalidUpgrades: function hasInvalidAttachmentsItemModel() {
			return _.some(this.get('upgrades') || [], function (id) {
				var model = this.collection.get(id);
				if (model) {
					return !model.get('owned');
				}
				return false;
			}, this);
		},
		/**
		 * Has Invalid Customizations
		 */
		hasInvalidCustomizations: function hasInvalidCustomizationsItemModel() {
			if (this.has('attachments')) {
				return this.hasInvalidAttachments();
			} else if (this.has('upgrades')) {
				return this.hasInvalidUpgrades();
			}
			return false;
		},
		
		
		
		/**
		 * Has Stats
		 */
		hasStats: function hasStatsItemModel() {
			return !_.isEmpty(this.get('stats'));
		},
		
		/**
		 * Get Stats
		 */
		getStats: function getStatsItemModel() {
			return this.get('stats') || {};
		},
		
		getCustomStats: function getCustomStatsItemModel() {
			return this.collection.getModelStats(this);
		},
		
		
		/**
		 * Get dependencies
		 */
		getDependencies: function () {
			var deps = {};
			
			// Abillity dependency
			if (this.has('dependency')) {
				// TODO: We need a better, non-global way to handle this. Add abilities as items?
				deps.ability = nsAbilities.collection.get(this.get('dependency'));
			}
			
			// Upgrade booster relation
			if (this.has('correspondingGearId')) {
				deps.gear = this.collection.get(this.get('correspondingGearId'));
			}
			
			return deps;
		},
		hasInvalidDependencies: function () {
			return !!(this.get('invalidDependency') || this.get('invalidCorrespondingGearId'));
		},
		
		
		/**
		 * Has Attachments
		 */
		hasAttachments: function hasAttachmentsItemModel() {
			return this.isItemType('weapon') && this.isCustomizable();
		},
		/**
		 * Has Upgrades
		 */
		hasUpgrades: function hasUpgradesItemModel() {
			return this.isItemType('appearance') && this.isCustomizable();
		},
		/**
		 * Has Customizations
		 */
		hasCustomizations: function hasInvalidCustomizationsItemModel() {
			if (this.isItemType('weapon')) {
				return this.hasAttachments();
			} else if (this.isItemType('appearance')) {
				return this.hasUpgrades();
			}
			return false;
		},
		
		/**
		 * Reset Attachments
		 */
		resetAttachments: function resetAttachmentsItemModel() {
			var attachments = _.clone(this.get('attachments'));
			
			// Reset Attachments
			_.forEach(attachments, function resetEachAttachment(value, key) {
				attachments[key] = null;
			});
			
			// Set Attachments
			this.set({
				attachments: attachments
			});
			
			return this;
		},
		/**
		 * Reset Upgrades
		 */
		resetUpgrades: function resetUpgradesItemModel() {
			var upgrades = _.clone(this.get('upgrades'));
			
			// Reset Upgrades
			_.forEach(upgrades, function resetEachUpgrade(value, key) {
				upgrades[key] = null;
			});
			
			// Set Upgrades
			this.set({
				upgrades: upgrades
			});
			
			return this;
		},
		/**
		 * Reset Customizations
		 */
		resetCustomizations: function hasInvalidCustomizationsItemModel() {
			if (this.has('attachments')) {
				return this.resetAttachments();
			} else if (this.has('upgrades')) {
				return this.resetUpgrades();
			}
			return this;
		},
		
		
		/**
		 * Is Allowed In Game
		 */
		// TODO: Make this test work for all types
		isAllowedInGame: function isAllowedInGameItemModel() {
			// Expired
			if (this.isExpired()) {
				return false;
			}
			
			// Not owned
			if (!this.isOwned()) {
				return false;
			}
			
			// Invalid dependencies
			if (this.hasInvalidDependencies()) {
				return false;
			}
			
			// Invalid customizations
			if (this.hasInvalidCustomizations()) {
				return false;
			}
			
			// Use count
			if (this.isConsumable() && !this.get('usecount')) {
				return false;
			}
			
			return true;
		},
		
		/**
		 * Sync
		 */
		sync: function syncItemModel(method, model, options) {
			
			var fnSuccess = options.success,
				bundledItems;
			
			/**
			 * Handle sync read
			 */
			if (method === 'read') {
				
				if (model.isType('bundle')) {
					bundledItems = model.collection.getBundledItems(model);
					
					fnSuccess = _.after(bundledItems.length + 1, fnSuccess);
					
					if (options.error) {
						options.error = _.once(options.error);
					}
					
					bundledItems.forEach(function (bundledItem) {
						// Invoke fetch on all items
						bundledItem.fetch({
							success: fnSuccess,
							error: options.error
						});
					});
				}
				
				options.success = function onSyncReadSuccess(res, status, xhr) {
					if (res && res.status === 'success') {
						fnSuccess(res, status, xhr);
					} else {
						options.error(model, res, options, 1);
					}
				};
			}
			
			return APP.Backbone.sync.call(this, method, model, options);
		},
		
		/**
		 * To JSON
		 */
		toJSON: function () {
			var data = parent.toJSON.apply(this, arguments);
			delete data.prices;
			return data;
		}
	}, {
		validateType: function validateTypeItemModel(type) {
			if (_.indexOf(validTypes, type) === -1) {
				throw new Error('Invalid item type "' + type + '"');
			}
		},
		getAttachmentCategoryMap: function getAttachmentCategoryMap(slot) {
			var attachmentCategoryMap = { 
					'1': 'MUZZLE', 
					'2': 'SCOPE', 
					'3': 'BARREL', 
					'4': 'AMMO', 
					'5': 'STOCK', 
					'6': 'TEXTURE' 
				};
			if (attachmentCategoryMap.hasOwnProperty(slot)) {
				return attachmentCategoryMap[slot];
			}
			throw new Error('Unable to get attachment category name for slot "' + slot + '"');
		}
	});
	
	/**
	 * Module support
	 */
	if (typeof module !== 'undefined' && module.exports) {
		module.exports = APP.Model.Item;
	}
}(this));

/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule items
 */
(function (root) {
	"use strict";
	
	// Node support
	if (typeof require !== 'undefined') {
		if (!root.APP) {
			root.APP = require('./../common/app');
		}
		
		if (!root.APP.Collection) {
			root.APP.Collection = require('./../common/collection');
		}
		
		if (!root.APP.Model.Item) {
			root.APP.Model.Item = require('./model.item');
		}
	}
	
	
	var APP = root.APP,
		_ = APP._,
		$ = APP.$,
		numberOfSlotsByItemType = {
			weapon: 10,
			appearance: 5
		},
		parent = APP.Collection.prototype;
	
	
	/**
	 * Collection: Items
	 */
	APP.Collection.Items = APP.Collection.extend({
		_selected: {},
		model: APP.Model.Item,
		itemType: null,
		
		/**
		 * initialize collection
		 */
		initialize: function initializeItemsCollection(models, options) {
			options = options || {};
			
			// Default type
			if (options.type) {
				this.model.validateType(options.type);
				this.type = options.type;
			}
		},
		
		/**
		 * Reset
		 */
		reset: function resetItemsCollection(models, options) {
			options = options || {};
			
			if (!options.silent) {
				this.trigger('reset:before', this);
			}
			
			var res = parent.reset.call(this, models, options);
			
			if (!options.silent) {
				this.trigger('reset:after', this);
			}
			
			return res;
		},
		
		/**
		 * Sort by this value
		 */
		comparator: function comparatorItemsCollection(model) {
			// We already got this no need re-calculate it
			if (model.hasOwnProperty('sortWeight')) {
				return model.sortWeight;
			}
			
			var sortWeight = 10000,
				groups = ['primary', 'secondary', 'gadget', 'melee', 'head', 'face', 'uniform', 'accessory1', 'accessory2' ].reverse(),
				group = model.get('validationGroup'),
				groupIndex = _.indexOf(groups, group),
				lowestOffers = model.get('offers').getLowestOffers();
			
			// Is Locked
			if (model.isLocked() && !model.isRented()) {
				sortWeight += 1000;
				sortWeight -= (100 * model.get('lockProgress'));
				
			// Is Customizable
			} else {
				if (model.isCustomizable()) {
					sortWeight -= 1000;
				}
				
				if (groupIndex !== -1) {
					sortWeight -= (groupIndex * 100);
				}
				
				//
				if (lowestOffers && lowestOffers.funds) {
					sortWeight -= lowestOffers.funds.get('price') / 10;
				}
			}
			
			// Remember sort weight
			return (model.sortWeight = sortWeight);
		},
		
		/**
		 * Get Item types
		 */
		types: function types() {
			return _.unique(this.pluck('itemType'));
		},
		
		/**
		 * get items by key value
		 */
		by: function by(key, value) {
			var items = this.filter(function filterBy(model) {
					return (model.get(key) === value);
				}),
				collection = new APP.Collection.Items(items);
			return collection;
		},
		
		/**
		 * Get Item by type
		 */
		byType: function itemsByType(itemType) {
			itemType = itemType || this.itemType;
			this.model.validateType(itemType);
			var collection = this.by('itemType', itemType);
			collection.itemType = itemType;
			return collection;
		},

		/**
		 * 
		 * @param itemType
		 * @return {Boolean}
		 */
		hasItemType: function (itemType) {
			return this.some(function (model) {
				return model.isItemType(itemType);
			});
		},
		
		
		getExpiredSince: function (since) {
			return this.filterBy({
				expired: true,
				expireTS: function (ts) {
					return ts > since;
				}
			});
		},
		
		getExpiringSoon: function (soon) {
			return this.filterBy(function (model) {
				// Expiring soon
				if (model.isRented() && model.get('expireTS') < soon) {
					return true;
				}
			});
		},
		
		getLowUseCount: function (limit) {
			limit = limit || 10;
			return this.filterBy(function (model) {
				// Low use count
				if (model.isConsumable() && model.isOwned()  && model.get('usecount') < limit) {
					return true;
				}
			});
		},
		
		
		/**
		 * Get items by bundle
		 */
		byBundle: function itemsByBundle(bundle) {
			bundle = this.get(bundle);
			var id = bundle.id,
				items = this.filter(function filterBundle(model) {
					return (_.indexOf(model.get('bundles'), id) !== -1);
				}),
				collection = new this.constructor(items);
			
			return collection;
		},
		
		/**
		 * Get items that are in a bundle any bundle
		 */
		getBundled: function getBundled() {
			var ids = [];
			
			this.pluck('items').forEach(function eachItem(items) {
				
				var item,
					model,
					len = (items || []).length,
					i;
				
				for (i = 0; i < len; i += 1) {
					item = items[i];
					model = this.get(item.id);
					if (model && _.indexOf(ids, item.id) === -1) {
						ids.push(this.get(item.id));
					}
				}
				
				
			}, this);
			
			return new this.constructor(ids);
		},
		
		/**
		 * Get items that are in a bundle
		 */
		getBundledItems: function getBundledItems(model) {
			model = this.get(model);
			
			if (!(model instanceof APP.Model.Item)) {
				throw new Error('Invalid Model "' + model + '"');
			}
			
			var items = _.map(model.get('items') || [], function mapBundledItems(item) {
					return this.get(item.id);
				}, this);
			
			return new this.constructor(items);
		},
		
		/**
		 * Get bundles that has model
		 */
		getBundles: function getBundles(model) {
			return this.filter(function (mdl) {
				var items = mdl.get('items') || [],
					item,
					len,
					i;
				
				for (i = 0, len = items.length; i < len; i += 1) {
					item = items[i];
					if (item.id === model.id) {
						return true;
					}
				}
			});
		},
		
		inBundle: function inBundle(model) {
			return (this.getBundles(model).length !== 0);
		},
		
		/**
		 * Set Selected items by item type
		 */
		getSelected: function getSelected(itemType) {
			itemType = itemType || this.itemType;
			this.model.validateType(itemType);
			var model;
			if (!(this._selected[itemType] instanceof APP.Model.Item)) {
				model = this.byType(itemType).at(0);
				if (!model) {
					throw new Error('No model of item type "' + itemType + '" exists!');
				}
				this.setSelected(itemType, model, {
					silent: true
				}).getSelected(itemType);
			}
			
			return this._selected[itemType];
		},
		
		/**
		 * Set selected item by type
		 */
		setSelected: function setSelected(itemType, selected, options) {
			itemType = itemType || this.itemType;
			this.model.validateType(itemType);
			
			options = options || {};
			
			var model,
				oldSelected = this._selected[itemType];
			
			if (selected instanceof APP.Model.Item) {
				model = selected;
			} else if (!((model = this.get(selected)) instanceof APP.Model.Item)) {
				model = this.getSelected(itemType);
			}
			
			if (model.get('itemType') !== itemType) {
				model = this.getSelected(itemType);
			}
			
			if (!oldSelected || oldSelected.id !== model.id || options.force) {
				this._selected[itemType] = model;
				
				if (!options.silent) {
					this.trigger('select:' + itemType, model);
					this.trigger('select', model);
				}
			}
			
			return this;
		},
		
		/**
		 * Get store item by type
		 */
		getStore: function getStore(itemType) {
			itemType = itemType || this.itemType;
			this.model.validateType(itemType);
			var items = this.filter(function filterInStore(model) {
					return (model.get('itemType') === itemType && model.isBuyable());
				}),
				collection = new this.constructor(items, {
					itemType: itemType
				});
			
			return collection;
		},
		
		/**
		 * Get equipped items by type
		 */
		getEquipped: function getEquipped(itemType) {
			itemType = itemType || this.itemType;
			this.model.validateType(itemType);
			
			var models = [],
				collection;
			
			_.times(numberOfSlotsByItemType[itemType] || 0, function (slot) {
				var model = this.bySlot(itemType, slot);
				if (model) {
					models.push(model);
				}
			}, this);
			
			collection = new this.constructor(models, {
				itemType: itemType
			});
			
			return collection;
		},

		getEquippedItems: function getEquippedItems() {
			var items = this.filter(function (model) {
					return model.isEquipped() && model.get('itemType') !== 'booster';
				}),
				customizations = _.unique(_.compact(_.flatten(this.filterBy({
					isEquipped: true,
					hasCustomizations: true
				}).map(function (model) {
					return _.values(model.getCustomizations());
				}))));
			
			return new this.constructor(items.concat(customizations));
		},
		
		/**
		 * Get item by type and slot id
		 */
		bySlot: function bySlot(itemType, slot, includeDefault) {
			itemType = itemType || this.itemType;
			this.model.validateType(itemType);
			
			return this.find(function findBySlot(model) {
				return (model.get('itemType') === itemType && model.get('equippedSlot') === slot);
			});
		},
		
		getDefaults: function getDefaults(itemType) {
			var defaults = {};
			
			this.filter(function (model) {
				if (model.isItemType(itemType) && model.isDefault()) {
					defaults[model.get('category')] = model;
				}
			});
			
			return defaults;
		},
		
		/**
		 * Get owned items by type
		 */
		getOwned: function getOwned(itemType) {
			itemType = itemType || this.itemType;
			
			var sourceCollection = this,
				items,
				collection;
			
			if (itemType) {
				sourceCollection = this.byType(itemType);
			}
			
			items = sourceCollection.filter(function filterOwned(model) {
				return model.get('owned');
			});
			
			collection = new this.constructor(items, {
				itemType: itemType
			});
			
			return collection;
		},
		
		/**
		 * Get Attachments
		 * @param {APP.Model.Item or itemId} model 
		 * @returns {APP.Collection}
		 */
		getModelAttachments: function getModelAttachments(model) {
			model = this.get(model);
			
			if (!(model instanceof APP.Model.Item)) {
				throw new Error('Invalid Model "' + model + '"');
			}
			
			var	id = model.id,
				items = this.filter(function (model) {
					return (model.get('itemType') === 'attachment' && _.indexOf(model.get('parentItems'), id) !== -1);
				}),
				collection = new this.constructor(items);
			
			return collection;
		},
		
		
		getModelCustomizableSlots: function getModelCustomizableSlots(model) {
			model = this.get(model);
			
			if (!(model instanceof APP.Model.Item)) {
				throw new Error('Invalid Model "' + model + '"');
			}
			
			var	id = model.id,
				slots = [];
			
			this.forEach(function (model) {
				var parentItems = model.get('parentItems'),
					fitsSlot = model.get('fitsSlot');
				
				if (model.isItemType('attachment') && _.indexOf(parentItems, id) !== -1 && _.indexOf(slots, fitsSlot) === -1 && !model.isDefault()) {
					slots.push(fitsSlot);
				}
			});
			
			return slots.sort();
		},
		
		/**
		 * Get Attached Items
		 * @param {APP.Model.Item or itemId} model 
		 * @param {boolean} excludeEmpty
		 * @returns {Object} ex: { slot: Model }
		 */
		getModelAttachedItems: function getModelAttachedItems(model, excludeEmpty) {
			model = this.get(model);
			
			if (!(model instanceof APP.Model.Item)) {
				throw new Error('Invalid Model "' + model + '"');
			}
			
			// Get attached
			var attached = model.get('attachments'),
				attachments = this.getModelAttachments(model),
				rented = model.isRented(),
				expired = model.isExpired(),
				items = {};
			
			_.forEach(attached, function (itemId, slot) {
				var category = this.model.getAttachmentCategoryMap(slot).toLowerCase(),
					model = this.get(itemId);
				
				// If non existent or expired we need to use the default
				if (!model || (expired && !model.isDefault()) || (rented && !model.isOwned())) {
					model = attachments.filterBy({
						'fitsSlot'	: parseInt(slot, 10),
						'isDefault'	: true
					}).at(0);
				}
				
				// Exclude empty
				if (model || !excludeEmpty) {
					items[category] = model;
				}
			}, this);
			
			return items;
		},
		
		/**
		 * Get Attached Items
		 * @param {APP.Model.Item or itemId} model 
		 * @param {boolean} excludeEmpty
		 * @returns {Object} ex: { slot: Model }
		 */
		getAttachedItems: function getAttachedItems() {
			APP.log.warn('Use APP.Collection.Items::getModelAttachedItems instead of APP.Collection.Items::getAttachedItems');
			return this.getModelAttachedItems.apply(this, arguments);
		},
		
		/**
		 * Validate Attachments
		 * @param {APP.Model.Item or itemId} model 
		 * @returns {Boolean}
		 */
		validateModelAttachments: function validateModelAttachments(model) {
			model = this.get(model);
			
			if (!(model instanceof APP.Model.Item)) {
				throw new Error('Invalid Model "' + model + '"');
			}
			
			var attached = model.get('attachments'),
				key,
				id,
				attachedModel;
			
			for (key in attached) {
				if (attached.hasOwnProperty(key)) {
					id = attached[key];
					attachedModel = this.get(id);
					if (id && attachedModel && !attachedModel.get('owned')) {
						return false;
					}
				}
			}
			
			return true;
		},
		
		/**
		 * Has Attachments
		 */
		hasAttachments: function hasAttachments() {
			var items = this.filter(function (model) {
					return _.values(model.get('attachments') || {}).length !== 0;
				}),
				collection = new this.constructor(items);
			
			return collection;
		},
		
		/**
		 * Get Model Attached Stats
		 */
		getModelAttachedStats: function getModelAttachedStats(model) {
			model = this.get(model);
			
			if (!(model instanceof APP.Model.Item)) {
				throw new Error('Invalid Model "' + model + '"');
			}
			
			var attached = this.getModelAttachments(model, true),
				attachedStats = {};
			
			// Loop over each attached item
			_.forEach(attached, function (model) {
				if (model) {
					var stats = model.getStats();
					
					// Loop over each stat
					_.forEach(stats, function (stat, key) {
						if (!attachedStats.hasOwnProperty(key)) {
							attachedStats[key] = [];
						}
						attachedStats[key].push(stat);
					});
				}
			}, this);
			
			return attachedStats;
		},
		getAttachedStats: function getAttachedStats() {
			APP.log.warn('Use APP.Collection.Items::getModelAttachedStats instead of APP.Collection.Items::getAttachedStats');
			return this.getModelAttachedStats.apply(this, arguments);
		},
		
		
		
		/**
		 * Get Upgrades
		 * @param {APP.Model.Item or itemId} model 
		 * @returns {APP.Collection}
		 */
		getModelUpgrades: function getModelUpgrades(model) {
			model = this.get(model);
			
			if (!(model instanceof APP.Model.Item)) {
				throw new Error('Invalid Model "' + model + '"');
			}
			
			var	collection = this.filterBy({
					itemType: 'upgrade',
					category: model.get('category')
				});
			
			return collection;
		},
		
		
		/**
		 * Get Upgrade Items
		 * @param {APP.Model.Item or itemId} model 
		 * @param {boolean} excludeEmpty
		 * @returns {Object} ex: { slot: Model }
		 */
		getModelUpgradeItems: function getModelUpgradeItems(model, excludeEmpty) {
			model = this.get(model);
			
			if (!(model instanceof APP.Model.Item)) {
				throw new Error('Invalid Model "' + model + '"');
			}
			
			var upgrades = model.get('upgrades') || {},
				upgradeItems = {};
			
			_.forEach(upgrades, function (upgrade, pocketIndex) {
				var model = this.get(upgrade);
				if (model || !excludeEmpty) {
					upgradeItems[pocketIndex] = this.get(upgrade);
				}
			}, this);
			
			return upgradeItems;
		},
		
		/**
		 * Get Model Attached Stats
		 */
		getModelUpgradesStats: function getModelUpgradesStats(model) {
			model = this.get(model);
			
			if (!(model instanceof APP.Model.Item)) {
				throw new Error('Invalid Model "' + model + '"');
			}
			
			var upgradeItems = this.getModelUpgradeItems(model, true),
				upgradeStats = {};
			
			// Loop over each attached item
			_.forEach(upgradeItems, function (model) {
				if (model) {
					var stats = model.getStats();
					
					// Loop over each stat
					_.forEach(stats, function (stat, key) {
						if (!upgradeStats.hasOwnProperty(key)) {
							upgradeStats[key] = [];
						}
						upgradeStats[key].push(stat);
					});
				}
			}, this);
			
			return upgradeStats;
		},
		
		/**
		 * Get Model Stats
		 */
		getModelStats: function getModelStatsItemsCollection(model) {
			model = this.get(model);
			
			if (!(model instanceof APP.Model.Item)) {
				throw new Error('Invalid Model "' + model + '"');
			}
			
			var baseStats = model.getStats(),
				one2oneStats = [ 'damage', 'accuracy', 'range' ],
				stats = {};
			
			// Damage (damage)
			if (baseStats.hasOwnProperty('damage')) {
				stats.damage = {
					base: APP.sidis.trans('WEB_GAME_STAT_DAMAGE_LEVEL_' + baseStats.damage)
				};
			}
			
			// Accuracy (accuracy)
			if (baseStats.hasOwnProperty('accuracy')) {
				stats.accuracy = {
					base: APP.sidis.trans('WEB_GAME_STAT_ACCURACY_LEVEL_' + baseStats.accuracy)
				};
			}
			
			// AMMO (ammo, mags)
			if (baseStats.hasOwnProperty('ammo') || baseStats.hasOwnProperty('mags')) {
				stats.ammo = { base: [] };
				if (baseStats.hasOwnProperty('ammo')) {
					stats.ammo.base.push(baseStats.ammo);
				}
				if (baseStats.hasOwnProperty('mags')) {
					stats.ammo.base.push(baseStats.mags);
				}
				stats.ammo.base = stats.ammo.base.join('/');
			}
			
			// Range
			if (baseStats.hasOwnProperty('range')) {
				stats.range = {
					base: APP.sidis.trans('WEB_GAME_STAT_ACCURACY_LEVEL_' + baseStats.range)
				};
			}
			
			// ROF
			if (baseStats.hasOwnProperty('rof') || baseStats.hasOwnProperty('action')) {
				stats.rof = { base: [] };
				if (baseStats.hasOwnProperty('rof')) {
					stats.rof.base.push(APP.sidis.trans('WEB_GAME_STAT_ROF_LEVEL_' + baseStats.rof));
				}
				if (baseStats.hasOwnProperty('action')) {
					stats.rof.base.push(APP.sidis.trans('WEB_GAME_STAT_ACTION_LEVEL_' + baseStats.action));
				}
				stats.rof.base = stats.rof.base.join(' ');
			}
			
			// Zoom
			if (baseStats.hasOwnProperty('zoom')) {
				stats.zoom = {
					base: APP.sidis.trans('WEB_GAME_STAT_ZOOM_LEVEL_' + baseStats.zoom)
				};
			}
			
			if (model.hasAttachments()) {
				_.forEach(this.getModelAttachedItems(model, true), function (attachmentModel, slot) {
					var attachedStats = attachmentModel ? attachmentModel.getStats() : [];
				
					_.forEach(attachedStats, function (value, key) {
						var statKey,
							statValue;
						
						// Simole on 2 one stats
						if (_.indexOf(one2oneStats, key) !== -1) {
							statKey = key;
							statValue = value;
							
						// Ammo
						} else if (key === 'ammo') {
							statKey = 'ammo';
							statValue = APP.sidis.transChoice('WEB_GAME_STAT_AMMO_MODS', value, { '%count%': value });
						
						// Mags
						} else if (key === 'mags') {
							statKey = 'ammo';
							statValue = APP.sidis.transChoice('WEB_GAME_STAT_MAGS_MODS', value, { '%count%': value });
							
						// ROF
						} else if (key === 'rof') {
							statKey = 'rof';
							statValue = APP.sidis.trans('WEB_GAME_STAT_ROF_LEVEL_' + value);
						
						// Action
						} else if (key === 'action') {
							statKey = 'rof';
							statValue = APP.sidis.trans('WEB_GAME_STAT_ACTION_LEVEL_' + value);
						
						// Zoom
						} else if (key === 'zoom') {
							statKey = 'zoom';
							statValue = APP.sidis.trans('WEB_GAME_STAT_ZOOM_LEVEL_' + value);
							// Set as base scope
							stats[statKey] = {
								base: statValue
							};
						}
						
						if (statKey && statValue && !attachmentModel.isDefault()) {
							// Fix missing stats properties
							if (!stats.hasOwnProperty(statKey)) {
								stats[statKey] = { mods: [] };
							} else if (!stats[statKey].hasOwnProperty('mods')) {
								stats[statKey].mods = [];
							}
							stats[statKey].mods.push(statValue);
						}
					});
				});
			
			} /*else if (model.hasUpgrades()) {
				
			}*/
			
			return stats;
		},
		getStats: function getStats() {
			APP.log.warn('Use APP.Collection.Items::getModelStats instead of APP.Collection.Items::getStats');
			return this.getModelStats.apply(this, arguments);
		},
		
		/**
		 * Get loadout array by type
		 */
		getLoadout: function getLoadoutItemsCollection(itemType) {
			itemType = itemType || this.itemType;
			
			var ids = [],
				model,
				i;
			
			// Attachment
			if (itemType === 'attachment') {
				ids = {};
				
				this.getEquipped('weapon').forEach(function eachWeapon(model) {
					if (model.isCustomizable()) {
						ids[model.id] = model.get('attachments');
					}
				}, this);
				
				return ids;
				
			// Upgrades
			} else if (itemType === 'upgrade') {
				ids = {};
				
				this.getEquipped('appearance').forEach(function eachAppearance(model) {
					if (model.isCustomizable()) {
						ids[model.id] = model.get('upgrades');
					}
				}, this);
				
				return ids;
			
			// Weapon
			} else if (itemType === 'weapon') {
				for (i = 0; i < 10; i += 1) {
					model = this.bySlot(itemType, i);
					ids.push(model ? model.id : 0);
				}
				return ids;
				
			// Appearance
			} else if (itemType === 'appearance') {
				for (i = 0; i < 5; i += 1) {
					model = this.bySlot(itemType, i);
					ids.push(model ? model.id : 0);
				}
				return ids;
			
			// Booster
			} else if (itemType === 'booster') {
				return this.filter(function (model) {
					return model.isItemType('booster') && model.isOwned();
				});
			}
			
			return [];
		},
		
		/**
		 * Get Equipped Customizations
		 */
		getEquippedCustomizations: function (options) {
			var customizations = _.unique(_.compact(_.flatten(this.filterBy({
					isEquipped: true,
					hasCustomizations: true
				}).map(function (model) {
					return _.values(model.getCustomizations());
				}))));
			
			return new this.constructor(customizations, options);
		},
		
		
		/**
		 * Get 
		 * @return {*}
		 */
		
		/**
		 * Validate Loadout
		 *
		 * @returns {true|Error}
		 */
		validateLoadout: function validateLoadoutItemsCollection() {
			var collection = this,
				equipped = new this.constructor(this.filter(function filterEquipped(model) {
					return model.isEquipped() && model.get('itemType') !== 'booster';
				})),
				extraWeaponSlotModelId = 7000,
				extraWeaponSlotModel = this.get(extraWeaponSlotModelId),
				primaryCount = 1,
				err;
			
			if (extraWeaponSlotModel && extraWeaponSlotModel.get('owned')) {
				primaryCount = 2;
			}

			// Invalid item or items
			if (equipped.by('validationGroup', 'primary').length === 0) {
				err = new Error('WEB_GAME_DOCK_ERROR_5017');
				err.name = 'PrimaryError';
				return err;
			} else if (equipped.by('validationGroup', 'primary').length > primaryCount) {
				err = new Error('WEB_GAME_DOCK_ERROR_5018');
				err.name = 'PrimaryError';
				return err;
			}
			
			
			// Unbought
			if (equipped.some(function findUnboughtItems(model) {
					if (!model.get('owned')) {
						return true;
					}
					
					// Attchments Owned
					if (model.hasInvalidCustomizations()) {
						return true;
					}
					
					return false;
				})) {
				err = new Error('Unbought items');
				err.name = 'UnboughtError';
				return err;
			}
			
			// Expired
			if (equipped.some(function findExpiredItems(model) {
					if (model.get('expired')) {
						return true;
					}
					
					// Attchments Expired
					if (model.isCustomizable() && _.some(model.get('attachments'), function findExpiredAttachments(id) {
							var attachmentModel = collection.get(id);
							return (attachmentModel && attachmentModel.get('expired'));
						})) {
						return true;
					}
					
					return false;
				})) {
				err = new Error('Expired items');
				err.name = 'ExpiredError';
				return err;
			}
			
			// Empty usecount
			if (equipped.some(function findEmptyUsecountItems(model) {
					return (model.isConsumable() && !model.get('usecount'));
				})) {
				err = new Error('Empty usecount');
				err.name = 'UsecountError';
				return err;
			}
			
			return null;
		}
	});
	
	/**
	 * Module support
	 */
	if (typeof module !== 'undefined' && module.exports) {
		module.exports = APP.Collection.Items;
	}
}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule items
 */
(function (root) {
	"use strict";
	
	
	var APP = root.APP,
		win = APP.win,
		$ = APP.$,
		_ = APP._;
	
	/**
	 * Item View
	 */
	APP.View.Item = APP.View.extend({
		name: 'item-view',
		tagName: 'div',
		
		options: {
			showName: true,
			showIcons: true,
			showAdditional: true,
			showLock: true,
			live: true
		},
		
		events: {
			'mouseenter a.buy': function (e) {
				this.sound('hover');
				this.trigger('buy:enter', this, this.model, e);
			},
			'mouseleave a.buy': function (e) {
				this.trigger('buy:leave', this, this.model, e);
			},
			'click a.buy, a.unlock': function (e) {
				e.preventDefault();
				e.stopImmediatePropagation();
				this.sound('click');
				this.trigger('buy', this, this.model, e);
			},
			'click': function (e) {
				e.preventDefault();
				this.sound('click');
				this.trigger('click', this, this.model, e);
			},
			'mouseenter': function (e) {
				this.sound('hover');
				this.trigger('enter', this, this.model, e);
			},
			'mouseleave': function (e) {
				this.trigger('leave', this, this.model, e);
			}
		},
		
		initialize: function initializeItemView() {
			// TODO: Make sure we don't rely on this "magic" binding
			_.bindAll(this);
			
			if (this.options.live) {
				this.model.bind('change', this._onChange, this);
			}
			
			this.$el.data('id', this.model.id);
			
			this.model.bind('heartbeat', this.render, this);
			
			this.model.bind('purchase:start', this._onPurchaseStart, this);
			this.model.bind('purchase:end', this._onPurchaseEnd, this);
		},
		
		destroy: function destroyItemView() {
			this.model.unbind('change', this.render, this);
			this.model.unbind('purchase:start', this._onPurchaseStart, this);
			this.model.unbind('purchase:end', this._onPurchaseEnd, this);
			return this;
		},
		
		_onChange: function _onChangeItemView() {
			
			var reRenderOnAttrs = [
					'expired',
					'owned',
					'buyable',
					'usecount',
					'isLocked'
				],
				reRender = _.some(reRenderOnAttrs, function (attr) {
					return this.model.hasChanged(attr);
				}, this);
			
			// Only re-render if it's worth it :D
			if (reRender) {
				this.render();
			}
		},
		
		_onPurchaseStart: function _onPurchaseStartItemView() {
			this.$el.addClass('loading');
		},
		
		_onPurchaseEnd: function _onPurchaseEndItemView() {
			this.$el.removeClass('loading');
		},
		
		dragHelper: function (e) {
			var $el = $('<span />').attr({
					'class': 'item item-drag game-item item-min item-min-' + this.model.id
				});
			
			return $el;
		},
		
		/**
		 * Render Lock
		 */
		renderLock: function renderLockItemView() {
			
			var nsConfig = APP.ns('config'),
                type = this.trans('WEB_GAME_LOCK_TYPE_' + this.model.get('lockType').toUpperCase()),
                criteria = this.model.get('lockCriteria'),
				lock = this.make('div', {
					'class': 'lock ' + type
				}),
				progressImage = nsConfig.imageFolder + 'game/item-lock-progress.png',
				progress = this.model.get('lockProgress'),
				canvas = win.progressCircle(progressImage, progress, {
					width: 32,
					height: 32,
					lineWidth: 5,
					duration: 500
				});
			
			lock.appendChild(this.make('span', {
				'class': 'key'
			}, criteria));
			
			lock.appendChild(canvas);
			this.el.appendChild(lock);
			
			return this;
		},
		
		
		/**
		 * Rener Item View
		 */
		render: function renderItemView() {
			
			/**
			 * Reset class names
			 */
			this.$el.addClass('item tier' + (this.model.get('tier') || 0) + ' ' + this.model.get('validationGroup'));
			
			/**
			 * Icon
			 */
			// Appparane items have a sprite
			if (this.model.isItemType('appearance')) {
				this.el.appendChild(this.make('span', {
					'class': 'game-item item-min item-min-' + this.model.id,
					'item-id': this.model.id
				}));
				
			// Others use a image
			} else {
				this.el.appendChild(this.make('img', {
					'src': this.model.getImage('min'),
					'width': 80,
					'height': 60,
					'class': 'game-item item-min item-min-' + this.model.id,
					'item-id': this.model.id
				}));
			}
			
			
			/**
			 * Show name
			 */
			if (this.options.showName) {
				// Append
				this.el.appendChild(this.make('span', {
					'class': 'name'
				}, this.model.get('name')));
			}
			
			
			/**
			 * Locked
			 */
			if (this.model.isLocked()) {
				if (!this.model.isOwned()) {
					this.$el.addClass('locked');
				}
				if (this.options.showLock) {
					this.renderLock();
					this.$el.disableTextSelect();
				}
			}
			
			/**
			 * Show additional
			 */
			if (this.options.showIcons) {
				// Rented
				if (this.model.isRented()) {
					this.$el.addClass('rented');
					
				// Expired
				} else if (this.model.isExpired()) {
					this.$el.addClass('expired');
				}
				
				// Is new
				if (this.model.get('isnew')) {
					this.$el.addClass('new');
					this.$el.append('<span class="new_item_icon">' + APP.sidis.trans('WEB_STORE_COMMON_NEW') + '</span>');
				}
				
				// Low use count
				if (this.model.get('owned') && this.model.get('type') === 'gadgets' && this.model.get('usecount') < 10) {
					if (!this.model.get('usecount')) {
						this.$el.addClass('no-usecount');
					} else {
						this.$el.addClass('low-usecount');
					}
				}
				
				// Locked
				if (this.model.isLocked()) {
					if (this.model.get('offers').hasUnlockOffers()) {
						this.$el.append('<a href="#unlock" class="icon unlock" />');
					} else {
						this.$el.append('<a href="#lock" class="icon lock" />');
					}
					
				// Buy
				} else if (this.model.isBuyable()) {
					this.$el.addClass('buyable');
					this.$el.append('<a href="#buy" class="icon buy"></a>');
				}
			}
			
			// Return this for chaining
			return this;
		}
	});
}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule items
 */
(function (win) {
	"use strict";
	
	
	var APP = win.APP,
		$ = APP.$,
		_ = APP._,
		nsConfig = APP.namespace('config'),
		parent = APP.View.Tooltip.prototype;
	
	/**
	 * Item Error View
	 */
	APP.View.ItemErrorTooltip = APP.View.Tooltip.extend({
		className: 'item-error-tooltip',
		render: function renderItemErrorTooltipView(model) {
			
			var html = [];
			
			// Expired
			
			
			this.$el.html(html.join(''));
		}
	});
}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule items
 */
(function (win) {
	"use strict";
	
	
	var APP = win.APP, 
		$ = APP.$, 
		_ = APP._, 
		doc = APP.doc, 
		parent = APP.View.DnD.prototype, 
		nsConfig = APP.namespace('config'), 
		ITEM_CLASS_NAME = 'item-list-view-item'; 
	
	/**
	 * Item List View
	 */
	APP.View.ItemList = APP.View.DnD.extend({
		name: 'item-list-view',
		tagName: 'ul',
		options: _.extend({}, parent.options, {
			selectedClassName: 'showing',
			drag: 'li.item-list-view-item:not(.locked)',
			viewClass: 'Item'
		}),
		dragOptions: _.extend({}, parent.dragOptions, {
			revert: 'invalid'
		}),
		events: {},
		
		/**
		 * Initialize view
		 */
		initialize: function initializeItemListView() {
			
			// Inital filtering
			this.filterCollection();
			
			// On Drag Start
			this.bind('drag:start', this._onDragStart, this);
			
			// On Drag Stop
			this.bind('drag:stop', this._onDragStop, this);
			
			// On Item Render
			this.bind('item:render', this._onItemRender, this);
			
			this.collection.bind('reset', this._onCollectionReset, this);
			this.collection.bind('add', this._onCollectionAdd, this);
			this.collection.bind('remove', this._onCollectionRemove, this);
			this.collection.bind('change', this._onCollectionChange, this);
		},
		
		destroy: function destroy() {
			this.collection.unbind('reset', this.onCollectionReset, this);
			this.collection.unbind('add', this.onCollectionAdd, this);
			this.collection.unbind('remove', this.onCollectionRemove, this);
			this.collection.unbind('change', this.onCollectionChange, this);
			return this;
		},
		
		_onDragStart: function _onDragStartItemListView(model, ui, el) {
			// TODO: There should be a better way to check it are "fake" dragging
			if (ui.helper.get(0).className !== '') {
				$(el).addClass('dragging');
				this.sound('equip');
			}
		},
		
		_onDragStop: function _onDragStopItemListView(model, ui, el) {
			$(el).removeClass('dragging').addClass('drag-delay').delay(200).removeClass('drag-delay');
			
			this.sound('unequip');
		},
		
		_onItemRender: function _onItemRenderItemListView(itemView) {
			if (itemView && itemView.model === this._selected) {
				itemView.$el.addClass(this.options.selectedClassName);
			}
		},
		
		_onCollectionReset: function _onCollectionResetListView() {
			this.filterCollection();
			this.render();
		},
		
		_onCollectionAdd: function _onCollectionAddListView(model) {
			// Should be in collection but is not
			if (this.collection.filterBy(this._currentFilter).indexOf(model) !== -1) {
				this.appendViewByModel(model).select();
			}
		},
		
		_onCollectionRemove: function _onCollectionRemoveListView(model) {
			// 
			if (this._currentCollection.indexOf(model) !== -1) {
				this.removeViewByModel(model);
			}
		},
		
		_onCollectionChange: function _onCollectionChangeListView(model) {
			var oldIndex = this._currentCollection.indexOf(model),
				newIndex = this.collection.filterBy(this._currentFilter).indexOf(model),
				itemViewEl;
			
			// Model was in view but removed
			if (oldIndex !== -1 && newIndex === -1) {
				this.removeViewByModel(model);
				
			// Model was not in view and has been added
			} else if (oldIndex === -1 && newIndex !== -1) {
				this.appendViewByModel(model).select();
			}
		},
		
		removeViewByModel: function removeViewByModelItemListView(model, options) {
			if (!this.$items) {
				return this;
			}
			
			var $itemViewEl = this.$items.eq(this._currentCollection.indexOf(model)),
				view = this.getView($itemViewEl);
			
			if (!view) {
				APP.log.warn('Unable to get view for', $itemViewEl);
			}
			
			$itemViewEl.remove();
			
			this.$items = this.$items.not($itemViewEl);
			
			this._currentCollection.remove(model);
			
			this.destroyView(view);
			
			if (!options || !options.silent) {
				this.trigger('remove', this, model);
			}
			
			return this;
		},
		
		appendViewByModel: function appendViewByModelItemListView(model, options) {
			if (!this.$items) {
				return this;
			}
			
			var itemViewEl = this.renderItem(model);
			
			this.$items = this.$items.add(itemViewEl);
			
			this.initializeDragAndDrop();
			
			this._currentCollection.add(model, {
				at: this._currentCollection.length
			});
			
			if (!options || !options.silent) {
				this.trigger('append', this, model);
			}
			
			return this;
		},
		
		/**
		 * Get the corresponding model from a DOM element
		 */
		getModelFromDOM: function getModelFromDOMItemListView(el) {
			var $el = this.$(el),
				id = $el.attr('item-id') || $el.data('id'),
				model = this.collection.get(id);
			
			return model;
		},
		
		
		/**
		 * Get the corresponding model from a DOM element
		 */
		getElementByModel: function getElementByModelItemListView(id) {
			if (!this.$items) {
				return this;
			}
			
			var model = this._currentCollection.get(id),
				index = this._currentCollection.indexOf(model),
				el;
				
			if (model && index !== -1) {
				el = this.$items.eq(index);
			}
			
			return el;
		},
		
		/**
		 * Get collection
		 */
		filterCollection: function filterCollectionItemListView(filter) {
			this._currentFilter = _.extend({}, filter || this._currentFilter || {}, this.options.filter || {});
			
			this._currentCollection = this.collection.filterBy(this._currentFilter);
			
			// Order by
			if (this.options.orderBy) {
				this._currentCollection = this._currentCollection.orderBy(this.options.orderBy);
			}
			
			// Sort order
			if (this.options.orderDesc) {
				this._currentCollection.comparator = null;
				this._currentCollection.models.reverse();
			}
			
			return this;
		},
		
		/**
		 * Select
		 */
		select: function selectItemListView(model, options) {
			options = options || {};
			
			if (model) {
				this._selected = model;
			}
			
			if (!this.$items) {
				return this;
			}
			
			var i = this._currentCollection.indexOf(this._selected);
			
			this.$items.removeClass(this.options.selectedClassName);
			
			// If model in current collection
			if (i !== -1) {
				this.$items.eq(i).addClass(this.options.selectedClassName);
				
				if (!options.silent) {
					this.trigger('select', this._selected, this.$items.eq(i));
				}
			}
			
			return this;
		},
		
		/**
		 * Deselect
		 */
		deselect: function deselectItemListView(options) {
			options = options || {};
			this.select(-1);
			if (!options.silent) {
				this.trigger('deselect');
			}
			return this;
		},
		
		/**
		 * Scroll To
		 */
		scrollTo: function scrollToItemListView($el) {
			
			// Make sure $el is an element
			if ($el instanceof APP.Model) {
				$el = this.getElementByModel($el);
			}
			
			var	elTop = $el.position().top,
				elHeight = $el.outerHeight(true),
				listTop = this.$el.position().top,
				listHeight = this.$el.outerHeight(),
				offset = elTop - listTop;
			
			if (offset < 0) {
				this.$el.animate({
					scrollTop: this.el.scrollTop - Math.abs(offset) - 5
				}, 200, 'easeOutCirc');
			} else if (offset > (listHeight - elHeight)) {
				this.$el.animate({
					scrollTop: this.el.scrollTop + elHeight - (listHeight - offset)
				}, 200, 'easeOutCirc');
			}
			
			return this;
		},
		
		/** 
		 * Drag Helper 
		 */ 
		dragHelper: function dragHelperItemList(e) { 
			
			var view = this.getViewByElement(e.currentTarget),
				$el;
			
			if (view && view.dragHelper) {
				$el = view.dragHelper(e);
				$el.data('id', view.model.id);
				$el.appendTo(doc.body);
			}
			
			return $el;
		},
		
		renderItem: function renderItemItemListView(model) {
			
			// Create View
			var viewClass = _.isString(this.options.viewClass) ? APP.View[this.options.viewClass] : this.options.viewClass,
				viewOptions = _.extend({}, {
					tagName: 'li',
					className: ITEM_CLASS_NAME, 
					container: this.el,
					model: model
				}, this.options.viewOptions || {}),
				itemView = this.createView(viewClass, viewOptions, 'item');
			
			// Attach
			itemView.attach();
			
			// Render
			itemView.render({
				silent: !this.$items
			});
			
			// Item view root element
			return itemView.el;
		},
		
		/**
		 * Render the view
		 */
		render: function renderItemListView() {
			this.$items = null;
			
			// loop over items
			var items = this._currentCollection.map(this.renderItem, this);
			
			if (items.length === 0) {
				this.$el.addClass('empty');
				
				if (this.options.emptyMessage) {
					this.$el.html(this.options.emptyMessage);
				}
			
			// Bundleinfo items are shrunk if too many
			} else if (items.length > 8 && this.$el.hasClass('bundles-item-list-view')) {
				this.$el.addClass('small');
			}
			
			// Get all the items for future reference
			this.$items = this.$(items);
			
			this.select(null, {'silent': true});
			
			// Enable Select
			this.$('img').enableTextSelect();
		}
	}, {
		ITEM_CLASS_NAME: ITEM_CLASS_NAME
	});
	
}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule items
 */
(function (win) {
	"use strict";
	
	
	var APP = win.APP,
		_ = APP._,
		
		STATS_NON_NUMERIC = [
			'DamageLvL',
			'AccuracyLvL',
			'RangeLvL',
			'Zoom'
		],
		STATS_PRE_FORMATED = [
			'ROFLvL',
			'ammo'
		],
		STATS_PLURAL = [ 
			'nrOfMAgs',
			'NrPrimaryWeapon',
			'NrHandGrenade',
			'NrClaymore',
			'MagIncrease',
			'MagSizeIncrease'
		],
		STAT_GROUPS = {
			"DamageLvL"		: "DamageLvL",
			"Damage"		: "DamageLvL",
			"DamageShort"	: "DamageLvL",
			"DamageMed"		: "DamageLvL",
			"DamageLong"	: "DamageLvL",
			
			"AccuracyLvL"	: "AccuracyLvL",
			"Accuracy"		: "AccuracyLvL",
			"AccControl"	: "AccuracyLvL",
			"AccPrecision"	: "AccuracyLvL",
			"AccVelocity"	: "AccuracyLvL",
			
			"ammo"				: "ammo",
			"nrOfMAgs"			: "ammo",
			"MagIncrease"		: "ammo",
			"MagSizeIncrease"	: "ammo",
			
			"RangeLvL"	: "RangeLvL",
			"Range"		: "RangeLvL",
			"RangeShort": "RangeLvL",
			"RangeMed"	: "RangeLvL",
			"RangeLong"	: "RangeLvL",
			
			"ROFLvL"	: "ROFLvL",
			"Action"	: "ROFLvL",
			
			"Zoom"	: "Zoom"
		};

	/**
	 * View stats list
	 */
	APP.View.Stats = APP.View.extend({
		name: 'stats-view',
		
		initialize: function initializeStatsView() {
			this.model.bind('change', this.render, this);
		},
		
		destroy: function destroyStatsView() {
			this.model.unbind('change', this.render, this);
		},
		
		_renderStats: function _renderStatsView(stat, key) {
			var row = this.make('div'),				
				titleWrapper = this.make('div', {
					'class': 'stat-title'
				}),
				title = this.make('div', {
					'class': 'label stat-' + key
				}, key),
				label = this.make('div', {
					'class': 'attachment-label'
				}, stat.base),				
				labelWrapper = this.make('div', {
					'class': 'base'
				}),	
				details = this.make('div', {
					'class': 'stat-details'
				}),
				bestInClass = (this.model.get('isBestInClass') || []).indexOf(key) !== -1;
			
			// Add marker for Best in Class
			if (bestInClass) {
				title.className += ' bic';
				// TODO: Localize
				title.appendChild(this.make('span', {
					'class': 'best-in-class'
				}, this.trans('WEB_GAME_STAT_BEST_IN_CLASS')));
			}
			
			titleWrapper.appendChild(title);
			row.appendChild(titleWrapper);
			labelWrapper.appendChild(label);
			details.appendChild(labelWrapper);
			row.appendChild(details);
			
			// Add stat changes
			if (stat.hasOwnProperty('mods')) {
				titleWrapper.className += ' active';
				if (key !== 'zoom' && stat.mods.length !== 0) {
					details.appendChild(this.make('div', {'class': 'mods'}, _.map(stat.mods, function (mod) {
						var className = 'value';
						if (mod.value < 0) {
							className += ' negative';
						}
						return '<span class="' + className + '">' + mod.text + '</span>';
					}).join(' ')));
				}
			} else {
				label.className += ' empty';
			}
			
            this.el.appendChild(row);
		},
		
		
		/**
		 * Render Weapon Info
		 */
		render: function renderStatsView() {
			var stats = this.model.getStats(),
				customizations = this.model.getCustomizations(),
				customizationStats = {},
				html = [];
			
			_.forEach(this.model.getCustomizations(), function (model) {
				_.forEach((model && model.getStats()) || {}, function (stat, type) {
					var group = STAT_GROUPS[type];
					
					if (!_.has(customizationStats, group)) {
						customizationStats[group] = [];
					}
					
					stat = _.clone(stat);
					stat.type = type;
					
					customizationStats[group].push(stat);
				});
			});
			
			if (this.model.isItemType('weapon')) {
				// ROF & Action
				if (stats.ROFLvL && stats.Action) {
					stats.ROFLvL = {
						value: [
							this.trans('WEB_GAME_STAT_ROFLVL_' + stats.ROFLvL.value),
							this.trans('WEB_GAME_STAT_ACTION_' + stats.Action.value)
						].join(' ')
					};
					delete stats.Action;
				}
				
				// Ammo & Mags
				if (stats.ammo && stats.nrOfMAgs) {
					stats.ammo = {
						value:  stats.ammo.value + '/' + stats.nrOfMAgs.value
					};
					delete stats.nrOfMAgs;
				}
			}
			
			html = _.map(stats, function (stat, key) {
				var group = STAT_GROUPS[key],
					customizationStat = customizationStats[group] || {},
					hasCustomizationStats = !_.isEmpty(customizationStat),
					label,
					value = stat.value,
					html = '';
		
				if (_.indexOf(STATS_PLURAL, key) !== -1) {
					label = this.transChoice('WEB_GAME_STAT_LABEL_' + key.toUpperCase(), value);
				} else {
					label = this.trans('WEB_GAME_STAT_LABEL_' + key.toUpperCase());
				}
				
				// Some stats are not numeric
				if (_.indexOf(STATS_NON_NUMERIC, key) !== -1) {
					value = this.trans('WEB_GAME_STAT_' + key.toUpperCase() + '_' + value);
				}
				
				// Title / Label
				html += '<div class="stat-title' + (hasCustomizationStats ? ' active' : '') + '">';
				html += '<div class="label stats stat-' + key + '">' + label + '</div>';
				html += '</div>';
				
				
				// Details
				html += '<div class="stat-details">';
				
				// Base value
				html += '<div class="base"><div class="attachment-label">' + value + '</div></div>';
				
				// Mods / customization stat
				if (hasCustomizationStats) {
					html += '<div class="mods">';
					html += _.map(customizationStat, function (stat) {
						
						var value = stat.value,
							label;
						
						if (_.indexOf(STATS_PLURAL, stat.type) !== -1) {
							label = this.transChoice('WEB_GAME_STAT_LABEL_' + stat.type.toUpperCase(), value);
						} else {
							label = this.trans('WEB_GAME_STAT_LABEL_' + stat.type.toUpperCase());
						}
						
						// Prepend a plus sign to values over zero
						if (value > 0) {
							value = '+' + value;
						}
						
						// Append a percentage sign if needed
						if (stat.isPercent) {
							value += '%';
						}
						
						return '<span class="value' + (stat.isPenalty ? ' penalty' : '') + '">' + label + ' ' + value + '</span>';
					}, this).join('');
					html += '</div>';
				}
				
				html += '</div>';
				
				return '<div>' + html + '</div>';
			}, this).join('');
			
			
			this.el.innerHTML = html;
		}
	});
}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule items
 */
(function (root) {
	"use strict";
	
	
	var APP = root.APP,
		_ = APP._,
		
		NON_NUMERIC_STATS = [
			'DamageLvL', 
			'AccuracyLvL',
			'RangeLvL',
			'Zoom'
		],
		PRE_FORMATED_STATS = [
			'ROFLvL',
			'ammo'
		],
		PLURAL_STATS = [
			'nrOfMAgs',
			'MagIncrease',
			'MagSizeIncrease'
		];
	
	APP.View.StatsList = APP.View.extend({
		name: 'stats-list-view',
		tagName: 'ul',
		
		
		/**
		 * Initialize
		 */
		initialize: function initializeStatsListView() {
			
		},
		
		
		/**
		 * Destroy
		 */
		destroy: function destroyStatsListView() {
			
		},
		
		
		/**
		 * Render
		 */
		render: function renderStatsListView() {
			if (this.model.hasStats()) {
				
				var stats = _.clone(this.model.get('stats') || {}),
					isWeapon = this.model.isItemType('weapon'),
					html;
				
				if (isWeapon) {
					// ROF & Action
					stats.ROFLvL = {
						value: [
							this.trans('WEB_GAME_STAT_ROFLVL_' + stats.ROFLvL.value),
							this.trans('WEB_GAME_STAT_ACTION_' + stats.Action.value)
						].join(' ')
					};
					delete stats.Action;
					
					// Ammo & Mags
					stats.ammo = {
						value:  stats.ammo.value + '/' + stats.nrOfMAgs.value
					};
					delete stats.nrOfMAgs;
				}
				
				// Loop over stats
				html = _.map(stats, function (stat, key) {
					
					var value = stat.value,
						label,
						className = 'stats stat-' + key,
						html;
					
					
					if (_.indexOf(PLURAL_STATS, key) !== -1) {
						label = this.transChoice('WEB_GAME_STAT_LABEL_' + key.toUpperCase(), value);
					} else {
						label = this.trans('WEB_GAME_STAT_LABEL_' + key.toUpperCase());
					}
					
					// Some stats are not numeric
					if (_.indexOf(NON_NUMERIC_STATS, key) !== -1) {
						label = this.trans('WEB_GAME_STAT_' + key.toUpperCase() + '_' + value);
						value = null;
					
					// ROF & ammo
					} else if (_.indexOf(PRE_FORMATED_STATS, key) !== -1) {
						label = value;
						value = null;
					
					// Prepend a plus sign to values over zero
					} else if (!isWeapon && value > 0) {
						value = '+' + value;
					}
					
					// Append a percentage sign if needed
					if (stat.isPercent) {
						value += '%';
					}
					
					// Is penalty
					if (stat.isPenalty) {
						className += ' penalty';
					}
					
					// Is best in class
					if (stat.bestInClass) {
						className += ' best-in-class';
					}
					
					html = '<li class="' + className + '">';
					if (label) {
						html += label;
					}
					if (value) {
						html += '<span class="value">' + value + '</span>';
					}
					html += '</li>';
					
					return html;
				}, this).join('');
				
				this.el.innerHTML = html;
				
			}
		}
	});
}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule items
 */
(function (win) {
	"use strict";
	
	
	var APP = win.APP,
		$ = APP.$,
		_ = APP._,
		nsConfig = APP.namespace('config'),
		parent = APP.View.Tooltip.prototype;
	
	/**
	 * Purchase View
	 */
	APP.View.StatsTooltip = APP.View.Tooltip.extend({
		className: 'stats-tooltip',
		renderModelAndShow: function renderModelAndShow(model, el) {
			return this.renderModel(model).show(el);
		},
		renderModel: function renderModelStatsTooltipView(model) {
			this.model = model;
			return this.render();
		},
		render: function renderStatsTooltipView() {
			
			this.createView(APP.View.Stats, {'model': this.model}).render().attach();
			
		}
	});
}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule items
 */
(function (win) {
	"use strict";
	
	
	var APP = win.APP,
		$ = APP.$,
		_ = APP._,
		nsConfig = APP.namespace('config'),
		parent = APP.View.Tooltip.prototype;
	
	
	/**
	 * Item tooltip view
	 */
	APP.View.ItemTooltip = APP.View.Tooltip.extend({
		className: 'item-tooltip',
		/**
		 * Render Model and Show
		 * @param {ItemModel} model
		 * @param {DOMElement} el
		 * @param {Object} options
		 * @return {*}
		 */
		renderModelAndShow: function renderModelAndShowItemTooltipView(model, el, options) {
			return this.renderModel(model, options).show(el);
		},
		/**
		 * Render model
		 * @param {ItemModel} model
		 * @param {Object} options
		 * @return {*}
		 */
		renderModel: function renderModelStatsItemTooltipView(model, options) {
			this.model = model;
			return this.render(options);
		},
		/**
		 * Render
		 * @param {Object} options
		 */
		render: function renderStatsItemTooltipView(options) {
						
			options = _.defaults(options || {}, {
				name		: false,
				description	: false,
				dependencies: false,
				stats		: false,
				slots		: false,
				offers		: false,
				uses		: false,
				time		: false,
				invalid		: false
			});
			
			
			var html = [],
				name,
				categoryName,
				description,
				dependencies,
				usecount,
				className;
			
			
			// Name
			if (options.name) {
				html.push('<h1>');
				html.push(this.model.get('name'));
				
				categoryName = this.model.get('categoryname');
				if (categoryName) {
					html.push('<span>' + categoryName + '</span>');
				}
				
				html.push('</h1>');
			}
			
			
			// Description
			if (options.description) {
				description = this.model.get('description');
				if (description) {
					html.push('<p class="description">' + this.model.get('description') + '</p>');
				}
			}
			
			
			// Stats
			if (options.stats) {
				html.push(this.createView(APP.View.StatsList, {
					model: this.model
				}).render().el.outerHTML);
			}
			
			
			// Dependencies
			if (options.dependencies) {
				
				dependencies = this.model.getDependencies();
				if (dependencies.gear && dependencies.gear.isOwned()) {
					html.push('<div class="dependency booster">');

                    // TODO: Localize
					html.push('<h3>' + this.trans('Booster interference') + '</h3>');
					html.push(dependencies.gear.get('name'));
					html.push('<span>' + dependencies.gear.getExpireText() + '</span>'); 
					html.push('</div>');
				} else if (dependencies.ability && dependencies.ability.get('level') === 0) {					
					html.push('<div class="dependency ability">');
                    
                    // TODO: Localize
					html.push('<h3>' + this.trans('Training requirement') + '</h3>');
					html.push(dependencies.ability.get('name'));
					html.push('</div>');
				}
			}
			
			
			// Slots
			if (options.slots && this.model.isCustomizable()) {
				if (this.model.isItemType('weapon')) {
					html.push(this.createView(APP.View.WeaponSlots, {
						model: this.model
					}).render().el.outerHTML);
				} else if (this.model.isItemType('appearance')) {
					html.push(this.createView(APP.View.AppearanceSlots, {
						model: this.model
					}).render().el.outerHTML);
				}
			}
			
			
			// Time - Rented/expired
			if (options.time) {
				// Rented
				if (this.model.isRented()) {
					html.push('<p class="rented">' + this.model.getExpireText() + '</p>');
					
				// Expired
				} else if (this.model.isExpired()) {
					html.push('<p class="expired">' + this.model.getExpireText() + '</p>');
				}
			}
			
			// Invalid
			if (options.invalid && this.model.hasInvalidCustomizations()) {
				html.push('<p class="invalid">' + this.trans('WEB_GAME_ITEM_INVALID_CUSTOMIZATIONS') + '</p>');
			}
			
			
			// Offers
			if (options.offers) {
				// Is Locked
				if (this.model.isLocked()) {
					this.$el.addClass('locked');
					
					html.push('<h3>' + this.trans('WEB_GAME_PURCHASE_ITEM_LOCKED') + '</h3>');
					
					html.push('<div class="lock-progress">');
					html.push('<span class="bar" style="width: ' + Math.round(100 - (100 * this.model.get('lockProgress'))) + '%;"></span>');
					html.push('<span class="text">' + this.trans('WEB_GAME_LOCK_TYPE_' + this.model.get('lockType').toUpperCase()) + ' ' + this.model.get('lockCriteria') + '</span>');
					html.push('</div>');
					
					if (this.model.get('offers').hasUnlockOffers()) {
						html.push('<h3>' + this.trans('WEB_GAME_PURCHASE_UNLOCK_OPTIONS') + '</h3>');
						html.push('<dl class="prices">');
						this.model.get('offers').filterBy({
							'isUnlockOffer': true
						}).forEach(function (model) {
							var limit = model.get('limit') || '';
							html.push('<dt>' + limit + '</dt>');
							html.push('<dd class="' + model.get('currency') + '">' + model.get('price') + '</dd>');
						});
						html.push('</dl>');
					}
					
				// Show prices
				} else if (this.model.isBuyable()) {
					html.push('<h3>' + this.trans('WEB_GAME_PURCHASE_OPTIONS') + '</h3>');
					html.push('<dl class="prices">');
					this.model.get('offers').filterBy({
						'isUnlockOffer': false
					}).forEach(function (model) {
						var limit = model.get('limit') || '';
						html.push('<dt>' + limit + '</dt>');
						html.push('<dd class="' + model.get('currency') + '">' + model.get('price') + '</dd>');
					});
					html.push('</dl>');
				}
			}
			
			
			// Uses
			if (options.uses && this.model.isConsumable()) {
				usecount = this.model.get('usecount');
				className = 'usecount';
				
				if (usecount === 0) {
					className += ' empty';
				} else if (usecount < 10) {
					className += ' low'; 
				}
				
				html.push('<p class="' + className + '">' + this.trans('WEB_GAME_ITEM_USES_LEFT') + ' ' + usecount + '</p>');
			}


			// Custom text
			if (options.customText) {
				html.push('<p class="custom">' + options.customText + '</p>');
			}
			
			
			this.el.innerHTML = html.join('');
		}
	});
}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule items
 */
/**
 * @class GAME.Task.items
 * @uses GAME.Task.abilities
 * @uses GAME.Task.sidis
 */
APP.domTask('items', [ 'abilities', 'sidis' ], function initializeItems(done) {
	"use strict";
	
	var win = APP.win,
		_ = APP._,
		$ = APP.$,
		
		backend = {
		// 	weapon: {
		// 		url: 'http://battlefield.play4free.com/game/getWeaponsJson',
		// 		key: 'weapons'
		// 	},
		// 	appearance: {
		// 		url: 'http://battlefield.play4free.com/game/getApparelJson',
		// 		key: 'apparel'
		// 	},
		// 	bundle: {
		// 		url: 'http://battlefield.play4free.com/game/getBundlesJson',
		// 		key: 'bundles'
		// 	},
		// 	booster: {
		// 		url: 'http://battlefield.play4free.com/game/getBoostersJson',
		// 		key: 'boosters'
		// 	},
		// 	attachment: {
		// 		url: 'http://battlefield.play4free.com/game/getAttachmentsJson',
		// 		key: 'attachments'
		// 	}/*,
		// 	http://battlefield.play4free.com/
		// 	upgrades: {
		// 		url: langPath + '/game/getItemUpgradesJson',
		// 		//url: 'http://battlefield.play4free.com/static/inserts.json',
		// 		key: 'upgrades'
		// 	}
		// 	*/
		},
		
		nsItems = APP.ns('items'),
		nsConfig = APP.ns('config'),
		
		
		/**
		 * Create the "top" items collection
		 */
		collection = nsItems.collection = new APP.Collection.Items(),
		
		
		/**
		 * Get Offer By Offer Id
		 */
		getOfferByOfferId = nsItems.getOfferByOfferId = function (offerId, fn) {
			_.defer(function () {
				
				var offer;
				
				collection.some(function (model) {
					var offers = model.get('offers');
					return (offer = offer.get(offerId));
				});
				
				if (offer) {
					fn(null, offer);
				} else {
					fn(new Error('Unable to get offer for offerId: ' + offerId));
				}
			});
		},
		
		
		/**
		 * Get Items By Offer
		 */
		getItemByOfferId = nsItems.getItemByOfferId = function (offerId, fn) {
			
			if (offerId.match(/^[0-9]+$/)) {
				offerId = 'OFB-BP4F:' + offerId;
			}
			
			$.ajax({
				url: nsConfig.getItemByOfferUrl + offerId,
				cache: false,
				success: function onSuccess(response) {
					if (response && response.status === 'success' && response.data.item) {
						
						var item = response.data.item,
							itemId = item.id,
							model = collection.get(itemId),
							offers = new APP.Collection.Offers(item.prices);
						
						if (model) {
							fn(null, model, offers);
						} else {
							fn(new Error('Unable to get item for offerId: ' + offerId));
						}
					} else {
						fn(new Error('Unable to get item for offerId: ' + offerId));
					}
				},
				error: function onError() {
					fn(new Error('Unable to get item for offerId: ' + offerId));
				}
			});
		},
		
		
		/**
		 * Request
		 */
		request = function request(url, fn) {
			console.log(url);
			$.ajax({
				"url": url,
				dataType: 'json',
				cache: false,
				error: function onError(xhr, status, err) {
					fn(err);
				},
				success: function onSuccess(res) {
					if (res && res.status === 'success') {
						fn(null, res.data);
					} else {
						fn(new Error('Request failed!'));
					}
				}
			});
		},
		
		
		/**
		 * Load Items
		 */
		loadItems = function loadItems(fn) {
			
			fn = _.once(fn);
			
			var counter = 0,
				total = 0,
				items = [],
				makeDone = function makeDone(key) {
					total += 1;
					return function isDone(err, res) {
						counter += 1;
						if (err) {
							counter = total * total;
							return fn(err);
						}
						
						var data = res[key];
						
						// 
						items = _.union(items, data);
						
						// Dummy Training Point item
						if (counter === total) {
							items.push({
								'id': 'tp',
								'name': APP.sidis.trans('WEB_STORE_ABILITIES_BUY_POINTS_TITLE'),
								'prices': nsItems.trainingPointOffers,
								'extraPointsPurchased': nsItems.extraPointsPurchased,
								'extraPointsMax': nsItems.extraPointsMax,
								'trainingPointsEarned': nsConfig.soldierLevel - 1, 
								'trainingPointsCurrent': nsItems.trainingPointsCurrent,
								'type': 'trainingpoint'
							});
							
							fn(null, items);
						}
					};
				};
			
			// Loop over each end point and request the data
			_.forEach(backend, function eachEndPoint(cfg) {
				var callback = makeDone(cfg.key);
				
				request(cfg.url, callback);
			});
		},
		
		
		/**
		 * Create Refresh Listener
		 */
		createRefreshListener = function createRefreshListener(type) {
			return function onRefresh(fn) {
				var cfg = backend[type];
				
				request(cfg.url, function onRequestResponse(err, response) {
					
					if (err) {
						if (fn) {
							fn(err);
						} else {
							APP.log.warn(err);
						}
						return false;
					}
					
					var key = cfg.key,
						items = response[key] || [],
						collection = new APP.Collection.Items(items);
					
					collection.unsetAll('equippedSlot');
					
					nsItems.collection.updateOrRemove(collection, {
						itemType: type
					});
					
					// Ensure attachments are valid
					nsItems.collection.invoke('_processCustomizations');
					
					// Trigger refreshed
					if (fn) {
						fn();
					} else {
						nsItems.trigger('refreshed:' + key);
					}
				});
			};
		},
		
		refreshWeapons = nsItems.refreshWeapons = createRefreshListener('weapon'),
		refreshAppearance = nsItems.refreshAppearance = createRefreshListener('appearance'),
		refreshBundles = nsItems.refreshBundles = createRefreshListener('bundle'),
		refreshBoosters = nsItems.refreshBoosters = createRefreshListener('booster'),
		refreshAttachments = nsItems.refreshAttachments = createRefreshListener('attachment'),
		refreshUpgrades = nsItems.refreshUpgrades = createRefreshListener('upgrade'),
		
		/**
		 * Changed locked
		 */
		onChangeIsLockedItemsTask = function onChangeIsLockedItemsTask(model) {
			APP.log('onChangeIsLockedItemsTask');
			if (!model.isItemType('bundle')) {
				
				var bundles = collection.filterBy({
						itemType: 'bundle'
					}),
					isLocked = model.get('isLocked'),
					changed = bundles.some(function (bundle) {
						var items = bundle.get('items');
						return _.some(items, function (item, i) {
							return (item.id === model.id && item.isLocked !== isLocked);
						});
					});
				
				//
				if (changed) {
					nsItems.refreshBundles();
				}
			}
		},
		
		equipAttachment = function (attachment, model) {
			model = collection.get(model);
			if (model) {
				var attachments = _.clone(model.get('attachments'));
				attachments[attachment.get('fitsSlot')] = attachment.id;
				model.set('attachments', attachments);
				return true;
			}
			return false;
		},


		/**
		 *  Go though all items can check id it has expired
		 */
		checkExpired = nsItems.checkExpired = function () {
			var nowTs = Math.round((Date.now() + nsConfig.timeDiff) / 1000);
			
			nsItems.collection.forEach(function (model) {
				if (model.isRented() && model.get('expireTS') < nowTs) {
					model.set({
						owned: false,
						expired: true
					});
				}
			});
			
			return nsItems;
		},

		/**
		 * Refresh Items
		 */
		refreshItems = nsItems.refreshItems = function (fn) {
			// Load weapons
			// TODO: Only go fetch the owned consumables
			nsItems.refreshWeapons(function (err) {
				if (err) {
					APP.log.warn(err);
					return fn(err);
				}

				checkExpired();
				
				fn();
			});

			return nsItems;
		};

	// Create some item refresh helpers
	nsItems.refreshWeapons = createRefreshListener('weapon');
	nsItems.refreshAppearance = createRefreshListener('appearance');
	nsItems.refreshBundles = createRefreshListener('bundle');
	nsItems.refreshBoosters = createRefreshListener('booster');
	nsItems.refreshAttachments = createRefreshListener('attachment');
	nsItems.refreshUpgrades = createRefreshListener('upgrade');
	
	/**
	 * Easy get access
	 */
	nsItems.get = function getItem(id) {
		return nsItems.collection.get(id);
	};
	
	
	/**
	 * Load items
	 */
	loadItems(function onDataLoaded(err, items) {
		if (err) {
			APP.log.warn(err);
			return done(new Error('Unable to load items'));
		}
		
		// Add Items
		nsItems.collection.add(items);
		
		// Ensure attachments are valid
		nsItems.collection.invoke('_processCustomizations');
		
		nsItems.collection.filter(function (model) {
			if (model.isItemType('pocket')) {
				var pocketOffers = {},
					offers;
				
				if (model.has('offers')) {
					offers = model.get('offers');
					_.forEach(offers.pluck('pocket'), function (pocket) {
						pocketOffers[pocket] = offers.filterBy({
							pocket: pocket
						});
					});
				}
				
				model.set({
					pocketOffers: pocketOffers,
					personaLevel: nsConfig.persona.level,
					unlockLevels: nsConfig.pockets.unlockLevels[model.get('category')] || []
				}, {
					silent: true
				});
			}
		});
		
		// Listen to lock changes
		nsItems.collection.bind('change:isLocked', onChangeIsLockedItemsTask);
		
		// Bind reset
		nsItems.collection.bind('reset', function () {
			// Reset the Items Collection
			nsItems.collection.reset(items);
		});
		
		/* log out all stat types available
		APP.log(_.unique(_.flatten(nsItems.collection.filterBy({ 'hasStats': true }).map(function (model) {
			return _.keys(model.getStats());
		}))));
		*/
		
		/**
		 * Task Done!
		 */
		done();
	});
	
	
	
	/**
	 * Handle change:equippedSlot
	 */
	nsItems.collection.bind('change:equippedSlot', function onChangeEquippedSlot(model, equippedSlot, changed) {
		
		equippedSlot = _.isNumber(equippedSlot) ? equippedSlot : model.previous('equippedSlot');
		
		var itemType = model.get('itemType'),
			event = model.isEquipped() ? 'equip' : 'unequip';
		
		nsItems.trigger(event + ':' + itemType, model, equippedSlot);
	});
	
	
	/**
	 * Refresh
	 */
	nsItems.bind('refresh:weapons', nsItems.refreshWeapons);
	nsItems.bind('refresh:appearance', nsItems.refreshAppearance);
	nsItems.bind('refresh:bundles', nsItems.refreshBundles);
	nsItems.bind('refresh:boosters', nsItems.refreshBoosters);
	nsItems.bind('refresh:attachments', nsItems.refreshAttachments);
	nsItems.bind('refresh:upgrades', nsItems.refreshUpgrades);
	
	
	/**
	 * Handle Refresh
	 */
	nsItems.collection.bind('refresh', function onRefresh() {
		nsItems.trigger('refresh:weapons');
		nsItems.trigger('refresh:appearance');
		nsItems.trigger('refresh:bundles');
		nsItems.trigger('refresh:boosters');
		nsItems.trigger('refresh:attachments');
		nsItems.trigger('refresh:upgrades');
	});
	
	
	/**
	 * Item tooltip
	 */
	nsItems.tooltip = new APP.View.ItemTooltip();
	nsItems.tooltip.attach();
});
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule weapons
 */
(function (win) {
	"use strict";
	
	
	var APP = win.APP,
		$ = APP.$,
		_ = APP._,
		nsConfig = APP.namespace('config'),
		parent = APP.View.PurchaseTooltip.prototype;
	
	/**
	 * Weapon Item View
	 */
	APP.View.AttachmentTooltip = APP.View.PurchaseTooltip.extend({
		className: 'attachment-tooltip purchase-tooltip',
		render: function renderAttachmentTooltip() {
			
			var expireText = this.model.getExpireText(),
				html = [];
			
			
			// Buyable
			if (this.model.isBuyable()) {
				parent.render.call(this);
			}
			
			// Rented
			if (this.model.isRented()) {
				this.$el.addClass('rented');
				
			// Expired
			} else if (this.model.isExpired()) {
				this.$el.addClass('expired');
			}
			
			html.push('<h1>' + this.model.get('categoryname') + '</h1>');
			
			if (this.model.has('reticleImage')) {
				html.push('<span class="item-reticle item-reticle-' + this.model.get('reticleImage') + '"></span>');
			}
			
			// Stats
			_.forEach(this.model.getStats(), function (value, key) {
				var className = key,
					label = this.trans('WEB_GAME_STAT_' + key.toUpperCase());
				
				if (value) {
					if (key === 'zoom') {
						value = this.trans('WEB_GAME_STAT_ZOOM_LEVEL_' + value);
					} else {
						if (value > 0) {
							value = '+' + value;
						} else {
							className += ' negative';
						}
					}
					
					html.push('<div class="stats stat-' + className + '">' + label + '<span class="value">' + value + '</span></div>');
				}
			}, this);
			
			// Expire Date
			if (expireText) {
				html.push('<p class="expiredate">' + expireText + '</p>');
			}
			
			this.$el.prepend(html.join(''));
		}
	});
}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule weapons
 */
(function (win) {
	"use strict";
	
	
	if (!win.APP && (typeof require !== 'undefined')) {
		win.APP = require('../common/app');
	}
	
	var APP = win.APP,
		$ = APP.$,
		_ = APP._,
		parent = APP.View.prototype;
	
	
	/**
	 * Attached List View Class
	 */
	APP.View.AttachedList = APP.View.extend({
		name: 'attached-list-view',
		tagName: 'ul',
		events: {
			'click a.attachment-label.buyable, a.attachment-label.expired, a.attachment-label.rented, a.attachment-label.unlockable': function (e) {
				e.preventDefault();
				this.sound('click:open');
				this.trigger('buy', this, this.getModelFromDOM(e.currentTarget), e);
			},
			'mouseenter li span, li a': function (e) {
				this.sound('hover');
				this.trigger('mouse:enter', this, this.getModelFromDOM(e.currentTarget), e);
			},
			'mouseleave li span, li a': function (e) {
				this.trigger('mouse:leave', this, this.getModelFromDOM(e.currentTarget), e);
			},
			'click li': function (e) {
				e.preventDefault();
				this.trigger('click', this, this.getModelFromDOM(e.currentTarget), e);
			}
		},
		
		/**
		 * Initialize Attached List
		 */
		initialize: function initializeAttachedListView() {
			if (this.options.attachedItems) {
				this.setAttachedItems(this.options.attachedItems);
			} else {
				this.model.bind('change:attachments', this._onChangeAttachments, this);
				this.setAttachedItems(this.model.collection.getModelAttachedItems(this.model, true));
			}
			
			this.collection = this.model.collection;
			this.collection.bind('purchase:end', this._onPurchaseEnd, this);
		},
		
		destroy: function destroyAttachedListView() {
			this.model.unbind('change:attachments', this.render, this);
			this.collection.unbind('purchase:end', this._onPurchaseEnd, this);
		},
		_onPurchaseEnd: function _onPurchaseEndAttachedListView(model) {
			model = this.collection.get(model);
			if (model && model.isItemType('attachment') && _.indexOf(_.values(this.attachedItems), model.id) !== -1) {
				this.render();
			}
		},
		
		_onChangeAttachments: function _onChangeAttachmentsAttachedListView() {
			this.setAttachedItems(this.model.collection.getModelAttachedItems(this.model, true));
			this.render();
		},
		
		/**
		 * Set Attached Items
		 */
		setAttachedItems: function setAttachedItemsAttachedListView(attachedItems) {
			this.attachedItems = attachedItems;
			return this;
		},
		
		getModelFromDOM: function getModelFromDOMAttachedListView(el) {
			return this.model.collection.get($(el).attr('item-id'));
		},
		
		/**
		 * Render Attached List
		 */
		render: function renderAttachedListView() {
			var items = [];
			
			_.forEach(this.attachedItems, function eachAttachedItem(model, key) {
				model = this.model.collection.get(model);
				if (model && !model.isDefault()) {
					var li = this.make('li'),
						tagName = 'span',
						name = model.get('name'),
						href = '#' + name.toLowerCase().replace(/\s/g, '-'),
						attrs = {
							'class': 'attachment-label ' + key,
							'item-id': model.id
						},
						invalid = false;
					
					// Locked
					if (model.isLocked()) {
						if (model.get('offers').hasUnlockOffers()) {
							tagName = 'a';
							attrs.href = href;
							attrs['class'] += ' unlockable';
						} else {
							attrs['class'] += ' locked';
						}
						
						if (model.isExpired()) {
							attrs['class'] += ' expired';
						} else if (model.isRented()) {
							attrs['class'] += ' rented';
						}
					
					// Buyable
					} else if (model.isBuyable()) {
						tagName = 'a';
						attrs.href = href;
						
						if (model.isExpired()) {
							attrs['class'] += ' expired';
						} else if (model.isRented()) {
							attrs['class'] += ' rented';
						} else {
							attrs['class'] += ' buyable';
						}
					
					// Expired
					} else if (model.isExpired()) {
						attrs['class'] += ' expired';
					
					// Rented
					} else if (model.isRented()) {
						attrs['class'] += ' rented';
					
					// Default
					} else if (model.isDefault()) {
						attrs['class'] += ' default';
					}
					
					// Show Invalid
					if (this.options.showInvalid) {
						if (this.options.hasOwnProperty('invalids')) {
							if (_.indexOf(this.options.invalids || [], model.id) !== -1) {
								invalid = true;
								attrs['class'] += ' invalid';
							}
						} else if (!model.get('owned')) {
							invalid =  true;
							attrs['class'] += ' invalid';
						}
					}
					
					li.appendChild(this.make(tagName, attrs, name));
					
					if (this.options.onlyInvalid) {
						if (invalid) {
							items.push(li);
						}
					} else {
						items.push(li);
					}
				}
			}, this);
			
			this.$items = $(items);
			this.$items.appendTo(this.el);
			
			this.$items.disableTextSelect();
		}
	});
}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule weapons
 */
(function (win) {
	"use strict";
	
	
	var APP = win.APP,
		parent = APP.Backbone.View.prototype,
		$ = APP.$,
		_ = APP._,
		EMPTY_ATTACHMENT_ID = 'EMPTY_ATTACHMENT',
		nsConfig = APP.ns('config');
	
	APP.View.WeaponCustomizeSlot = APP.View.extend({
		name: 'weapon-customize-slot-view',
		
		events: {
			'click a.attachment-label': function onClickLabelWeaponCustomizeSlotView(e) {
				e.preventDefault();
				var model = this.getSelected();
				if (model) {
					this.sound('click:open');
					this.trigger('buy', this, model, e, this.options.category);
				}
			},
			'click a.prev': function (e) {
				e.preventDefault();
				this.selectPrev();
			},
			'click a.next': function (e) {
				e.preventDefault();
				this.selectNext();
			},
			'click a.buy, a.unlock': function (e) {
				e.preventDefault();
				var model = this.getSelected();
				if (model) {
					this.sound('click:open');
					this.trigger('buy', this, model, e, this.options.category);
				}
			},
			'mouseleave': function onLeave(e) {
				this.sound('select:open');
				this.trigger('leave', this, e);
			},
			'mouseenter': function onEnter(e) {
				this.sound('select:close');
				this.trigger('enter', this, e);
			},
			'mouseenter a.buy, a.unlock, a.prev, a.next, a.attachment-label': function () {
				this.sound('hover');
			}
		},
		
		
		/**
		 * Initialize
		 */
		initialize: function initializeWeaponCustomizeSlotView() {
			var defaults = this.collection.by('isDefault', true);
			
			// It this don't have a default add an empty model
			if (defaults.length === 0) {
				// TODO: Make a better default/blank attachment
				this.collection.add([
					new APP.Model.Item({
						id: EMPTY_ATTACHMENT_ID,
						name: this.trans('WEB_GAME_NO_' + this.options.category.toUpperCase() + '_ATTACHMENT'),
						slot: this.options.slot,
						category: this.options.category,
						buyable	: false,
						isDefault: true		
					})
				], { at: 0 });
			}
			
			// Ensure that we have something selected
			if (!this.options.selected) {
				this.options.selected = (defaults.length !== 0 ? defaults : this.collection).at(0).id;
			}
			
			this.collection.bind('purchase:start', this._onPurchaseStart, this);
			this.collection.bind('purchase:end', this._onPurchaseEnd, this);
			this.collection.bind('purchase:success', this._onPurchaseSuccess, this);
			this.collection.bind('change', this.render, this);
		},
		
		/**
		 * Destroy
		 */
		destroy: function destroyWeaponCustomizeSlotView() {
			this.collection.unbind('purchase:start', this._onPurchaseStart, this);
			this.collection.unbind('purchase:end', this._onPurchaseEnd, this);
			this.collection.unbind('purchase:success', this._onPurchaseSuccess, this);
			this.collection.unbind('change', this.render, this);
		},
		
		_onMouseEnter: function _onMouseEnterWeaponCustomizeSlotView(e) {
			this.$list.slideDown(200);
		},
		
		_onMouseLeave: function _onMouseLeaveWeaponCustomizeSlotView(e) {
			if (!this.$el.hasClass('loading')) {
				this.$list.slideUp(200);
			}
		},
		
		_onPurchaseStart: function _onPurchaseStartCustomizeSlotView() {
			this.$el.addClass('loading');
		},
		_onPurchaseEnd: function _onPurchaseEndCustomizeSlotView() {
			this.$el.removeClass('loading');
			this.render();
		},
		_onPurchaseSuccess: function _onPurchaseSuccessCustomizeSlotView(model) {
			var i = _.indexOf(this.options.invalids || [], model ? model.id : null);
			if (i !== -1) {
				this.options.invalids.splice(i, 1);
				if (this.options.selected === model.id) {
					this.$name.removeClass('invalid');
				}
			}
		},
		
		/**
		 * Get Current Index
		 */
		getCurrentIndex: function getCurrentIndexWeaponCustomizeSlotView() {
			var model = this.getSelected();
			return this.collection.indexOf(model);
		},
		
		/**
		 * Select Prev
		 */
		selectPrev: function selectPrevWeaponCustomizeSlotView() {
			var max = this.collection.length - 1,
				i = this.getCurrentIndex(),
				prev = (i === -1) ? max : i - 1;
			
			if (prev > max) {
				prev = 0;
			} else if (prev < 0) {
				prev = max;
			} 
			
			this.sound('prev');
			
			return this.selectNum(prev, 'prev');
		},
		
		/**
		 * Select Next
		 */
		selectNext: function selectNextWeaponCustomizeSlotView() {
			var max = this.collection.length - 1,
				i = this.getCurrentIndex(),
				next = (i === -1) ? 0 : i + 1;
			
			if (next > max) {
				next = 0;
			} else if (next < 0) {
				next = max;
			}
			
			this.sound('next');
			
			return this.selectNum(next, 'next');
		},
		
		/**
		 * Select Num
		 */
		selectNum: function selectNumWeaponCustomizeSlotView(num, dir) {
			var model = this.collection.at(num);
			
			this.select(model, dir);
			
			return this;
		},
		
		select: function selectWeaponCustomizeSlotView(model, dir) {
			model = this.collection.get(model);
			
			if (model) {
				this.options.selected = model.id;
			} else {
				this.options.selected = null;
			}
			
			this.renderSelected(dir);
			this.trigger('select', this.options.selected);
		},
		
		/**
		 * Get Selected
		 */
		getSelected: function getSelectedWeaponCustomizeSlotView() {
			return this.collection.get(this.options.selected);
		},
		
		/**
		 * Render Selected
		 */
		renderSelected: function renderSelectedWeaponCustomizeSlotView(dir) {
			var model = this.getSelected(),
				name = model.get('name'),
				i = this.getCurrentIndex(),
				href = '#' + name.toLowerCase().replace(/\s/g, '-'),
				tagName = 'span',
				attrs = {
					'class': 'attachment-label'
				},
				$new;
			
			this.$pages.hide();
			
			this.$el.removeClass('empty rented buyable expired default locked unlockable');
			
			if (i !== -1) {
				
				// Empty
				if (model.id === EMPTY_ATTACHMENT_ID) {
					this.$el.addClass('empty');
					
					attrs['class'] += ' empty';
				
				// Locked
				} else if (model.isLocked()) {
					if (model.get('offers').hasUnlockOffers()) {
						tagName = 'a';
						attrs.href = href;
						attrs['class'] += ' unlockable';
					} else {
						attrs['class'] += ' locked';
					}
					
					if (model.isExpired()) {
						attrs['class'] += ' expired';
					} else if (model.isRented()) {
						attrs['class'] += ' rented';
					}
					
				
				// Buyable
				} else if (model.isBuyable()) {
					tagName = 'a';
					attrs.href = href;
					
					if (model.isExpired()) {
						attrs['class'] += ' expired';
					} else if (model.isRented()) {
						attrs['class'] += ' rented';
					} else {
						attrs['class'] += ' buyable';
					}
				
				// Expired
				} else if (model.isExpired()) {
					attrs['class'] += ' expired';
				
				// Rented
				} else if (model.isRented()) {
					attrs['class'] += ' rented';
				
				// Default
				} else if (model.isDefault()) {
					attrs['class'] += ' default';
				}
				
				// Invalid
				if (_.indexOf(this.options.invalids || [], model.id) !== -1) {
					attrs['class'] += ' invalid';
				}
				
				$new = this.$(this.make(tagName, attrs, name));
				
				this.$name.replaceWith($new);
				this.$name = $new;
				
				this.$name.disableTextSelect();
				
				this.$pages.eq(i).show();
				
				// Render nav buttons
				if (this.collection.length > 1) {
					this.renderNavButtons();
				}
			}
			
			return this;
		},
		
		/**
		 * Render Item
		 */
		renderItem: function renderItemWeaponCustomizeSlotView(model) {
			
			var li = this.make('li', {
					'item-id': model.id
				}),
				statsBar = this.make('div', {
					'class': 'stats-bar'
				}),
				bottomBar = this.make('div', {
					'class': 'bottom-bar'
				}),
				inner = this.make('div'),
				offers = model.get('offers'),
				startingPrices,
				lockProgress;
			
			
			/**
			 * Stats
			 */
			this.createView(APP.View.StatsList, {
				container: statsBar,
				model: model
			}).render().attach();
			
			/**
			 * Reticle
			 */
			if (model.has('reticleImage')) {
				li.appendChild(this.make('span', {'class': 'item-reticle item-reticle-' + model.get('reticleImage')}));
			}
			
			
			/**
			 * Locked
			 */
			if (model.isLocked() || model.get('lockProgress') < 1) {
				li.className = 'locked';
				offers = offers.getUnlockOffers();
				
				lockProgress = this.make('div', {
					'class': 'lock-progress'
				});
				lockProgress.appendChild(this.make('span', {
					'class': 'bar',
					'style': 'width: ' + Math.round(100 - (100 * model.get('lockProgress'))) + '%;'
				}));
				lockProgress.appendChild(this.make('span', {
					'class': 'text'
				}, this.trans('WEB_GAME_LOCK_TYPE_' + model.get('lockType').toUpperCase()) + ' ' + model.get('lockCriteria')));
				li.appendChild(lockProgress);
			} else if (model.has('lockType') && model.has('lockCriteria')) {

				APP.log('model unlocked', model, model.get('name'));

				li.className = 'unlocked';

				lockProgress = this.make('div', {
					'class': 'lock-progress unlocked'
				});
				lockProgress.appendChild(this.make('span', {
					'class': 'bar',
					'style': 'width: ' + Math.round(100 - (100 * model.get('lockProgress'))) || 100 + '%;'
				}));
				lockProgress.appendChild(this.make('span', {
					'class': 'text'
				}, this.trans('WEB_GAME_LOCK_TYPE_' + model.get('lockType').toUpperCase()) + ' ' + model.get('lockCriteria')));
				li.appendChild(lockProgress);
			}
			
			
			/**
			 * Description
			 */
			if (model.get('description')) {
				li.appendChild(this.make('p', null, model.get('description')));
				
			}
			
			
			/**
			 * Buyable
			 */
			if (model.isBuyable() && offers.length !== 0) {
				startingPrices = offers.getLowestOffers();
				
				if (startingPrices.credits) {
					inner.appendChild(this.make('span', {
						'class': 'currency credits'
					}, startingPrices.credits.get('price')));
				}
				if (startingPrices.funds) {
					inner.appendChild(this.make('span', {
						'class': 'currency funds'
					}, startingPrices.funds.get('price')));
				}
				
				bottomBar.appendChild(this.make('a', {
					'class': 'buy' + (model.isLocked() ? ' unlock' : ''),
					'href': '#buy'
				}));
			}
			
			
			
			// Has sonem stats
			if (statsBar.childNodes.length !== 0) {
				li.appendChild(statsBar);
			}
			// Has some offers
			if (inner.childNodes.length !== 0) {
				bottomBar.appendChild(inner);
				li.appendChild(bottomBar);
			}
			
			return li;
		},
		
		/**
		 * Render Navigation Buttons
		 */
		renderNavButtons: function renderNavButtonsWeaponCustomizeSlotView() {
			
			var i = this.getCurrentIndex() + 1,
				total = this.collection.length,
				prev = i - 1,
				next = i + 1;
			
			if (prev < 1) {
				prev = total;
			}
			this.$prev.html('<span>' + prev + '/' + total + '</span>');
			
			if (next > total) {
				next = 1;
			}
			this.$next.html('<span>' + next + '/' + total + '</span>');
			
			this.$prev.disableTextSelect();
			this.$next.disableTextSelect();
			
			return this;
		},
		
		/**
		 * Render
		 */
		render: function renderWeaponCustomizeSlotView() {
			
			// Add Class
			this.$el.addClass(this.options.category);
			
			var bar = this.make('div', { 'class': 'bar' }),
				pages;
			
			// Top bar
			this.$name = $('<span />').addClass('attachment-label').appendTo(bar);
			
			// Add Prev and Next
			if (this.collection.length > 1) {
				this.$prev = $('<a />').addClass('prev').appendTo(bar);
				this.$next = $('<a />').addClass('next').appendTo(bar);
			}
			
			// Append to view
			this.el.appendChild(bar);
			
			// Pages
			if (this.collection.length !== 0) {
				pages = this.collection.map(this.renderItem, this);
				this.$pages = $(pages);
				this.$list = this.$('<ul>').addClass('list');
				this.$pages.appendTo(this.$list);
				this.$list.appendTo(this.el);
			}
			
			this.$('li p').disableTextSelect();
			
			// Render Bar
			this.renderSelected();
		}
	});
	
}(this));

/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule weapons
 */
(function (win) {
	"use strict";
	
	
	var APP = win.APP,
		parent = APP.Backbone.View.prototype,
		$ = APP.$,
		_ = APP._,
		nsConfig = APP.namespace('config'),
		EMPTY_ATTACHMENT_ID = 'EMPTY_ATTACHMENT';
	
	APP.View.WeaponCustomize = APP.View.extend({
		name: 'weapon-customize-view',
		
		events: {
			'click a.button-view.close, a.button-view.done, a.close-view': function (e) {
				e.preventDefault();
				this.sound('close');
				this.trigger('close', this, this.model, e);
			},
			'mouseenter a.button, a.close-view': function () {
				this.sound('hover');
			}
		},
		
		options: {
			animDelay: 500
		},
		
		initialize: function initializeWeaponCustomizeView() {
			this.slots = {};
			
			this.attached = _.clone(this.model.get('attachments'));
			
			this.attachments = this.model.collection.getModelAttachments(this.model);
			
			if (!this.collection && this.model.collection) {
				this.collection = this.model.collection;
			}
			
			// Invalids
			this.invalids = _.filter(this.attached, function findInvalidIterator(id) {
				var model = this.model.collection.get(id);
				return (model && !model.get('owned'));
			}, this);
			
			this.bind('slot:select', this._onSlotSelect, this);
			this.bind('slot:buy', this._onSlotBuy, this);
			this.bind('slot:leave', this._onSlotLeave, this);
			this.bind('slot:enter', this._onSlotEnter, this);
			
			this.bind('select', this.onSelect, this);
			this.bind('select:texture', this.renderTexture, this);
			this.bind('select:scope', this.renderScope, this);
			this.bind('select:muzzle', this.renderMuzzle, this);
			
			this.model.bind('change', this.render, this);
			this.model.bind('purchase:start', this._onPurchaseStart, this);
			this.model.bind('purchase:end', this._onPurchaseEnd, this);
			
			this.onEscapeClose = _.bind(this.onEscapeClose, this);
			$(win).bind('keyup', this.onEscapeClose);
			
			this.bind('buy:click', this._onBuyClick, this);
		},
		
		destroy: function destroyWeaponCustomizeView() {
			this.model.unbind('change', this.render, this);
			this.model.unbind('purchase:start', this._onPurchaseStart, this);
			this.model.unbind('purchase:end', this._onPurchaseEnd, this);
			$(win).unbind('keyup', this.onEscapeClose);
		},
		
		/**
		 * On Click Buy
		 */
		_onBuyClick: function _onBuyClickWeaponCustomizeView(e) {
			this.buy();
		},
		
		_onPurchaseStart: function _onPurchaseStartWeaponCustomizeView() {
			this.$el.addClass('loading');
		},
		
		_onPurchaseEnd: function _onPurchaseEndWeaponCustomizeView() {
			this.$el.removeClass('loading');
		},
		
		_swapImage: function _swapImageWeaponCustomizeView($img, attrs) {
			var $old = $img,
				$new = $('<img />').attr(attrs).css('opacity', 0);
				
			$old.animate({ opacity: 0 }, this.options.animDelay, function () {
				$old.remove();
			});
			
			$new.appendTo($old.parent());
			$new.animate({ opacity: 1 }, this.options.animDelay);
			
			$new.disableTextSelect();
			
			return $new;
		},
		
		/**
		 * On Slot Leave
		 */
		_onSlotLeave: function _onSlotLeave(view) { 
			this.$el.removeClass('muzzle scope stock ammo texture barrel'); 
		}, 
		
		/**
		 * On Slot Enter
		 */
		_onSlotEnter: function _onSlotEnter(view) { 
			this.$el.removeClass('muzzle scope stock ammo texture barrel');                  
			this.$el.addClass(view.options.category); 
		}, 
		
		/**
		 * On Slot Select
		 */
		_onSlotSelect: function _onSlotSelectWeaponCustomizeView(model, view) {
			model = this.model.collection.get(model);
			
			var slot = view.options.slot,
				category = view.options.category;
			
			this.trigger('select', model, slot, category);
			this.trigger('select:' + category, model, slot, category);
		},
		
		/**
		 * On Slot Buy
		 */
		_onSlotBuy: function _onSlotBuyWeaponCustomizeView(view, model) {
			// Can't buy attachments if you don't own the weapon
			if (this.model.isBuyable()) {
				var dialogView,
					options = {
						className: 'buy-for-non-permanent-dialog',
						renderData: {
							title: this.trans('WEB_GAME_BUY_FOR_NON_PERMANENT_DIALOG_TITLE'),
							buttonRight: this.trans('WEB_GAME_BUY_FOR_NON_PERMANENT_DIALOG_CLOSE'),
							close: true
						},
						container: APP.doc.body
					};
				
				// Weapon is locked WITHOUT bypass offer
				if (this.model.isLocked()) {
					options.renderData.body = this.trans('WEB_GAME_BUY_FOR_LOCKED_DIALOG_TEXT');
				
					// Weapon is locked WITH bypass offer
					if (this.model.get('offers').hasUnlockOffers()) {
						options.renderData.buttonLeft = this.trans('WEB_GAME_BUY_FOR_LOCKED_DIALOG_BUY');						
					}
					
				} else {
					options.renderData.body = this.trans('WEB_GAME_BUY_FOR_NON_PERMANENT_DIALOG_TEXT');
					options.renderData.buttonLeft = this.trans('WEB_GAME_BUY_FOR_NON_PERMANENT_DIALOG_BUY');					
				}
				
				dialogView = this.createView(APP.View.Dialog, options);
				
				// Buy Weapon
				dialogView.bind('button:left', function () {
					dialogView.destroy();
					this.buy();
				}, this);
					
				// Close Dialog
				dialogView.bind('close', dialogView.destroy, dialogView);
				dialogView.bind('button:right', dialogView.destroy, dialogView);
                
				// Attach
				dialogView.attach();
				
				// Render
				dialogView.render();
				
				// Show
				dialogView.show();
				
				
			// Buy attachment
			} else {
				this.trigger('buy', this, model);
			}
		},
		
		/**
		 * On Escape Close
		 */
		onEscapeClose: function onEscapeCloseDialogView(e) {
			if (e.keyCode === 27 && this.$el.is(':visible')) {
				this.sound('close');
				this.trigger('close', this, this.model, e);
			}
		},
		
		/**
		 * Buy
		 */
		buy: function buyWeaponCustomizeView() {
			this.trigger('buy', this, this.model, {
				groupPrices: 'unlimited'
			});
			return this;
		},
		/**
		 * On Select
		 */
		onSelect: function onSelectWeaponCustomizeView(model, slot) {
			if (this.attached.hasOwnProperty(slot)) {
				this.attached[slot] = (model && model.id !== EMPTY_ATTACHMENT_ID) ? model.id : null;
				
				// Attached list
				if (this.attachedList) {
					this.attachedList.setAttachedItems(this.attached).render();
					
				// Attachments on non permanent
				} else {
					this.checkForAttachmentsOnNonPermanent();
				}
			}
		},
		/**
		 * Check for attachments on non permanent
		 */
		checkForAttachmentsOnNonPermanent: function checkForAttachmentsOnNonPermanentCustomizeView() {
			
			var $warning = this.$('div.warning');
			
			if (this.model.isBuyable() && !this.model.isLocked() && !_.isEqual(this.attached, this.model.get('attachments'))) {
				if ($warning.hasClass('hide')) {
					this.sound('error');
					$warning.removeClass('hide');
				}
			} else {
				$warning.addClass('hide');
			}
			
			return this;
		},
		
		/**
		 * Preload images
		 */
		preloadImages: function preloadImagesWeaponCustomizeView() {
			
			// Get Images
			var visualSlots = [ 1, 2, 6 ],
				visualItems = this.attachments.filter(function filterVisualItems(model) {
					return (_.indexOf(visualSlots, model.get('fitsSlot')) !== -1);
				}),
				images = _.invoke(visualItems, 'getAttachmentImage', 'max'),
				
				// Create a function that will only be called after all images has been loaded
				// TODO: Better error handling
				doneFn = _.afterWithoutErrors(images.length, _.bind(function () {
					if (this.model.isLocked()) {
						this.renderLock();
					}
					this.$el.removeClass('loading');
					this.trigger('ready');
				}, this), function onError(err) {
					APP.log.warn(err);
				});
			
			if (images.length === 0 && this.model.isCustomizable()) {
				images.push(this.model.getImage('max'));
			}
			
			// Preload images, if needed
			if (images.length === 0) {
				this.$el.removeClass('loading');
			} else {
				_.forEach(images, function (src) {
					APP.preload.image(src, _.bind(function (err, src) {
						var model,
							fallback;
						
						if (err) {
							model = this.collection.get(src.match(/[0-9]+/g).pop());
							if (model) {
								fallback = nsConfig.imageFolder + 'attachment-icons/max/' + model.get('category') + '.png';
								model.setAttachmentImage('max', fallback);
								
								// Muzzle
								if (this.$muzzle && this.$muzzle.attr('src') === src) {
									this.$muzzle.attr('src', fallback);
									
								// Scope
								} else if (this.$scope && this.$scope.attr('src') === src) {
									this.$scope.attr('src', fallback);
									
								// Texture
								} else if (this.$img && this.$img.attr('src') === src) {
									this.$img.attr('src', fallback);
								}
							}
						}
						doneFn();
					}, this), 15000);
				}, this);
			}
			
			return this;
		},
		
		/**
		 * Render Muzzle: This use update muzzle attachment image
		 */
		renderMuzzle: function renderMuzzleWeaponCustomizeView(model) {
			var attrs = _.clone(nsConfig.attachmentSize.max);
			
			if (model && model.id !== EMPTY_ATTACHMENT_ID) {
				attrs.src = model.getAttachmentImage('max');
			} else {
				attrs.src = nsConfig.imageFolder + 'game/1x1-transparent.png';
			}
			
			this.$muzzle = this._swapImage(this.$muzzle, attrs);
			
			return this;
		},
		
		/**
		 * Render Scope: This use update scope attachment image
		 *  
		 */
		renderScope: function renderScopeWeaponCustomizeView(model) {
			var attrs = _.clone(nsConfig.attachmentSize.max);
			
			if (model && model.id !== EMPTY_ATTACHMENT_ID) {
				attrs.src = model.getAttachmentImage('max');
			} else {
				attrs.src = nsConfig.imageFolder + 'game/1x1-transparent.png';
			}
			
			this.$scope = this._swapImage(this.$scope, attrs);
			
			return this;
		},
		
		/**
		 * Render Texture
		 */
		renderTexture: function renderTextureWeaponCustomizeView(model) {
			var attrs = _.clone(nsConfig.imageSize.max);
			
			if (model && model.id !== EMPTY_ATTACHMENT_ID) {
				attrs.src = model.getAttachmentImage('max');
			} else {
				attrs.src = nsConfig.imageFolder + 'game/1x1-transparent.png';
			}
			
			attrs['class'] = 'main-item';
			
			this.$img = this._swapImage(this.$img, attrs);
			
			return this;
		}, 
		
		/**
		 * Render Connector
		 */
		renderConnector: function renderConnectorWeaponCustomizeView(category, view) {
			
			var $container = this.$(view.getContainer()),
				pos = this.slotPositions[category],
				$dot = $('<span />').addClass('connector-dot ' + category).appendTo($container),
				
				offsetWidth = 200,  // TODO: Fix this!
				
				startX = pos.start[0],
				startY = pos.start[1],
				stopX = pos.stop[0] + (pos.start[0] > (pos.stop[0] + (offsetWidth / 2)) ? offsetWidth : 0),
				stopY = pos.stop[1],
				
				width = Math.abs(startX - stopX),
				height = Math.abs(startY - stopY),
				
				lineLength = Math.sqrt(width * width + height * height),
				
				deg = Math.round((180 / Math.PI) * Math.acos((height * height - (-lineLength * lineLength) - width * width) / (2 * height * lineLength))),
				
				svg = APP.doc.createElementNS("http://www.w3.org/2000/svg", "svg"),
				line = APP.doc.createElementNS("http://www.w3.org/2000/svg", "line");
			
			svg.style.left	= (startX > stopX ? stopX : startX) + 'px';
			svg.style.top	= (startY > stopY ? stopY : startY) + 'px';
			
			svg.setAttribute("class", 'connector-line ' + category);
			svg.setAttribute("width", width + 'px');
			svg.setAttribute("height", height + 'px');
			svg.setAttribute("viewBox", '0 0 ' + width + ' ' + height);
			
			// LEFT TOP 
			if (startX > stopX && startY > stopY) {
				line.setAttribute("x1", 0);
				line.setAttribute("x2", '100%');
				line.setAttribute("y1", 0);
				line.setAttribute("y2", '100%');
				
				// Rotate connector dot
				deg = 270 + (90 - deg);
				
				
			// RIGHT TOP
			} else if (startX < stopX && startY > stopY) {
				line.setAttribute("x1", '100%');
				line.setAttribute("x2", 0);
				line.setAttribute("y1", 0);
				line.setAttribute("y2", '100%');
				
			// RIGHT BOTTOM 
			} else if (startX < stopX && startY < stopY) {
				line.setAttribute("x1", '100%');
				line.setAttribute("x2", 0);
				line.setAttribute("y1", '100%');
				line.setAttribute("y2", 0);
				
				// Rotate connector dot
				deg = 90 + (90 - deg);
				
			// LEFT BOTTOM
			} else {
				line.setAttribute("x1", 0);
				line.setAttribute("x2", '100%');
				line.setAttribute("y1", '100%');
				line.setAttribute("y2", 0);
				
				deg = 180 + deg;
			}
			svg.appendChild(line);
			
			$container.append(svg);
			
			$dot.css({
				'left'	: pos.start[0],
				'top'	: pos.start[1],
				'-webkit-transform': 'rotate(' + deg + 'deg)'
			});
			
			view.$el.css({
				'left': pos.stop[0],
				'top': pos.stop[1]
			}).addClass((pos.start[0] > (pos.stop[0] + (offsetWidth / 2))) ? 'right' : 'left');
			
			return this;
		},
		
		/**
		 * Render Slot
		 */
		renderSlot: function renderSlotWeaponCustomizeView(selected, slot) {
			
			slot = parseInt(slot, 10);
			
			var container = this.el,
				category = APP.Model.Item.getAttachmentCategoryMap(slot).toLowerCase(),
				view,
				viewOptions,
				collection = this.attachments.by('fitsSlot', slot),
				imgAttrs;
			
			if (collection.length === 0) {
				return this;
			}
			
			if (!collection.get(selected)) {
				APP.log('Selected attachment does not exist, reverting to default');
				selected = null;
			}
			
			// Ensure that defaults come first
			collection.comparator = function comparator(model) {
				return model.get('isDefault') ? 0 : 1;
			};
			collection.sort();  
			
			// Scope and Muzzle attachments are "special"
			if (category === 'scope' || category === 'muzzle') { 
				container = this.make('div', {
					'class': 'slot-' + category
				});
				
				// Set position
				container.style.left = this.slotPositions[category].box[0] + 'px';
				container.style.top = this.slotPositions[category].box[1] + 'px';
				
				// Image
				imgAttrs = _.clone(nsConfig.attachmentSize.max);
				imgAttrs.src = nsConfig.imageFolder + 'game/1x1-transparent.png';
				this['$' + category] = $(this.make('img', imgAttrs));
				this['$' + category].appendTo(container);
				
				this.el.appendChild(container);
			}
			
			// Create View
			viewOptions = {
				collection: collection,
				container: container,
				selected: selected,
				slot: slot,
				category: category,
				invalids: this.invalids
			};
			view = this.slots[category] = this.createView(APP.View.WeaponCustomizeSlot, viewOptions, 'slot');
			
			// Trigger select for visual attachments so that we can render their images
			if (category === 'scope' || category === 'muzzle' || category === 'texture') {
				this.trigger('select:' + category, view.getSelected(), category);
			}
			
			// Render View
			view.render();
			
			// Render Connector
			if (category === 'texture') {
				view.$el.css({
					'left': this.slotPositions[category].stop[0],
					'top': this.slotPositions[category].stop[1]
				});
			} else {
				this.renderConnector(category, view);
			}
			
			// Attach to container
			view.attach();
			
			return this;
		},
		
		
		/**
		 * Render Lock
		 */
		renderLock: function renderLockWeaponItemView() {
			
			var nsConfig = APP.ns('config'),
				type = this.model.get('lockType'),
				criteria = this.model.get('lockCriteria'),
				lock = this.make('div', {
					'class': 'lock ' + type
				}),
				progressImage = nsConfig.imageFolder + 'game/item-lock-progress.png',
				progress = this.model.get('lockProgress'),
				canvas = win.progressCircle(progressImage, progress, {
					width: 116,
					height: 116,
					lineWidth: 20,
					duration: 500
				});
			
			lock.appendChild(this.make('span', {
				'class': 'type'
			}, type));
			
			lock.appendChild(this.make('span', {
				'class': 'key'
			}, criteria));
			
			lock.appendChild(canvas);
			this.el.appendChild(lock);
			
			return this;
		},
		
		
		/**
		 * Render
		 */
		render: function renderWeaponCustomizeView() {
			
			// Add some classes
			this.$el.addClass('loading ' + this.model.get('category').toLowerCase().replace(/[\s_]/, '-') + ' item-' + this.model.id);
			
			// Name
			var mainBar = this.make('div', { 'class': 'main-bar' }),
				name = this.make('h1', null, this.model.get('name')),
				offers = this.model.get('offers'),
				div,
				unlimitiedOffers,
				buyFor,
				attachedList,
				warning;
			
			name.appendChild(this.make('span', { 'class': 'category' }, this.model.get('categoryname')));
			mainBar.appendChild(name);
			
			// Append Main bar
			this.el.appendChild(mainBar);
			
			
			/**
			 * Locked
			 */
			if (this.model.isLocked()) {
				this.$el.addClass('locked');
				offers = offers.getUnlockOffers();
			}
			
			
			/**
			 * Buyable?
			 */
			if (this.model.isBuyable()) {
				div = this.make('div');
				
				// Unlimited prices
				unlimitiedOffers = offers.getUnlimitedOffers();
				if (unlimitiedOffers.length !== 0) {
					// Buy
					this.createView(APP.View.Button, {
						container: div,
						className: 'buy',
						text: this.trans('WEB_STORE_COMMON_BUY_BTN'),
						sound: true,
						large: true,
						glyph: 'buy'
					}, 'buy').render().attach();
					
					buyFor = this.make('div', {
						'class': 'unlimitied-prices'	
					});
					
					if (this.model.isLocked()) {
						buyFor.appendChild(this.make('span', null, this.trans('WEB_GAME_WEAPONS_INFO_PRICE_UNLOCK')));
					} else {
						buyFor.appendChild(this.make('span', null, this.trans('WEB_GAME_CUSTOMIZE_PRICE_UNLIMITED')));
					}
					
					unlimitiedOffers.forEach(function (model) {
						buyFor.appendChild(this.make('span', {
							'class': 'currency-' + model.get('currency')
						}, model.get('price')));
					}, this);
					div.appendChild(buyFor);
				}
				
				// Warning
				warning = this.make('div', {
					'class': 'warning'
				});
				warning.appendChild(this.make('span', null, this.trans('WEB_GAME_CUSTOMIZE_WARNING_TEXT')));
				div.appendChild(warning);
				
				mainBar.appendChild(div);
				
				// Close button
				this.createView(APP.View.Button, {
					className: 'close',
					text: this.trans('WEB_GAME_CUSTOMIZE_BTN_CLOSE')
				}).render().attach();
				
			/**
			 * Show a list of attached items
			 */
			} else {
				
				if (this.model.isOwnedPermanent()) {
					// Done button
					this.createView(APP.View.Button, {
						className: 'done',
						text: this.trans('WEB_GAME_CUSTOMIZE_BTN_DONE')
					}).render().attach();
				} else {
					// Close button
					this.createView(APP.View.Button, {
						className: 'close',
						text: this.trans('WEB_GAME_CUSTOMIZE_BTN_CLOSE')
					}).render().attach();
					
				}
				
				// Attached List
				this.attachedList = this.createView(APP.View.AttachedList, {
					container		: mainBar,
					model			: this.model,
					invalids		: this.invalids,
					showInvalid		: true,
					attachedItems	: this.attached
				}, 'list');
				
				// Render
				this.attachedList.render();
				
				// Attch
				this.attachedList.attach();
			}
			
			// Create main image
			this.$img = $('<img />').attr({
				'class'	: 'main-item',
				'width'	: 900,
				'height': 450,
				'src'	: nsConfig.imageFolder + 'game/1x1-transparent.png'
			});
			this.$img.appendTo(this.el);
			
			// Render slot
			this.slotPositions = this.options.getSlotPositions(this.model);
			this.slots = {};
			_.forEach(this.attached, this.renderSlot, this);
			
			// Preload images
			this.preloadImages();
			
			// Check for attachments on non permanent
			this.checkForAttachmentsOnNonPermanent();
			
			// Close button
			this.el.appendChild(this.make('a', {
				'class': 'close-view'
			}));
			
			// Disable Text Select
			this.$('div.warning span, div.unlimitied-prices span').disableTextSelect();
		}
	});
	
}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule weapons
 */
(function (win) {
	"use strict";
	
	
	var APP = win.APP,
		_ = APP._,
        doc = APP.doc;
	
	APP.View.WeaponInfo = APP.View.extend({
		name: 'weapon-info-view',
		className: 'info-view',
				
		initialize: function initializeWeaponInfoView() {
			this.collection = this.model.collection;
			this.collection.bind('purchase:start', this._onPurchaseStart, this);
			this.collection.bind('purchase:end', this._onPurchaseEnd, this);
			this.model.bind('remove', this._onModelRemove, this);
			this.model.bind('change', this._onModelChange, this);
			this.model.bind('heartbeat', this.render, this);
			this.bind('buy:click', this._onClickBuy, this);
            this.bind('customize:click', function () {
                this.trigger('customize', this, this.model);
            }, this);
		},
		
		destroy: function destroyWeaponCustomizeView() {
			this.collection.unbind('purchase:start', this._onPurchaseStart, this);
			this.collection.unbind('purchase:end', this._onPurchaseEnd, this);
			this.model.unbind('remove', this._onModelRemove, this);
			this.model.unbind('change', this._onModelChange, this);
		},
		
		_onPurchaseStart: function _onPurchaseStartWeaponInfoView(model) {
			model = this.collection.get(model);
			if (model && (model.id === this.model.id || _.indexOf(_.values(this.model.get('attachments') || {}), model.id) !== -1)) {
				this.$el.addClass('loading');
			}
		},
		_onPurchaseEnd: function _onPurchaseEndWeaponInfoView(model) {
			model = this.collection.get(model);
			if (model && (model.id === this.model.id || _.indexOf(_.values(this.model.get('attachments') || {}), model.id) !== -1)) {
				this.render();
			}
		},
		_onModelRemove: function _onModelRemoveWeaponInfoView() {
			if (this.collection.indexOf(this.model) === -1) {
				this.destroy();
			}
		},
		_onModelChange: function _onModelChangeWeaponInfoView() {
			this.render();
		},
		
		_onClickBuy: function _onClickBuyWeaponInfoView() {
			this.trigger('buy', this, this.model);
		},
		
		renderStats: function renderStatsWeaponInfoView(stat, key) {
			var row = doc.createDocumentFragment(),				
				titleWrapper = this.make('div', {
					'class': 'stat-title'
				}),
				title = this.make('div', {
					'class': 'label stat-' + key
				}, key),
				label = this.make('div', {
					'class': 'attachment-label'
				}, stat.base),				
				labelWrapper = this.make('div', {
					'class': 'base'
				}),	
				details = this.make('div', {
					'class': 'stat-details'
				}),
				bestInClass = (this.model.get('isBestInClass') || []).indexOf(key) !== -1;
			
			// Add marker for Best in Class
			if (bestInClass) {
				title.className += ' bic';
				// TODO: Localize
				title.appendChild(this.make('span', {
					'class': 'best-in-class'
				}, this.trans('WEB_GAME_STAT_BEST_IN_CLASS')));
			}
			
			titleWrapper.appendChild(title);
			row.appendChild(titleWrapper);
			labelWrapper.appendChild(label);
			details.appendChild(labelWrapper);
			row.appendChild(details);
			
			// Add stat changes
			if (stat.hasOwnProperty('mods')) {
				titleWrapper.className += ' active';
				if (key !== 'zoom' && stat.mods.length !== 0) {
					details.appendChild(this.make('div', {'class': 'mods'}, _.map(stat.mods, function (value) {
						var className = 'value';
						if (value > 0) {
							value = '+' + value;
						} else {
							className += ' negative';
						}
						return '<span class="' + className + '">' + value + '</span>';
					}).join(' ')));
				}
			} else {
				label.className += ' empty';
			}
			
			return row;
		},
		
		
		/**
		 * Render Lock
		 */
		renderLock: function renderLockWeaponItemView() {
			
			var nsConfig = APP.ns('config'),
				type = this.trans('WEB_GAME_LOCK_TYPE_' + this.model.get('lockType').toUpperCase()),
				criteria = this.model.get('lockCriteria'),
				lock = this.make('div', {
					'class': 'lock ' + type
				}),
				progressImage = nsConfig.imageFolder + 'game/item-lock-progress.png',
				progress = this.model.get('lockProgress'),
				canvas = win.progressCircle(progressImage, progress, {
					width: 116,
					height: 116,
					lineWidth: 20,
					duration: 500
				});
			
			lock.appendChild(this.make('span', {
				'class': 'type'
			}, type));
			
			lock.appendChild(this.make('span', {
				'class': 'key'
			}, criteria));
			
			lock.appendChild(canvas);
			this.el.appendChild(lock);
			
			return this;
		},
		
		_renderPurchaseBox: function (labelText, lowest) {
			var purchaseOptions = doc.createDocumentFragment(),
				prices = this.make('div', {
					'class': 'prices'
				});

			if (lowest.credits) {
				prices.appendChild(this.make('span', {
					'class': 'currency credits'
				}, lowest.credits.get('price') + '<i class="glyphs glyphs-credits20"></i>'));
			}
			if (lowest.funds) {
				prices.appendChild(this.make('span', {
					'class': 'currency funds'
				}, lowest.funds.get('price') + '<i class="glyphs glyphs-funds20"></i>'));
			}
			purchaseOptions.appendChild(prices);

			this.createView(APP.View.Button, {
				container: purchaseOptions,
				className: 'buy',
				primary: true,
				glyph: 'buy',
				text: this.trans('WEB_STORE_COMMON_BUY_BTN'),
				sound: true
			}, 'buy').render().attach();


			this.createView(APP.View.LabelBox, {
				'label': labelText,
				'content': purchaseOptions,
				'className': 'bottom purchase',
				'container': this.el
			}).render().attach();
		},
		
		/**
		 * Render Weapon Info
		 */
		render: function renderWeaponInfoView() {
			
			this.$el.addClass('border-box');
			
			var title = this.make('h2'),
				descriptionWrapper = this.make('p', {
					'class': 'description'
				}),
				description = this.make('span', null, this.model.get('description')),
				
				// Render Stats
				stats,
				purchaseOptions = doc.createDocumentFragment(),
				lowest,
				prices,
				customizeWrapper = this.make('div', {
					'class': 'label-box bottom'
				}),
				customize = this.make('div', {
					'class': 'box-content'
				}),
				attachedListView,
				offers = this.model.get('offers');
			
			// Title - Name
			title.appendChild(this.make('span', {
				'class': 'name'
			}, this.model.get('name')));
			
			// Title - Category
			title.appendChild(this.make('span', {
				'class': 'category'
			}, this.model.get('categoryname')));
			
			// Title
			this.el.appendChild(title);
			
			// Description
			descriptionWrapper.appendChild(description);
			this.el.appendChild(descriptionWrapper);
			
			// Render stats
			if (this.model.hasStats()) {
				
				stats = this.createView(APP.View.Stats, {'model': this.model});
				
				this.createView(APP.View.LabelBox, {
					'label': this.trans('WEB_GAME_WEAPONS_INFO_WEAPON_STATS'),
					'content': stats,
					'className': 'stats-wrapper',
					'container': this.el
				}).render().attach();
			}
			
			
			// Is Locked
			if (this.model.isLocked()) {
				
				this.$el.addClass('locked');
				
				this.renderLock();
				
				if (offers.hasUnlockOffers()) {
					lowest = offers.getUnlockOffers().getLowestOffers();

					this._renderPurchaseBox(this.trans('WEB_GAME_WEAPONS_INFO_PRICE_UNLOCK'), lowest);
				}
			
			// Is unlocked
			} else {
				// Weapon config
				if (this.model.isCustomizable()) {
					
					// Weapon has been customized
					if (this.model.isCustomized()) {
						
						this.createView(APP.View.LabelBox, {
							'label': this.trans('WEB_GAME_WEAPONS_INFO_WEAPON_CONFIG'),
							'content': this.createView(APP.View.AttachedList, {
								model: this.model,
								showInvalid: true
							}, 'list'),
							'className': 'config-wrapper',
							'container': this.el
						}).render().attach();
						
					// Buy show a button to open customize view
					} else if (this.model.isBuyable()) {

                        this.createView(APP.View.Button, {
                            'glyph': 'customize',
                            'large': true,
                            'text': this.trans('WEB_GAME_WEAPONS_INFO_VIEW_CUSTOMIZATION_OPTIONS'),
                            'className': 'customize'
                        }, 'customize').render().attach();
					}
				}
				
				// Show buy section if buyable
				if (this.model.isBuyable() && offers) {
					lowest = offers.getLowestOffers();

					this._renderPurchaseBox(this.trans('WEB_GAME_WEAPONS_INFO_PRICE_FROM'), lowest);
					
				// Show customize-button if owned and customizable
				} else if (this.model.isCustomizable()) {
					
					this.createView(APP.View.Button, {
                        'glyph': 'customize',
                        'large': true,
                        'text': this.trans('WEB_GAME_WEAPONS_INFO_CUSTOMIZE_WEAPON'),
                        'className': 'customize bottom'
                    }, 'customize').render().attach();
				}
			}
		}
	});
}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule weapons
 */
(function (win) {
	"use strict";
	
	
	var APP = win.APP,
		$ = APP.$,
		_ = APP._,
		nsConfig = APP.namespace('config'),
		parent = APP.View.prototype;
	
	/**
	 * Weapon Slots View
	 */
	APP.View.WeaponSlots = APP.View.extend({
		name: 'weapon-slots-view',
		initialize: function initializeWeaponSlotsView() {
			if (!this.collection && this.model.collection) {
				this.collection = this.model.collection;
			}
		},
		destroy: function destroyWeaponSlotsView() {
			
		},
		render: function renderWeaponSlotsView() {
			var attachedItems = this.collection.getModelAttachedItems(this.model, true),
				slotMap = {
					1: 'muzzle',
					2: 'scope',
					3: 'barrel',
					4: 'ammo',
					5: 'stock',
					6: 'texture'
				};
			
			_.forEach(this.collection.getModelCustomizableSlots(this.model), function (slot) {
				
				var key = slotMap[slot],
					model = attachedItems[key],
					container = this.make('span', {
						'class': key
					});
				
				if (key !== 'muzzle') {
					if (model && !model.isDefault()) {
						container.className += ' modded';
						
						if (!model.get('owned')) {
							container.className += ' invalid';
						}
					}
					this.el.appendChild(container);
				}
			}, this);
		}
	});
}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule weapons
 */
(function (root) {
	"use strict";
	
	
	var APP = root.APP,
		$ = APP.$,
		_ = APP._,
		win = APP.win,
		nsConfig = APP.namespace('config'),
		parent = APP.View.prototype;
	
	/**
	 * Weapon Item View
	 */
	APP.View.WeaponItem = APP.View.extend({
		name: 'weapon-item-view',
		tagName: 'div',
		
		events: {
			'mouseenter span.exclaim': function (e) {
				this.sound('hover');
				this.trigger('exclaim:enter', this, this.model, e);
			},
			'mouseleave span.exclaim': function (e) {
				this.trigger('exclaim:leave', this, this.model, e);
			},
			'mouseenter a.buy, a.lock, a.unlock': function (e) {
				this.sound('hover');
				this.trigger('buy:enter', this, this.model, e);
			},
			'mouseleave a.buy, a.lock, a.unlock': function (e) {
				this.trigger('buy:leave', this, this.model, e);
			},
			'click a.buy, a.unlock': function (e) {
				e.preventDefault();
				e.stopImmediatePropagation();
				this.sound('click');
				this.trigger('buy', this, this.model, e);
			},
			'click a.customize': function (e) {
				e.preventDefault();
				e.stopImmediatePropagation();
				this.sound('click');
				this.trigger('customize', this, this.model, e);
			},
			'click': function (e) {
				e.preventDefault();
				this.sound('click');
				this.trigger('click', this, this.model, e);
			},
			'mouseenter': function (e) {
				this.sound('hover');
				this.trigger('enter', this, this.model, e);
			},
			'mouseleave': function (e) {
				this.trigger('leave', this, this.model, e);
			},
			'mouseenter a.customize': function (e) {
				this.sound('hover');
				this.trigger('customize:enter', this, this.model, e);
			},
			'mouseleave a.customize': function (e) {
				this.trigger('customize:leave', this, this.model, e);
			}
		},
		
		options: {
			showName: true,
			showIcons: true,
			showAdditional: true,
			showLock: true,
			itemSize: 'min',
			live: true
		},
		
		initialize: function initializeWeaponItemView() {
			// TODO: Make sure we don't rely on this "magic" binding
			_.bindAll(this);
			
			if (this.options.live) {
				this.model.bind('change', this._onChange);
			}
			
			this.collection = this.model.collection;
			this.collection.bind('purchase:start', this._onPurchaseStart);
			this.collection.bind('purchase:end', this._onPurchaseEnd);
		},
		
		destroy: function destroyWeaponItemView() {
			this.model.unbind('change', this.render, this);
			this.collection.unbind('purchase:start', this._onPurchaseStart, this);
			this.collection.unbind('purchase:end', this._onPurchaseEnd, this);
			return this;
		},
		
		_onPurchaseStart: function _onPurchaseStartWeaponItemView(model) {
			model = this.collection.get(model);
			if (model && (model.id === this.model.id || _.indexOf(_.values(this.model.get('attachments') || {}), model.id) !== -1)) {
				this.$el.addClass('loading');
			}
		},
		_onPurchaseEnd: function _onPurchaseEndWeaponItemView(model) {
			model = this.collection.get(model);
			if (model && (model.id === this.model.id || _.indexOf(_.values(this.model.get('attachments') || {}), model.id) !== -1)) {
				this.render();
			}
		},
		_onChange: function _onChangeItemView() {
			
			var reRenderOnAttrs = [
					'attachments',
					'expired',
					'owned',
					'usecount',
					'invalidDependency',
					'isLocked'
				],
				reRender = _.some(reRenderOnAttrs, function (attr) {
					return this.model.hasChanged(attr);
				}, this),
				equippedChange = this.model.hasChanged('equippedSlot');
			
			if (this.model.hasChanged('equippedSlot')) {
				equippedChange = (!_.isNumber(this.model.previous('equippedSlot')) || !this.model.isEquipped());
			}
			
			// Only re-render if it's worth it :D
			if (reRender || equippedChange) {
				this.render();
			}
		},
		
		/**
		 * Drag helper: should return a jQuery wrapped DOM element
		 */
		dragHelper: function (e) {
            
			var	dragHelper = this.make('div', {
					'class': 'weapon-draghelper'
				});
			
			// Build images
			this.model.composeImage('med', function (itemSrc, silhouetteSrc) {
				var item = new Image(),
					silhouette = new Image();
				
				
				item.width = silhouette.width = nsConfig.imageSize.med.width;
				item.height = silhouette.height = nsConfig.imageSize.med.height;
				item.ondragstart = silhouette.ondragstart = function () {
					return false;
				};
				
				item.src = itemSrc;
				silhouette.src = silhouetteSrc;
				
				silhouette.className = 'mask';
				
				dragHelper.appendChild(item);
				dragHelper.appendChild(silhouette);
			});
			
			// Return drag helper
			return $(dragHelper);
		},
		
		/**
		 * Render Image
		 */
		renderImage: function renderImageWeaponItemView() {
			
			var width = nsConfig.imageSize[this.options.itemSize].width,
				height = nsConfig.imageSize[this.options.itemSize].height;
			
			// TODO: Fix this in a better way
			if (this.options.itemSize === 'min' && this.model.get('validationGroup') === 'primary' && this.model.get('category') !== 'shotgun') {
				width = 90;
				height = 40;
			}
			
			if (!this.model.hasComposedImage(this.options.itemSize)) {
				this.$el.addClass('loading');
			}
			
			// Fetch Image
			this.model.composeImage(this.options.itemSize, _.bind(function onComposeImage(imageSrc, silhouetteSrc) {
				
				this.image.src = imageSrc;
				this.image.width = width;
				this.image.height = height;
				
				if (this.silhouette && silhouetteSrc) {
					this.silhouette.src = silhouetteSrc;
					this.silhouette.width = width;
					this.silhouette.height = height;
				}
				this.$el.removeClass('loading');
			}, this));
			
			return this;
		},
		
		
		/**
		 * Render Lock
		 */
		renderLock: function renderLockWeaponItemView() {
			
			var type = this.trans('WEB_GAME_LOCK_TYPE_' + this.model.get('lockType').toUpperCase()),
				criteria = this.model.get('lockCriteria'),
				lock = this.make('div', {
					'class': 'lock ' + type
				}),
				progressImage = nsConfig.imageFolder + 'game/item-lock-progress.png',
				progress = this.model.get('lockProgress'),
				canvas = win.progressCircle(progressImage, progress, {
					width: 56,
					height: 56,
					lineWidth: 8,
					duration: 500
				});
			
			lock.appendChild(this.make('span', {
				'class': 'type'
			}, type));
			
			lock.appendChild(this.make('span', {
				'class': 'key'
			}, criteria));
			
			lock.appendChild(canvas);
			this.el.appendChild(lock);
			
			return this;
		},
		
		/**
		 * Render
		 */
		render: function renderWeaponItemView() {
			
			var $bar = this.$('<div class="bar" />'),
				usecount = this.model.get('usecount');
			
			// Model id
			this.$el.attr('item-id', this.model.id);
			
			// Add Default Classes
			this.$el.addClass(this.model.get('category') + ' ' + this.model.get('validationGroup'));
			
			// Equipped
			if (this.model.isEquipped()) {
				this.$el.addClass('equipped');
			}
			
			/**
			 * Show Additional
			 */
			if (this.options.showIcons) {
				// Rented
				if (this.model.isRented()) {
					this.$el.addClass('rented');
					$bar.append('<span class="exclaim timer">?</span>');
				
				// Use count
				} else if (this.model.isConsumable() && this.model.has('usecount')) {
					if (usecount === 0) {
						this.$el.addClass('uses-empty');
						$bar.append('<span class="exclaim">!</span>');
					} else if (usecount < 10) {
						this.$el.addClass('uses-low');
						$bar.append('<span class="warn">' + usecount + '</span>');
					} else {
						$bar.append('<span class="normal">' + usecount + '</span>');
					}
					
				// Invalid Attachments
				} else if (this.model.hasInvalidAttachments()) {
					this.$el.addClass('invalid');
					$bar.append('<span class="exclaim">!</span>');
				}
				
				// Customizable
				if (this.model.isCustomizable()) {
					this.$el.addClass('customizable');
					this.$el.append('<a href="#customize" class="icon customize" />');
					
				// Trainable
				} else if (this.model.isBoostable()) {
					this.$el.addClass('boostable');
					this.$el.append('<a href="#boost" class="icon boost" />');
				}
				
				
				// Locked
				if (this.model.isLocked()) {
					if (!this.model.isOwned()) {
						this.$el.addClass('locked');
						if (this.options.showLock) {
							this.renderLock();
						}
					}
					
					if (this.model.get('offers').hasUnlockOffers()) {
						this.$el.append('<a href="#unlock" class="icon unlock" />');
					} else {
						this.$el.append('<a href="#lock" class="icon lock" />');
					}
					
				
				// Buyable
				} else if (this.model.isBuyable()) {
					this.$el.append('<a href="#buy" class="icon buy" />');
				
				// Boostable
				} else if (this.model.isTrainable()) {
					this.$el.append('<a href="#train" class="icon train" />');
				} 
			}
			
			
			// Show modded parts on permanent weapon
			if (this.options.showAdditional) {
				if (this.model.isCustomizable()) {
					this.createView(APP.View.WeaponSlots, {
						container: this.el,
						model: this.model
					}).render().attach();
				}
				
				// Promted
				if (this.model.isPromoted()) {
					this.el.appendChild(this.make('span', {
						'class': 'promotion ' + this.model.get('promotionType')
					}, this.model.get('promotionLabel')));
				}
			}
			
			
			// Show Name?
			if (this.options.showName) {
				$bar.append('<span class="name">' + this.model.get('name') + '</span>');
				$bar.append('<span class="category">' + this.model.get('categoryname') + '</span>');
				$bar.appendTo(this.el);
			}
			
			if (this.options.itemSize === 'med' && (!this.model.isLocked() || this.model.isOwned() || this.model.isExpired())) {
				this.silhouette = this.make('img', {
					'class'	: 'silhouette',
					'width'	: 1,
					'height': 1,
					'src'	: nsConfig.imageFolder + 'game/1x1-transparent.png'
				});
				this.el.appendChild(this.silhouette);
				
				this.silhouette.ondragstart = function () {
					return false;
				};
			}
			
			this.image = this.make('img', {
				'class'	: 'item',
				'width'	: 1,
				'height': 1,
				'src'	: nsConfig.imageFolder + 'game/1x1-transparent.png'
			});
			this.el.appendChild(this.image);
			if (this.model.isLocked()) {
				this.image.ondragstart = function () {
					return false;
				};
			}
			
			
			
			
			// Render image
			this.renderImage();
		}
	});
}(this));

/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule weapons
 */
/**
 * @class GAME.Task.weapons
 * @uses GAME.Task.items
 */
APP.task('weapons', [ 'items' ], function taskWeapons(done) {
	"use strict";
	
	
	var win = APP.win,
		$ = APP.$,
		_ = APP._,
		nsWeapons = APP.ns('weapons'),
		nsItems = APP.ns('items'),
		
		$main = nsWeapons.$el = $('<div>').addClass('main main_weapons page hidden loading').appendTo('#frontend'),
		$panelLeft = nsWeapons.$panelLeft = $('<div>').addClass('page-panel left').appendTo($main),
		$panelRight = nsWeapons.$panelRight = $('<div>').addClass('page-panel right').appendTo($main),
		
		// Get Weapons Collection
		collection = nsWeapons.collection = nsItems.collection.by('itemType', 'weapon'),
		
		selected = collection.at(0).id,
		getSelected = nsWeapons.getSelected = function getSelected() {
			return selected;
		},
		
		/**
		 * Attachment Tooltip
		 */
		attachmentTooltip = nsWeapons.attachmentTooltip = new APP.View.AttachmentTooltip().attach();
		
	/**
	 *
	 */
	nsWeapons.bind('select', function (model) {
		selected = nsWeapons.collection.get(model);
		// Set the selected model
		nsItems.collection.setSelected('weapon', selected);
	});
	
	
	/**
	 * Collection Select Events
	 */
	nsItems.collection.bind('select:weapon', function onCollectionSelectWeapon(model) {
		if (model !== selected) {
			nsWeapons.trigger('select', model);
		}
	});
	
	
	/**
	 * On purchase end goto weapon page
	 */
	collection.bind('purchase:end', function (model) {
		APP.navigate('/weapons/' + model.id, true);
	});
	
	
	/**
	 * Select first equipped primary weapon
	 */
	if (!collection.filterBy({ 'validationGroup': 'primary' }).some(function (model) {
			if (model.isEquipped()) {
				selected = model;
				return true;
			}
		})) {
		
		selected = collection.filterBy({
			'validationGroup': 'primary'
		}).at(0);
	}
	
	
	/**
	 * Initialize
	 */
	nsWeapons.ready(function onInitializedWeapons() {
		nsWeapons.$el.removeClass('loading');
	});
	
	/**
	 * Task done!
	 */
	done();
});
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule weapons
 */
/**
 * @class GAME.Task.weapons.list
 * @uses GAME.Task.weapons
 * @uses GAME.Task.sidis
 * @uses GAME.Task.store
 */
APP.task('weapons.list', [ 'weapons', 'sidis', 'store' ], function taskWeaponsList(done) {
	"use strict";
	
	
	var doc = APP.doc,
		$ = APP.$,
		_ = APP._,
		nsWeapons = APP.namespace('weapons'),
		nsStore = APP.namespace('store'),
		nsItems = APP.namespace('items'),
		$container = nsWeapons.$panelRight,
		
		/**
		 * Main tabs
		 */
		mainTabs = nsWeapons.mainTabs = new APP.View.Tabs({
			container	: $container,
			className	: 'main-tabs',
			tabs		: [
				{ name: 'store', text: APP.sidis.trans('WEB_GAME_WEAPONS_TAB_STORE'), filter: 'buyable' },
				{ name: 'inventory', text: APP.sidis.trans('WEB_GAME_WEAPONS_TAB_INVENTORY'), filter: 'owned' }
			]
		}).attach().render(),
		
		$menuBar = $('<div>').addClass('menu-bar').appendTo($container),
		/**
		 * Category Tabs
		 */
		categoryTabs = nsWeapons.categoryTabs = new APP.View.Tabs({
			container: $menuBar,
			className: 'category-tabs'
		}).attach(),
		
		/**
		 * Filter Groups
		 */
		currentFilter = {},
		mainTabIndex = 0,
		categoryTabIndex = [ 0, 0, 0],
		
		/**
		 * Weapons list
		 */
		list = nsWeapons.list = new APP.View.ItemList({
			container	: $container,
			className	: 'selectable-list',
			collection	: nsItems.collection,
			viewClass	: APP.View.WeaponItem,
			viewOptions	: {
				itemSize: 'med'
			},
			filter		: {
				itemType: 'weapon'
			},
			selectedClassName: 'selected'
		}).attach(),
		
		
		/**
		 * Customize tooltip
		 */
		customizeTooltip = new APP.View.Tooltip({
			className: 'customize-tooltip',
			html: '<p>' + APP.sidis.trans('WEB_GAME_CLICK_TO_CUSTOMIZE') + '</p>'
		}).render().attach();
	
	
	/**
	 * Filter on main tab select
	 */
	mainTabs.bind('select', function onMainTabSelect(i, tab) {
		currentFilter = { itemType: 'weapon' };
		currentFilter[tab.filter] = true;
		
		var	categories = _.unique(nsItems.collection.filterBy(currentFilter).pluck('category')),
			order = [ 'assault_rifle', 'sniper_rifle', 'lmg', 'smg', 'shotgun', 'pistol', 'gadget', 'melee' ],
			tabs = [{
				text: APP.sidis.trans('WEB_GAME_ITEM_CATEGORY_ALL'),
				category: 'all'
			}],
			len = order.length,
			x;
		
		for (x = 0; x < len; x += 1) {
			if (_.indexOf(categories, order[x]) !== -1) {
				tabs.push({
					name: order[x],
					text: APP.sidis.trans('WEB_GAME_ITEM_CATEGORY_' + order[x].toUpperCase()),
					category: order[x]
				});
			}
		}
		
		mainTabIndex = i;
		
		categoryTabs.options.tabs = tabs;
		
		categoryTabs.render().select(categoryTabIndex[mainTabIndex]);
	});
	
	
	/**
	 * Filter on category tab select
	 */
	categoryTabs.bind('select', function onCategoryTabSelect(i, tab) {
		if (tab) {
			if (tab.category === 'all') {
				delete currentFilter.category;
			} else {
				currentFilter.category = tab.category;
			}
			
			categoryTabIndex[mainTabIndex] = i;
			
			// Filter List View
			list.filterCollection(currentFilter).render();
		}
	});
	
	
	/**
	 * Set some drag options
	 */
	list.dragOptions.containment = [ -158, 0, 882, 704 ];
	list.dragOptions.cursorAt = { left: 158, top: 77 };
		 
	/**
	 * Scroll into view
	 */
	list.bind('select', function onSelectInList(model, $el) {
		list.scrollTo($el);
	});
	
	
	/**
	 * Select item on click
	 */
	list.bind('item:click', function onItemClickTaskWeaponList(view, model) {
		nsWeapons.trigger('select', model);
	});
	
	
	/**
	 * Buy
	 */
	list.bind('item:buy', function onItemBuy(view, model) {
		nsStore.trigger('buy', model);
	});
	
	
	/**
	 * Customize
	 */
	list.bind('item:customize', function onItemCustomize(view, model) {
		nsWeapons.trigger('customize', model);
	});
	
	
	/**
	 * Listen for weapon select events
	 */
	nsWeapons.bind('select', function onSelect(model) {
		list.select(model);
	});
	
	
	/**
	 * Purchase Tooltip
	 */
	list.bind('item:buy:enter', function onBuyEnter(view, model, e) {
		/**
			name		: false
			description	: false
			dependencies: false
			stats		: false
			slots		: false
			offers		: false
			uses		: false
			time		: false
			invalid		: false
		**/
		nsItems.tooltip.renderModelAndShow(model, e.currentTarget, {
			offers	: true
		});
	});
	list.bind('item:buy:leave', function onBuyLeave() {
		nsItems.tooltip.hide();
	});
	
	
	/**
	 * Exclaim Tooltip
	 */
	list.bind('item:exclaim:enter', function onExclaimEnter(view, model, e) {
		/**
			name		: false
			description	: false
			dependencies: false
			stats		: false
			slots		: false
			offers		: false
			uses		: false
			time		: false
			invalid		: false
		**/
		nsItems.tooltip.renderModelAndShow(model, e.currentTarget, {
			time		: true,
			invalid		: true
		});
	});

	list.bind('item:exclaim:leave', function onExclaimLeave() {
		nsItems.tooltip.hide();
	});
	
	
	/**
	 * Customize Tooltip
	 */
	list.bind('item:customize:enter', function onCustomizeEnter(view, model, e) {
		customizeTooltip.show(e.currentTarget);
	});
	list.bind('item:customize:leave', function onCustomizeLeave() {
		customizeTooltip.hide();
	});
	
	
	/**
	 * Initialize
	 */
	nsWeapons.setup(function initializeWeaponList(ready) {
		// Ready once the list has been rendered
		list.once('render', ready);
		
		// Select First Tab
		mainTabs.select(0);
	});
	
	
	/**
	 * Task done!
	 */
	done();
});
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule weapons
 */
/**
 * @class GAME.Task.weapons.routes
 * @uses GAME.Task.weapons.list
 * @uses GAME.Task.weapons.info
 * @uses GAME.Task.weapons.customize
 */
APP.task('weapons.routes', [ 'weapons.list', 'weapons.info', 'weapons.customize' ], function taskWeaponsRoutes(done) {
	"use strict";
	
	
	var win = APP.win,
		$ = APP.$,
		_ = APP._,
		nsWeapons = APP.ns('weapons'),
		nsItems = APP.ns('items'),
		nsConfig = APP.ns('config'),
		primaryMap = [ 'sniper_rifle', 'assault_rifle', 'lmg', 'smg' ];
	
	/**
	 * Weapons Page
	 */
	APP.bind('page:weapons', function onPageWeapons(from, data) {
		if (from !== 'weapons') {
			APP.ns('dock').change('weapons');
			win.dontUpdateDoll = true;
			win.hideDoll();
		}
		
		// Start
		nsWeapons.start(function () {
			var model;
			
			if (data.tab) {
				nsWeapons.mainTabs.select(data.tab);
				
				if (data.categoryTab) {
					nsWeapons.categoryTabs.select(data.categoryTab);
				}
				
			} else if (data.id) {
				model = nsItems.collection.get(data.id);
				
				if (model.isOwned()) {
					nsWeapons.mainTabs.select(1);
				} else {
					nsWeapons.mainTabs.select(0);
				}
				nsWeapons.categoryTabs.select(0);
				
				nsWeapons.trigger('select', model);
				
				// Customize
				if (data.customize) {
					nsWeapons.trigger('customize', model);
				}
			}
		});
	});
	
	
	/**
	 * Weapons page
	 */
	APP.route('weapons', 'weapons', function onRouteWeapons() {
		APP.page('weapons');
	});
	
	
	/**
	 * Weapons main tab
	 */
	APP.route('weapons/:tab', 'weapons-tab', function onRouteWeaponsTab(tab) {
		APP.page('weapons', {
			tab: tab
		});
	});
	
	
	/**
	 * Weapons main tab
	 */
	APP.route('weapons/:tab/:categorytab', 'weapons-categorytab', function onRouteWeaponsTab(tab, categoryTab) {
		if (categoryTab === 'primary') {
			categoryTab = primaryMap[nsConfig.persona.kit];
		} else if (categoryTab === 'secondary') {
			categoryTab = 'pistols';
		}
		APP.page('weapons', {
			tab: tab,
			categoryTab: categoryTab
		});
	});
	
	
	/**
	 * Weapons item
	 */
	APP.route(/^weapons\/([\d]+)$/, 'weapons-id', function onRouteWeaponsId(id) {
		var model = nsItems.collection.get(id),
			url;
		
		// Check if model exists and is of type weapon
		if (model && model.isType('weapon')) {
			url = '/weapons/' + model.id  + '/' + model.get('name').toLowerCase().replace(/([\s])+/g, '-');
			
			APP.navigate(url);
			
			APP.page('weapons', {
				id: id
			});
		}
	});
	
	
	/**
	 * Weapons Customize
	 */
	APP.route('/weapons/customize/:id', 'weapons-id', function onRouteWeaponsCustomize(id) {
		var model = nsItems.collection.get(id),
			url;
		
		// Check if model exists and is of type weapon
		if (model && model.isType('weapon')) {
			APP.page('weapons', {
				id: id,
				customize: model.isCustomizable()
			});
		}
	});
	
	
	/**
	 * Task done!
	 */
	done();
});
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule weapons
 */
/**
 * @class GAME.Task.weapons.info
 * @uses weapons.list
 */
APP.task('weapons.info', [ 'weapons.list' ], function taskWeaponsInfo(done) {
	"use strict";
	
	
	var $ = APP.$,
		_ = APP._,
		nsWeapons = APP.namespace('weapons'),
		nsStore = APP.namespace('store'),
		nsItems = APP.namespace('items'),
		weaponInfoView;
	
	/**
	 * Selected is removed
	 */
	nsItems.collection.bind('remove', function onRemove(model) {
		if (nsWeapons.getSelected() === model.id) {
			nsWeapons.trigger('select', nsWeapons.list._currentCollection.at(0));
		}
	});
	
	/**
	 * Listen for weapon select events
	 */
	nsWeapons.bind('select', function onSelectWeapon(model) {
		// Ensure model
		model = nsItems.collection.get(model);
		
		if (weaponInfoView && weaponInfoView.model.id !== model.id) {
			weaponInfoView.destroy();
			weaponInfoView = nsWeapons.info = null;
		}
		
		if (!weaponInfoView) {
			
			/**
			 * Craete Weapon Info View
			 */
			weaponInfoView = nsWeapons.info = new APP.View.WeaponInfo({
				model: model,
				container: nsWeapons.$panelLeft
			}).attach();
						
			/**
			 * Show tooltips on attachments
			 */
			weaponInfoView.bind('list:mouse:enter', function (view, model, e) {
				/**
					name		: false
					description	: false
					dependencies: false
					stats		: false
					slots		: false
					offers		: false
					uses		: false
					time		: false
					invalid		: false
				**/
				nsItems.tooltip.renderModelAndShow(model, e.currentTarget, {
					name	: true,
					stats	: true,
					offers	: true,
					time	: true,
					invalid	: true
				});
			});
			weaponInfoView.bind('list:mouse:leave', function () {
				nsItems.tooltip.hide();
			});
			
			/**
			 * Buy
			 */
			weaponInfoView.bind('buy', function onCustomizeWeaponInfoView(view, model) {
				nsStore.trigger('buy', model);
			});
			weaponInfoView.bind('list:buy', function onCustomizeWeaponInfoView(view, model) {
				nsStore.trigger('buy', model);
			});
			
			/**
			 * Customize
			 */
			weaponInfoView.bind('customize', function onCustomizeWeaponInfoView(view, model) {
				nsWeapons.trigger('customize', model);
			});
		}
		
		// Render View
		weaponInfoView.render();
	});
	
	
	
	/**
	 * Initialize
	 */
	nsWeapons.ready(function onReadyWeapons() {
		// Select a weapon
		nsWeapons.trigger('select', nsWeapons.getSelected());
	});
	
	
	/**
	 * Task done!
	 */
	done();
});
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule weapons
 */
/**
 * @class GAME.Task.weapons.customize
 * @uses GAME.Task.weapons.customize.positions
 * @uses GAME.Task.weapons
 * @uses GAME.Task.store
 */
APP.task('weapons.customize', [ 'weapons.customize.positions', 'weapons', 'store' ], function taskWeaponsCustomize(done) {
	"use strict";
	
	/**
	 * Store and Inventory List
	 */
	var $ = APP.$,
		_ = APP._,
		nsStore = APP.namespace('store'),
		nsItems = APP.namespace('items'),
		nsWeapons = APP.namespace('weapons'),
		
		/**
		 * Dialog
		 */
		customizationDialogView = new APP.View.Dialog({
			className: 'invalid-attachment-dialog'
		}).attach(),
		
		customizationView;
	
	
	/**
	 * Customization Error : NOW
	 */
	customizationDialogView.bind('button:left', function onButtonLeftCustomizationDialogView() {
		customizationDialogView.hide();
		nsWeapons.trigger('customize', customizationView.model);
	});
	
	/**
	 * Customization Error : LATER
	 */
	customizationDialogView.bind('button:right', function onButtonRightCustomizationDialogView() {
		customizationDialogView.hide();
	});
	
	/**
	 * Customization
	 */
	nsWeapons.bind('customize', function (model) {
		
		// Ensure model
		model = nsItems.collection.get(model);
		
		if (customizationView) {
			customizationView.destroy();
		}
		
		/**
		 * Create the customization view
		 */
		customizationView = nsWeapons.customizationView = new APP.View.WeaponCustomize({ 
			model: model,
			getSlotPositions: nsWeapons.getSlotPositions
		});
		
		customizationView.bind('list:mouse:enter', function (view, model, e) {
			/**
				name		: false
				description	: false
				dependencies: false
				stats		: false
				slots		: false
				offers		: false
				uses		: false
				time		: false
				invalid		: false
			**/
			nsItems.tooltip.renderModelAndShow(model, e.currentTarget, {
				name	: true,
				stats	: true,
				offers	: true,
				time	: true,
				invalid	: true
			});
		});
		customizationView.bind('list:mouse:leave', function () {
			nsItems.tooltip.hide();
		});
		
		// 
		customizationView.bind('list:buy', function onListBuy(view, model) {
			nsStore.trigger('buy', model);
		});

		/**
		 * Buy
		 */
		customizationView.bind('buy', function buyListener(view, model, options) {
			// Let the store handle the buying
			nsStore.trigger('buy', model, options);
		});
		
		/**
		 * Send Items To game when closing
		 */
		customizationView.bind('detach', function onDetach() {
			var nsGame = APP.ns('game');
			
			// Give items
			nsGame.giveItems();
			
			// Save Customizations Config
			nsGame.saveCustomizations(model);
		});
		
		/**
		 * Validate on close
		 */
		customizationView.bind('close', function onCloseCustomizationView(view, model, e) {
			
			var attachmentList,
				el = e && e.currentTarget;

			if (model.isOwnedPermanent() && el && el.className.indexOf('close') === -1) {
				
				// Set Attachments
				model.set({
					'attachments': customizationView.attached
				});
				
				// Validate
				if (nsItems.collection.validateModelAttachments(model)) {
					customizationView.detach();
					
				// Invalid
				} else {
					
					// Attachment list
					attachmentList = new APP.View.AttachedList({
						model		: model,
						onlyInvalid	: true,
						showInvalid	: true
					}).render();
					
					customizationDialogView.setRenderData({
						title: APP.sidis.trans('WEB_GAME_INVALID_ATTACHMENT_DIALOG_TITLE'),
						body: [
							APP.sidis.trans('WEB_GAME_INVALID_ATTACHMENT_DIALOG_TEXT'),
							attachmentList
						],
						buttonLeft: APP.sidis.trans('WEB_GAME_INVALID_ATTACHMENT_DIALOG_FIX_NOW'),
						buttonRight: APP.sidis.trans('WEB_GAME_INVALID_ATTACHMENT_DIALOG_FIX_LATER')
					}).render().show();
				}
			}
			
			// Detach Customization View
			customizationView.detach();
		});
		
		/**
		 * Render
		 */
		customizationView.render();
		
		/**
		 * Attach
		 */
		customizationView.attach();
	});
	
	/**
	 * Task done!
	 */
	done();
});
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule weapons
 */
/**
 * @class GAME.Task.weapons.customize.positions
 * @uses GAME.Task.items
 */
APP.task('weapons.customize.positions', [ 'items' ], function taskWeaponsPositions(done) {
	"use strict";
	
	
	/**
	 *
	 * 1 = MUZZLE
	 * 2 = SCOPE
	 * 3 = BARREL
	 * 4 = AMMO
	 * 5 = STOCK
	 * 6 = TEXTURE
	 *
	 */
	
	var $ = APP.$,
		_ = APP._,
		nsItems = APP.namespace('items'),
		nsWeapons = APP.namespace('weapons'),
		
		slotNamesToNum = {
			muzzle	: 1,
			scope	: 2,
			barrel	: 3,
			ammo	: 4,
			stock	: 5,
			texture	: 6
		},
		
		slotNumsToName = {
			1 : 'muzzle',
			2 : 'scope',
			3 : 'barrel',
			4 : 'ammo',
			5 : 'stock',
			6 : 'texture'
		},
		
		positions = nsWeapons.pos = {
			base: {
				muzzle: {
					box		: [ 0, 0 ],
					start	: [ 200, 100 ],
					stop	: [ 300, 25 ]
				},
				scope: {
					box		: [ 400, 0 ],
					start	: [ 180, 82 ],
					stop	: [ 300, 25 ]
				},
				barrel: {
					start	: [ 230, 370 ],
					stop	: [ 80, 410 ]
				},
				ammo: {
					start	: [ 500, 420 ],
					stop	: [ 245, 475 ]
				},
				stock: {
					start	: [ 800, 380 ],
					stop	: [ 755, 455 ]
					
				},
				texture: {
					start	: [ 600, 360 ],
					stop	: [ 412, 540 ]
				}
			}
		},
		
		/**
		 * Get Position
		 */
		get = nsWeapons.getSlotPositions = function getSlotPositions(key) {
			
			var model,
				category;
			
			if (positions.hasOwnProperty(key)) {
				return positions[key];
			}
			
			model = nsItems.collection.get(key);
			
			if (model) {
				if (positions.hasOwnProperty(model.id)) {
					return positions[model.id];
				}
				
				category = model.get('category');
				
				if (positions.hasOwnProperty(category)) {
					return positions[category];
				}
			}
			
			return positions.base;
		},
		
		/**
		 * Add Position
		 */
		add = nsWeapons.addSlotPosition = function addSlotPositions(key, baseKey, props) {
			if (positions.hasOwnProperty(key)) {
				throw new Error('Position for key "' + key + '" already exists!');
			}
			
			var pos = _.extend({}, get(baseKey));
			
			_.forEach(props || {}, function (value, slot) {
				pos[slot] = _.extend({}, pos[slot], value);
			});
			
			positions[key] = pos;
			
			return positions[key];
		};
	
	
	/**
	 * Assault Rifle
	 */
	add('assault_rifle', 'base', {
		
	});
	
	// G3A4
	add(3005, 'assault_rifle', {
		scope: { box: [380, 0] },
		stock: { start: [810, 351] },
		ammo: { start: [513, 405] },
		barrel: { start: [182, 331] }
	});
	
	// M16A2
	add(3001, 'assault_rifle', {
		scope: { box: [360, 0] },
		stock: { start: [800, 350] },
		ammo: { start: [540, 420] },
		barrel: { start: [230, 325] }
	});
	//// M16A2 +3
	add(3095, 3001, {});	
	
	// AEK-971
	add(3007, 'assault_rifle', {
		scope: { box: [380, 0] },
		stock: { start: [800, 360] },
		ammo: { start: [550, 406] },
		barrel: { start: [260, 331] }
	});
	//// AEK-971 +3
	add(3096, 3007, {});
	
	// SCAR-L
	add(3011, 'assault_rifle', {
		scope: { box: [310, 0] },
		stock: { start: [800, 360] },
		ammo: { start: [484, 450] },
		barrel: { start: [230, 340] }
	});
	//// SCAR-L +3
	add(3093, 3011, {});
	
	// STG77AUG
	add(3046, 'assault_rifle', {
		scope: { box: [250, 0] },
		stock: { start: [790, 370] },
		ammo: { start: [666, 440] },
		barrel: { start: [285, 338] }
	});
	//// STG77AUG +3
	add(3094, 3046, {});
	
	// M4A1
	add(3062, 'assault_rifle', {
		scope: { box: [340, 0] },
		stock: { start: [830, 345] },
		ammo: { start: [530, 440] },
		barrel: { start: [250, 325] }
	});
	//// M4A1 +3
	add(3097, 3062, {});
	
	// AN-94 Abakan
	add(3067, 'assault_rifle', {
		scope: { box: [360, 0] },
		stock: { start: [820, 360] },
		ammo: { start: [570, 420] },
		barrel: { start: [260, 326] }
	});
	//// AN-94 Abakan +3
	add(3098, 3067, {});
	
	// 416-Carbine
	add(3071, 'assault_rifle', {
        scope: { box: [315, 0] },
		stock: { start: [780, 340] },
		ammo: { start: [488, 450] },
		barrel: { start: [216, 333] }
	});
	//// 416-Carbine +3
	add(3099, 3071, {});
	
	// XM8
	add(3075, 'assault_rifle', {
		scope: { box: [330, 0] },
		stock: { start: [760, 360] },
		ammo: { start: [512, 452] },
		barrel: { start: [262, 355] }
	});
	//// XM8 +3
	add(3100, 3075, {});
	
	// AK-47
	add(3110, 'assault_rifle', {
		scope: { box: [380, 0] },
		stock: { start: [790, 369] },
		ammo: { stop: [225, 475] },
		barrel: { start: [203, 329] }
	});
    
    // F2000
    add(3114, 'assault_rifle', {
        scope: { box: [225, 0] },
        stock: { start: [730, 388] },
        ammo: { start: [629, 468] },
        barrel: { start: [230, 341] }
    });
    
    // FAMAS
    add(3120, 'assault_rifle', {
        scope: { box: [290, 0] },
        stock: { start: [800, 355] },
        ammo: { start: [669, 445] },
        barrel: { start: [205, 337] }
    });

	// L85A2
	add(3127, 'assault_rifle', {
		scope: { box: [370, 0] },
		stock: { start: [800, 350] },
		ammo: { start: [667, 460] },
		barrel: { start: [230, 337] }
	});

    // ACW-R
    add(3132, 'assault_rifle', {
        scope: { box: [419, 0], stop: [285, 25] },
        stock: { start: [800, 333] },
        ammo: { start: [540, 460] },
        barrel: { start: [230, 337] }
    });

    // A-91
    add(3133, 'assault_rifle', {
        scope: { box: [290, -13], stop: [350, 55] },
        stock: { start: [814, 380], stop: [755, 470] },
        ammo: { start: [650, 465] },
        barrel: { start: [275, 356] }
    });
	
	
	/**
	 * LMG
	 */
	add('lmg', 'base', {
		
	});
	// M249 SAW
	add(3003, 'lmg', {
		scope: { box: [345, 0] },
		stock: { start: [820, 370] },
		ammo: { start: [516, 420] },
		barrel: { start: [248, 343] }
	});
	//// M249 SAW +3
	add(3074, 3003, {});
	
	// MG3
	add(3013, 'lmg', {
		scope: { box: [365, 0] },
		stock: { start: [800, 350] },
		ammo: { start: [586, 413] },
		barrel: { start: [310, 350] }
	});
	// PKM
	add(3014, 'lmg', {
		stock: { start: [836, 366] },
		ammo: { start: [553, 445] },
		barrel: { start: [310, 344] }
	});
	//// PKM +3
	add(3080, 3014, {});
	
	// M60
	add(3015, 'lmg', {
		scope: { box: [435, 0], stop: [-100, 25] },
		stock: { start: [830, 360] },
		ammo: { start: [598, 402] },
		barrel: { start: [270, 352] }
	});
	//// M60 +3
	add(3079, 3015, {});
	
	// MG36
	add(3048, 'lmg', {
		stock: { start: [840, 357] },
		ammo: { start: [569, 411] },
		barrel: { start: [240, 350] }
	});
	//// MG36 +3
	add(3101, 3048, {});
	
	// M240B
	add(3063, 'lmg', {
		stock: { start: [850, 347] },
		ammo: { start: [562, 387] },
		barrel: { start: [230, 332] }
	});
	//// M240B +3
	add(3081, 3063, {});
	
	// QJY-88
	add(3068, 'lmg', {
		scope: { box: [475, 0], stop: [-100, 25] },
		stock: { start: [871, 364] },
		ammo: { start: [614, 437] },
		barrel: { start: [279, 331] }
	});
	//// QJY-88 +3
	add(3082, 3068, {});
	
	// FN MINI PARA
	add(3072, 'lmg', {
		scope: { box: [350, 0] },
		stock: { start: [840, 357] },
		ammo: { start: [530, 435] },
		barrel: { start: [240, 334] }
	});
	//// FN MINI PARA +3
	add(3083, 3072, {});
	
	// XM8AR
	add(3076, 'lmg', {
		scope: { box: [440, 0], stop: [-140, 25] },
		stock: { start: [820, 360] },
		ammo: { start: [582, 414] },
		barrel: { start: [217, 358] }
	});
	//// XM8AR +3
	add(3084, 3076, {});

    // RPK
    add(3113, 'lmg', {
        scope: { box: [430, 0], stop: [-170, 25] },
        stock: { start: [870, 395] },
        ammo: { start: [584, 442] },
        barrel: { start: [250, 341] }
    });

    // M27 IAR
    add(3116, 'lmg', {
        scope: { box: [355, 0] },
        stock: { start: [817, 342] },
        ammo: { start: [530, 470] },
        barrel: { start: [190, 332] }
    });
    
    // QBB-95
    add(3121, 'lmg', {
        scope: { box: [355, -20] },
        stock: { start: [867, 369] },
        ammo: { start: [735, 470] },
        barrel: { start: [230, 363] }
    });

	// Pecheneg
	add(3128, 'lmg', {
		scope: { box: [460, 0], stop: [-240, 25] },
		stock: { start: [867, 375] },
		ammo: { start: [551, 450] },
		barrel: { start: [287, 348] }
	});

    // L86A2
    add(3135, 'lmg', {
        scope: { box: [420, 0], stop: [270, 25] },
        stock: { start: [874, 366], stop: [755, 485] },
        ammo: { start: [718, 433] },
        barrel: { start: [270, 331] }
    });

    // LSAT
    add(3134, 'lmg', {
        scope: { box: [400, 0], stop: [300, 25] },
        stock: { start: [860, 336], stop: [745, 455] },
        ammo: { start: [550, 438] },
        barrel: { start: [224, 328] }
    });
    

	
	/**
	 * SMG
	 */
	add('smg', 'base', {
		scope: { box: [325, 0] }
	});
	// PP-2000
	add(3018, 'smg', {
		scope: { box: [353, 0] },
		ammo: { start: [533, 410] },
		barrel: { start: [329, 331] },		
		stock: { start: [776, 375] }
	});
	
	// UZI
	add(3064, 'smg', {
		ammo: { start: [560, 400] },
		barrel: { start: [310, 334] },		
		stock: { start: [711, 380] }
	});
	//// UZI +3
	add(3089, 3064, {});
	
	// XM8c
	add(3078, 'smg', {
		scope: { box: [395, 0] },
		ammo: { start: [525, 460] },
		barrel: { start: [295, 358] },		
		stock: { start: [695, 335] }
	});
	//// XM8c +3
	add(3092, 3078, {});
	
	// MP7
	add(3016, 'smg', {
		scope: { box: [245, 0] },
		ammo: { start: [536, 430] },
		barrel: { start: [317, 344] },		
		stock: { start: [750, 334] }
	});
	//// MP7 +3
	add(3086, 3016, {});
	
	// MP5
	add(3047, 'smg', {
		scope: { box: [295, 0] },
		ammo: { start: [461, 456] },
		barrel: { start: [240, 348] }
	});
	//// MP5 +3
	add(3088, 3047, {});
	
	// AKS-74U
	add(3069, 'smg', {
		scope: { box: [365, 0] },
		ammo: { start: [478, 435] },
		barrel: { start: [242, 333] },		
		stock: { start: [800, 367] }
	});
	//// AKS-74U +3
	add(3090, 3069, {});	
	
	// 9A-91
	add(3073, 'smg', {
		scope: { box: [305, 0] },
		ammo: { start: [482, 420] },
		barrel: { start: [350, 326] },		
		stock: { start: [770, 363] }
	});
	//// 9A-91 +3
	add(3091, 3073, {});
	
	// FN P90
	add(3017, 'smg', {
		scope: { box: [118, 0] },
		ammo: { start: [544, 357] },
		barrel: { start: [230, 388] },		
		stock: { start: [730, 407] }
	});
	//// FN P90 +3
	add(3087, 3017, {});
	
	// UMP45
	add(3012, 'smg', {
		scope: { box: [295, 0] },
		ammo: { start: [460, 450], stop: [185, 475] },
		barrel: { start: [303, 343] },
		stock: { start: [790, 368] },
		texture: { stop: [490, 540] }
	});
	//// UMP45 +3
	add(3085, 3012, {});
	
	// PP-19
	add(3112, 'smg', {
		scope: { box: [355, 0] },
		ammo: { start: [390, 393] },
		barrel: { start: [217, 349] }
	});

    // PDW-R
    add(3117, 'smg', {
        scope: { box: [134, 0], stop: [420, 25] },
        stock: { start: [810, 391] },
        ammo: { start: [660, 476], stop: [235, 485] },
        barrel: { start: [210, 356], stop: [60, 430] }
    });
    
    // As Val
    add(3122, 'smg', {
        scope: { box: [335, 40], stop: [320, -5] },
        stock: { start: [786, 394] },
        ammo: { start: [520, 434] },
        barrel: { start: [290, 354] }
    });

	// G53
	add(3129, 'smg', {
		scope: { box: [317, -10] },
		stock: { start: [768, 331] },
		ammo: { start: [457, 434], stop: [175, 475] },
		barrel: { start: [355, 330], stop: [80, 380] }
	});

    // M5K
    add(3137, 'smg', {
        scope: { box: [310, 0] },
        stock: { start: [639, 334], stop: [755, 365] },
        ammo: { start: [460, 460], stop: [185, 475] },
        barrel: { start: [380, 315] }
    });

    // MTAR
    add(3136, 'smg', {
        scope: { box: [230, 0] },
        stock: { start: [770, 340], stop: [745, 475] },
        ammo: { start: [634, 490] },
        barrel: { start: [230, 362], stop: [80, 420] }
    });
	
	
	
	/**
	 * Sniper Rifle
	 */
	add('sniper', 'base', {
		
	});
	// SV-98
	add(3004, 'sniper', {
		scope: { box: [440, 0], stop: [-195, 25] },
		ammo: { start: [637, 407] },
		barrel: { start: [270, 339] },		
		stock: { start: [840, 405] }
	});
	
	// M110
	add(3066, 'sniper', {
		scope: { box: [320, 0] },
		ammo: { start: [538, 430] },
		barrel: { start: [350, 342] },		
		stock: { start: [780, 370] }
	});
	//// M110 +3
	add(3107, 3066, {});
		
	// VSS Vintorez
	add(3070, 'sniper', {
		scope: { box: [353, 0] },
		ammo: { start: [526, 414] },
		barrel: { start: [290, 358] },		
		stock: { start: [750, 407] }
	});
	//// VSS Vintorez +3
	add(3108, 3070, {});
		
	// GOL
	add(3077, 'sniper', {
		scope: { box: [344, 0]},
		ammo: { start: [609, 353] },
		barrel: { start: [230, 334] }
	});
	//// GOL +3
	add(3109, 3077, {});
		
	// SVD
	add(3023, 'sniper', {
		ammo: { start: [616, 413] },
		barrel: { start: [230, 365] },
		stock: { start: [820, 397] }
	});
	//// SVD +3
	add(3104, 3023, {});
		
	// M95
	add(3022, 'sniper', {
		scope: { box: [290, 0] },
		ammo: { start: [792, 425] },
		barrel: { start: [285, 354] },
		stock: { start: [888, 352], stop: [700, 500] }
	});
	//// M95 +3
	add(3102, 3022, {});
		
	// M24
	add(3024, 'sniper', {
		scope: { box: [384, 0] },
		ammo: { start: [640, 352] },
		barrel: { start: [230, 355] },
		stock: { start: [868, 402] }
	});
	//// M24 +3
	add(3103, 3024, {});
		
	// M14 EBR
	add(3065, 'sniper', {
		ammo: { start: [620, 430] },
		barrel: { start: [206, 340] },
		stock: { start: [913, 396] }
	});
	//// M14 EBR +3
	add(3106, 3065, {});
		
	// SVU-A
	add(3045, 'sniper', {
		scope: { box: [330, 0] },
		ammo: { start: [679, 403] },
		barrel: { start: [213, 358] },
		stock: { start: [820, 370] }
	});
	//// SVU-A +3
	add(3105, 3045, {});
		
	// L96A1
	add(3111, 'sniper', {
		scope: { box: [390, 0] },
		ammo: { start: [628, 406] },
		barrel: { start: [270, 342] },
		stock: { start: [860, 380], stop: [755, 475] }
	});

    // SKS
    add(3119, 'sniper', {
        scope: { box: [415, 0], stop: [-220, 25] },
        ammo: { start: [547, 423] },
        barrel: { start: [272, 343] },
        stock: { start: [907, 381] }
    });

	// L82A3
	add(3126, 'sniper', {
		scope: { box: [388, 0], stop: [-220, 25] },
		ammo: { start: [647, 423] },
		barrel: { start: [272, 350] },
		stock: { start: [907, 351] }
	});

    // JNG-90
    add(3139, 'sniper', {
        scope: { box: [354, 20] },
        ammo: { start: [605, 395] },
        barrel: { start: [305, 349] },
        stock: { start: [810, 400], stop: [755, 475] }
    });

    // M98B
    add(3138, 'sniper', {
        scope: { box: [400, 20] },
        ammo: { start: [640, 405] },
        barrel: { start: [260, 347] },
        stock: { start: [929, 384], stop: [725, 480] }
    });
	
	
	/**
	 * Task done!
	 */
	done();
});
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule servers
 */
(function createServerModel(root) {
	"use strict";
	
	
	// Node support
	if (typeof require !== 'undefined') {
		if (!root.APP) {
			root.APP = require('./../common/app');
		}
		
		if (!root.APP.Model) {
			root.APP.Model = require('./../common/model');
		}
	}
	
	var APP = root.APP,
		win = APP.win,
		parent = APP.Model.prototype,
		_ = APP._,
		nsConfig = APP.namespace('config'),
        nsServers = APP.namespace('servers'),
		bookmarksEvent = _.extend({}, APP.Backbone.Events);
	
	// Bind game event onPingResponse
    if (win.matchmaking) {
		
		win.onPingResponse = function (ip, ms) {
			APP.trigger('ping', ip, ms);
			APP.trigger('ping:' + ip, ip, ms);
		};	
        win.matchmaking.addEventHandler('onPingResponse', 'onPingResponse');
    }
	
	// Bind game event onServerAdded
    if (win.bookmarks) {
		
		// Add
		win.onServerAdded = function (response, guid) {
			bookmarksEvent.trigger('added:' + guid, response);
		};
        win.bookmarks.addEventHandler('onServerAdded', 'onServerAdded');
		
		// Remove
		win.onServerRemoved = function (response, guid) {
			bookmarksEvent.trigger('removed:' + guid, response);
		};
        win.bookmarks.addEventHandler('onServerRemoved', 'onServerRemoved');
    }
	
	
	/**
	 * Model: Server
	 */
	APP.Model.Server = APP.Model.extend({
		normalizeKeys: {
			'persistentId': 'id',
			'gameId': 'gameId',
			'passwordprotected': 'hasPassword',
			'map': 'currentMapName'
			
		},
		defaults: {
			'gameId': null,
			'name': '',
			'mapList': [],
            'mapIndex': null,
			'roundsPerMap': null,
			'currentRound': null,
			'gameMode': null,
			'ranked': false,
			'hasPassword': false,
			'players': null,
			'capacity': null,
			'pingSite': null,
			'ip': null,
			'online': false,
			'isVIP': false,
			'bookmarked': false,
			'currentMap': null,
			'currentMapName': null,
			'currentGameMode': null,
			'nextMap': null,
			'nextGameMode': null,
			'ping': null,
			'pingState': -1,
			'gameRoster': []
		},
		
		schema: {
			'name'	: 'string',
			
			'mapIndex'			: 'number',
			'roundsPerMap'		: 'number',
			'currentRound'		: 'number',
			'gameMode'			: 'number',
			'players'			: 'number',
			'capacity'			: 'number',
			'currentMap'		: 'number',
			'currentGameMode'	: 'number',
			'nextMap'			: 'number',
			'nextGameMode'		: 'number',
			'ping'				: 'number',
			'pingState'			: 'number',
			
			'ranked'		: 'bool',
			'hasPassword'	: 'bool',
			'online'		: 'bool',
			'isVIP'			: 'bool',
			'bookmarked'	: 'bool'
		},
		
		initialize: function initializeServerModel() {
			
			this.bind('change:currentMap', this._setCurrentMapName, this);
			this.bind('change:mapList', this._formatMapList, this);
			this.bind('change:online', this._checkOffline, this);
			this.bind('change:mapIndex', this._formatMapList, this);
			
			this.bind('change:ping', this._onChangePing, this);
			
			this.bind('remove', this._onRemove, this);

            this._maps = this.constructor.maps;
            this._gameModes = this.constructor.gameModes;
            
			bookmarksEvent.bind('added:' + this.id, this._onBookmarkAdded, this);
			bookmarksEvent.bind('removed:' + this.id, this._onBookmarkRemoved, this);
			
			this._setCurrentMapName();
			this._formatMapList();
			this._checkOffline();
		},
		
		_onChangePing: function _onChangePingServerModel() {
			if (this.get('ping') < 0) {
				this.set({ 'ping': 9999 }, { 'silent': true });
			}
		},
		
		_onRemove: function _onRemoveServerModel() {
			if (!(this.collection instanceof APP.Collection)) {
				bookmarksEvent.unbind('added:' + this.id, this._onBookmarkAdded);
				bookmarksEvent.unbind('removed:' + this.id, this._onBookmarkRemoved);
			}
		},
		
		_onBookmarkAdded: function _onBookmarkAddedServerModel(respone) {
			this.set({'bookmarked': true});
		},
		
		_onBookmarkRemoved: function _onBookmarkRemovedServerModel(respone) {
			this.set({'bookmarked': false});			
		},
		
		_setCurrentMapName: function _setCurrentMapNameServerModel() {
			var currentMap = this.get('currentMap');
			if (currentMap) {
				this.set('currentMapName', APP.sidis.trans(this._maps[currentMap]), {
					silent: true
				});
			}
		},
		
		_formatMapList: function _formatMapListServerModel() {
			var mapList = this.get('mapList'),
				mapIndex = this.get('mapIndex'),
				formattedMapList = _.map(mapList, function (map, i) {
					var mapObj,
						mapId,
						gameModeId;
					
					
					if (_.isString(map)) {
						// Split the map on :
						map = map.split(':');
						// First part is the map id
						mapId = map[0];
						// Second part is game mode
						gameModeId = map[1];
						
						// Create map obj
						mapObj = {
							id: 'round-' + i,
							map_id: mapId,
							name: APP.sidis.trans(this._maps[mapId]),
							gameModeId: gameModeId,
							gameModeName: APP.sidis.trans(this._gameModes[gameModeId]),
							order: i
						};
					
					// It's the cached version
					} else {
						mapObj = map;
					}
					
					mapObj.current = (mapIndex === i);
					
					return mapObj;
				}, this);
			
			// TODO: Handle this better "silent = true"
			// this.attributes.mapList = formatedMapList;
			this.set('mapList', formattedMapList, {
				silent: true
			});
		},
		
		_checkOffline: function _checkOfflineServerModel() {
			if (!this.get('online')) {
				this.set('pingState', -1, {
					silent: true
				});
			}
		},
		
		url: function urlServerModel() {
			if (win.game) {
				return nsConfig.serverInfoUrl + '?persistentId=' + this.id;
			}
			return 'http://battlefield.play4free.com/static/server-info.json';
		},
		
		addBookmark: function addBookmarkServerModel() {
			if (win.bookmarks) {
				win.bookmarks.add(this.id);
			}
			return this;
		},
		
		removeBookmark: function removeBookmarkServerModel() {
			if (win.bookmarks) {
				win.bookmarks.remove(this.id);
			}
			return this;
		},
		
		toggleBookmark: function toggleBookmarkServerModel() {
			if (this.get('bookmarked')) {
				this.removeBookmark();
			} else {
				this.addBookmark();
			}
			return this;
		},
		
		ping: function pingServerModel() {
			var ip = this.get('ip'),
				ping = this.get('ping') || 9999;
			
			// Listen to ping events for this IP
			APP.once('ping:' + ip, function (ip, ms) {
				this.set('ping', ms);
			}, this);
			
			// Set "dummy" ping
			this.set({
				'ping': ping
			});
			
			// Trigger Pinging
			if (win.matchmaking) {
				win.matchmaking.pingGameServers(JSON.stringify([ ip ]));
			} else {
				_.delay(function () {
					var ms = Math.floor(Math.random() * 300);
					APP.trigger('ping', ip, ms);
					APP.trigger('ping:' + ip, ip, ms);
				}, APP.randomInt(500, 1000));
			}

			return this;
		},
		
		parse: function parseServerModel(response) {
			// Response is full server info
			if (response && response.data && response.data.hasOwnProperty('gameRoster')) {
				response.data.gameRoster = _.values(response.data.gameRoster);
				return response.data;
			}
			
			return response;
		}
	}, {
        /**
         * MAPS
         */
        maps: {
            1: 'WEB_GAME_SERVERBROWSER_MAPS_1',
            2: 'WEB_GAME_SERVERBROWSER_MAPS_2',
            3: 'WEB_GAME_SERVERBROWSER_MAPS_3',
            4: 'WEB_GAME_SERVERBROWSER_MAPS_4',
            5: 'WEB_GAME_SERVERBROWSER_MAPS_5',
            6: 'WEB_GAME_SERVERBROWSER_MAPS_6',
            7: 'WEB_GAME_SERVERBROWSER_MAPS_7',
            8: 'WEB_GAME_SERVERBROWSER_MAPS_8'
        },

        /**
         * GAME MODES
         */
        gameModes: {
            1: 'WEB_GAME_SERVERBROWSER_MODE_1',
			2: 'WEB_GAME_SERVERBROWSER_MODE_2'
        }
    });
	
	/**
	 * Module support
	 */
	if (typeof module !== 'undefined' && module.exports) {
		module.exports = APP.Model.Server;
	}
}(this));

/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule servers
 */
(function createPlayerModel(win) {
	"use strict";
	
	
	if (!win.APP && (typeof require !== 'undefined')) {
		win.APP = require('./../common/app');
	}
	
	var APP = win.APP,
		parent = APP.Model.prototype,
		_ = APP._;
    
	
	/**
	 * Model: Player
	 */
	APP.Model.Player = APP.Model.extend({
		defaults: {
			'kit': null,
			'level': null,
			'name': null,
			'state': null
		},
		schema: {
			'kit'	: 'number',
			'level'	: 'number'
		}
	});
	
	/**
	 * Module support
	 */
	if (typeof module !== 'undefined' && module.exports) {
		module.exports = APP.Model.Item;
	}
}(this));

/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule servers
 */
(function createFilterModel(win) {
	"use strict";
	
	
	if (!win.APP && (typeof require !== 'undefined')) {
		win.APP = require('./../common/app');
	}
	
	var APP = win.APP,
		parent = APP.Model.prototype,
		_ = APP._,
		defaults = {
			'name': '',
			'tab': 'browser',
            'hideEmpty': true,
            'hideFull': true,
            'showUnranked': false,
            'hidePwd': false,
            'onlyVip': false,
            'geo': 'gva',
            'maps': [],
            'gamemodes': [],
            'onlyVipBookmarked': false,
            'showOffline': false
		};
    
	
	/**
	 * Model: Server Filter
	 */
	APP.Model.ServerFilter = APP.Model.extend({
		schema: {
			'hideEmpty'			: 'bool',
			'hideFull'			: 'bool',
			'showUnranked'		: 'bool',
			'hidePwd'			: 'bool',
			'onlyVip'			: 'bool',
			'onlyVipBookmarked'	: 'bool',
			'showOffline'		: 'bool'
		},
        initialize: function initialize(attributes, options) {
            
			// Retrieve set filter attributes for this session
			var prevAttrs,
				nsConfig = APP.ns('config');
			/**
			if (options.storageKey) {
				prevAttrs = APP.win.sessionStorage.getItem(options.storageKey);
				
				if (prevAttrs) {
					this.set(JSON.parse(prevAttrs), {'silent': true});
				}
				
				this.bind('change', function (model) {
					APP.win.sessionStorage.setItem(options.storageKey, JSON.stringify(model.toJSON()));
				});				
			}
			**/
			
			this.bind('change:showUnranked', function (model) {
				if (!model.get('showUnranked')) {
					model.set({'hidePwd': false}, {'silent': true});
				}
			});
        }
        
	});
	
	/**
	 * Module support
	 */
	if (typeof module !== 'undefined' && module.exports) {
		module.exports = APP.Model.Item;
	}
}(this));

/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule servers
 */
(function (root) {
	"use strict";
	
	
	if (!root.APP && (typeof require !== 'undefined')) {
		root.APP = require('./../common/app');
	}
	
	if (!root.APP.Model && (typeof require !== 'undefined')) {
		root.APP.Collection = require('./../common/collection');
	}
	
	if (!root.APP.Model.Server && (typeof require !== 'undefined')) {
		root.APP.Model.Server = require('./model.server');
	}
	
	var APP = root.APP,
		win = APP.win,
		_ = APP._,
		$ = APP.$,
		nsConfig = APP.namespace('config');
	
	APP.Collection.Servers = APP.Collection.extend({
		_selected: null,
		model: APP.Model.Server,
		
		initialize: function initializeServersCollection(data, options) {
			options = options || {};
			if (options.handlePing) {
				APP.bind('ping', function onPing(ip, ms) {
					var attrs = {
							ping: ms,
							pingState: 1
						},
						collection = this,
						filtered = this.filterBy({
							ip: ip
						});
					
					if (filtered.length !== 0) {
						filtered.forEach(function (model) {
							model.set(attrs);
						});
						collection.trigger('ping', collection);
					}
				}, this);
			}
            this.options.handlePing = false;
			
			this.bind('ping', this._onPing, this);
		},
		
		_onPing: function () {
			var hasPending = this.some(function (model) {
					return model.get('pingState') === 0;
				}),
				cacheKey,
				data;
			/**
			if (!hasPending && win.sessionStorage) {
				cacheKey = this.url();
				data = this.at(0).collection.toJSON();
				win.sessionStorage.setItem(cacheKey, JSON.stringify(data));
			}
			**/
		},
		
		url: function urlServersCollection() {
			if (win.game) {
				return nsConfig.serverListUrl + '?gameVersion=' + nsConfig.gameVersion;
			}
			return 'http://battlefield.play4free.com/static/servers.json';
		},
		
		parse: function parseServersCollection(resp, xhr) {
			if (resp && resp.hasOwnProperty('data')) {
				return _.values(resp.data);
			}
			return resp;
		},
		ping: function pingServersCollection() {
			
			var pingables = this.filterBy({
					pingState: -1
				}),
				ips = pingables.getIPs();
			
			pingables.setAll({
				ping: 9999,
				pingState: 0
			}, { 'silent': true });
			
			if (win.matchmaking) {
				win.matchmaking.pingGameServers(JSON.stringify(ips));
			} else {
				_.forEach(ips, function (ip) {
					if (ip && ip.length > 6) {
						_.delay(function () {
							var ms = Math.floor(Math.random() * 300);
							APP.trigger('ping', ip, ms);
						}, APP.randomInt(200, 1000));
					}
				});
			}
			
			return this;
		},
		getIPs: function getIPsServersCollection() {
			return _.unique(this.pluck('ip'));
		},
		
		setSelected: function setSelectedServersCollection(model) {
			model = this.get(model);
			this._selected = model;
			
			this.trigger('select', model);
			
			return this;
		},
		getSelected: function getSelectedServersCollection() {
			return this._selected;
		},
		filterByValidator: function filterByValidatorServersCollection(value, key, model) {
			var i,
				len,
				name;
			
			/**
			 * Tab
			 */
			if (key === 'tab') {
				if (value === 'bookmarks') {
					return model.get('bookmarked');
				}
				return true;
			}			
			
			/**
			 * Hide Password
			 */
			if (key === 'hidePwd') {
				if (value) {
					return !model.get('hasPassword');
				}				
				return true;
			}			
			
			/**
			 * Hide Empty
			 */
			if (key === 'hideEmpty') {
				if (value) {
					return model.get('players') !== 0;
				}				
				return true;
			}
			
			/**
			 * Hide Full
			 */
			if (key === 'hideFull') {
				if (value) {
					return model.get('players') !== model.get('capacity');
				}				
				return true;
			}
			
			/**
			 * Show Offline
			 */
			if (key === 'showOffline') {
				if (value) {
					return true;
				}				
				return model.get('online');
			}
			
			/**
			 * Only VIP
			 */	
			if (key === 'onlyVip') {
				if (value) {
					return model.get('isVIP');
				}				
				return true;
			}
			
			/**
			 * Show Unranked
			 */	
			if (key === 'showUnranked') {
				if (value) {
					return true;
				}				
				return model.get('ranked');
			}
			
			/**
			 * GEO
			 */
			if (key === 'geo') {
				return (value === model.get('pingSite'));
			}
			
			/**
			 * Maps
			 */
			if (key === 'maps') {
				return _.indexOf(value, model.get('currentMap')) !== -1;
			}
			
			/**
			 * Game Modes
			 */
			if (key === 'gamemodes') {
				return _.indexOf(value, model.get('currentGameMode')) !== -1;
			}
			
			/**
			 * Name
			 */
            if (key === 'name') {
				value = (value || '').toLowerCase().trim().split(/[\s]+/);
				name = (model.get('name') || '').toLowerCase();
				for (i = 0, len = value.length; i < len; i += 1) {		
					if (name.indexOf(value[i]) === -1) {
						return false;
					}
				}
				return true;
            }
			
			/**
			 * Default
			 */
			if (model.get(key) !== value) {                            
                return false;
            }
			
            return true;
        },

		/**
		sync: function syncServersCollection(method, model, options) {
			
			var cacheKey = this.url(),
				cachedServers;
			
			if (method === 'read' && this.length === 0 && win.sessionStorage && win.sessionStorage[cacheKey]) {
				cachedServers = win.sessionStorage.getItem(cacheKey);
				if (cachedServers) {
					_.defer(function () {
						cachedServers = JSON.parse(cachedServers);
						options.success(cachedServers);
					});
					return this;
				}
			}
			
			return APP.Backbone.sync.apply(this, arguments);
		},
		 **/
		
		reload: function reloadServersCollection(options) {
			options = options || {};
			
			if (!options.silent) {
				this.trigger('reload:before', this);
			}
			
			// TODO: Fix the following code
			var collection = this,
				Model = this.model;
			
			$.ajax({
				url: typeof this.url === 'function' ? this.url() : this.url,
				dataType: 'json',
				cache: false,
				success: function onSuccess(resp, status, xhr) {
					var servers = _.map(collection.parse(resp, xhr), function (server) {
							server.ping = null;
							server.pingState = -1;
							return server;
						});
					
					collection.updateOrRemove(servers);
					
					if (!options.silent) {
						collection.trigger('reload', collection);
						collection.trigger('reload:after', collection);
					}
					
					if (options.success) {
						options.success(collection);
					}
				},
				error: function onError(xhr, status, err) {
					if (options.error) {
						options.error(collection);
					}
				}
			});
			
			return this;
		}
	});
	
	/**
	 * Module support
	 */
	if (typeof module !== 'undefined' && module.exports) {
		module.exports = APP.Collection.Servers;
	}
}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule servers
 */
(function (win) {
	"use strict";
	
	
	if (!win.APP && (typeof require !== 'undefined')) {
		win.APP = require('./../common/app');
	}
	
	if (!win.APP.Model && (typeof require !== 'undefined')) {
		win.APP.Collection = require('./../common/collection');
	}
	
	if (!win.APP.Model.Player && (typeof require !== 'undefined')) {
		win.APP.Model.Player = require('./model.player');
	}
	
	var APP = win.APP,
		_ = APP._,
		$ = APP.$;
	
	APP.Collection.Players = APP.Collection.extend({
		model: APP.Model.Player
	});
	
	/**
	 * Module support
	 */
	if (typeof module !== 'undefined' && module.exports) {
		module.exports = APP.Collection.Items;
	}
}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule servers
 */
(function (win) {
	"use strict";
	
	
	var APP = win.APP,
		parent = APP.View.prototype,
		_ = APP._,
		nsGame = APP.ns('game');
	
	/**
	 * Item List View
	 */
	APP.View.Server = APP.View.extend({
		name: 'server-view',
		tagName: 'tr',
        
		/**
		 * Initialize view
		 */
		initialize: function initializeServerView() {
			this.model.bind('change', this.render, this);
		},
        
		destroy: function destroyServerView() {
			this.model.unbind('change', this.render, this);
			return this;
		},
		
		/**
		 * Render the view
		 */
		render: function renderServerView() {
			// Empty
			this.$el.empty();
            this.$el.attr('class', [this.name, this.className].join(' '));
            
            if (this.model.get('hasPassword')) {
                this.$el.addClass('pwd');
            }
            if (this.model.get('isVIP')) {
                this.$el.addClass('vip');
            }
            if (this.model.get('ranked')) {
                this.$el.addClass('ranked');
            }
            if (this.model.get('bookmarked')) {
                this.$el.addClass('bookmarked');
            }            
            
            if (this.model.get('online')) {
                this.$el.addClass('online');
            } else {                
                this.$el.addClass('offline');
            }
            
            var status = this.make('span', {'class': 'status'}),
                name = this.make('td', {'class': 'name'}),
				nameWrapper = this.make('div'),
                map = this.make('td', {'class': 'map'}),
				mode = this.make('td', {'class': 'mode'}),
				modeName = this.model.get('currentGameMode') ? this.trans('WEB_GAME_SERVERBROWSER_MODE_' + this.model.get('currentGameMode')) : '',
                players = this.make('td', {'class': 'players'}, this.model.get('players') + '/' + this.model.get('capacity')),
                ms = this.model.get('ping') || 0,
                ping = this.make('td', {'class': 'ping'}, ms + String()),
                join = this.make('td', {'class': 'join'}),
				levelAvg = this.model.get('levelAvg'),
				levelSdv = this.model.get('levelSdv'),
				levelSpan = [
					Math.round(levelAvg - levelSdv),
					Math.round(levelAvg + levelSdv)
				],
				
				// Recommended servers fulfill these demands:
				// - Soldier rank is in server rank span
				// - Ping is belox 200ms
				// - Server is at least half full & not full
				isRecommended = (levelSpan[0] <= nsGame.persona.get('level')) && 
								(nsGame.persona.get('level') <= levelSpan[1]) && 
								(ms < 200) && 
								(this.model.get('players') > (this.model.get('capacity') / 2)) && 
								(this.model.get('players') < this.model.get('capacity'));

			// Mark server as recommended
			if (isRecommended) {
				this.$el.addClass('recommended');
			}

			status.appendChild(this.make('span', {'title-tooltip': 'Recommended'}));
            status.appendChild(this.make('span', {'title-tooltip': 'Password protected'}));// TODO: Localize this
            status.appendChild(this.make('span', {'title-tooltip': 'VIP'}));
            status.appendChild(this.make('span', {'title-tooltip': 'Ranked'}));
            status.appendChild(this.make('span', {'title-tooltip': 'Bookmarked'}));

			nameWrapper.appendChild(status);
			nameWrapper.appendChild(this.make('span', {'class': 'title'}, this.model.get('name')));
			name.appendChild(nameWrapper);


			map.appendChild(this.make('span', null, this.model.get('currentMapName')));
			mode.appendChild(this.make('span', null, modeName));
            
            // Ping quality
			if (ms < 0) {
				ping.innerHTML = '999+';
			} else if (ms < 50) {
				ping.className += ' great';
			} else if (ms < 200) {
				ping.className += ' good';
			} else if (ms < 350) {
				ping.className += ' ok'; 
			} else if (ms < 999) {
				ping.className += ' bad';                    
			} else {
				ping.innerHTML = '999+';
			}
            
            if (this.model.get('online')) {
                join.appendChild(this.make('a', {'class': 'join_this_row', 'title-tooltip': 'Join this server', 'href': '#connect'}, 'Join this server')); // TODO: Localize
            }
            
            this.el.appendChild(name);
            this.el.appendChild(map);
			this.el.appendChild(mode);
            this.el.appendChild(players);
            this.el.appendChild(ping);
            this.el.appendChild(join);
            
			// Return this for chaining
			return this;
		}
	});
	
}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule servers
 */
(function (APP) {
	"use strict";
	
	
	var parent = APP.View.prototype,
		_ = APP._;
	
	/**
	 * Item List View
	 */
	APP.View.Player = APP.View.TableRow.extend({
		name: 'player-view',
        
        renderCell: function renderCellPlayerView(key) {
			var td;
			
            if (key === 'kit') {
                td = this.make('td', {'class': key + ' kit' + this.model.get(key)});                
            } else {
                td = this.make('td', {'class': key}, this.model.get(key));
            }
            
			this.el.appendChild(td);
			
            return td;
        }
	});
	
}(this.APP));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule servers
 */
(function (APP) {
	"use strict";
	
	
	var parent = APP.View.prototype,
		_ = APP._,
		nsServers = APP.ns('servers');
	
	/**
	 * Item List View
	 */
	APP.View.ServerFilter = APP.View.extend({
		name: 'server-filter-view',
		tagName: 'div',
		tabName: 'browser',
		numberOfServers: 0,
		modelBrowser: null,
		modelBookmarks: null,
		events: {
            'click div.reload_icon:not(.active)': 'onClickReload',
			'change input': 'onChange',
			'keydown input[type=text]': 'onKeyDown',
			'click span.filter-free-reset': 'onClickReset',
			'mouseenter .dropdown-filter': 'onMouseEnter',
			'mouseleave .dropdown-filter': 'onMouseLeave'
        },
		
		geoValues: [ 'nrt', 'syd', 'gva', 'iad', 'sjc' ],
		
		/**
		 * Initialize view
		 */
		initialize: function initializeServerInfoView(options) {			
			this.modelBrowser = options.modelBrowser;		
			this.modelBookmarks = options.modelBookmarks;
			
			this.numberOfServers = this.collection.filterBy(this.modelBrowser.toJSON()).length;
			
			// Collection
			this.collection.bind('reload', this._onReloadCollection, this);
			
			// Browser
			this.modelBrowser.bind('change', this._onChangeBrowser, this);
			
			// Bookmarks
			this.modelBookmarks.bind('change', this._onChangeBookmarks, this);
			
			this.bind('tabs:select', this._onTabsSelect, this);
			
			this.bind('geo:choose', this._onGeoChoose, this);
		},
		
		destroy: function destroy() {
			this.collection.unbind('reload', this._onReloadCollection, this);
			
			this.modelBrowser.unbind('change', this._onChangeBrowser, this);
			
			this.modelBookmarks.unbind('change', this._onChangeBookmarks, this);
		},
        
		_onReloadCollection: function _onReloadCollectionServerFilterView() {
			if (this.tabName === 'browser') {
				this.numberOfServers = this.collection.filterBy(this.modelBrowser.toJSON()).length;
			} else if (this.tabName === 'bookmarks') {
				this.numberOfServers = this.collection.filterBy(this.modelBookmarks.toJSON()).length;
			} 
		},
		
		_onChangeBrowser: function _onChangeModelBrowserServerFilterView() {
			var filter = this.modelBrowser.toJSON();
			
			this.numberOfServers = this.collection.filterBy(filter).length;
			
			if (this.modelBrowser.hasChanged('name') || this.modelBrowser.hasChanged('geo')) {
				this.$('p.visible-servers').text(this.numberOfServers + ' ' + this.trans('WEB_GAME_SERVERBROWSER_FILTER_SERVERS'));
			} else if (!this.modelBrowser.hasChanged('geo')) {
				this.renderFilterBrowser();
				this.trigger('render');
			}
			
			this.trigger('filter', filter);
		},
		
		_onChangeBookmarks: function _onChangeModelBrowserServerFilterView() {
			var filter = this.modelBookmarks.toJSON();
			
			this.numberOfServers = this.collection.filterBy(filter).length;
			
			this.renderFilterBookmarks();
			
			this.trigger('render');
			
			this.trigger('filter', filter);	
		},
		
		_onTabsSelect: function _onTabsSelect(i) {
			var filter;
			
			if (i === 0) {
				filter = this.modelBrowser.toJSON();
				this.tabName = 'browser';
			} else if (i === 1) {
				filter = this.modelBookmarks.toJSON();
				this.tabName = 'bookmarks';
			}
			
			this.numberOfServers = this.collection.filterBy(filter).length;
			this.render();
			this.trigger('filter', filter);
		},
		
		_onGeoChoose: function _onGeoChoose(index) {
			var value = this.geoValues[index];
			if (value) {
				this.modelBrowser.set('geo', value);
			}
		},
		
        onClickReload: function onClickReload(e) {
            e.preventDefault();
			
			this.sound('click', 'Clicked reload');
            
            var $el = this.$(e.currentTarget);
			
			$el.addClass('active');
			
            this.collection.reload({
				'success': function (collection) {					
					$el.removeClass('active');
				},
				'error': function () {
					$el.removeClass('active');
				}
			});
        },
        
		onChange: function onChange(e) {
			var el = e.currentTarget,
				key = el.name,
				value = el.checked,
				attrs = {},
				model;
			
			if (el.disabled) {
				return;
			}
			
			if (this.tabName === 'browser') {
				model = this.modelBrowser;
			} else if (this.tabName === 'bookmarks') {
				model = this.modelBookmarks;
			}
			
			if (key.substr(0, 4) === 'maps') {
				if (value) {
					value = _.values(model.get('maps'));
					value.push(parseInt(key.substr(4), 10));
					attrs.maps = _.uniq(value);
				} else {
					attrs.maps = _.without(model.get('maps'), parseInt(key.substr(4), 10));
				}
			} else if (key.substr(0, 9) === 'gamemodes') {				
				if (value) {
					value = _.values(model.get('gamemodes'));
					value.push(parseInt(key.substr(9), 10));
					attrs.gamemodes = _.uniq(value);
				} else {
					attrs.gamemodes = _.without(model.get('gamemodes'), parseInt(key.substr(9), 10));
				}
			} else if (key === 'name' || key === 'geo') {
				attrs[key] = el.value;
			} else {
				attrs[key] = value;
			}
			
			model.set(attrs);
		},
		
		onMouseEnter: function onMouseEnter(e) {
			this.$(e.currentTarget).addClass('active');
		},
		
		onMouseLeave: function onMouseLeave(e) {
			this.$(e.currentTarget).removeClass('active');			
		},
		
		onKeyDown: function onKeyDown(e) {
			
			var modelBrowser = this.modelBrowser;
			if (e.keyCode === 13) {
				this.$('.dropdown-filter').removeClass('active');
				
				return false;
			}
			
			setTimeout(function () {
				var value = e.currentTarget.value;
				modelBrowser.set({'name': value});
			}, 0);
		},
		
		onClickReset: function onClickReset(e) {
			e.preventDefault();
			
			this.modelBrowser.unset('name');
			
			this.renderFilterBrowser();
			this.trigger('render');
		},
		
		
        renderTabs: function renderTabs() {
			this.categoryTabs = this.createView(APP.View.Tabs, {
				'className'	: 'category-tabs menu servers_menu',
				'tabs'		: [
					{ text: this.trans('WEB_GAME_ITEM_CATEGORY_BROWSER'), filter: 'browser' },
					{ text: this.trans('WEB_GAME_ITEM_CATEGORY_BOOKMARKS'), filter: 'bookmarks' }
				]	
			}, 'tabs').render().attach();
			
			
			
            return this;
        },
        
        renderFieldset: function renderFieldset(value, key, text) {
            var fieldset = this.make('fieldset'),
                label = this.make('label', {'class': 'checkbox'}, text),
                input = this.make('input', {'class': 'invisible', 'name': key, 'type': 'checkbox'});
            
            if (value) {
                input.checked = true;
				label.className += ' checked';
            }
            
            label.appendChild(input);
            fieldset.appendChild(label);
            
            return fieldset;
        },
        
        renderFilterBrowser: function renderFilterBrowser() {
            var filterBrowser = this.make('div', {'class': 'server-filter dropdown-filter server-filter-browser'}),
                filterNav = this.make('div', {'class': 'dropdown-nav'}),
                
                filterContent = this.make('div', {'class': 'filter-list'}),
                filterContainerLeft = this.make('div', {'class': 'filter-container'}),
                filterContainerMiddle = this.make('div', {'class': 'filter-container'}),
                filterContainerRight = this.make('div', {'class': 'filter-container thin'}),
				
				freeForm = this.make('form'),
				freeFieldset = this.make('fieldset', {'class': 'filter-free'}),
				freeLabel = this.make('label', null, this.trans('WEB_GAME_SERVERBROWSER_FILTER_SEARCH_SERVER_NAME') + ':'),
				freeInput = this.make('input', {'class': 'filter-free-text', 'name': 'name', 'type': 'text', 'value': this.modelBrowser.get('name') || ''}),
				freeSpan = this.make('span', {'class': 'filter-free-reset'}, 'X'),
				
				
				geoFieldset = this.make('fieldset'),
				geoLabel = this.make('label', null, this.trans('WEB_GAME_SERVERBROWSER_FILTER_LOCATION') + ':'),
				geoWrapper = this.make('div', {'class': 'selectbox'}),
				geoData = [
					this.trans('WEB_GAME_SERVERBROWSER_FILTER_LOCATION_ASIA'),
					this.trans('WEB_GAME_SERVERBROWSER_FILTER_LOCATION_AUSTRALIA'),
					this.trans('WEB_GAME_SERVERBROWSER_FILTER_LOCATION_EUROPE'),
					this.trans('WEB_GAME_SERVERBROWSER_FILTER_LOCATION_NORTH_AMERICA_EAST'),
					this.trans('WEB_GAME_SERVERBROWSER_FILTER_LOCATION_NORTH_AMERICA_WEST')
				],
				geoValue = _.indexOf(this.geoValues, this.modelBrowser.get('geo')), // TODO: This won't work when we localize
				geoSelected = this.make('div', {'class': 'selected'}),
				geoOptions = this.make('div', {'class': 'options'}),
				
                filterCurrent = this.make('div', {'class': 'filter-current'}),
				filterList = this.make('ul', {'class': 'server-filters'}),
                unranked,
                pwd,
                numOfMaps = this.options.maps.length,
				numOfModes = this.options.gamemodes.length;
			
            // Filter nav
            filterNav.appendChild(this.make('span', {'class': 'title'}, this.trans('WEB_GAME_TIER_FILTER_LABEL')));
            
			// Filter left content
			freeFieldset.appendChild(freeLabel);
			freeFieldset.appendChild(freeInput);
			freeFieldset.appendChild(freeSpan);
			freeForm.appendChild(freeFieldset);
			filterContainerLeft.appendChild(freeForm);
			
			
			
			geoFieldset.appendChild(geoLabel);
			this.createView(APP.View.Choose, {
				container	: geoFieldset,
				values		: geoData,
				value		: geoValue === -1 ? 0 : geoValue
			}, 'geo').render().attach();
			filterContainerLeft.appendChild(geoFieldset);
			
			
            // Filter middle content
            filterContainerMiddle.appendChild(this.make('label', null, this.trans('WEB_GAME_SERVERBROWSER_FILTER_MISC') + ':'));
            filterContainerMiddle.appendChild(this.renderFieldset(this.modelBrowser.get('hideFull'), 'hideFull', this.trans('WEB_GAME_SERVERBROWSER_FILTER_HIDE_FULL')));
            filterContainerMiddle.appendChild(this.renderFieldset(this.modelBrowser.get('hideEmpty'), 'hideEmpty', this.trans('WEB_GAME_SERVERBROWSER_FILTER_HIDE_EMPTY')));
            
			unranked = this.renderFieldset(this.modelBrowser.get('showUnranked'), 'showUnranked', this.trans('WEB_GAME_SERVERBROWSER_FILTER_SHOW_UNRANKED'));
            pwd = this.renderFieldset(this.modelBrowser.get('hidePwd'), 'hidePwd', this.trans('WEB_GAME_SERVERBROWSER_FILTER_HIDE_PASSWORD_PROTECTED')).getElementsByTagName('label')[0];
			pwd.className += ' dependency';
			if (!this.modelBrowser.get('showUnranked')) {
				pwd.className += ' disabled';
				pwd.getElementsByTagName('input')[0].disabled = true;
			}			
            unranked.appendChild(pwd);
			filterContainerMiddle.appendChild(unranked);
            filterContainerMiddle.appendChild(this.renderFieldset(this.modelBrowser.get('onlyVip'), 'onlyVip', this.trans('WEB_GAME_SERVERBROWSER_FILTER_SHOW_ONLY_VIP')));

			filterContainerMiddle.appendChild(this.make('label', null, this.trans('WEB_GAME_SERVERBROWSER_FILTER_MODE') + ':'));
			_.forEach(this.options.gamemodes, function (i) {
				filterContainerMiddle.appendChild(this.renderFieldset(_.indexOf(this.modelBrowser.get('gamemodes'), i) !== -1, 'gamemodes' + i, this.trans('WEB_GAME_SERVERBROWSER_MODE_' + i)));
			}, this);
			
			// Filter right content
            filterContainerRight.appendChild(this.make('label', null, this.trans('WEB_GAME_SERVERBROWSER_FILTER_MAPS') + ':'));
			
			_.forEach(this.options.maps, function (i) {
				filterContainerRight.appendChild(this.renderFieldset(_.indexOf(this.modelBrowser.get('maps'), i) !== -1, 'maps' + i, this.trans('WEB_GAME_SERVERBROWSER_MAPS_' + i)));
			}, this);
			
			// Filter current
			filterList.appendChild(this.make('li', {'class': 'hide'}, this.trans('WEB_GAME_SERVERBROWSER_FILTER_HIDES') + ':'));
			
			if (this.modelBrowser.get('hideFull')) {
				filterList.appendChild(this.make('li', null, this.trans('WEB_GAME_SERVERBROWSER_FILTER_HIDES_FULL')));				
			}
			
			if (this.modelBrowser.get('hideEmpty')) {
				filterList.appendChild(this.make('li', null, this.trans('WEB_GAME_SERVERBROWSER_FILTER_HIDES_EMPTY')));				
			}
			
			if (!this.modelBrowser.get('showUnranked')) {
				filterList.appendChild(this.make('li', null, this.trans('WEB_GAME_SERVERBROWSER_FILTER_HIDES_UNRANKED')));				
			}
			
			if (this.modelBrowser.get('hidePwd')) {
				filterList.appendChild(this.make('li', null, this.trans('WEB_GAME_SERVERBROWSER_FILTER_HIDES_PASSWORD_PROTECTED')));				
			}
			
			if (this.modelBrowser.get('onlyVip')) {
				filterList.appendChild(this.make('li', null, this.trans('WEB_GAME_SERVERBROWSER_FILTER_HIDES_NON_VIP')));				
			}
			
			if (this.modelBrowser.get('maps').length !== numOfMaps) {
				if (this.modelBrowser.get('maps').length === (numOfMaps - 1)) {
					filterList.appendChild(this.make('li', null, 1 + ' ' + this.trans('WEB_GAME_SERVERBROWSER_FILTER_HIDES_MAP')));				
				} else {
					filterList.appendChild(this.make('li', null, (numOfMaps - this.modelBrowser.get('maps').length) + ' ' + this.trans('WEB_GAME_SERVERBROWSER_FILTER_HIDES_MAPS')));				
				}	
			}
			
			if (this.modelBrowser.get('gamemodes').length !== numOfModes) {
				if (this.modelBrowser.get('gamemodes').length === (numOfModes - 1)) {
					filterList.appendChild(this.make('li', null, 1 + ' ' + this.trans('WEB_GAME_SERVERBROWSER_FILTER_HIDES_MODE')));
				} else {
					filterList.appendChild(this.make('li', null, (numOfModes - this.modelBrowser.get('gamemodes').length) + ' ' + this.trans('WEB_GAME_SERVERBROWSER_FILTER_HIDES_MODES')));
				}
			}
			filterCurrent.appendChild(filterList);
			filterCurrent.appendChild(this.make('p', {'class': 'visible-servers'}, this.numberOfServers + ' ' + this.trans('WEB_GAME_SERVERBROWSER_FILTER_SERVERS')));
            
            filterContent.appendChild(filterContainerLeft);
            filterContent.appendChild(filterContainerMiddle);
            filterContent.appendChild(filterContainerRight);
            filterContent.appendChild(filterCurrent);
			
			this.$filterBrowser.empty();
            this.$filterBrowser.append(filterNav);
			this.$filterBrowser.append(filterContent);
			
            return this;
        },
        
        renderFilterBookmarks: function renderFilterBookmarks() {
			var filterBookmarks = this.make('div', {'class': 'server-filter dropdown-filter server-filter-bookmarks'}),
                filterNav = this.make('div', {'class': 'dropdown-nav'}),                
                filterContent = this.make('div', {'class': 'filter-list'}),
                filterContainer = this.make('div', {'class': 'filter-container'}),				
				filterCurrent = this.make('div', {'class': 'filter-current'});
			
            filterNav.appendChild(this.make('span', {'class': 'title'}, this.trans('WEB_GAME_TIER_FILTER_LABEL')));			
			
            filterContainer.appendChild(this.renderFieldset(this.modelBookmarks.get('onlyVip'), 'onlyVip', this.trans('WEB_GAME_SERVERBROWSER_FILTER_SHOW_ONLY_VIP')));
            filterContainer.appendChild(this.renderFieldset(this.modelBookmarks.get('showOffline'), 'showOffline', this.trans('WEB_GAME_SERVERBROWSER_FILTER_SHOW_OFFLINE')));
			
			filterCurrent.appendChild(this.make('p', {'class': 'visible-servers'}, this.numberOfServers + ' ' + this.trans('WEB_GAME_SERVERBROWSER_FILTER_SERVERS')));
			filterContent.appendChild(filterContainer);
            filterContent.appendChild(filterCurrent);
			
			this.$filterBookmarks.empty();
            this.$filterBookmarks.append(filterNav);
			this.$filterBookmarks.append(filterContent);
			
			return this;
        },        
        
        renderReloadButton: function renderReloadButton() {
            var button = this.make('div', {'class': 'icon_bg_wrapper reload'});
            
            button.appendChild(this.make('div', {'class': 'reload_icon'}));
            this.el.appendChild(button);
            
            return this;
        },
        
		/**
		 * Render the view
		 */
		render: function renderServerFilterView() {            

            // List tabs
            this.renderTabs();
            this.$filterBrowser = this.$('<div>').attr({'class': 'server-filter dropdown-filter server-filter-browser'}).appendTo(this.el);
            this.$filterBookmarks = this.$('<div>').attr({'class': 'server-filter dropdown-filter server-filter-bookmarks'}).appendTo(this.el);
			
            // Filters
            if (this.tabName === 'browser') {
                this.renderFilterBrowser();
				this.categoryTabs.select(0, {'silent': true});
            } else if (this.tabName === 'bookmarks') {
                this.renderFilterBookmarks();
				this.categoryTabs.select(1, {'silent': true});
            }
			
            // Reload button
            this.renderReloadButton();

		}
	});
	
}(this.APP));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule servers
 */
(function (root) {
	"use strict";
	
	
	var APP = root.APP,
		parent = APP.View.prototype,
		_ = APP._,
		$ = APP.$,
		win = APP.win,
		nsGame = APP.ns('game');
	
	/**
	 * Server Info View
	 */
	APP.View.ServerInfo = APP.View.extend({
		name: 'server-info-view',
		tagName: 'div',
        canIBookmark: true,
        rosterFetched: false,
		currentTabName: 'map-rotation',
		events: {

			/**
			 * Event listener for
			 * @param e
			 * @private
			 */
            'click div.bookmark_icon': function _onClickBookmarkServerInfoView(e) {
				e.preventDefault();
		
				if (this.canIBookmark) {
					this.canIBookmark = false;
		
					e.currentTarget.className += ' loading';
		
					this.sound('click', 'Clicked bookmark');
		
					if (this.model.get('bookmarked')) {
						this.model.removeBookmark();
					} else {
						this.model.addBookmark();
					}
				}
			},

			/**
			 * Event listener for
			 * @param e
			 * @private
			 */
            'click div.reload_icon:not(.active)': function _onClickReloadServerInfoView(e) {
				e.preventDefault();

				this.sound('click', 'Clicked reload');

				var $el = this.$(e.currentTarget),
					view = this;

				$el.addClass('active');

				this.model.fetch({
					lookAtMe: true,
					success: function (model) {
						model.ping();
					},
					error: function () {
						view.render();
					}
				});
			},

			/**
			 * Event listener for 
			 * @param e
			 * @private
			 */
            'click .serverinfo_menu a': function _onClickInfoTabServerInfoView(e) {
				e.preventDefault();

				this.sound('click');

				var tabName = e.currentTarget.parentNode.className;

				this.switchInfoTab(tabName);
			}
        },
		
		/**
		 * Initialize view
		 */
		initialize: function initializeServerInfoView() {
			this.model.bind('change', this._onChange, this);
			
			this.bind('join:click', this._onJoinClick, this);
		},

		/**
		 * Destroy view
		 */
        destroy: function destroyServerInfoView() {
            this.model.unbind('change', this._onChange, this);
        },
		
		_onChange: function _onChangeServerInfoView() {
			if (this.model.hasChanged('bookmarked')) {
				this.canIBookmark = true;
			}
			
			if (this.model.get('players') !== this.model.get('gameRoster').length) {
				this.rosterFetched = false;
				this.currentTabName = 'map-rotation';
			}
			
			
			this.render();
		},
		
		_onJoinClick: function _onJoinClickServerInfoView() {
			this.trigger('join', this, this.model);
		},
				
        switchInfoTab: function switchInfoTab(tabName) {
            if (tabName) {
                this.currentTabName = tabName;
            }
            this.$('.serverinfo_menu a').removeClass('active');
            
            this.$('.serverinfo_menu li.' + this.currentTabName + ' a').addClass('active');
            
            if (this.currentTabName === 'map-rotation') {
                this.$players.hide(); 
                this.$mapRotation.show();
				
            } else {
                this.$mapRotation.hide(); 
                this.$players.show();
                
                // Load data
                if (!this.rosterFetched) {
					this.model.fetch({
						success: _.bind(function () {
							this.rosterFetched = true;
							this.$players.find('div.update-overlay').remove();
						}, this),
						error: _.bind(function () {
							this.$players.find('div.update-overlay').remove();
						}, this)
					});
                }
            }
            
			this.trigger('render');
			
            return this;
        },
        
        renderTitle: function renderTitle() {
            var title = this.make('h2', {'class': 'title'}),
                titleWrapper = this.make('span', {'class': 'title-wrapper'}),
                titleContent = this.make('span', {'class': 'title'}, this.model.get('name'));
            
            // Append title
            titleWrapper.appendChild(titleContent);
            title.appendChild(titleWrapper);
            this.el.appendChild(title);
            
            return this;
        },
        
        renderIcons: function renderIcons() {
            var bookmarkIcon = this.make('div', {'class': 'icon_bg_wrapper bookmark'}),
                bookmarkContent = this.make('div', {'class': 'bookmark_icon'}),
                reloadIcon = this.make('div', {'class': 'icon_bg_wrapper reload'}),
                reloadContent = this.make('div', {'class': 'reload_icon'});
            
            // Check bookmarked
            if (this.model.get('bookmarked')) {
                bookmarkContent.className += ' active';
            }            
            
            bookmarkIcon.appendChild(bookmarkContent);
            this.el.appendChild(bookmarkIcon);
            
            reloadIcon.appendChild(reloadContent);
            this.el.appendChild(reloadIcon);
            
            return this;
        },
        
        renderDetails: function renderDetailsServerInfoView() {
            var gameWrapper = this.make('div', {'class': 'game map' + this.model.get('currentMap')}),
                gameTitle = this.make('h3'),
                gameMap = this.make('span', {'class': 'game-map'}, this.model.get('currentMapName')),
                gameRound = this.make('span', {'class': 'game-round'}, '(' + this.model.get('currentRound') + '/' + this.model.get('roundsPerMap') + ')'),
				levelSpan = [
					Math.round(this.model.get('levelAvg') - this.model.get('levelSdv')),
					Math.round(this.model.get('levelAvg') + this.model.get('levelSdv'))
				],
				isRecommended = (levelSpan[0] <= nsGame.persona.get('level')) && 
								(nsGame.persona.get('level') <= levelSpan[1]) && 
								(this.model.get('ping') < 200) && 
								(this.model.get('players') > (this.model.get('capacity') / 2)) && 
								(this.model.get('players') < this.model.get('capacity')),
				gameLevel = this.make('span', {'class': 'game-level'}, this.trans('WEB_GAME_HOME_SOLDIERLIST_LEVEL') + ': ' + levelSpan[0] + ' - ' + levelSpan[1]),
                gameDetails = this.make('dl');
                
            // Game title
            gameTitle.appendChild(gameMap);
            gameTitle.appendChild(gameRound);
            gameWrapper.appendChild(gameTitle);
			
			// Game level
			if (isRecommended) {
				gameLevel.appendChild(this.make('i', {}, this.trans('WEB_GAME_OPTIONS_RECOMMENDED')));
			}			
			gameWrapper.appendChild(gameLevel);
			
            // Game details
			gameDetails.appendChild(this.make('dt', null, this.trans('WEB_GAME_SERVERBROWSER_DETAILS_MODE') + ':'));
			gameDetails.appendChild(this.make('dd', {'class': 'game-mode'}, this.trans('WEB_GAME_SERVERBROWSER_MODE_' + this.model.get('currentGameMode'))));
            gameDetails.appendChild(this.make('dt', null, this.trans('WEB_GAME_SERVERBROWSER_DETAILS_PLAYERS') + ':'));
            gameDetails.appendChild(this.make('dd', {'class': 'game-players'}, this.model.get('players') + '/' + this.model.get('capacity')));
            gameDetails.appendChild(this.make('dt', null, this.trans('WEB_GAME_SERVERBROWSER_DETAILS_PING') + ':'));
            gameDetails.appendChild(this.make('dd', {'class': 'game-ping'}, (this.model.get('ping') || 0) + String()));
            gameWrapper.appendChild(gameDetails);
            
            this.el.appendChild(gameWrapper);
            return this;
        },
        
        renderTable: function renderTableServerInfoView() {
			
            var tabbedBox = this.make('div', {'class': 'tabbed-box'}),
                tableMenu = this.make('ul', {'class': 'menu serverinfo_menu'}),
                menuOptionMapRotation = this.make('li', {'class': 'map-rotation'}),
                menuOptionPlayers = this.make('li', {'class': 'players'}),
                mapListCollection = new APP.Collection(this.model.get('mapList')),                
                playerCollection = new APP.Collection.Players(this.model.get('gameRoster'));
			
            // Menu
            menuOptionMapRotation.appendChild(this.make('a', {'href': '#map-rotation'}, this.trans('WEB_GAME_ITEM_CATEGORY_MAP-ROTATION')));
            menuOptionPlayers.appendChild(this.make('a', {'href': '#players'}, this.trans('WEB_GAME_ITEM_CATEGORY_PLAYERS')));
            tableMenu.appendChild(menuOptionMapRotation);
            tableMenu.appendChild(menuOptionPlayers);
            tabbedBox.appendChild(tableMenu);
            
            // Map rotation
            this.$mapRotation = $('<div>').addClass('serverinfo_tab map-rotation tableContainer').appendTo(tabbedBox);
            this.mapRotation = this.createView(APP.View.Table, {
				headers: [
					{'label': 'WEB_GAME_SERVERBROWSER_COL_MAP', 'key': 'name'},
					{'label': 'WEB_GAME_SERVERBROWSER_COL_MODE', 'key': 'gameModeName'}
				],
				view: APP.View.TableRow,
				collection: mapListCollection,
				container: this.$mapRotation,
				orderByDirection: false,
				orderByKey: 'order'
			}).render().select(mapListCollection.at(this.model.get('mapIndex'))).attach();
			    
            // Players
            this.$players = $('<div>').addClass('serverinfo_tab players tableContainer').appendTo(tabbedBox);
            this.players = this.createView(APP.View.Table, {        
				orderByKey: 'name',
				orderByDirection: 'asc',
				headers: [
					{'label': 'WEB_GAME_SERVERBROWSER_COL_LEVEL', 'key': 'level', 'attrs': { 'class': 'headerSort' }},
					{'label': 'WEB_GAME_SERVERBROWSER_COL_CLASS', 'key': 'kit', 'attrs': { 'class': 'headerSort' }},
					{'label': 'WEB_GAME_SERVERBROWSER_COL_SOLDIER_NAME', 'key': 'name', 'attrs': { 'class': 'headerSort' }}
				],
				view: APP.View.Player,
				collection: playerCollection,
				container: this.$players
			}).render().attach();
			
            if (!this.rosterFetched) {
                this.$players.append(this.make('div', {
					'class': 'update-overlay',
					'style': 'opacity:1; display:block;'
				}, this.trans('WEB_GAME_SERVERBROWSER_RETRIEVING_PLAYERS')));
            }
            
			
            this.el.appendChild(tabbedBox);
            
            this.switchInfoTab();
            
            return this;
        },
        
		/**
		 * Render the view
		 */
		render: function renderServerInfoView() {
            // Title & Icons
            this.renderTitle().renderIcons();            
            
            // Game details
            if (this.model.get('online')) {
                this.renderDetails();
                
                // Table
                this.renderTable();
				
                // Button
				this.createView(APP.View.Button, {
					className: 'join',
                    primary: true,
                    glyph: this.model.get('hasPassword') ? 'unlock' : 'arrow',
                    text: this.trans('WEB_GAME_JOIN_JOIN_GAME')
				}, 'join').render().attach();
				
            } else {
                this.el.appendChild(this.make('div', {
					'class': 'game-offline'
				}, this.trans('WEB_GAME_SERVERBROWSER_SERVER_OFFLINE')));                
            }
			
			// Return this for chaining
			return this;
		}
	});
}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule servers
 */
(function (APP) {
	"use strict";
	
	
	var	$ = APP.$,
		_ = APP._,
		parent = APP.View.Table.prototype;
	
	/**
	 * Server List View
	 */
	APP.View.ServerList = APP.View.Table.extend({
		name: 'server-list-view',
		options: {
            orderByKey: 'ping',
            orderByDirection: 'asc',
            headers: [
                {
                    'label': 'WEB_GAME_SERVERBROWSER_COL_SERVER_NAME',
                    'attrs': { 'class': 'headerSort' },
                    'key': 'name'
                },
                {
                    'label': 'WEB_GAME_SERVERBROWSER_COL_MAP',
                    'attrs': { 'class': 'headerSort' },
                    'key': 'currentMapName'
                },
				{
					'label': 'WEB_GAME_SERVERBROWSER_COL_MODE',
					'attrs': { 'class': 'headerSort' },
					'key': 'currentGameMode'
				},
                {
                    'label': 'WEB_GAME_SERVERBROWSER_COL_PLAYERS',
                    'attrs': { 'class': 'headerSort' },
                    'key': 'players'
                },
                {
                    'label': 'WEB_GAME_SERVERBROWSER_COL_PING',
                    'attrs': { 'class': 'headerSort' },
                    'key': 'ping'
                },
                {
                    'label': null
                }
            ],
			view: APP.View.Server,
			limit: 25,
			pending: true,
			pendingText: 'WEB_GAME_SERVERBROWSER_PENDING_TEXT'
        },
		
		events: _.extend({
			'click .join_this_row': function (e) {
				e.preventDefault();
				
				this.sound('click');
				
				var $el = this.$(e.currentTarget).closest('tr.server-view'),
					i = this.$trs.index($el),
					model = this.currentCollection.at(i);
				
				this.joinServer(model);
			},
            'click tr.server-view': function (e) {
				e.preventDefault();
				
				this.sound('click');
				
				var $el = this.$(e.currentTarget),
					i = this.$trs.index($el),
					model = this.currentCollection.at(i);
				
				this.select(model);
			}
		}, parent.events),
		
		
		initialize: function initializeServerListView() {
			parent.initialize.apply(this, arguments);
			
			this.collection.bind('ping', this._onPing, this);
			
			this.collection.bind('change', this._onChange, this);
		},
        
		destroy: function destroyServerListView() {
			this.collection.unbind('ping', this._onPing, this);
			this.collection.unbind('change', this._onChange, this);
		},
		
		_onPing: function _onPingServerListView() {
			this.renderBody();
		},
		
		_onChange: function _onChangeServerListView() {
			this.select();
		},
		
		/**
		 * Sort By Iterator
		 */
		sortByIterator: function sortByIteratorServerListView(model) {
			if (this.options.orderByKey === 'ping') {
				return (model.get('ping') * 1000) + parseInt(model.cid.substr(1), 10);
			}
			
			if (this.options.orderByKey === 'name') {
				return model.get('name').toLowerCase();
			}
			
			return model.get(this.options.orderByKey);
		},
        
		
		/**
		 * Join Server
		 */
        joinServer: function joinServer(model) {
            model = this.currentCollection.get(model);
            
            APP.trigger('join', model);
            
            return this;
        },
		
		/**
		 * Render Pending Row
		 */
		renderPendingRow: function renderPendingRowServerListView(pending, total) {
	
			var tr = this.make('tr', { 'class': 'pending-indicator' });
			
			tr.appendChild(this.make('td', { 'colspan': this.options.headers.length }, (total - pending) + ' / ' +  total + ' Pinged'));
			this.$tbody.append(tr);
			
			this.trigger('renderpending');
			
			return this;
		},
		
		renderLimitIterator: function renderLimitIteratorServerListView(model) {
			return model.get('pingState') !== 1;
		},
		
		renderBody: function renderBodyServerListView() {
			parent.renderBody.apply(this, arguments);
			
			if (this.currentCollection.length !== this.collection.length) {
				this.currentCollection.ping();
			}			
			
			return this;
		}
	});	
}(this.APP));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule servers
 */
/**
 * @class GAME.Task.servers
 * @uses GAME.Task.sidis
 */
APP.domTask('servers', ['sidis'], function initServers(done) {
	"use strict";
	
	
	var $ = APP.$,
		win = APP.win,
		_ = APP._,
		nsServers = APP.namespace('servers'),
		nsConfig = APP.namespace('config'),
		$main = nsServers.$el = $('<div>').addClass('main main_serverbrowser page hidden').appendTo('#frontend'),
		collection = nsServers.collection = new APP.Collection.Servers([], {
			handlePing: true   
		}),
		$panelLeft = nsServers.$panelLeft = $('<div>').addClass('page-panel left').appendTo($main),
		$browserlist = $('<div>').attr('id', 'browser-list').addClass('tableContainer scroll-pane server-list-browser').appendTo($panelLeft),
		$loading = $('<div>').addClass('update-overlay').text(APP.sidis.trans('WEB_GAME_SERVERBROWSER_RETRIEVING_SERVERS')).appendTo($browserlist),
		
		
		/**
		 * On Sekect Server
		 */
		onSelectServer = function onSelectServer(model) {
			if (model && (!nsServers.infoView || model.id !== nsServers.infoView.model.id)) {
				if (nsServers.infoView) {
					nsServers.infoView.destroy();
				}
				
				nsServers.infoView = new APP.View.ServerInfo({
					model: model,
					container: $main,
					className: 'server_info has_buttons page-panel right'
				});
								
				nsServers.infoView.bind('join', function (view, model) {
					APP.trigger('join', model);
				});
				
				nsServers.infoView.attach().render();
			}
        },

        mapIds = _.keys(APP.Model.Server.maps).map(function (key) {
            return parseInt(key, 10);
        }),

		gamemodeIds = _.keys(APP.Model.Server.gameModes).map(function (key) {
			return parseInt(key, 10);
		});
    
		
	/**
	 * Handle join events
	 */
	APP.bind('join', function (model) {
		APP.ns('game').joinServer(model);
	});
	
	/**
	 * Add bookmark
	 */
	APP.bind('bookmark:add', function addBookmark(model) {
		model = collection.get(model);
		
		if (!model) {
			return;
		}
		
		$.ajax({
			type: 'POST',
			url: nsConfig.serverAddUrl,
			data: {serverId: model.id},
			cache: false,
			success: function (message) {
				if (message && message.result === 'success') {
					model.set({'bookmarked': true});
				} else {
					APP.log.warn('add server bookmark error!');
				}
			},
			error: function (XMLHttpRequest, textStatus, errorThrown) {
				APP.log.warn('add server bookmark error!');
			}
		});
	});
	
	/**
	 * Remove bookmark
	 */
	APP.bind('bookmark:remove', function removeBookmark(model) {
		model = collection.get(model);
		
		if (!model) {
			return;
		}
		
		$.ajax({
			type: 'POST',
			url: nsConfig.serverRemoveUrl,
			data: {serverId: model.id},
			cache: false,
			success: function (message) {
				if (message && message.result === 'success') {
					model.set({'bookmarked': false});
				} else {
					APP.log.warn('remove server bookmark error!');
				}
			},
			error: function (XMLHttpRequest, textStatus, errorThrown) {
				APP.log.warn('remove server bookmark error!');
			}
		});
	});
	
	
	/**
	 * The first time we get some data
	 */
	collection.once('reset', function onResetCollection() {
		
		/**
		 * Filter View
		 */
		nsServers.filterView = new APP.View.ServerFilter({
            maps: mapIds,
			gamemodes: gamemodeIds,
			modelBrowser: new APP.Model.ServerFilter({
				'tab': 'browser',
				'hideEmpty': true,
				'hideFull': true,
				'geo': win.matchmaking ? win.matchmaking.getPingSite() : 'gva',
				'maps': mapIds,
				'gamemodes': gamemodeIds,
				'showUnranked': false
			}, {
				'storageKey': 'filterBrowser'
			}),
			modelBookmarks: new APP.Model.ServerFilter({
				'tab': 'bookmarks',
				'showOffline': false
			}, {
				'storageKey': 'filterBookmarks'
			}),                
			container: $panelLeft,                
			collection: collection
		});
				
		// Attach
		nsServers.filterView.attach({
			prepend: true
		});
		
		// Render
		nsServers.filterView.render();
		
		/**
		 * Browser List View
		 */
		nsServers.tableView = new APP.View.ServerList({
			collection: collection,
			container: $browserlist
		});
		
		nsServers.tableView.once('render', function () {
			$loading.hide();
		});
		
		nsServers.tableView.render();
        
        
		nsServers.tableView.filterBy(nsServers.filterView.modelBrowser.toJSON());
		
       
        
		nsServers.tableView.attach();
		
		// Listen to select events
		nsServers.tableView.bind('select', function (model) {
			collection.setSelected(model);
		});
		
		nsServers.filterView.bind('filter', function (filter) {
			nsServers.tableView.filterBy(filter);
		});
	});
	
	
	/**
	 * On Server reload
	 */
	collection.bind('reload:before', function () {
		$loading.show();
	});
	collection.bind('reload', function () {
		$loading.hide();
		if (nsServers.filterView.tabName === 'browser') {
			nsServers.tableView.filterBy(nsServers.filterView.modelBrowser.toJSON());
		} else if (nsServers.filterView.tabName === 'bookmarks') {
			nsServers.tableView.filterBy(nsServers.filterView.modelBookmarks.toJSON());
		}
	});
	
	
	/**
	 * On sever select
	 */
	collection.bind('select', function (model) {
		nsServers.trigger('select', model);
	});
	nsServers.bind('select', onSelectServer);
	
	
	/**
	 * Initialize
	 */
	nsServers.setup(function initializeServers(ready) {
		// Reader loading text
		$loading.show();
		
		// Fetch servers
		collection.fetch();
		
		// 
		ready();
	});
	nsServers.ready(function onReadyServers() {
		nsServers.$el.removeClass('loading');
	});
	
	/**
	 * Task done!
	 */
	done();
});



/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule servers
 */
/**
 * @class GAME.Task.server-friends
 */
APP.domTask('server-friends', function taskServerFriends(done) {
	"use strict";
	
	var nsGame = APP.ns('game'),
		$ = APP.$,
		win = APP.win,
		_ = APP._,
		
		$main = $('div.main_joinfriends'),
		$friendList = $('ul.list.friends_list'),

		getServerFromDOM = function (el) {

			var attrs = $(el).data(),
				server;

			if (!_.isEmpty(attrs)) {
				attrs.online = true;
				server = new APP.Model.Server(attrs);
			}

			return server;
		},
		
		tooltipView,
		destroyTooltip = function () {
			if (tooltipView) {
				tooltipView.destroy();
				tooltipView = null;
			}
		},
		
		
		joinButton = new APP.View.Button({
			text: APP.sidis.trans('WEB_GAME_JOIN_JOIN_GAME'),
			container: $('div.main_joinfriends div.buttons')
		}),

		
		checkActiveFriend = nsGame.checkActiveFriend = function () {
			var	server = getServerFromDOM($friendList.find('li.active span.gameinfo'));

			if (server && server.get('online')) {
				joinButton.enable();
			} else {
				joinButton.disable();
			}
		};
	
	joinButton.bind('click', function (view, e) {
		e.preventDefault();
		
		var $active = $friendList.find('li.active'),
			server = getServerFromDOM($active.find('span.gameinfo')),
			playerName;
			
		if (server && server.get('online')) {
			playerName = $active.find('a').data('name');
			nsGame.joinPlayer(playerName, server);
		}
	});
		
	joinButton.attach({
		prepend: true
	});

	joinButton.render();

	checkActiveFriend();
	
	

	/**
	 * Click on a 
	 */
	$friendList.delegate('li.friend', 'click', function onClickFriend(e) {
		e.preventDefault();
		
		var $el = $(this),
			isActive = $el.hasClass('active');
		
		$friendList.find('li.friend').removeClass('active');
		if (!isActive) {
			$el.addClass('active');	
		}

		checkActiveFriend();
	});

	
	
	$friendList.delegate('li.friend.status-ingame a  span.joinNow', 'click', function onClickJoinFriend(e) {
		e.preventDefault();
		
		destroyTooltip();
		
		var $el = $(this),
			server = getServerFromDOM($el.prev('span.gameinfo')),
			playerName;
		
		if (server && server.get('online')) {
			playerName = $el.closest('a').data('name');
			nsGame.joinPlayer(playerName, server);
		}
	});
	
	
	
	$friendList.delegate('li.friend.status-ingame span.joinNow', 'mouseenter', function onMouseEnterFriend(e) {
		destroyTooltip();
		
		var $el = $(this),
			server = getServerFromDOM($el.prev('span.gameinfo')),
			html = [];
		
		if (server && server.get('online')) {
			html.push('<h2>' + (server.get('name') || '') + '</h2>');
			html.push('<p>' + server.get('currentMapName') + '<span>' + server.get('players') + '/' + server.get('capacity') + '</span></p>');

			if (server.get('hasPassword')) {
				html.push('<span class="password">' + APP.sidis.trans('WEB_GAME_GAMEINFO_LOCKED') + '</span>');
			}

			if (!server.get('ranked')) {
				html.push('<span class="unranked">' + APP.sidis.trans('WEB_GAME_GAMEINFO_UNRANKED') + '</span>');
			}

			tooltipView = new APP.View.Tooltip({
				className: 'server-tooltip'
			});

			tooltipView.attach();

			tooltipView.renderHTMLAndShow(html.join(''), $el);
		}
	});
	
	
	$friendList.delegate('li.friend.status-ingame span.joinNow', 'mouseleave', function onMouseLeaveFriend(e) {
		destroyTooltip();
	});
	
	
	/**
	 * Task done
	 */
	done();
});
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule servers
 */
/**
 * @class GAME.Task.servers.routes
 * @uses GAME.Task.servers
 */
APP.task('servers.routes', [ 'servers' ], function taskOptionsRoutes(done) {
	"use strict";
	
	
	var win = APP.win,
		$ = APP.$,
		_ = APP._,
		nsServers = APP.namespace('servers');
	
	/**
	 * Serverbrowser Page
	 */
	APP.bind('page:serverbrowser', function onPageServerbrowser(from, data) {
		if (from !== 'serverbrowser') {
			win.dontUpdateDoll = true;
			win.hideDoll();
		}
		
		// Start
		nsServers.start(function onRunServersNS() {
			var model;
			
			if (data.id) {
				model = nsServers.collection.get(data.id);
				if (model) {
					nsServers.trigger('select', model);
				
				} else {
					new APP.Model.Server({
						persistentId: data.id
					}).fetch({
						'success': function onFetchSuccess(model) {
							nsServers.trigger('select', model);
						},
						'error': function onFetchError() {
							APP.log.warn('Unable to fetch server');
						}
					});
				}
			}
		});
	});
	
	
	/**
	 * Serverbrowser route
	 */
	APP.route('serverbrowser', 'serverbrowser', function onServerbrowserRoute() {
		APP.page('serverbrowser');
	});
	
	
	/**
	 * Serverbrowser route
	 */
	APP.route('/serverbrowser/:id', 'server-info', function onServerInfoRoute(id) {
		APP.page('serverbrowser', {
			id: id
		});
	});
	
	// TEMP
	
	
	
	/**
	 * Joinfriends Page
	 */
	APP.bind('page:joinfriends', function onPageJoinfriends(from) {
		if (from !== 'joinfriends') {
			win.dontUpdateDoll = true;
			win.hideDoll();
		}
	});
	
	
	/**
	 * Joinfriends route
	 */
	APP.route('joinfriends', 'joinfriends', function onJoinfriendsRoute() {
		APP.page('joinfriends');
	});
	
	
	
	
	/**
	 * Task done!
	 */
	done();
});
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule welcome
 */
(function (root) {
	"use strict";


	var APP = root.APP,
		$ = APP.$,
		_ = APP._;
	
	
	/**
	 * Welcome View
	 */
	APP.View.Welcome = APP.View.extend({

		name: 'welcome-view',
		
		initialize: function initializeWelcomeView() {
			this._index = 0;
			this._length = this.options.views.length;
			
			this.bind('button:click', this.next, this);
			
			this.bind('view:buy', function (view, model) {
				this.trigger('buy', this, model);
			}, this);

			this.bind('view:equip', function (view, model) {
				this.trigger('equip', this, model);
			}, this);
		},
		
		next: function nextWelcomeView(options) {
			this._index += 1;
			// At the end
			if (this._index >= this._length) {
				if (!options || !options.silent) {
					this.trigger('done', this);
				}
			// 
			} else {
				this._renderView(options);
				if (!options || !options.silent) {
					this.trigger('next', this, this._index);
				}
			}
			return this;
		},
		
		_renderView: function _renderViewWelcomeView(options) {
			
			var text = this._index === (this._length - 1) ? 'DONE' : 'NEXT',
				view = this.options.views[this._index],
				$lights = this.$('ul.lights li'),
				oldView = this._currentView;

			this._button.text(this.trans('WEB_GAME_WELCOME_BTN_' + text));
			
			// Mark
			$lights.slice(0, this._index).addClass('done');
			
			// Create, render and attach
			this._currentView = this.createView(view.view, _.extend(view.options, {
				container: this._container
			}), 'view').render().attach();
			

			// If we got a old view, move it back!
			if (oldView) {
				oldView.$el.one('webkitTransitionEnd', _.bind(function () {
					if (oldView) {
						oldView.destroy();
					}
					$lights.eq(this._index).addClass('active');
					this._button.enable();
				}, this));
				oldView.$el.css({
					'opacity': 0,
					'z-index': 0
				});
				this._button.disable();
			} else {
				$lights.eq(this._index).addClass('active');
			}
			
			this._currentView.$el.css('opacity', 1);
		},
		
		
		render: function renderWelcomeView() {
			
			var ul = this.make('ul', {
					'class': 'lights'
				});
			
			this._container = this.make('div', {
				'class': 'container'
			});
			this.el.appendChild(this._container);
			
			
			if (this._length > 1) {
				_.times(this._length, function () {
					ul.appendChild(this.make('li'));
				}, this);
			}
			this.el.appendChild(ul);
			
			this._button = this.createView(APP.View.Button, {
                large: true,
                glyph: 'arrow',
                text: ' '
            }, 'button').render().attach();
			
			this._renderView();
		}
	});


}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule welcome
 */
(function (root) {
	"use strict";


	var APP = root.APP;
	
	APP.View.WelcomeRankUp = APP.View.extend({
		name: 'welcome-rankup-view',

		initialize: function () {
			this.bind('item:buy', this._onItemBuy, this);


			this.bind('item:equip', this._onItemEquip, this);
		},

		_onItemBuy: function _onItemBuyWelcomeRankUp(view) {
			APP.log('_onItemBuyWelcomeRankUp', view);
			this.trigger('buy', this, view.model);
		},

		_onItemEquip: function _onItemEquipWelcomeRankUp(view) {
			APP.log('_onItemEquipWelcomeRankUp', view);
			this.trigger('equip', this, view.model);
		},
		
		_renderTrainingPoint: function _renderTrainingPointWelcomeRankUpView() {
			var li = this.make('li', {
					'class': 'border-box'
				});

			li.appendChild(this.make('div', {
				'class': 'title-bar'
			}, '<span class="name">' + this.trans('WEB_GAME_GAMEEVENT_ONE_TRAINING_POINT') + '</span>'));

			li.appendChild(this.make('span', {
				'class': 'training-point'
			}));
			
			return li;
		},
		
		_renderList: function _renderListWelcomeRankUpView(collection) {
			var list = this.make('ul', {
					'class': 'item-list'
				});
			
			list.appendChild(this._renderTrainingPoint());
			
			
			this.collection.forEach(function (model) {

				this.createView(APP.View.WelcomeRankUpItem, {
					container	: list,
					className	: 'border-box',
					model		: model
				}, 'item').render().attach();

			}, this);


			return list;
		},
		
		render: function renderWelcomeRankUpView() {
			

			var scrollContainer = this.make('div', {
					'class': 'scroll-container'
				}),
				rankBar = this.make('div', {
					'class': 'rank-bar'
				}),
				list = this._renderList(),
                h2 = this.make('h2');
            
            h2.appendChild(this.make('span', {'class': 'header-label'}, this.trans('WEB_GAME_GAMEEVENT_LEVEL') + ' ' + this.options.level));
            h2.appendChild(this.make('span', null, (this.collection.length > 1 ? this.trans('WEB_GAME_GAMEEVENT_NEW_ITEMS_UNLOCKED') : this.trans('WEB_GAME_GAMEEVENT_NEW_ITEM_UNLOCKED')) + ':'));
            
			this.el.appendChild(this.make('h1', null, this.trans('WEB_GAME_WELCOME_EXPIRED_HEADER')));
			this.el.appendChild(h2); 

			rankBar.appendChild(this.make('div', {
				'class': 'rank-meter',
				'style': 'width: 100%'
			}));
			this.el.appendChild(rankBar);

			this.el.appendChild(this.make('div', {
				'class': 'scroll-well'
			}));
			scrollContainer.appendChild(list);
			this.el.appendChild(scrollContainer);
		}
	});


}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule welcome
 */
(function (root) {
	"use strict";

	var APP = root.APP,
		_ = APP._,
		nsConfig = APP.ns('config'),
		doc = APP.doc;


	APP.View.WelcomeRankUpItem = APP.View.extend({
		name: 'welcome-rankup-item',
		tagName: 'li',
		events: {
			'click a.more-info': function (e) {
				e.preventDefault();
				this.$el.addClass('show-stats');
			},
			'click div.stats-view': function (e) {
				e.preventDefault();
				this.$el.removeClass('show-stats');
			} 
		},

		initialize: function initializeGameEventItemView() {
			this.model.bind('change', this.render, this);
			this.model.bind('purchase:start', this._onPurchaseStart, this);
			this.model.bind('purchase:end', this._onPurchaseEnd, this);
			this.bind('buy:click', this._onBuyClick, this);
			this.bind('equip:click', this._onEquipClick, this);


			var category = this.model.get('category');


			if (this.model.get('itemType') === 'appearance') {
				this.pocketModel = this.model.collection.get(function (model) {
					return (model.isItemType('pocket') && model.get('category') === category);
				});
			}
		},

		destroy: function destroyGameEventItemView() {
			this.model.unbind('change', this.render, this);
			this.model.unbind('purchase:start', this._onPurchaseStart, this);
			this.model.unbind('purchase:end', this._onPurchaseEnd, this);
		},

		_onPurchaseStart: function _onPurchaseStartGameEventItemView() {
			this.$el.addClass('loading');
		},

		_onPurchaseEnd: function _onPurchaseEndGameEventItemView() {
			this.$el.removeClass('loading');
		},

		_onBuyClick: function _onBuyClickGameEventItemView(view, e) {
			this.trigger('buy', this, this.model, e);
		},

		_onEquipClick: function _onEquipClickGameEventItemView(view, e) {
			this.trigger('equip', this, this.model, e);
		},

		/* Render pockets on apparel items */
		_renderPockets: function () {
			var maxSlots = this.model.get('maxNumPockets'),
				availableSlots = this.model.get('numberOfPockets'),
				upgrades = this.model.getCustomizations(),
				pocketWrapper = this.make('div', {'class': 'pocket-wrapper'}),
				unlockLevels = (this.pocketModel && this.pocketModel.get('unlockLevels')) || {},
				pocketOffers = (this.pocketModel && this.pocketModel.get('pocketOffers')) || {},
				personaLevel = (this.pocketModel && this.pocketModel.get('personaLevel')) || 0;

			_.forEach(upgrades, function (upgrade, index) {
				var available = availableSlots > index,
					classNames,
					isLocked = personaLevel < unlockLevels[index],
					offers = pocketOffers[index];

				// Owned pocket
				if (available) {

					// Upgrade	
					if (upgrade) {
						if (upgrade.isOwned()) {
							classNames = 'filled';
						} else {
							classNames = 'invalid';
						}
					} else {
						classNames = 'empty';
					}

					// Not Owned
				} else if (isLocked) {
					if (offers && offers.hasUnlockOffers()) {
						classNames = 'unlockable';
					} else {
						classNames = 'locked';
					}

					// Buyable
				} else if (offers && offers.length !== 0) {
					classNames = 'buyable';

				}



				pocketWrapper.appendChild(this.make('span', {'class': classNames}));
			}, this);

			return pocketWrapper;
		},


		/**
		 * Render
		 */
		render: function renderItemGameEventItemView() {
			var nsConfig = APP.namespace('config'),
				titleBar = this.make('div', {
					'class': 'title-bar'
				}),
				itemImgWrapper = this.make('div', {'class': 'img-container'}),
				itemImg = this.make('img', {
					'src': this.model.getImage('med'),
					'width'	: nsConfig.imageSize.med.width,
					'height': nsConfig.imageSize.med.height
				}),
				purchaseOptions = doc.createDocumentFragment(),
				lowest,
				prices,
				offers,
				pocket,
				priceLabel,
				statsList,
				dependency = this.model.getDependencies(),
				activeGear = dependency.gear && dependency.gear.isOwned(),
				untrainedAbility = dependency.ability && dependency.ability.get('level') === 0,
				unresolvedDeps = activeGear || untrainedAbility,
				trialBanner,
				trial = this.model.get('trial');


			if (this.model.isItemType('pocket')) {
				pocket = _.indexOf(this.model.get('unLockLevels'), this.model.get('personaLevel'));
				offers = this.model.get('pocketOffers')[pocket];
				priceLabel = this.trans('WEB_GAME_WEAPONS_INFO_PRICE');
			} else {
				offers = this.model.get('offers');
				priceLabel = this.trans('WEB_GAME_WEAPONS_INFO_PRICE_FROM');
			}

			// Show purchase area if buyable
			if (offers && offers.length !== 0) {
				lowest = offers.getLowestOffers();

				prices = this.make('div', {
					'class': 'prices'
				});
				
				if (lowest.credits) {
					prices.appendChild(this.make('span', {
						'class': 'currency credits'
					}, lowest.credits.get('price') + '<i class="glyphs glyphs-credits20"></i>'));
				}
				if (lowest.funds) {
					prices.appendChild(this.make('span', {
						'class': 'currency funds'
					}, lowest.funds.get('price') + '<i class="glyphs glyphs-funds20"></i>'));
				}
				purchaseOptions.appendChild(prices);

				// Don't show button when there are unresolved dependencies or when it's a pocket
				if (!unresolvedDeps && !this.model.isItemType('pocket')) {
					this.createView(APP.View.Button, {
						container: purchaseOptions,
						className: 'buy',
						primary: true,
						glyph: 'buy',
						text: this.trans('WEB_GAME_TOOLTIPS_BUY_BTN'),
						sound: true
					}, 'buy').render().attach();
				}
				

				this.createView(APP.View.LabelBox, {
					'label': priceLabel,
					'content': purchaseOptions,
					'className': 'purchase'
				}).render().attach();
			} else {
				itemImgWrapper.className += " solo";
			}

			/* Show pockets in apparel items */
			if (this.model.get('itemType') === 'appearance') {
				this.el.appendChild(this._renderPockets());
			}

			// Show stats on weapons & upgrades
			if (this.model.hasStats()) {
				titleBar.appendChild(this.make('a', {
					'class': 'more-info'
				}, this.trans('WEB_GAME_GAMEEVENT_INFO')));
				titleBar.className += " with-info";
			}

			// Title Bar
			titleBar.appendChild(this.make('span', {
				'class': 'name'
			}, this.model.get('name')));
			titleBar.appendChild(this.make('span', {
				'class': 'category'
			}, this.model.get('categoryname')));
			
			// Trial
			if (trial) {
				trialBanner = this.make('div', {
					'class': 'trial-banner'
				});
				
				// Equipped
				if (this.model.isEquipped()) {
					trialBanner.appendChild(this.make('span', {
						'class': 'trial-message'
					}, this.trans('WEB_GAME_WELCOME_RANKUP_TRIAL_EQUIPPED')));
					
					trialBanner.appendChild(this.make('span', {
						'class': 'trial-label'
					}, this.trans('WEB_GAME_WELCOME_RANKUP_UNLOCK_BONUS')));
					
					
				// Equipable
				} else if (this.model.autoEquip(true)) {
					
                    if (this.model.get('itemType') !== 'attachment'){
                        this.createView(APP.View.Button, {
                            container: trialBanner,
                            text: this.trans('WEB_GAME_COMMON_BTN_EQUIP')
                        }, 'equip').render().attach();
                    }
					
					trialBanner.appendChild(this.make('span', {
						'class': 'trial-label'
					}, this.trans('WEB_GAME_WELCOME_RANKUP_UNLOCK_BONUS')));
					
					trialBanner.appendChild(this.make('span', {
						'class': 'trial-message'
					}, this.transChoice('WEB_GAME_WELCOME_RANKUP_TRIAL_ACTION', trial, {
						'%amount%': trial
					})));
				
					
				// 
				} else {
					trialBanner.appendChild(this.make('span', {
						'class': 'trial-label'
					}, this.trans('WEB_GAME_WELCOME_RANKUP_UNLOCK_BONUS')));

					trialBanner.appendChild(this.make('span', {
						'class': 'trial-message'
					}, this.transChoice('WEB_GAME_WELCOME_RANKUP_TRIAL_INVENTIORY', trial, {
						'%amount%': trial
					})));
				}

				titleBar.appendChild(trialBanner);
			}
			this.el.appendChild(titleBar);
				
			
			
			// Image
			itemImgWrapper.appendChild(itemImg);
			this.el.appendChild(itemImgWrapper);

			// Item id
			this.$el.attr({
				'item-id': this.model.id
			});

			if (this.model.hasStats()) {
				this.createView(APP.View.Stats, {
					model: this.model
				}).render().attach();
			}
		}
	});

}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule welcome
 */
(function (root) {
	"use strict";


	var APP = root.APP,
		_ = APP._,
		nsConfig = APP.ns('config');
	

	APP.View.WelcomeExpired = APP.View.extend({
		name: 'welcome-expired-view',

		initialize: function () {
			this._expired = this.options.expired;	
			this._soon = this.options.soon;
			this._low = this.options.low;
			
			this.bind('item:buy:click', this._onClickItemBuy, this);
		},
		
		_onClickItemBuy: function _onClickItemBuyWelcomeExpired(buttonView) {
			this.trigger('buy', this, buttonView.model);
		},
		
		_renderList: function _renderListWelcomeExpiredView(collection) {
			var list = this.make('ul', {
					'class': 'item-list'
				});
			
			collection.forEach(function (model) {
				
				this.createView(APP.View.WelcomeExpiredItem, {
					container	: list,
					className	: 'border-box',
					soonTs		: this.options.soonTs,
					lowLimit	: this.options.lowLimit,
					model		: model
				}, 'item').render().attach();
				
			}, this);
			
			
			return list;
		},
		
		render: function renderWelcomeExpiredView() {

			var scrollContainer = this.make('div', {
					'class': 'scroll-container'
				}),
				header;


			this.el.appendChild(this.make('h1', null, this.trans('WEB_GAME_WELCOME_EXPIRED_HEADER')));
			this.el.appendChild(this.make('h2', null, this.trans('WEB_GAME_WELCOME_EXPIRED_SUBHEADER') + ':'));
			

			this.el.appendChild(this.make('div', {
				'class': 'scroll-well'
			}));
			
			// Expired
			header = this.make('h3', { 'class': 'expired' }, this.trans('WEB_GAME_HEAD_EXPIRED_ITEMS'));
			header.appendChild(this.make('i', { 'class': 'glyphs glyphs-exclaim-expired' }));
			scrollContainer.appendChild(header);
			scrollContainer.appendChild(this._renderList(this._expired));
			
			// Expires soon
			if (this._soon && this._soon.length !== 0) {
				header = this.make('h3', { 'class': 'soon' }, this.trans('WEB_GAME_HEAD_EXPIRING_ITEMS'));
				header.appendChild(this.make('i', { 'class': 'glyphs glyphs-exclaim-rented' }));
				scrollContainer.appendChild(header);
				scrollContainer.appendChild(this._renderList(this._soon));
			}
			
			// Low use count
			if (this._low && this._low.length !== 0) {
				header = this.make('h3', { 'class': 'soon' }, this.trans('WEB_GAME_HEAD_LOWCOUNT_ITEMS'));
				header.appendChild(this.make('i', { 'class': 'glyphs glyphs-exclaim-info' }));
				scrollContainer.appendChild(header);
				scrollContainer.appendChild(this._renderList(this._low));
			}
			
			this.el.appendChild(scrollContainer);
		}
	});


}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule welcome
 */
(function (root) {
	"use strict";
	
	var APP = root.APP,
		_ = APP._,
		nsConfig = APP.ns('config');
	
	
	/**
	 * Welcome Expired Item View
	 */
	APP.View.WelcomeExpiredItem = APP.View.extend({
		name: 'welcome-expired-item-view',
		tagName: 'li',
		
		initialize: function () {
			this.model.bind('purchase:start', this._onPurchaseStart, this);
			this.model.bind('purchase:end', this._onPurchaseEnd, this);
		},

		_onPurchaseStart: function _onPurchaseStartWelcomeExpired() {
			this.$el.addClass('loading');
		},
		
		_onPurchaseEnd: function _onPurchaseEndWelcomeExpired() {
			// TODO: Decide it we should show the buy button or not
			
			this.render();
		},
		
		render: function () {
			var inner = this.make('div', {
					'class': 'inner'
				}),
				flagLabel,
				flagState,
				showButton = false,
				customIconCategories = [ 'barrel', 'ammo', 'stock' ],
				icon,
				src;

			

			// Weapon, Attachment & Upgrade Item icon
			if (this.model.isItemType('weapon') || this.model.isItemType('booster') || this.model.isItemType('attachment')) {
				if (!this.model.isItemType('attachment') || _.indexOf(customIconCategories, this.model.get('category')) === -1) {
					src = nsConfig.imageFolder + 'item-icons/min/' + this.model.id + '.png';
				} else {
					src = nsConfig.imageFolder + 'item-icons/min/' + this.model.get('category') + '.png';
				}

				icon = this.make('img', {
					'width': 80,
					'height': 60,
					'src': src
				});

				// Other (apparel) item icons
			} else {
				icon = this.make('span', {
					'class': 'item-min item-min-' + this.model.id
				});
			}
			this.el.appendChild(icon);


			// Text block
			inner.appendChild(this.make('h4', null, this.model.get('name')));
			inner.appendChild(this.make('p', null, this.model.get('categoryname')));
			
			if (this.model.isConsumable()) {
				flagLabel = this.trans('WEB_GAME_ITEM_USES_LEFT') + ' ' + this.model.get('usecount');
				flagState = this.model.get('usecount') < this.options.lowLimit ? 'invalid' : '';

				inner.appendChild(this.make('p', {
					'class': flagState
				}, flagLabel));
				
			} else if (!this.model.isOwnedPermanent()) {
				flagLabel = this.model.getExpireText();
				flagState = this.model.isExpired() ? 'invalid' : '';

				inner.appendChild(this.make('p', {
					'class': flagState
				}, flagLabel));
			}
			

			this.el.appendChild(inner);
			
			if (this.model.isExpired()) {
				showButton = true;
			} else if (this.model.isRented() && this.model.get('expireTS') < this.options.soonTS) {
				showButton = true;
			} else if (this.model.isConsumable() && this.model.isOwned()  && this.model.get('usecount') < this.options.lowLimit) {
				showButton = true;
			}
			
			if (this.model.isBuyable()) {
				// Buy button
				if (showButton) {
					this.createView(APP.View.Button, {
						model: this.model,
						glyph: 'buy',
						primary: true,
						text: this.trans('WEB_GAME_TOOLTIPS_BUY_BTN')
					}, 'buy').render().attach();
	
				// Purchased
				} else {
					this.el.appendChild(this.make('span', {
						'class': 'purchased'
					}, this.trans('WEB_GAME_WELCOME_EXPIRED_ITEM_PURCHASED')));
				}
			}
		}
	});
	
}(this));

/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule welcome
 */
(function (root) {
	"use strict";


	var APP = root.APP,
		doc = APP.doc;


	APP.View.WelcomeVIP = APP.View.extend({
		name: 'welcome-vip-view',
		
		_renderList: function _renderListWelcomeVIPView(collection) {
			var list = this.make('ul', {
				'class': 'item-list'
			});

			collection.forEach(function (model) {

				this.createView(APP.View.WelcomeVIPItem, {
					container	: list,
					className	: 'border-box',
					model		: model
				}, 'item').render().attach();

			}, this);


			return list;
		},
		
		render: function renderWelcomeVIPView() {

			var scrollContainer = this.make('div', {
					'class': 'scroll-container'
				}),
				added = doc.createDocumentFragment(),
				removed = doc.createDocumentFragment();

            this.el.appendChild(this.make('h1', null, this.trans('WEB_GAME_WELCOME_EXPIRED_HEADER')));
            this.el.appendChild(this.make('h2', null, this.trans('WEB_GAME_TOOLTIPS_HEADER_VIP_ADDED') + ':'));
			
			// Added
			if (this.options.added && this.options.added.length !== 0) {
				added.appendChild(this.make('h3', null, this.trans('WEB_GAME_TOOLTIPS_MESSAGE_VIP_ADDED')));
				
				// Render list
				added.appendChild(this._renderList(this.options.added));
			}
			
			// Removed
			if (this.options.removed && this.options.removed.length !== 0) {
				removed.appendChild(this.make('h3', null, this.trans('WEB_GAME_TOOLTIPS_MESSAGE_VIP_REMOVED')));
				
				// Render list
				removed.appendChild(this._renderList(this.options.removed));
			}
			
			this.el.appendChild(this.make('div', {
				'class': 'scroll-well'
			}));
			scrollContainer.appendChild(added);
			scrollContainer.appendChild(removed);
			this.el.appendChild(scrollContainer);
		}
	});


}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule welcome
 */
(function (root) {
	"use strict";

	var APP = root.APP,
		_ = APP._,
		nsConfig = APP.ns('config'),
		doc = APP.doc;


	APP.View.WelcomeVIPItem = APP.View.extend({
		name: 'welcome-vip-item',
		tagName: 'li',
		events: {
			'click a.button-view': function onClickBookmark(e) {
				e.preventDefault();
				this.model.toggleBookmark();
				this.$el.addClass('loading');
			}
		},

		initialize: function initializeGameEventItemView() {
			this.model.bind('change:bookmarked', this.render, this);
		},

		destroy: function destroyGameEventItemView() {
			this.model.unbind('change:bookmarked', this.render, this);
		},
		
		/**
		 * Render
		 */
		render: function renderItemGameEventItemView() {
            var serverRow = this.make('div');
            
			this.$el.attr({
				'server-id': this.model.id
			});


            serverRow.appendChild(this.make('i', {'class': 'glyphs glyphs-exlaim-info'}));
            
			serverRow.appendChild(this.make('span', {
				'class': 'name'
			}, this.model.get('name')));

            this.el.appendChild(serverRow);
            
			this.createView(APP.View.Button, {
                container: this.el,
                primary: true,
                glyph: (this.model.get('bookmarked') ? 'star' : 'star-black'),
                attrs: {'href': '#bookmark/' + this.model.id },
                text: (this.model.get('bookmarked') ? this.trans('WEB_GAME_SERVERBROWSER_TITLETOOLTIP_BOOKMARKED') : this.trans('WEB_GAME_TOOLTIPS_ADD_VIP_BOOKMARK_BTN')),
                sound: true
            }, 'bookmark').render().attach();

		}
	});

}(this));
/*jshint smarttabs:true white:true */
/**
 * @module GAME
 * @submodule welcome
 */
/**
 * @class GAME.Task.welcome
 * @uses GAME.Task.items
 * @uses GAME.Task.game
 * @uses GAME.Task.game-vip
 * @uses GAME.Task.config
 */
APP.task('welcome', [ 'items', 'game', 'game-vip', 'config' ], function (done) {
	"use strict";
	
	var $ = APP.$,
		_ = APP._,
		nsWelcome = APP.ns('welcome'),
		nsItems = APP.ns('items'),
		nsGame = APP.ns('game'),
		nsConfig = APP.ns('config'),
		nsStore = APP.ns('store'),
        freshStart = true, // Used to determined if expired items should be included in welcome screen
		
		
		/**
		 * Check if there is any new messages
		 * @param {Function} fn
		 */
		checkMessages = nsWelcome.checkMessages = function (fn) {
			
			var lockTypeMap = {
					'LevelUpEvent'	: 'level',
					'level'			: 'level'
				},
				view,
				
				// Expired
				lastAuthenticated = nsConfig.lastAuthenticated,
				expiredItems = nsItems.collection.getExpiredSince(lastAuthenticated),

				// Expiring soon
				soonTS = Math.round((Date.now() + nsConfig.timeDiff + (5 * 60)) / 1000),
				soonItems = nsItems.collection.getExpiringSoon(soonTS),
	
				// Low use count
				lowLimit = 10,
				lowItems = nsItems.collection.getLowUseCount(lowLimit);
			
			
			//  Get game events
			nsGame.getGameEvents(function (err, gameEvents) {

				var views = [],
					queue = 0,
					ready = function (err) {
						if (queue === 0) {
							fn(err || null, nsWelcome.view);
						}
					},
					tpModel = nsItems.get('tp');
				
				
				if (err) {
					return ready(err);
				}
				
				
				if (gameEvents) {
					_.forEach(gameEvents, function (gameEvent) {
						var lockType = (lockTypeMap[gameEvent.lockType] || gameEvent.lockType).toLowerCase(),

							// Filter out items unlocked items
							collection = nsItems.collection.filterBy({
								lockType		: lockType,
								lockCriteria	: gameEvent.lockCriteria,
								buyable			: true
							}),

							unlockLevel;

						if (lockType === 'level') {
							
							unlockLevel = parseInt(gameEvent.lockCriteria, 10);
							
							// Ensure that they are unlocked
							collection.invoke('set', {
								isLocked: false	
							});
							
							// Unlocked pockets
							_.forEach(nsConfig.pockets.unlockLevels, function (levels, category) {
								var pocket = _.indexOf(levels, unlockLevel),
									model;

								// Check if there's a pocket unlock at this level
								if (pocket !== -1) {

									model = nsItems.collection.getBy({
										category	: category,
										itemType	: 'pocket'
									});

									if (model) {
										collection.unshift(model);
									}
								}
							});
						}

						// Trials
						if (!_.isEmpty(gameEvent.trialItems)) {
							_.forEach(gameEvent.trialItems, function (days, id) {
								var model = collection.get(id);
								if (model) {
									model.set('trial', days);
									queue += 1;
									model.fetch({
										complete: function () {
											queue -= 1;
											ready();
										}
									});
								}
							});
						}

						// Add RankUP view
						views.push({
							view: APP.View.WelcomeRankUp,
							options: {
								level: unlockLevel,
								collection: collection
							}
						});
					});
				}


				// Expired Items
				if (expiredItems.length !== 0 && freshStart) {
					// Add Expired view
					views.push({
						view: APP.View.WelcomeExpired,
						options: {

							expired	: expiredItems,

							soonTS	: soonTS,
							soon	: soonItems,

							lowLimit: lowLimit,
							low		: lowItems
						}
					});
				}
				
				
				// VIP Change
				if (!_.isEmpty(nsGame.vipStatusChanged)) {
					// Add VIP view
					views.push({
						view: APP.View.WelcomeVIP,
						options: {
							added: new APP.Collection.Servers(nsGame.vipStatusChanged.added || []),
							removed: new APP.Collection.Servers(nsGame.vipStatusChanged.removed || [])
						}
					});
				}


				// Should the welcome screen be shown?
				if (views.length !== 0) {
					nsWelcome.view = new APP.View.Welcome({
						views: views
					});
					
                    nsWelcome.view.bind('destroy', function () {
                        
                        // Removed trials property from items
                        _.forEach(gameEvents, function (gameEvent) {
                            // Trials
                            if (!_.isEmpty(gameEvent.trialItems)) {
                                _.forEach(gameEvent.trialItems, function (days, id) {
                                    var model = nsItems.collection.get(id);
                                    if (model) {
                                        model.unset('trial');
                                    }
                                });
                            }
                        });
                    });
                    
					// When "done" navigate home
					nsWelcome.view.bind('done', function () {
						APP.log('WelcomeView::done');
						
						// Destroy Welcome view
						nsWelcome.view.destroy();
						nsWelcome.view = null;
						
						
						
						// Clear VIP changes list						
						if (!_.isEmpty(nsGame.vipStatusChanged)) {
							$.ajax({
								type: 'POST',
								url: nsConfig.vipUpdatedURL,
								data: {},
								cache: false,
								success: function (message) {
									if (message && message.result === 'success') {
										APP.log('VIP list cleared');
									} else {
										APP.log.warn('clear VIP changes error!');
									}
								},
								error: function (XMLHttpRequest, textStatus, errorThrown) {
									APP.log.warn('clear VIP changes error!');
								}
							});
						}
						
						
						
						// Navigate "home"
						APP.navigate('home', {
							trigger: true
						});
					});

					// Listen to buy events
					nsWelcome.view.bind('buy', function (view, model) {
						APP.log('WelcomeView::buy', model);
						// Trigger Store buy event
						nsStore.trigger('buy', model);
					});

					// Listen to equip events
					nsWelcome.view.bind('equip', function (view, model) {
						APP.log('WelcomeView::equip', model);
						model.autoEquip();
					});
				}
				
				ready();
			});
		};

	
	checkMessages(function (err, view) {
		if (err) {
			APP.log.warn(err);
			
		} else if (view) {
			APP.ready(function () {
				view.render();
				view.attach();
			});
		}
        
        // Seen once, don't show expired items again during this session
        freshStart = false;
		
		// Task Done!
		done();
	});
});
/*globals window, document, Image, setTimeout, jQuery, $, console,
  hideDoll, localStorage, Cufon */

/**
 * Common utilities used by the frontend.
 * @name magma
 * @memberOf $
 * @constructor
*/
$.magma = (function($) {
    /**
    * Log debug messages to console.
    * @param {debuglevel} level Can be either debug, info, warn or error.
    */
    function debugLog(level, message) {
	
      var currentTime = new Date(),
        currentHours = currentTime.getHours(),
        currentMinutes = currentTime.getMinutes(),
        currentSeconds = currentTime.getSeconds(),
        currentMilliSeconds = currentTime.getMilliseconds(),
        timestamp,
        logEntry;

      currentMinutes = (currentMinutes < 10 ? '0' : '') + currentMinutes;
      currentSeconds = (currentSeconds < 10 ? '0' : '') + currentSeconds;

      timestamp = currentHours + ':' + currentMinutes + ':' +
        currentSeconds + ':' + currentMilliSeconds;

      // Firebug Console
      if (window.console !== undefined && console.log !== undefined) {

          logEntry = timestamp + ' - ' + message;

          if (console.debug !== undefined) {
              if (level === 'debug') {
                  console.debug(logEntry);
              } else if (level === 'warning' || level === 'warn') {
                  console.warn(logEntry);
              } else if (level === 'info') {
                  console.info(logEntry);
              } else if (level === 'error') {
                  console.error(logEntry);
              } else {
                  console.log(logEntry);
              }
          } else {
              console.log(logEntry);
          }
      }
      // Game log
      if (window.log && window.log.debug) {
          window.log.debug(timestamp + ' - ' + message);
      }
    }

    /**
    * Show info window before a reload.
    */
    function showReloadStatus() {
      // Hide doll
      if (window.doll && window.doll.visible === true) {
      hideDoll();
      }

      $('#preloader').show();
    }

    /**
    * Show loading window and reload page.
    */
    function reload() {
      showReloadStatus();

      // Reload page
      debugLog('debug', 'reload::Reloading page');
      setTimeout(function onTimeout() {
        window.location.reload();
      }, 1000);
    }

    /**
    * Show loading window and go to a new page.
    * @param {string} url URL to open.
    */
    function gotoURL(url) {
      showReloadStatus();

      // Reload page
      debugLog('debug', 'gotoURL::Reloading page');
      setTimeout(function onTimeout() {
        window.location = url;
      }, 200);
    }
	
	function changeItemClassSize(from, to) {
		return from.replace(/item\-(min|med|max)/g, 'item-' + to);
	}
	$.fn.changeItemClassSize = function (to) {
		var $el = $(this),
			className = $el.attr('class');
		if (className) {
			$el.attr('class', changeItemClassSize(className, to));
		}
		return this;
	};
	
	function changeItemClassId(from, to) {
		var size = (from.match(/item\-(min|med|max)/) || ['min']).pop();
		return $.trim(from.replace(/item\-(min|med|max)(\-[0-9]+)?/g, '')) + ' item-' + size + ' item-' + size + '-' + to;
	}
	$.fn.changeItemClassId = function (to) {
		var $el = $(this),
			className = $el.attr('class');
		if (className) {
			$el.attr('class', changeItemClassId(className, to));
		}
		return this;
	};
	
	// Game Item
	$.fn.gameItem = function gameItem(selector) {
		selector = '.game-item' + (selector || '');
		var $el = $(this);
		if ($el.is(selector)) {
			return $el;
		}
		return $el.find(selector);
	};
	
	
	$.fn.changeItemId = function (id) {
		var $el = $(this);
		$el.attr('item-id',id);
		$el.data('id',id);
		$el.changeItemClassId(id);
		return this;
	};

	function createGameItem(id) {
		var $item = $('<span>');
		$item.addClass('game-item item-min item-min-' + id);
		$item.attr('item-id', id);
		$item.data('id', id);
		return $item;
	}
	$.createGameItem = createGameItem;
	
	$.fn.itemId = function itemId(to) {
		var $el = $(this),
			id = $el.data('id');
		if (!id) {
			id = $el.attr('item-id');
			$el.data('id', id);
		}
		return id + String();
	};
	
	
	$.fn.webkitHighlight = function (webkitAnimationName, webkitAnimationDuration) {
		webkitAnimationName = webkitAnimationName || 'highlight';
		webkitAnimationDuration = webkitAnimationDuration || 500;
		
		var els = $(this).toArray(),
			len = els.length,
			i = 0,
			ended = 0,
			next = function () {
				i += 1;
				if (len > i) {
					setTimeout(process, Math.round(webkitAnimationDuration / 3));
				}
			},
			process = function () {
				var el = els[i],
					onEnd = function () {
						ended += 1;
						this.removeEventListener('webkitAnimationEnd', onEnd, false);
						this.style.webkitAnimationName = '';
						this.style.webkitAnimationDuration = '';
						if (len > 1 && ended === len) {
							setTimeout(function () {
								els.forEach(function (el) {
									var onEnd = function () {
											this.removeEventListener('webkitAnimationEnd', onEnd, false);
											this.style.webkitAnimationName = '';
											this.style.webkitAnimationDuration = '';
										};
									el.addEventListener('webkitAnimationEnd', onEnd, false)
									el.style.webkitAnimationName = webkitAnimationName;
									el.style.webkitAnimationDuration = webkitAnimationDuration + 'ms';
								});
							}, 0);
						}
					};
				el.addEventListener('webkitAnimationEnd', onEnd, false)
				el.style.webkitAnimationName = webkitAnimationName;
				el.style.webkitAnimationDuration = webkitAnimationDuration + 'ms';
				next();
			};
		
		if (len > i) {
			process();
		}
		
		return this;
	};
	
    return {
        debugLog: debugLog,
        reload: reload,
        gotoURL: gotoURL,
		changeItemClassSize: changeItemClassSize,
		createGameItem: createGameItem,
		getImageUrl: function getImageUrl(id, size) {
			size = size || 'max';
			return $.magma.jsVariables.imageFolder + 'item-icons/' + size + '/' + id + '.png';
		}
    };
}(jQuery));




/**
 * @author	Andreas Lanjerud, alanjerud@ea.com
 * @created	2009-07-24
 */

(function (root) {

	var $ = root.$ || function () {};
	
	$.highlights = (function() {

		// Log debug messages to Firefox console or Game Log
		function startSlideshow() {
			//$.magma.debugLog('Start slideshow');
			$.highlights.auto_rotate = setTimeout(rotateHighlights, auto_rotate_timeout);

			/*$('ul#hl_navigation').stop(true, true).delay(2500).animate({ 'bottom':'-60px' },{
			 duration: 400,
			 easing:'easeInCirc'
			 });*/
		}

		function afterRotation(data) {
			// Trigger this after the ad transition have completed
			$.highlights.$nav_elements.removeClass('selected');
			el = '#highlights a[href$="' + data.id + '"]';
			$(el).parent().addClass('selected');
			$('#hl_lights li.selected span').fadeOut().parent().removeClass('selected');
			el2 = '#hl_lights li[id$="' + data.id + '"]';
			$(el2).addClass('selected').find('span').fadeIn();
		}

		function rotateHighlights() {
			$($.highlights.scroll).delay(500).trigger("next.serialScroll");

			/*$('ul#hl_navigation').stop(true, true).animate({ 'bottom':'0px' },{
			 duration: 400,
			 easing:'easeOutCirc'
			 }).delay(2500).animate({ 'bottom':'-60px' },{
			 duration: 400,
			 easing:'easeInCirc'
			 });*/
			$.highlights.auto_rotate = setTimeout(rotateHighlights, auto_rotate_timeout);
		}

		var auto_rotate;
		var do_auto_rotate = true;
		var auto_rotate_timeout = 8000;
		var $container;
		var offset;
		var scroll;
		var $nav_elements;
		var $light_elements;
		var scrollOptions;

		return {
			afterRotation: afterRotation,
			rotateHighlights: rotateHighlights,
			startSlideshow: startSlideshow,
			scroll: scroll,
			scrollOptions: scrollOptions,
			auto_rotate: auto_rotate,
			offset: offset,
			$container: $container
		};
	}());

	$(function() {
		if ($('#hl_navigation li').length > 1) { //Only apply scroll functionality if there's more than one item

			$.highlights.auto_rotate;
			$.highlights.do_auto_rotate = true;
			$.highlights.auto_rotate_timeout = 8000;
			$.highlights.$container = $("h1_scroll_container"); // Should this be a class?
			$.highlights.offset = parseInt($("h1_scroll_container").css('paddingLeft') || 0) * -1;
			$.highlights.scroll = $('#highlights .hl_scroll');
			$.highlights.$nav_elements = $('#hl_navigation li');
			$.highlights.$light_elements = $('#hl_lights li');

			$.highlights.scrollOptions = {
				target: $('#highlights .hl_scroll'),
				items: 'div.panel',
				navigation: '#hl_navigation li',
				offset: parseInt($("h1_scroll_container").css('paddingLeft') || 0) * -1,
				duration: 800,
				axis: 'xy',
				easing: 'easeInOutCubic',
				step: 1,
				cycle: true,
				hash: false,
				constant: false,
				onAfter: function(data){
					$.highlights.afterRotation(data);
				}
			};

			$('#highlights .hl_scroll').serialScroll($.highlights.scrollOptions);

			// Pause scrolling when the mouse is over the ad
			$.highlights.scroll.bind('mouseenter', function() {
				//clearTimeout($.highlights.auto_rotate); 
			});
			$.highlights.scroll.bind('mouseleave', function() {
				if (do_auto_rotate) {
					$.highlights.auto_rotate = setTimeout(rotateHighlights, auto_rotate_timeout);
				}
			});

			$.localScroll($.highlights.scrollOptions);

			if (window.location.hash){
				// Mark current ad according to whats saved in the location hash
				$.highlights.afterRotation({ id: window.location.hash.substr(1) });
			}

			$('#highlights').click(function() {
				$(this).parents('ul:first').find('li').removeClass('selected').end().end().addClass('selected');
				clearTimeout($.highlights.auto_rotate);
				do_auto_rotate = false;
			});
			$('#highlights').hover(function(){
				$(this).find('ul#hl_navigation').stop(true, true).animate({ 'bottom':'0px' },{
					duration: 200,
					easing:'easeOutCirc'
				});
			},function(){
				$(this).find('ul#hl_navigation').stop(true, true).animate({ 'bottom':'-60px' },{
					duration: 200,
					easing:'easeInCirc'
				});
			});

			$('ul#hl_navigation').delay(4000).animate({ 'bottom':'-60px' },{
				duration: 600,
				easing:'easeInCirc'
			})

			$('#hl_lights li:not(.selected) span').hide();

		}else{

			// Hide navigation if there's only one item
			$('#hl_navigation').hide();
			$('#hl_lights').hide();
		}
	});
}(this));
/*
 
 jQuery Tools 1.2.5 / Expose - Dim the lights

 NO COPYRIGHTS OR LICENSES. DO WHAT YOU LIKE.

 http://flowplayer.org/tools/toolbox/expose.html

 Since: Mar 2010
 Date:    Wed Sep 22 06:02:10 2010 +0000 
*/
(function(b){function k(){if(b.browser.msie){var a=b(document).height(),d=b(window).height();return[window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth,a-d<20?d:a]}return[b(document).width(),b(document).height()]}function h(a){if(a)return a.call(b.mask)}b.tools=b.tools||{version:"1.2.5"};var l;l=b.tools.expose={conf:{maskId:"exposeMask",loadSpeed:"slow",closeSpeed:"fast",closeOnClick:true,closeOnEsc:true,zIndex:9998,opacity:0.8,startOpacity:0,color:"#fff",onLoad:null,
onClose:null}};var c,i,e,g,j;b.mask={load:function(a,d){if(e)return this;if(typeof a=="string")a={color:a};a=a||g;g=a=b.extend(b.extend({},l.conf),a);c=b("#"+a.maskId);if(!c.length){c=b("<div/>").attr("id",a.maskId);b("body").append(c)}var m=k();c.css({position:"absolute",top:0,left:0,width:m[0],height:m[1],display:"none",opacity:a.startOpacity,zIndex:a.zIndex});a.color&&c.css("backgroundColor",a.color);if(h(a.onBeforeLoad)===false)return this;a.closeOnEsc&&b(document).bind("keydown.mask",function(f){f.keyCode==
27&&b.mask.close(f)});a.closeOnClick&&c.bind("click.mask",function(f){b.mask.close(f)});b(window).bind("resize.mask",function(){b.mask.fit()});if(d&&d.length){j=d.eq(0).css("zIndex");b.each(d,function(){var f=b(this);/relative|absolute|fixed/i.test(f.css("position"))||f.css("position","relative")});i=d.css({zIndex:Math.max(a.zIndex+1,j=="auto"?0:j)})}c.css({display:"block"}).fadeTo(a.loadSpeed,a.opacity,function(){b.mask.fit();h(a.onLoad);e="full"});e=true;return this},close:function(){if(e){if(h(g.onBeforeClose)===
false)return this;c.fadeOut(g.closeSpeed,function(){h(g.onClose);i&&i.css({zIndex:j});e=false});b(document).unbind("keydown.mask");c.unbind("click.mask");b(window).unbind("resize.mask")}return this},fit:function(){if(e){var a=k();c.css({width:a[0],height:a[1]})}},getMask:function(){return c},isLoaded:function(a){return a?e=="full":e},getConf:function(){return g},getExposed:function(){return i}};b.fn.mask=function(a){b.mask.load(a);return this};b.fn.expose=function(a){b.mask.load(a,this);return this}})(jQuery);

/*
 
 jQuery Tools 1.2.5 Overlay - Overlay base. Extend it.

 NO COPYRIGHTS OR LICENSES. DO WHAT YOU LIKE.

 http://flowplayer.org/tools/overlay/

 Since: March 2008
 Date:    Wed Sep 22 06:02:10 2010 +0000 
*/
(function(a){function t(d,b){var c=this,j=d.add(c),o=a(window),k,f,m,g=a.tools.expose&&(b.mask||b.expose),n=Math.random().toString().slice(10);if(g){if(typeof g=="string")g={color:g};g.closeOnClick=g.closeOnEsc=false}var p=b.target||d.attr("rel");f=p?a(p):d;if(!f.length)throw"Could not find Overlay: "+p;d&&d.index(f)==-1&&d.click(function(e){c.load(e);return e.preventDefault()});a.extend(c,{load:function(e){if(c.isOpened())return c;var h=q[b.effect];if(!h)throw'Overlay: cannot find effect : "'+b.effect+
'"';b.oneInstance&&a.each(s,function(){this.close(e)});e=e||a.Event();e.type="onBeforeLoad";j.trigger(e);if(e.isDefaultPrevented())return c;m=true;g&&a(f).expose(g);var i=b.top,r=b.left,u=f.outerWidth({margin:true}),v=f.outerHeight({margin:true});if(typeof i=="string")i=i=="center"?Math.max((o.height()-v)/2,0):parseInt(i,10)/100*o.height();if(r=="center")r=Math.max((o.width()-u)/2,0);h[0].call(c,{top:i,left:r},function(){if(m){e.type="onLoad";j.trigger(e)}});g&&b.closeOnClick&&a.mask.getMask().one("click",
c.close);b.closeOnClick&&a(document).bind("click."+n,function(l){a(l.target).parents(f).length||c.close(l)});b.closeOnEsc&&a(document).bind("keydown."+n,function(l){l.keyCode==27&&c.close(l)});return c},close:function(e){if(!c.isOpened())return c;e=e||a.Event();e.type="onBeforeClose";j.trigger(e);if(!e.isDefaultPrevented()){m=false;q[b.effect][1].call(c,function(){e.type="onClose";j.trigger(e)});a(document).unbind("click."+n).unbind("keydown."+n);g&&a.mask.close();return c}},getOverlay:function(){return f},
getTrigger:function(){return d},getClosers:function(){return k},isOpened:function(){return m},getConf:function(){return b}});a.each("onBeforeLoad,onStart,onLoad,onBeforeClose,onClose".split(","),function(e,h){a.isFunction(b[h])&&a(c).bind(h,b[h]);c[h]=function(i){i&&a(c).bind(h,i);return c}});k=f.find(b.close||".close");if(!k.length&&!b.close){k=a('<a class="close"></a>');f.prepend(k)}k.click(function(e){c.close(e)});b.load&&c.load()}a.tools=a.tools||{version:"1.2.5"};a.tools.overlay={addEffect:function(d,
b,c){q[d]=[b,c]},conf:{close:null,closeOnClick:true,closeOnEsc:true,closeSpeed:"fast",effect:"default",fixed:!a.browser.msie||a.browser.version>6,left:"center",load:false,mask:null,oneInstance:true,speed:"normal",target:null,top:"10%"}};var s=[],q={};a.tools.overlay.addEffect("default",function(d,b){var c=this.getConf(),j=a(window);if(!c.fixed){d.top+=j.scrollTop();d.left+=j.scrollLeft()}d.position=c.fixed?"fixed":"absolute";this.getOverlay().css(d).fadeIn(c.speed,b)},function(d){this.getOverlay().fadeOut(this.getConf().closeSpeed,
d)});a.fn.overlay=function(d){var b=this.data("overlay");if(b)return b;if(a.isFunction(d))d={onBeforeLoad:d};d=a.extend(true,{},a.tools.overlay.conf,d);this.each(function(){b=new t(a(this),d);s.push(b);a(this).data("overlay",b)});return d.api?b:this}})(jQuery);

/*globals document, $, jQuery, Cufon */

//disables text/image selection on selected elements
(function ($) {
    
    function findTextNodes(el, nodes) { 
		nodes = nodes || [];
		var len, i;
		if (el.nodeType === 3 && el.parentNode.tagName.indexOf('CUFON') === -1) {
			nodes.push(el.parentNode);
		} else {
			for (i = 0, len = el.childNodes.length; i < len; i += 1) {
				getTextNodes(el.childNodes[i], nodes);
			}
		}
		return nodes;
	}
    
    
    
    $.fn.disableTextSelect = function disableTextSelect() {
        return this.each(function each() {
            $(this).bind('mousedown.disableTextSelect', function on() {
                return false;
            });
        });
    };
    $.fn.enableTextSelect = function enableTextSelect() {
        return this.each(function each() {
            $(this).unbind('mousedown.disableTextSelect');
        });
    };
    
    $.fn.disableAllTextSelect = function disableAllTextSelect() {
        return this.each(function each() {
            $(this).bind('mousedown.disableTextSelect', function on() {
                return false;
            });
        });
       return $(findTextNodes)
    };
}(jQuery));

function initDisableSelect() {
    $('#frontend a, #frontend img').not($('.dock_item img, .my_list img, .buy_list img, .ui-slider-handle, #weapon-hover img, .weapon-item-view img')).disableTextSelect();
    $('#weapon-hover .item.bundle_item img, #weapon-hover .item.booster img, .buy_list.bundles_list img, .buy_list.boosters img').disableTextSelect();
}

APP.domTask('disable-select', function taskDisableSelect(done) {
    APP.doc.onselectstart = function () {
        return false;
    };
    initDisableSelect();
    
    done();
});

/*globals window, jQuery, $, document */

/*
 * Scales the screen size so the frontend fits on a 800x600 display or similar
 */

/**
 * The current scale the game window is resized to.
 */
var screen_scale = 1;

/**
 * Fix tooltip z-index when the game is running in 800x600.
 * If we're running in 800x600 we've applied a CSS3 scale transformation
 * and this messes up z-index of absolute positioned elements. As a
 * workaround we move the background overlay into the frontend div
 * so it's a child of the transformed div.
 */
function fixTooltipBackgroundIn800() {
    if ($('html').width() === 1600) {
        $('#exposeMask').detach().appendTo('#frontend');
        $('#menu-tooltip').css('left', '380px');
        $('#buy-tooltip').css('left', '200px');
    }
}

/**
 * Is the game running in 800x600 resolution?
 * @return {Boolean} True or false.
 */
function isGameRunningIn800() {
    // Get window size
    var generalAPI = (window.APP && window.APP.api && window.APP.api.general) || window.general,
		windowSize = (generalAPI && JSON.parse(generalAPI.getWindowSize()));
    
    return windowSize && (parseInt(windowSize.width, 10) === 800);
}

/**
 * Resize the game window to fit in 800x600 resolution.
 */
// Scale the screen for 800x600 resolution
function scaleScreenSize() {
    // Scale frontend
    if (isGameRunningIn800() === true) {
        screen_scale = 0.78125;
        if ((document.body.className || '').indexOf('scale800') === -1) {
        	document.body.className += ' scale800';
        }
    }
}

jQuery(scaleScreenSize);

/*globals window, jQuery, $, Cufon, SWFAddress, saveWeaponLoadout, saveAppearanceLoadout,
	personaUrl:true, addSubmenuAlpha, removeSubmenuAlpha */

/**
 * jQuery Namespace.
 * @name $
 * @see The <a href="http://docs.jquery.com">jQuery documentation</a>.
 * @constructor
 */


//shows & closes alerts
function showAlert(alert) {

	$(alert).hide().removeClass('hidden');

	var height = parseInt($(alert).height(), 10) + parseInt($(alert).css('padding-top'), 10) + 4,
		startPos = '-' + height + 'px',
		item;
	
	$(alert).css('margin-top', startPos).show().animate({
		'marginTop': 0
	}, 500, 'swing').delay(5000).animate({
		'marginTop': startPos
	}, 500, 'swing');
	
	// Grab Item from URL parameter
	item = $('.my_list img[item-id="' + SWFAddress.getParameter('item') + '"]');
	
	// Animate it
	$(item)
		// Init
		.css('background-color', 'rgba(0, 0, 0, 0)')
		.animate({ 'backgroundColor': 'rgba(167, 158, 141, 0)' }, 0)
		.delay(500)
		// Fade in
		.animate({ 'backgroundColor': 'rgba(167, 158, 141, 0.3)' }, 500)
		// Pulse
		.animate({ 'backgroundColor': 'rgba(167, 158, 141, 0.2)' }, 1000)
		.animate({ 'backgroundColor': 'rgba(167, 158, 141, 0.3)' }, 1000)
		// Pulse
		.animate({ 'backgroundColor': 'rgba(167, 158, 141, 0.2)' }, 1000)
		.animate({ 'backgroundColor': 'rgba(167, 158, 141, 0.3)' }, 1000)
		// Fade out
		.animate({ 'backgroundColor': 'rgba(167, 158, 141, 0)' }, 500);
	
	// Since we bought a new item we want to save it to the backend
	saveWeaponLoadout();
	saveAppearanceLoadout();
}

// Rounds a float to 2 decimals
function roundDec(num) {
	var result = Math.round(num * 100) / 100;
	return result;
}

function switchPersona(personaId, personaName) {
	
	var pick;
	
	personaUrl = personaUrl + personaId;
	
	$.magma.debugLog('debug', 'Switching persona to ' + personaName);
	$('#loading .holder p').html('Switching soldier...');
	
	if (window.login) {
		$('#preloader').show();
		
		// Give it some breading room
		setTimeout(function () {
			window.doll.visible = false;
			pick = window.login.pickSoldier(personaName);
			
			if (pick === true) {
				$.magma.debugLog('debug', 'Switched! pickSoldier returned ' + pick);
				window.location.href = personaUrl;
				return false;
				
			} else {
				$('#loading .holder p').html('Switch soldier failed...');
				$.magma.debugLog('warning', 'Switch soldier failed!');
			}
		}, 0);
	} else {
		$.magma.gotoURL(personaUrl);
	}
}

function radomBackgroundPosition(selector, leftOffset, topOffset, leftCenter, topCenter) {
	var left = leftOffset + Math.floor(Math.random() * leftCenter),
		top = topOffset + Math.floor(Math.random() * topCenter);
	
	$(selector).css('background-position', '-' + left + 'px -' + top + 'px');
}

var playNowDeparturePage;

APP.domTask('old-script-task', [ 'dock', 'weapons', 'appearance' ], function (done) {
	
  
    var text = $('.menu .captain-shop a').text();
    $('.menu .captain-shop a').html(text.replace(/([A-Z])/g, '<span class="caps">$1</span>'));
    
	/* Activate Custom Inputs */
	$('form input').customInput();
	
	done();
});



function setEquipmentWarningPosition() {
	// Do we have any weapon error messages?
	if ($('.dock_errors:visible').length > 0) {
		// Then move the message position to match the dock height
		var newHeight = $('#frontend .footer').height();
		if (newHeight > 80) { // Only animate if bar is visible
			$('.dock_errors').animate({
				bottom: newHeight
			}, 200);
		}
	}
}

/*globals window, setTimeout, $, Cufon, showTooltip, playSound, loaded_usecount_tooltip:true,
 sendItemsToGame, remove_server_url, change_friend_page_url, friendTooltip,
 initDisableSelect, change_server_page_url, reason, SWFAddress, jQuery, hideDoll,
 fixTooltipBackgroundIn800, playNowDeparturePage, updateDoll, countEORChecked: true,
 equipBundle, bundle_items: true, APP: true */

/** If there's been a popup in the joining flow that we don't want to be overwriten with later popups. */
var showingErrorPopup = false;

/**
 * Go to a page in the player bookmark list.
 * @param {string} page The page we want to load.
 * @param {string} cached Use cached version.
 */
function changePlayerPage(page, useCache) {

    useCache = !!useCache;

    APP.log('Changing friends page id ' + page + ' useCache:' + useCache);

    // Show non-playing friends?
    var status = $('#sof1').is(':checked') ? 'offline,online' : 'ingame',
        url = window.game ? change_friend_page_url : '/static/mock-friends-list.html',
		$reloadFriends = $('a.reload_friends');

	$reloadFriends.addClass('active');
	
	$.ajax({
		type: 'GET',
		url: url,
		data: {
			page: page,
			status: status,
			cached: useCache
		},
		cache: false,
		success: function (message) {

			var $friendsList =  $('div.main_joinfriends ul.friends_list'),
				$homeFriendsList = $('div.main_home ul.friends_list'),
				$inGame,
				numberInGame;

			$friendsList.html(message);

			$inGame = $friendsList.find('li.friend.status-ingame');
			numberInGame = $inGame.size();

			$homeFriendsList.html($inGame.clone());

			initDisableSelect();

			APP.ns('menu').setFriendsCount(numberInGame);
			
			$reloadFriends.removeClass('active');
		},
		error: function (XMLHttpRequest, textStatus, errorThrown) {
			if (textStatus !== null) {
				$.magma.debugLog('warning', 'change page error!');
				//console.log(XMLHttpRequest);
				//console.log(textStatus);
				//console.log(errorThrown);
				//console.log('---');
			}
			$reloadFriends.removeClass('active');
		}
	});
}

/**
 * TODO: What is this?
 */
var fadeLoadingStarted = false;

/**
 * Is the matchmaking status popup open?
 */
var isMenuTooltipOpen = false;


jQuery(function () {
	"use strict";
	
	/* open new friends page*/
	$('.friends_list').delegate('.more p a', 'click', function(e) {
		e.preventDefault();
		playSound('click', 'Next friends page');
		var page = $(this).text();
		$(this).parents('.more').find('.reload_icon').addClass('active');
		changePlayerPage(page);
	});

    /* refresh friends*/
    $('.reload_friends').not('.active').bind('click', function(e) {
        e.preventDefault();
        $(this).addClass('active');
        playSound('click', 'Reload friends');
        var page = parseInt($('.friends_list .more p span').text(), 10);
        if (page && page.length > 0) {
            changePlayerPage(page, false);
        } else {
            changePlayerPage(1, false);
        }
    });

    /* Show offline friends */
    $('#frontend .show_offline_friends').click(function () {
        $('.reload_friends').click();
    });
});
/*globals window jQuery $ dontUpdateDoll getCurrentPage
	default_appearance_team:true bundleOnDoll:true isGameRunningIn800 */

var defaultCameraTransitionTime = 0.5;

function updateDollIcons() {
	if (!updateDollIcons.$model) {
		updateDollIcons.$model = $('#soldierModel');
		updateDollIcons.$revert = updateDollIcons.$model.find('a.revert-try');
		updateDollIcons.$switch = updateDollIcons.$model.find('a.switch-team');
	}
	
	var isTeamRu = updateDollIcons.$switch.hasClass('team-ru'),
		teamId = parseInt(default_appearance_team, 10);
	
	if (bundleOnDoll) {
		updateDollIcons.$revert.show();
		updateDollIcons.$switch.hide();
	} else {
		updateDollIcons.$revert.hide();
		updateDollIcons.$switch.show();
		
		if (teamId === 1) {
			if (!isTeamRu) {
				updateDollIcons.$switch.addClass('team-ru');
			}
		} else if (isTeamRu) {
			updateDollIcons.$switch.removeClass('team-ru');
		}
	}
}

window.showDoll = function () {
	APP._.defer(function () {
		if (window.showDoll.force) {
			window.showDoll.force = false;
			dressDoll(null, true);
		}

		APP.doll.visible = true;
		
		if (window.doll) {
			window.doll.visible = true;
		}
		
		if (!showDoll.$model) {
			showDoll.$model = $('#soldierModel');
		}
		
		showDoll.$model.show();
		
		updateDollIcons();
	});
};

window.hideDoll = function () {
	APP._.defer(function () {
		APP.doll.visible = false;
		if (window.doll) {
			window.doll.visible = false;
		}
		
		if (!hideDoll.$model) {
			hideDoll.$model = $('#soldierModel');
		}
		
		hideDoll.$model.hide();
		
		updateDollIcons();
	});
};

window.dressDoll = (function () {
	
	var _ = APP._,
		nsItems = APP.ns('items'),
		activeKey = null,
		nsConfig = APP.ns('config'),
		debouncedDresser = APP._.debounce(function (teamId, items, force) {
			
			items = items || [];
			
			var doll = window.doll,
				key = teamId + '|' + items.join(':'),
				len,
				i,
				defaultCustomization = nsConfig.defaultCustomization,
				defaultAppearance = defaultCustomization[teamId][nsConfig.persona.kit].appearance.slice(0);
			
			defaultAppearance.push(defaultCustomization.head);
			defaultAppearance.push(defaultCustomization.hair);
			defaultAppearance.push(defaultCustomization.facialFeature);
			
			items = defaultAppearance.concat(items);
			
			// Do we really to dress up the doll do this?
			if (doll && (force || activeKey !== key)) {
				doll.updateItems = false;
				doll.clearItems();
				doll.setTeam(teamId);
				
				for (i = 0, len = items.length; i < len; i += 1) {
					// Dress doll.
					doll.addItemEx(items[i]);
				}
				activeKey = key;
				
				doll.updateItems = true;
			}
			
			// Update Doll icons
			updateDollIcons();
			
			// Trigger
			APP.trigger('doll:dress', items, bundleOnDoll);
		}, 100);
	
	return function dressDoll(tryItems, force) {
		var teamId = parseInt(default_appearance_team, 10),
			items = [];
		
		if (tryItems) {
			if (tryItems instanceof APP.Model.Item) {
				if (tryItems.isItemType('bundle')) {
					items = APP._.pluck(tryItems.get('items'), 'id');
				} else {
					items = [ tryItems.id ];
				}
				bundleOnDoll = tryItems;
			} else {
				items = tryItems;
				bundleOnDoll = true;
			}
			
		} else {
			items = _.pluck(nsItems.collection.getEquipped('appearance').filter(function (model) {
				return !model.isDefault();
			}), 'id');
			bundleOnDoll = false;
		}
		
		debouncedDresser(teamId, items, force);
	};
}());

function getCurrentPage() {
    var currentPage;
    if ($('ul.menu .submenu a.active').length > 0) {
        currentPage = $('ul.menu .submenu a.active').attr('href').replace('#', '');
    } else {
        currentPage = $('ul.menu a.active').attr('href').replace('#', '');            
    }
    return currentPage;
}


var dollState;
function updateDoll(options) {
	
	options = options || {};
	
	// Timeout
	if (options.hasOwnProperty('timeout')) {
		return setTimeout(function onTimeout() {
			delete(options.timeout);
			updateDoll(options);
		}, options.timeout);
	}
	
	var page = ((APP.$main.find('div.main').not('.hidden').attr('class') || '').match(/main_([^\s]+)/) || []).pop();
	
    if (dontUpdateDoll) {
        return false;
    }
    
	
    if (window.doll) {
        dollState = window.doll.visible;
    }

    if (page === 'home' || page === 'appearance' || page === 'bundles' || page === 'emotes') {
        if (!dollState) {
            showDoll();
        }            
    } else {
        if (dollState) {
            hideDoll();
        }                        
    }
}

function switchDollTeam() {
	default_appearance_team = parseInt(default_appearance_team, 10);
	
    if (default_appearance_team === 2) {
        default_appearance_team = 1;
    } else {
        default_appearance_team = 2;
    }
	
    dressDoll();
}




var lastMousePosition = [];
function rotateDoll(event) {
	if (window.doll) {
		var maxRotationSpeed = 25,    
			currentX = Math.round(window.doll.camAzimuth),
			diffX = event.pageX - lastMousePosition[0];
			
	
		// Enforce max rotation speed
		if (diffX > maxRotationSpeed) {
			diffX = maxRotationSpeed;
		} else if (diffX < 0 - maxRotationSpeed) {
			diffX = 0 - maxRotationSpeed;
		}
		
		if (window.doll) {
			window.doll.camAzimuth = (currentX - diffX);
		}
	}
    lastMousePosition = [ event.pageX, event.pageY ];
}

function initDoll() {
    var doll = window.doll,
		destX = -35,
		destY = 61,
		width = 399,
		height = 640,
		screen_scale;
    
    if (isGameRunningIn800()) {
        screen_scale = $('html').width() / 2048;
        
        destX = 50; // destX is usually zero, so multiplying won't help
        destY = destY * screen_scale + 1; // +1 for rounding error
        width = width * screen_scale;
        height = height * screen_scale;
    }

    hideDoll();
	
	if (doll) {
		
		// Initialize 3D model.
		doll.init(width, height);
		doll.setTeam(2);
	
		// We can't change doll aspect ratio so we just change the size of the container
		// A best case scenario would be this: window.doll.setDestRect(destX, destY, width, height); 
		doll.setDestRect(destX - 230, destY, width * 2.2, height); 
		
		doll.camAzimuth = 205;
		doll.camZenith = 80;
		doll.camDistance = 2.5;
		doll.setCameraLookAt(0.05, 0.85, 0);
		doll.camTransitionTime = 0;
	}
	
    dressDoll();
    updateDoll();
}


APP.domTask('old-doll', function taskDoll(done) {
	var nsAppearance = APP.ns('appearance'),
		dummyItem = new APP.Model.Item(),
		$soldierModel = $('<div id="soldierModel"></div>'),
		$body = $(APP.doc.body),
		$revertTryButton = $('<a href="#revert-try" class="revert-try button-view button-view-icon"><i class="glyphs glyphs-takeoff"></i></a>').appendTo($soldierModel),
		$switchTeam = $('<a href="#switch-team" class="switch-team"></a>').appendTo($soldierModel),
		startMousePos,
		isDollRotate = false;
	
	
	/**
	 * Revert try bundle
	 */
	$revertTryButton.bind('click', function onClickRevertTry(e) {
		e.preventDefault();
		e.stopImmediatePropagation();
		
		// Trigger
		APP.trigger('doll:undress', bundleOnDoll);
		dressDoll();
	});
	
	
	/**
	 * Switch team on click
	 */
	$soldierModel.bind('click', function onClickSwitchTeam(e) {
		e.preventDefault();
		if (!bundleOnDoll && startMousePos[0] === e.pageX && startMousePos[1] === e.pageY) {
			switchDollTeam();
		}
	});
	
	$soldierModel.mousedown(function (e) {
		lastMousePosition = startMousePos = [
			event.pageX,
			event.pageY
		];
		
		if (window.doll) {
			window.doll.camTransitionTime = 0;
		}
		
		nsAppearance.trigger('highlight', dummyItem, 'doll');
		
		$body.bind('mousemove', rotateDoll);
		
		isDollRotate = true;
	});
	
	$(APP.win).mouseup(function (e) {
		if (isDollRotate) {
			nsAppearance.trigger('highlight', null, 'doll');
			$body.unbind('mousemove', rotateDoll);
			lastMousePosition = [ 0, 0 ];
		}
		isDollRotate = false;
	});
	
	$soldierModel.appendTo('#frontend');
	
	// Task done!
	done();
});
/*globals window, document, jQuery, $, Audio */

// Create audio channels
var channel_max = 10,
	audiochannels = [],
	soundMapping = {};

(function () {
	for (var channel = 0; channel < channel_max; channel += 1) {
		audiochannels[channel] = {
			channel: new Audio(),
			finished: -1
		};
	}
	
	// Map our IDs to in-game sound ID
	soundMapping.loading_splash		= 'Loading';
	soundMapping.click				= 'Click';
	soundMapping.select_item		= 'Cash';
	soundMapping.open_menu			= 'Select';
	soundMapping.pickup_item		= 'Pickup';
	soundMapping.drop_item			= 'Drop';
	soundMapping.error				= 'Error';
	soundMapping.bottom_bar_open	= 'BarSlideUp';
	soundMapping.bottom_bar_close	= 'BarSlideDown';
	soundMapping.click_buy			= 'ClickBuy';
	soundMapping.play_now			= 'PlayNow';
	soundMapping.eor_splash			= 'Loading';
	soundMapping.LoadedSoldier		= 'LoadedSoldier';
	soundMapping.Loaded				= 'Loaded';
	soundMapping.ClickBuy			= 'ClickBuy';
	soundMapping.Reset				= 'Reset';
	soundMapping.TrainingPoint		= 'TrainingPoint';
	soundMapping.BonusSplash		= 'BonusSplash';
	soundMapping.Counter			= 'Counter';
	soundMapping.Ready				= 'Ready';
	soundMapping.level_up			= 'LevelUp';
}());

function playsoundInBrowser(s) {
	
	var len = audiochannels.length,
		i = 0,
		audio,
		soundItem,
		thistime;
	
	for (; i < len; i += 1) {
		thistime = new Date();
		audio = audiochannels[i];
		
		if (audio.finished < thistime.getTime()) {			// is this channel finished?
			soundItem = document.getElementById(s);
			
			if (soundItem) {
				audio.finished = thistime.getTime() + soundItem.duration * 1000;
				audio.channel.src = soundItem.src;
				audio.channel.load();
				audio.channel.play();
				break;
			}
		}
	}
}

function playSound(sound, reason) {
	if (reason) {
		$.magma.debugLog('debug', 'Playing sound ' + soundMapping[sound] + ': ' + reason);
	} else {
		$.magma.debugLog('debug', 'Playing sound ' + soundMapping[sound]);
	}
	
	if (window.game) {
		window.game.playSound(soundMapping[sound]);
	} else {
		playsoundInBrowser('sound_' + soundMapping[sound]);
	}
}


APP.task('old-sound', 'game-sound', function taskOldSound(done) {
	
	var nsGame = APP.ns('game');
	
	$("ul.menu a").mouseenter(function () {
		nsGame.sound('hover');
	});
	
	$(".button").click(function () {
		nsGame.sound('click');
	});
	
	/**
	 * Task Done
	 */
	done();
});
/*globals jQuery setTimeout $ showTooltip purchase_ability_url playSound
    saveStoreURL currentDock: true addPreloadedImagesToPage openDeepLink
    initDisableSelect initItemTooltips initWeaponDragAndDrop
    initEquipmentDragAndDrop initKeyBindings checkIfOwnItem addItemHoverBoxes
    selectDefaultWeapon removeTooltipAlpha reset_abilities_url */

function updateMenuPoints() {
	
    var model = APP.ns('items').collection.get('tp'),
		points = model.get('trainingPointsCurrent'),
		pointsMax = model.get('extraPointsMax'),
		pointsPurchased = model.get('extraPointsPurchased'),
		$menuPoints = $('#frontend div.header ul.menu li.abilities a span'),
		$labelPoints = $('#available_points'),		
		$mainAbilities = $('div.main.main_abilities');
	
	
    if (points === 0) {
        $menuPoints.addClass('hidden');
		$labelPoints.removeClass('active');
    } else {
        $menuPoints.html(points).removeClass('hidden');
		$labelPoints.addClass('active');
    }
	$labelPoints.html(points);
		
	
	// Hide button if limit reached
	if (pointsPurchased === pointsMax) {
		$('#buy_training_points').addClass('hidden');
	}
		
	$mainAbilities.removeClass('loading');
}


function updateAbilities(html, reloadWeapons) {

	var $mainAbilities = $('div.main.main_abilities'),
		$html = $(html),
		$error = $html.eq(0),
		nsItems = APP.namespace('items'),
		
		update = function () {
			// HTML
			$mainAbilities.empty().append($html);

			nsItems.collection.get('tp').set({
				'prices': nsItems.trainingPointOffers,
				'extraPointsPurchased': nsItems.extraPointsPurchased,
				'extraPointsMax': nsItems.extraPointsMax,
				'trainingPointsCurrent': nsItems.trainingPointsCurrent
			});

			// Disble Select
			$mainAbilities.disableTextSelect();
			$mainAbilities.find('a, span').disableTextSelect();

			// Refresh abilities collection
			APP.ns('abilities').collection.trigger('refresh');

			// Game Items
			APP.ns('game').trigger('giveitems');
			//APP.trigger('game:items');

			updateMenuPoints();

			// Ready for next round
			buyAbility.busy = false;
		};
	
	if ($error.attr('id') === "ability_error") {
		APP.trigger('error', $error.text());
		$error.addClass('hidden').remove();
	}


	// Reload Weapons
	if (reloadWeapons) {
		playSound('TrainingPoint', 'Bought ability');
		nsItems.refreshWeapons(update);
	} else {
		update();
	}
}


/**
 * Buy Ability
 */
function buyAbility(el) {
	
    buyAbility.busy = true;
    
    var $el = $(el),
        id = $el.find('span.item-ability').attr('abilityid'),
        new_purchase_url = purchase_ability_url.replace('ABILITYID', id);
        
	// 
    $el.addClass('loading');
    
    $.ajax({
		type: 'POST',
		url: new_purchase_url,
		cache: false,
		success: function onSuccess(response) {
			updateAbilities(response, true);
		},
		error: function onError(XMLHttpRequest, textStatus, errorThrown) {
			playSound('error', 'Buy ability error');
			$.magma.debugLog('warning', 'Buy ability failed!');
			buyAbility.busy = false;
		}
    });
}
buyAbility.busy = false;


/**
 * Task
 */
APP.domTask('old-abilities', [ 'items' ], function initOldAbilities(done) {
	var $mainAbilities = $('.main.main_abilities'),
		tooltipView = new APP.View.Tooltip({
			className: 'abilities-tooltip'
		}).attach(),
		timer,
		ms = 500,
		nsStore = APP.namespace('store'),
		nsItems = APP.namespace('items'),
		nsConfig = APP.namespace('config'),
		nsAbilities = APP.namespace('abilities'),
		trainingPointModel = nsItems.collection.get('tp'),
		$resetAbilities = $mainAbilities.find('.abilities_bar .reset_abilities');
	
	APP.bind('crash!', function () {
		var counter = 0,
			doit = function doit() {
				if (!buyAbility.busy) {
					APP.log('CRASH', counter++);
					if (parseInt($mainAbilities.find('.abilities_bar .points').text(), 10) > 0) {
						$mainAbilities.find('a.unlocked').click();
					} else {
						$mainAbilities.find('a.reset_abilities').click();
					}
				}
				setTimeout(doit, 200);
			};
		doit();
	});
	
	
    /**
	 * Disable Buy ability
	 */
    $mainAbilities.delegate('a.locked', 'click', function onClickLocked(e) {
        e.preventDefault();
    });
    
    
	/**
	 * Train ability
	 */
    $mainAbilities.delegate('a.unlocked', 'click', function onClickUnlocked(e) {
        e.preventDefault();
		
		if (buyAbility.busy) {
			return;
		}
		
		var $abilitiesPoints = $mainAbilities.find('.abilities_bar .points'),
			el = this,
			extraPointsMax = trainingPointModel.get('extraPointsMax'),
			extraPointsPurchased = trainingPointModel.get('extraPointsPurchased'),
			trainingPointsCurrent = trainingPointModel.get('trainingPointsCurrent'),
            $resetAbilities = $mainAbilities.find('.abilities_bar .reset_abilities'),
            $buyTp = $mainAbilities.find('.abilities_bar .buy_points');
		
		// Buy training point to train ability
		if (trainingPointsCurrent === 0 && extraPointsPurchased < extraPointsMax && !$resetAbilities.hasClass('trying')) {
			nsStore.trigger('buy', trainingPointModel);
			
			tooltipView.hide();
			
		// Train ability
		} else if (parseInt($abilitiesPoints.text(), 10) > 0 && !$resetAbilities.hasClass('trying')) {			
			$mainAbilities.find('a.ability').removeClass('started full unlocked').addClass('empty locked');

            $resetAbilities.attr({'disabled': true});
            $buyTp.addClass({'disabled': true});
            
			clearTimeout(timer);
			tooltipView.hide();
			
			setTimeout(function () {
				buyAbility.busy = true;
				buyAbility(el);
			}, 0);
        }
    });
    
	
	/**
	 * Buy trainingpoints
	 */
    $mainAbilities.delegate('#buy_training_points', 'click', function onEnabledBuyTrainingPoints(e) {
        e.preventDefault();
			
		if (buyAbility.busy) {
			return;
		}
		
		var extraPointsMax = trainingPointModel.get('extraPointsMax'),
			extraPointsPurchased = trainingPointModel.get('extraPointsPurchased'),
			trainingPointsCurrent = trainingPointModel.get('trainingPointsCurrent');
		
		// Buy training point
        if (extraPointsPurchased < extraPointsMax && !$resetAbilities.hasClass('trying')) {			
			nsStore.trigger('buy', trainingPointModel);
        }
    });
	
	
	/**
	 * Reset abilities
	 */
	$mainAbilities.delegate('a.reset_abilities', 'click', function onReset(e) {
		e.preventDefault();


        var $resetAbilities = $mainAbilities.find('.abilities_bar .reset_abilities');
		if (buyAbility.busy) {
            
			return;
		}
        
		if (!$resetAbilities.hasClass('trying')) {
			$mainAbilities.addClass('loading');
			
			$mainAbilities.find('a.ability').removeClass('started full unlocked').addClass('empty locked');
			
			clearTimeout(timer);
			tooltipView.hide();
			
			$resetAbilities.addClass('trying');
			
			buyAbility.busy = true;
			
			$.ajax({
				type: 'POST',
				url: reset_abilities_url,
				cache: false,
				success: function onSuccess(response) {
					updateAbilities(response, true);
				},
				error: function onError(XMLHttpRequest, textStatus, errorThrown) {
					$.magma.debugLog('warning', 'Abilities reset failed! ' + textStatus);
					buyAbility.busy = false;
				},
				complete: function onComplete() {
					$resetAbilities.removeClass('trying');
				}
			});
		}
	});

	// TODO: Move this code elsewhere
	nsAbilities.updatePage = function updateAbilitiesPage () {
		if (!buyAbility.busy) {
			$mainAbilities.addClass('loading');

			clearTimeout(timer);
			tooltipView.hide();

			buyAbility.busy = true;
			
			$.ajax({
				type: 'get',
				url: nsConfig.updateAbilitiesUrl,
				cache: false,
				success: function onSuccess(response) {
					updateAbilities(response, false);
				},
				error: function onError() {
					buyAbility.busy = false;
				}
			});
		}
	};
	
	
    /**
	 * Check for new training points
	 */
    $('#menu-tooltip .buttons .training_button').click(function () {
        $('#menu-tooltip').overlay().close();
        $('#frontend .header .menu .abilities a').click();
    });
	
	
	/**
	 * Mouse Enter
	 */
	$mainAbilities.delegate('a.ability', 'mouseenter', function onMouseEnterAbility() {
		var $el = $(this),
			$ability = $el.find('span.item-ability');
		
		clearTimeout(timer);
		timer = setTimeout(function onTimeout() {
			var level = parseInt($ability.attr('level'), 0),
				available = $ability.attr('available') === 'true',
				name = $ability.attr('name'),
				description = level <= 1 ? $ability.attr('description') : $ability.attr('upgrade' + (level-1)),
				dependency = $ability.attr('dependency'),
				dependencyMax = (dependency ? nsAbilities.collection.getByName(dependency).get('maxlevel') : false),
				dependencyLevel = (dependency ? nsAbilities.collection.getByName(dependency).get('level') : false),
				html = [
					'<h1>' + name + '</h1>',
					'<p>' + description + '</p>'
				],
				tpModel = APP.ns('items').collection.get('tp'),
				extraPointsMax = tpModel.get('extraPointsMax'),
				extraPointsPurchased = tpModel.get('extraPointsPurchased'),
				trainingPointsCurrent = tpModel.get('trainingPointsCurrent'),
				neededpoints = $ability.closest('.tier').find('.neededpoints').text();
			
			if (level && level < parseInt($ability.attr('maxlevel'), 10)) {
				// TODO: Localize
				html.push('<h2>' + APP.sidis.trans('WEB_GAME_ABILITIES_NEXT_LEVEL') + '</h2>');
				html.push('<p>' + $ability.attr('upgrade' + level) + '</p>');				
			}
			
			// Make ability icons link to buy trainingpoints
			if (trainingPointsCurrent === 0 && extraPointsPurchased < extraPointsMax && available) {
				html.push('<p class="notice">' + APP.sidis.trans('WEB_GAME_ABILITIES_BUY_POINTS_TIP') + '</p>');
			}
			
			// Check dependency
			if (dependency && dependencyLevel < dependencyMax) {
				// TODO: Localize
				html.push('<h2>' + APP.sidis.trans('WEB_GAME_ABILITIES_REQUIREMENT') + '</h2>');
				html.push('<p>' + dependency + ' ' + dependencyMax + '/' + dependencyMax + '</p>');
			}
			
			// Check needed points
			if ($ability.closest('.tier').hasClass('locked')) {
				 // TODO: Localize
				html.push('<p class="notice">' + APP.sidis.transChoice('WEB_GAME_ABILITIES_NEED_POINTS', parseInt(neededpoints, 10), {'%amount%': neededpoints}) + '</p>');
			}
			
			tooltipView.renderHTMLAndShow(html.join(''), $el);			
		}, ms);
	});
	
	
	/**
	 * Mouse Leave
	 */
	$mainAbilities.delegate('a.ability', 'mouseleave', function onMouseLeaveAbility() {
		clearTimeout(timer);
		tooltipView.hide();
	});
	
	$mainAbilities.disableTextSelect();
	$mainAbilities.find('a, span').disableTextSelect();
	
	
	/**
	 * On Purchase Start - Training Point
	 */
	trainingPointModel.bind('purchase:start', function onPurchaseStartTrainingPoint() {
		$mainAbilities.addClass('loading');
		buyAbility.busy = true;
	});
	
	/**
	 *
	 * On Purchase End - Training Point
	 */
	trainingPointModel.bind('purchase:end', function onPurchaseEndTrainingPoint() {
		updateMenuPoints();
		buyAbility.busy = false;
	});
	
	
	/**
	 * Update menu points
	 */
	updateMenuPoints();
	
	
	/**
	 * task Done
	 */
	done();
});